{ Fast KDTree Single Type support                                                }
{ ****************************************************************************** }
{ * fast KDTree Support,writen by QQ 600585@qq.com                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ ****************************************************************************** }

unit FastKDTreeS;

interface

uses CoreClasses, KM;

{$I zDefine.inc}

{$IFDEF FPC}
{$DEFINE DEBUG}
{$ENDIF FPC}

const

  // Single float: KDTree
  KDT1DS_Axis = 1;
  KDT2DS_Axis = 2;
  KDT3DS_Axis = 3;
  KDT4DS_Axis = 4;
  KDT5DS_Axis = 5;
  KDT6DS_Axis = 6;
  KDT7DS_Axis = 7;
  KDT8DS_Axis = 8;
  KDT9DS_Axis = 9;
  KDT10DS_Axis = 10;
  KDT11DS_Axis = 11;
  KDT12DS_Axis = 12;
  KDT13DS_Axis = 13;
  KDT14DS_Axis = 14;
  KDT15DS_Axis = 15;
  KDT16DS_Axis = 16;
  KDT17DS_Axis = 17;
  KDT18DS_Axis = 18;
  KDT19DS_Axis = 19;
  KDT20DS_Axis = 20;
  KDT21DS_Axis = 21;
  KDT22DS_Axis = 22;
  KDT23DS_Axis = 23;
  KDT24DS_Axis = 24;
  KDT25DS_Axis = 25;
  KDT26DS_Axis = 26;
  KDT27DS_Axis = 27;
  KDT28DS_Axis = 28;
  KDT29DS_Axis = 29;
  KDT30DS_Axis = 30;
  KDT31DS_Axis = 31;
  KDT32DS_Axis = 32;
  KDT33DS_Axis = 33;
  KDT34DS_Axis = 34;
  KDT35DS_Axis = 35;
  KDT36DS_Axis = 36;
  KDT37DS_Axis = 37;
  KDT38DS_Axis = 38;
  KDT39DS_Axis = 39;
  KDT40DS_Axis = 40;
  KDT41DS_Axis = 41;
  KDT42DS_Axis = 42;
  KDT43DS_Axis = 43;
  KDT44DS_Axis = 44;
  KDT45DS_Axis = 45;
  KDT46DS_Axis = 46;
  KDT47DS_Axis = 47;
  KDT48DS_Axis = 48;
  KDT49DS_Axis = 49;
  KDT50DS_Axis = 50;
  KDT51DS_Axis = 51;
  KDT52DS_Axis = 52;
  KDT53DS_Axis = 53;
  KDT54DS_Axis = 54;
  KDT55DS_Axis = 55;
  KDT56DS_Axis = 56;
  KDT57DS_Axis = 57;
  KDT58DS_Axis = 58;
  KDT59DS_Axis = 59;
  KDT60DS_Axis = 60;
  KDT61DS_Axis = 61;
  KDT62DS_Axis = 62;
  KDT63DS_Axis = 63;
  KDT64DS_Axis = 64;
  KDT65DS_Axis = 65;
  KDT66DS_Axis = 66;
  KDT67DS_Axis = 67;
  KDT68DS_Axis = 68;
  KDT69DS_Axis = 69;
  KDT70DS_Axis = 70;
  KDT71DS_Axis = 71;
  KDT72DS_Axis = 72;
  KDT84DS_Axis = 84;
  KDT96DS_Axis = 96;
  KDT128DS_Axis = 128;
  KDT140DS_Axis = 140;
  KDT160DS_Axis = 160;
  KDT196DS_Axis = 196;
  KDT256DS_Axis = 256;
  KDT272DS_Axis = 272;
  KDT288DS_Axis = 288;
  KDT372DS_Axis = 372;
  KDT512DS_Axis = 512;
  KDT576DS_Axis = 576;
  KDT768DS_Axis = 768;
  KDT1024DS_Axis = 1024;
  KDT1040DS_Axis = 1040;
  KDT1056DS_Axis = 1056;
  KDT1536DS_Axis = 1536;
  KDT1920DS_Axis = 1920;
  KDT1980DS_Axis = 1980;
  KDT2048DS_Axis = 2048;
  KDT3072DS_Axis = 3072;
  KDT3088DS_Axis = 3088;
  KDT3104DS_Axis = 3104;
  KDT4096DS_Axis = 4096;
  KDT8192DS_Axis = 8192;

type

  // Single float: KDTree
  TKDT1DS = class;  TKDT1DS_VecType = Single; // 1D
  TKDT2DS = class;  TKDT2DS_VecType = Single; // 2D
  TKDT3DS = class;  TKDT3DS_VecType = Single; // 3D
  TKDT4DS = class;  TKDT4DS_VecType = Single; // 4D
  TKDT5DS = class;  TKDT5DS_VecType = Single; // 5D
  TKDT6DS = class;  TKDT6DS_VecType = Single; // 6D
  TKDT7DS = class;  TKDT7DS_VecType = Single; // 7D
  TKDT8DS = class;  TKDT8DS_VecType = Single; // 8D
  TKDT9DS = class;  TKDT9DS_VecType = Single; // 9D
  TKDT10DS = class;  TKDT10DS_VecType = Single; // 10D
  TKDT11DS = class;  TKDT11DS_VecType = Single; // 11D
  TKDT12DS = class;  TKDT12DS_VecType = Single; // 12D
  TKDT13DS = class;  TKDT13DS_VecType = Single; // 13D
  TKDT14DS = class;  TKDT14DS_VecType = Single; // 14D
  TKDT15DS = class;  TKDT15DS_VecType = Single; // 15D
  TKDT16DS = class;  TKDT16DS_VecType = Single; // 16D
  TKDT17DS = class;  TKDT17DS_VecType = Single; // 17D
  TKDT18DS = class;  TKDT18DS_VecType = Single; // 18D
  TKDT19DS = class;  TKDT19DS_VecType = Single; // 19D
  TKDT20DS = class;  TKDT20DS_VecType = Single; // 20D
  TKDT21DS = class;  TKDT21DS_VecType = Single; // 21D
  TKDT22DS = class;  TKDT22DS_VecType = Single; // 22D
  TKDT23DS = class;  TKDT23DS_VecType = Single; // 23D
  TKDT24DS = class;  TKDT24DS_VecType = Single; // 24D
  TKDT25DS = class;  TKDT25DS_VecType = Single; // 25D
  TKDT26DS = class;  TKDT26DS_VecType = Single; // 26D
  TKDT27DS = class;  TKDT27DS_VecType = Single; // 27D
  TKDT28DS = class;  TKDT28DS_VecType = Single; // 28D
  TKDT29DS = class;  TKDT29DS_VecType = Single; // 29D
  TKDT30DS = class;  TKDT30DS_VecType = Single; // 30D
  TKDT31DS = class;  TKDT31DS_VecType = Single; // 31D
  TKDT32DS = class;  TKDT32DS_VecType = Single; // 32D
  TKDT33DS = class;  TKDT33DS_VecType = Single; // 33D
  TKDT34DS = class;  TKDT34DS_VecType = Single; // 34D
  TKDT35DS = class;  TKDT35DS_VecType = Single; // 35D
  TKDT36DS = class;  TKDT36DS_VecType = Single; // 36D
  TKDT37DS = class;  TKDT37DS_VecType = Single; // 37D
  TKDT38DS = class;  TKDT38DS_VecType = Single; // 38D
  TKDT39DS = class;  TKDT39DS_VecType = Single; // 39D
  TKDT40DS = class;  TKDT40DS_VecType = Single; // 40D
  TKDT41DS = class;  TKDT41DS_VecType = Single; // 41D
  TKDT42DS = class;  TKDT42DS_VecType = Single; // 42D
  TKDT43DS = class;  TKDT43DS_VecType = Single; // 43D
  TKDT44DS = class;  TKDT44DS_VecType = Single; // 44D
  TKDT45DS = class;  TKDT45DS_VecType = Single; // 45D
  TKDT46DS = class;  TKDT46DS_VecType = Single; // 46D
  TKDT47DS = class;  TKDT47DS_VecType = Single; // 47D
  TKDT48DS = class;  TKDT48DS_VecType = Single; // 48D
  TKDT49DS = class;  TKDT49DS_VecType = Single; // 49D
  TKDT50DS = class;  TKDT50DS_VecType = Single; // 50D
  TKDT51DS = class;  TKDT51DS_VecType = Single; // 51D
  TKDT52DS = class;  TKDT52DS_VecType = Single; // 52D
  TKDT53DS = class;  TKDT53DS_VecType = Single; // 53D
  TKDT54DS = class;  TKDT54DS_VecType = Single; // 54D
  TKDT55DS = class;  TKDT55DS_VecType = Single; // 55D
  TKDT56DS = class;  TKDT56DS_VecType = Single; // 56D
  TKDT57DS = class;  TKDT57DS_VecType = Single; // 57D
  TKDT58DS = class;  TKDT58DS_VecType = Single; // 58D
  TKDT59DS = class;  TKDT59DS_VecType = Single; // 59D
  TKDT60DS = class;  TKDT60DS_VecType = Single; // 60D
  TKDT61DS = class;  TKDT61DS_VecType = Single; // 61D
  TKDT62DS = class;  TKDT62DS_VecType = Single; // 62D
  TKDT63DS = class;  TKDT63DS_VecType = Single; // 63D
  TKDT64DS = class;  TKDT64DS_VecType = Single; // 64D
  TKDT65DS = class;  TKDT65DS_VecType = Single; // 65D
  TKDT66DS = class;  TKDT66DS_VecType = Single; // 66D
  TKDT67DS = class;  TKDT67DS_VecType = Single; // 67D
  TKDT68DS = class;  TKDT68DS_VecType = Single; // 68D
  TKDT69DS = class;  TKDT69DS_VecType = Single; // 69D
  TKDT70DS = class;  TKDT70DS_VecType = Single; // 70D
  TKDT71DS = class;  TKDT71DS_VecType = Single; // 71D
  TKDT72DS = class;  TKDT72DS_VecType = Single; // 72D
  TKDT84DS = class;  TKDT84DS_VecType = Single; // 84D
  TKDT96DS = class;  TKDT96DS_VecType = Single; // 96D
  TKDT128DS = class;  TKDT128DS_VecType = Single; // 128D
  TKDT140DS = class;  TKDT140DS_VecType = Single; // 140D
  TKDT160DS = class;  TKDT160DS_VecType = Single; // 160D
  TKDT196DS = class;  TKDT196DS_VecType = Single; // 196D
  TKDT256DS = class;  TKDT256DS_VecType = Single; // 256D
  TKDT272DS = class;  TKDT272DS_VecType = Single; // 272D
  TKDT288DS = class;  TKDT288DS_VecType = Single; // 288D
  TKDT372DS = class;  TKDT372DS_VecType = Single; // 372D
  TKDT512DS = class;  TKDT512DS_VecType = Single; // 512D
  TKDT576DS = class;  TKDT576DS_VecType = Single; // 576D
  TKDT768DS = class;  TKDT768DS_VecType = Single; // 768D
  TKDT1024DS = class;  TKDT1024DS_VecType = Single; // 1024D
  TKDT1040DS = class;  TKDT1040DS_VecType = Single; // 1040D
  TKDT1056DS = class;  TKDT1056DS_VecType = Single; // 1056D
  TKDT1536DS = class;  TKDT1536DS_VecType = Single; // 1536D
  TKDT1920DS = class;  TKDT1920DS_VecType = Single; // 1920D
  TKDT1980DS = class;  TKDT1980DS_VecType = Single; // 1980D
  TKDT2048DS = class;  TKDT2048DS_VecType = Single; // 2048D
  TKDT3072DS = class;  TKDT3072DS_VecType = Single; // 3072D
  TKDT3088DS = class;  TKDT3088DS_VecType = Single; // 3088D
  TKDT3104DS = class;  TKDT3104DS_VecType = Single; // 3104D
  TKDT4096DS = class;  TKDT4096DS_VecType = Single; // 4096D
  TKDT8192DS = class;  TKDT8192DS_VecType = Single; // 8192D





  // Single float: KDTree


  TKDT1DS = class(TCoreClassObject)
  public type
    // code split
    TKDT1DS_Vec = packed array [0 .. KDT1DS_Axis - 1] of TKDT1DS_VecType;
    PKDT1DS_Vec = ^TKDT1DS_Vec;

    TKDT1DS_DynamicVecBuffer = array of TKDT1DS_Vec;
    PKDT1DS_DynamicVecBuffer = ^TKDT1DS_DynamicVecBuffer;

    TKDT1DS_Source = packed record
      Buff: TKDT1DS_Vec;
      index: Integer;
    end;

    PKDT1DS_Source       = ^TKDT1DS_Source;
    TKDT1DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1DS_Source) - 1] of PKDT1DS_Source;
    PKDT1DS_SourceBuffer = ^TKDT1DS_SourceBuffer;

    TKDT1DSyanmicSourceBuffer = packed array of PKDT1DS_Source;
    PKDT1DSyanmicSourceBuffer = ^TKDT1DSyanmicSourceBuffer;

    TKDT1DSyanmicStoreBuffer = packed array of TKDT1DS_Source;
    PKDT1DSyanmicStoreBuffer = ^TKDT1DSyanmicStoreBuffer;

    PKDT1DS_Node = ^TKDT1DS_Node;

    TKDT1DS_Node = packed record
      Parent, Right, Left: PKDT1DS_Node;
      vec: PKDT1DS_Source;
    end;

    TKDT1DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1DS_Source; const Data: Pointer);
    TKDT1DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1DSyanmicStoreBuffer;
    KDBuff     : TKDT1DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1DS_Node;
    TestBuff   : TKDT1DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DS_Node;
    function GetData(const index: NativeInt): PKDT1DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DS_Node; overload;
    function Search(const Buff: TKDT1DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DS_Node; overload;
    function Search(const Buff: TKDT1DS_Vec; var SearchedDistanceMin: Double): PKDT1DS_Node; overload;
    function Search(const Buff: TKDT1DS_Vec): PKDT1DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1DS_DynamicVecBuffer; var OutBuff: TKDT1DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1DS_Node);
    procedure PrintBuffer;

    class function KDT1DSVec(const s: string): TKDT1DS_Vec; overload;
    class function KDT1DSVec(const v: TKDT1DS_Vec): string; overload;
    class function KDT1DSPow(const v: TKDT1DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1DSDistance(const v1, v2: TKDT1DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT2DS = class(TCoreClassObject)
  public type
    // code split
    TKDT2DS_Vec = packed array [0 .. KDT2DS_Axis - 1] of TKDT2DS_VecType;
    PKDT2DS_Vec = ^TKDT2DS_Vec;

    TKDT2DS_DynamicVecBuffer = array of TKDT2DS_Vec;
    PKDT2DS_DynamicVecBuffer = ^TKDT2DS_DynamicVecBuffer;

    TKDT2DS_Source = packed record
      Buff: TKDT2DS_Vec;
      index: Integer;
    end;

    PKDT2DS_Source       = ^TKDT2DS_Source;
    TKDT2DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT2DS_Source) - 1] of PKDT2DS_Source;
    PKDT2DS_SourceBuffer = ^TKDT2DS_SourceBuffer;

    TKDT2DSyanmicSourceBuffer = packed array of PKDT2DS_Source;
    PKDT2DSyanmicSourceBuffer = ^TKDT2DSyanmicSourceBuffer;

    TKDT2DSyanmicStoreBuffer = packed array of TKDT2DS_Source;
    PKDT2DSyanmicStoreBuffer = ^TKDT2DSyanmicStoreBuffer;

    PKDT2DS_Node = ^TKDT2DS_Node;

    TKDT2DS_Node = packed record
      Parent, Right, Left: PKDT2DS_Node;
      vec: PKDT2DS_Source;
    end;

    TKDT2DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT2DS_Source; const Data: Pointer);
    TKDT2DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT2DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT2DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT2DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT2DSyanmicStoreBuffer;
    KDBuff     : TKDT2DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2DS_Node;
    TestBuff   : TKDT2DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DS_Node;
    function GetData(const index: NativeInt): PKDT2DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT2DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DS_Node; overload;
    function Search(const Buff: TKDT2DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DS_Node; overload;
    function Search(const Buff: TKDT2DS_Vec; var SearchedDistanceMin: Double): PKDT2DS_Node; overload;
    function Search(const Buff: TKDT2DS_Vec): PKDT2DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2DS_DynamicVecBuffer; var OutBuff: TKDT2DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT2DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT2DS_Node);
    procedure PrintBuffer;

    class function KDT2DSVec(const s: string): TKDT2DS_Vec; overload;
    class function KDT2DSVec(const v: TKDT2DS_Vec): string; overload;
    class function KDT2DSPow(const v: TKDT2DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT2DSDistance(const v1, v2: TKDT2DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3DS = class(TCoreClassObject)
  public type
    // code split
    TKDT3DS_Vec = packed array [0 .. KDT3DS_Axis - 1] of TKDT3DS_VecType;
    PKDT3DS_Vec = ^TKDT3DS_Vec;

    TKDT3DS_DynamicVecBuffer = array of TKDT3DS_Vec;
    PKDT3DS_DynamicVecBuffer = ^TKDT3DS_DynamicVecBuffer;

    TKDT3DS_Source = packed record
      Buff: TKDT3DS_Vec;
      index: Integer;
    end;

    PKDT3DS_Source       = ^TKDT3DS_Source;
    TKDT3DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT3DS_Source) - 1] of PKDT3DS_Source;
    PKDT3DS_SourceBuffer = ^TKDT3DS_SourceBuffer;

    TKDT3DSyanmicSourceBuffer = packed array of PKDT3DS_Source;
    PKDT3DSyanmicSourceBuffer = ^TKDT3DSyanmicSourceBuffer;

    TKDT3DSyanmicStoreBuffer = packed array of TKDT3DS_Source;
    PKDT3DSyanmicStoreBuffer = ^TKDT3DSyanmicStoreBuffer;

    PKDT3DS_Node = ^TKDT3DS_Node;

    TKDT3DS_Node = packed record
      Parent, Right, Left: PKDT3DS_Node;
      vec: PKDT3DS_Source;
    end;

    TKDT3DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3DS_Source; const Data: Pointer);
    TKDT3DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3DSyanmicStoreBuffer;
    KDBuff     : TKDT3DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3DS_Node;
    TestBuff   : TKDT3DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DS_Node;
    function GetData(const index: NativeInt): PKDT3DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DS_Node; overload;
    function Search(const Buff: TKDT3DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DS_Node; overload;
    function Search(const Buff: TKDT3DS_Vec; var SearchedDistanceMin: Double): PKDT3DS_Node; overload;
    function Search(const Buff: TKDT3DS_Vec): PKDT3DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3DS_DynamicVecBuffer; var OutBuff: TKDT3DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3DS_Node);
    procedure PrintBuffer;

    class function KDT3DSVec(const s: string): TKDT3DS_Vec; overload;
    class function KDT3DSVec(const v: TKDT3DS_Vec): string; overload;
    class function KDT3DSPow(const v: TKDT3DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3DSDistance(const v1, v2: TKDT3DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT4DS = class(TCoreClassObject)
  public type
    // code split
    TKDT4DS_Vec = packed array [0 .. KDT4DS_Axis - 1] of TKDT4DS_VecType;
    PKDT4DS_Vec = ^TKDT4DS_Vec;

    TKDT4DS_DynamicVecBuffer = array of TKDT4DS_Vec;
    PKDT4DS_DynamicVecBuffer = ^TKDT4DS_DynamicVecBuffer;

    TKDT4DS_Source = packed record
      Buff: TKDT4DS_Vec;
      index: Integer;
    end;

    PKDT4DS_Source       = ^TKDT4DS_Source;
    TKDT4DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT4DS_Source) - 1] of PKDT4DS_Source;
    PKDT4DS_SourceBuffer = ^TKDT4DS_SourceBuffer;

    TKDT4DSyanmicSourceBuffer = packed array of PKDT4DS_Source;
    PKDT4DSyanmicSourceBuffer = ^TKDT4DSyanmicSourceBuffer;

    TKDT4DSyanmicStoreBuffer = packed array of TKDT4DS_Source;
    PKDT4DSyanmicStoreBuffer = ^TKDT4DSyanmicStoreBuffer;

    PKDT4DS_Node = ^TKDT4DS_Node;

    TKDT4DS_Node = packed record
      Parent, Right, Left: PKDT4DS_Node;
      vec: PKDT4DS_Source;
    end;

    TKDT4DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT4DS_Source; const Data: Pointer);
    TKDT4DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT4DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT4DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT4DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT4DSyanmicStoreBuffer;
    KDBuff     : TKDT4DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4DS_Node;
    TestBuff   : TKDT4DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DS_Node;
    function GetData(const index: NativeInt): PKDT4DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT4DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DS_Node; overload;
    function Search(const Buff: TKDT4DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DS_Node; overload;
    function Search(const Buff: TKDT4DS_Vec; var SearchedDistanceMin: Double): PKDT4DS_Node; overload;
    function Search(const Buff: TKDT4DS_Vec): PKDT4DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4DS_DynamicVecBuffer; var OutBuff: TKDT4DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT4DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT4DS_Node);
    procedure PrintBuffer;

    class function KDT4DSVec(const s: string): TKDT4DS_Vec; overload;
    class function KDT4DSVec(const v: TKDT4DS_Vec): string; overload;
    class function KDT4DSPow(const v: TKDT4DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT4DSDistance(const v1, v2: TKDT4DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT5DS = class(TCoreClassObject)
  public type
    // code split
    TKDT5DS_Vec = packed array [0 .. KDT5DS_Axis - 1] of TKDT5DS_VecType;
    PKDT5DS_Vec = ^TKDT5DS_Vec;

    TKDT5DS_DynamicVecBuffer = array of TKDT5DS_Vec;
    PKDT5DS_DynamicVecBuffer = ^TKDT5DS_DynamicVecBuffer;

    TKDT5DS_Source = packed record
      Buff: TKDT5DS_Vec;
      index: Integer;
    end;

    PKDT5DS_Source       = ^TKDT5DS_Source;
    TKDT5DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT5DS_Source) - 1] of PKDT5DS_Source;
    PKDT5DS_SourceBuffer = ^TKDT5DS_SourceBuffer;

    TKDT5DSyanmicSourceBuffer = packed array of PKDT5DS_Source;
    PKDT5DSyanmicSourceBuffer = ^TKDT5DSyanmicSourceBuffer;

    TKDT5DSyanmicStoreBuffer = packed array of TKDT5DS_Source;
    PKDT5DSyanmicStoreBuffer = ^TKDT5DSyanmicStoreBuffer;

    PKDT5DS_Node = ^TKDT5DS_Node;

    TKDT5DS_Node = packed record
      Parent, Right, Left: PKDT5DS_Node;
      vec: PKDT5DS_Source;
    end;

    TKDT5DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT5DS_Source; const Data: Pointer);
    TKDT5DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT5DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT5DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT5DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT5DSyanmicStoreBuffer;
    KDBuff     : TKDT5DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT5DS_Node;
    TestBuff   : TKDT5DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DS_Node;
    function GetData(const index: NativeInt): PKDT5DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT5DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT5DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT5DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT5DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DS_Node; overload;
    function Search(const Buff: TKDT5DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DS_Node; overload;
    function Search(const Buff: TKDT5DS_Vec; var SearchedDistanceMin: Double): PKDT5DS_Node; overload;
    function Search(const Buff: TKDT5DS_Vec): PKDT5DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT5DS_DynamicVecBuffer; var OutBuff: TKDT5DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT5DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT5DS_Node);
    procedure PrintBuffer;

    class function KDT5DSVec(const s: string): TKDT5DS_Vec; overload;
    class function KDT5DSVec(const v: TKDT5DS_Vec): string; overload;
    class function KDT5DSPow(const v: TKDT5DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT5DSDistance(const v1, v2: TKDT5DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT6DS = class(TCoreClassObject)
  public type
    // code split
    TKDT6DS_Vec = packed array [0 .. KDT6DS_Axis - 1] of TKDT6DS_VecType;
    PKDT6DS_Vec = ^TKDT6DS_Vec;

    TKDT6DS_DynamicVecBuffer = array of TKDT6DS_Vec;
    PKDT6DS_DynamicVecBuffer = ^TKDT6DS_DynamicVecBuffer;

    TKDT6DS_Source = packed record
      Buff: TKDT6DS_Vec;
      index: Integer;
    end;

    PKDT6DS_Source       = ^TKDT6DS_Source;
    TKDT6DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT6DS_Source) - 1] of PKDT6DS_Source;
    PKDT6DS_SourceBuffer = ^TKDT6DS_SourceBuffer;

    TKDT6DSyanmicSourceBuffer = packed array of PKDT6DS_Source;
    PKDT6DSyanmicSourceBuffer = ^TKDT6DSyanmicSourceBuffer;

    TKDT6DSyanmicStoreBuffer = packed array of TKDT6DS_Source;
    PKDT6DSyanmicStoreBuffer = ^TKDT6DSyanmicStoreBuffer;

    PKDT6DS_Node = ^TKDT6DS_Node;

    TKDT6DS_Node = packed record
      Parent, Right, Left: PKDT6DS_Node;
      vec: PKDT6DS_Source;
    end;

    TKDT6DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT6DS_Source; const Data: Pointer);
    TKDT6DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT6DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT6DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT6DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT6DSyanmicStoreBuffer;
    KDBuff     : TKDT6DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT6DS_Node;
    TestBuff   : TKDT6DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DS_Node;
    function GetData(const index: NativeInt): PKDT6DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT6DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT6DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT6DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DS_Node; overload;
    function Search(const Buff: TKDT6DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DS_Node; overload;
    function Search(const Buff: TKDT6DS_Vec; var SearchedDistanceMin: Double): PKDT6DS_Node; overload;
    function Search(const Buff: TKDT6DS_Vec): PKDT6DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT6DS_DynamicVecBuffer; var OutBuff: TKDT6DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT6DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT6DS_Node);
    procedure PrintBuffer;

    class function KDT6DSVec(const s: string): TKDT6DS_Vec; overload;
    class function KDT6DSVec(const v: TKDT6DS_Vec): string; overload;
    class function KDT6DSPow(const v: TKDT6DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT6DSDistance(const v1, v2: TKDT6DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT7DS = class(TCoreClassObject)
  public type
    // code split
    TKDT7DS_Vec = packed array [0 .. KDT7DS_Axis - 1] of TKDT7DS_VecType;
    PKDT7DS_Vec = ^TKDT7DS_Vec;

    TKDT7DS_DynamicVecBuffer = array of TKDT7DS_Vec;
    PKDT7DS_DynamicVecBuffer = ^TKDT7DS_DynamicVecBuffer;

    TKDT7DS_Source = packed record
      Buff: TKDT7DS_Vec;
      index: Integer;
    end;

    PKDT7DS_Source       = ^TKDT7DS_Source;
    TKDT7DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT7DS_Source) - 1] of PKDT7DS_Source;
    PKDT7DS_SourceBuffer = ^TKDT7DS_SourceBuffer;

    TKDT7DSyanmicSourceBuffer = packed array of PKDT7DS_Source;
    PKDT7DSyanmicSourceBuffer = ^TKDT7DSyanmicSourceBuffer;

    TKDT7DSyanmicStoreBuffer = packed array of TKDT7DS_Source;
    PKDT7DSyanmicStoreBuffer = ^TKDT7DSyanmicStoreBuffer;

    PKDT7DS_Node = ^TKDT7DS_Node;

    TKDT7DS_Node = packed record
      Parent, Right, Left: PKDT7DS_Node;
      vec: PKDT7DS_Source;
    end;

    TKDT7DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT7DS_Source; const Data: Pointer);
    TKDT7DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT7DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT7DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT7DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT7DSyanmicStoreBuffer;
    KDBuff     : TKDT7DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT7DS_Node;
    TestBuff   : TKDT7DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DS_Node;
    function GetData(const index: NativeInt): PKDT7DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT7DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT7DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT7DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT7DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DS_Node; overload;
    function Search(const Buff: TKDT7DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DS_Node; overload;
    function Search(const Buff: TKDT7DS_Vec; var SearchedDistanceMin: Double): PKDT7DS_Node; overload;
    function Search(const Buff: TKDT7DS_Vec): PKDT7DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT7DS_DynamicVecBuffer; var OutBuff: TKDT7DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT7DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT7DS_Node);
    procedure PrintBuffer;

    class function KDT7DSVec(const s: string): TKDT7DS_Vec; overload;
    class function KDT7DSVec(const v: TKDT7DS_Vec): string; overload;
    class function KDT7DSPow(const v: TKDT7DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT7DSDistance(const v1, v2: TKDT7DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT8DS = class(TCoreClassObject)
  public type
    // code split
    TKDT8DS_Vec = packed array [0 .. KDT8DS_Axis - 1] of TKDT8DS_VecType;
    PKDT8DS_Vec = ^TKDT8DS_Vec;

    TKDT8DS_DynamicVecBuffer = array of TKDT8DS_Vec;
    PKDT8DS_DynamicVecBuffer = ^TKDT8DS_DynamicVecBuffer;

    TKDT8DS_Source = packed record
      Buff: TKDT8DS_Vec;
      index: Integer;
    end;

    PKDT8DS_Source       = ^TKDT8DS_Source;
    TKDT8DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT8DS_Source) - 1] of PKDT8DS_Source;
    PKDT8DS_SourceBuffer = ^TKDT8DS_SourceBuffer;

    TKDT8DSyanmicSourceBuffer = packed array of PKDT8DS_Source;
    PKDT8DSyanmicSourceBuffer = ^TKDT8DSyanmicSourceBuffer;

    TKDT8DSyanmicStoreBuffer = packed array of TKDT8DS_Source;
    PKDT8DSyanmicStoreBuffer = ^TKDT8DSyanmicStoreBuffer;

    PKDT8DS_Node = ^TKDT8DS_Node;

    TKDT8DS_Node = packed record
      Parent, Right, Left: PKDT8DS_Node;
      vec: PKDT8DS_Source;
    end;

    TKDT8DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT8DS_Source; const Data: Pointer);
    TKDT8DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT8DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT8DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT8DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT8DSyanmicStoreBuffer;
    KDBuff     : TKDT8DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8DS_Node;
    TestBuff   : TKDT8DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DS_Node;
    function GetData(const index: NativeInt): PKDT8DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT8DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DS_Node; overload;
    function Search(const Buff: TKDT8DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DS_Node; overload;
    function Search(const Buff: TKDT8DS_Vec; var SearchedDistanceMin: Double): PKDT8DS_Node; overload;
    function Search(const Buff: TKDT8DS_Vec): PKDT8DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8DS_DynamicVecBuffer; var OutBuff: TKDT8DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT8DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT8DS_Node);
    procedure PrintBuffer;

    class function KDT8DSVec(const s: string): TKDT8DS_Vec; overload;
    class function KDT8DSVec(const v: TKDT8DS_Vec): string; overload;
    class function KDT8DSPow(const v: TKDT8DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT8DSDistance(const v1, v2: TKDT8DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT9DS = class(TCoreClassObject)
  public type
    // code split
    TKDT9DS_Vec = packed array [0 .. KDT9DS_Axis - 1] of TKDT9DS_VecType;
    PKDT9DS_Vec = ^TKDT9DS_Vec;

    TKDT9DS_DynamicVecBuffer = array of TKDT9DS_Vec;
    PKDT9DS_DynamicVecBuffer = ^TKDT9DS_DynamicVecBuffer;

    TKDT9DS_Source = packed record
      Buff: TKDT9DS_Vec;
      index: Integer;
    end;

    PKDT9DS_Source       = ^TKDT9DS_Source;
    TKDT9DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT9DS_Source) - 1] of PKDT9DS_Source;
    PKDT9DS_SourceBuffer = ^TKDT9DS_SourceBuffer;

    TKDT9DSyanmicSourceBuffer = packed array of PKDT9DS_Source;
    PKDT9DSyanmicSourceBuffer = ^TKDT9DSyanmicSourceBuffer;

    TKDT9DSyanmicStoreBuffer = packed array of TKDT9DS_Source;
    PKDT9DSyanmicStoreBuffer = ^TKDT9DSyanmicStoreBuffer;

    PKDT9DS_Node = ^TKDT9DS_Node;

    TKDT9DS_Node = packed record
      Parent, Right, Left: PKDT9DS_Node;
      vec: PKDT9DS_Source;
    end;

    TKDT9DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT9DS_Source; const Data: Pointer);
    TKDT9DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT9DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT9DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT9DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT9DSyanmicStoreBuffer;
    KDBuff     : TKDT9DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT9DS_Node;
    TestBuff   : TKDT9DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DS_Node;
    function GetData(const index: NativeInt): PKDT9DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT9DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT9DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT9DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT9DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DS_Node; overload;
    function Search(const Buff: TKDT9DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DS_Node; overload;
    function Search(const Buff: TKDT9DS_Vec; var SearchedDistanceMin: Double): PKDT9DS_Node; overload;
    function Search(const Buff: TKDT9DS_Vec): PKDT9DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT9DS_DynamicVecBuffer; var OutBuff: TKDT9DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT9DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT9DS_Node);
    procedure PrintBuffer;

    class function KDT9DSVec(const s: string): TKDT9DS_Vec; overload;
    class function KDT9DSVec(const v: TKDT9DS_Vec): string; overload;
    class function KDT9DSPow(const v: TKDT9DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT9DSDistance(const v1, v2: TKDT9DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT10DS = class(TCoreClassObject)
  public type
    // code split
    TKDT10DS_Vec = packed array [0 .. KDT10DS_Axis - 1] of TKDT10DS_VecType;
    PKDT10DS_Vec = ^TKDT10DS_Vec;

    TKDT10DS_DynamicVecBuffer = array of TKDT10DS_Vec;
    PKDT10DS_DynamicVecBuffer = ^TKDT10DS_DynamicVecBuffer;

    TKDT10DS_Source = packed record
      Buff: TKDT10DS_Vec;
      index: Integer;
    end;

    PKDT10DS_Source       = ^TKDT10DS_Source;
    TKDT10DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT10DS_Source) - 1] of PKDT10DS_Source;
    PKDT10DS_SourceBuffer = ^TKDT10DS_SourceBuffer;

    TKDT10DSyanmicSourceBuffer = packed array of PKDT10DS_Source;
    PKDT10DSyanmicSourceBuffer = ^TKDT10DSyanmicSourceBuffer;

    TKDT10DSyanmicStoreBuffer = packed array of TKDT10DS_Source;
    PKDT10DSyanmicStoreBuffer = ^TKDT10DSyanmicStoreBuffer;

    PKDT10DS_Node = ^TKDT10DS_Node;

    TKDT10DS_Node = packed record
      Parent, Right, Left: PKDT10DS_Node;
      vec: PKDT10DS_Source;
    end;

    TKDT10DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT10DS_Source; const Data: Pointer);
    TKDT10DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT10DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT10DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT10DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT10DSyanmicStoreBuffer;
    KDBuff     : TKDT10DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT10DS_Node;
    TestBuff   : TKDT10DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DS_Node;
    function GetData(const index: NativeInt): PKDT10DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT10DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT10DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT10DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DS_Node; overload;
    function Search(const Buff: TKDT10DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DS_Node; overload;
    function Search(const Buff: TKDT10DS_Vec; var SearchedDistanceMin: Double): PKDT10DS_Node; overload;
    function Search(const Buff: TKDT10DS_Vec): PKDT10DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT10DS_DynamicVecBuffer; var OutBuff: TKDT10DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT10DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT10DS_Node);
    procedure PrintBuffer;

    class function KDT10DSVec(const s: string): TKDT10DS_Vec; overload;
    class function KDT10DSVec(const v: TKDT10DS_Vec): string; overload;
    class function KDT10DSPow(const v: TKDT10DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT10DSDistance(const v1, v2: TKDT10DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT11DS = class(TCoreClassObject)
  public type
    // code split
    TKDT11DS_Vec = packed array [0 .. KDT11DS_Axis - 1] of TKDT11DS_VecType;
    PKDT11DS_Vec = ^TKDT11DS_Vec;

    TKDT11DS_DynamicVecBuffer = array of TKDT11DS_Vec;
    PKDT11DS_DynamicVecBuffer = ^TKDT11DS_DynamicVecBuffer;

    TKDT11DS_Source = packed record
      Buff: TKDT11DS_Vec;
      index: Integer;
    end;

    PKDT11DS_Source       = ^TKDT11DS_Source;
    TKDT11DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT11DS_Source) - 1] of PKDT11DS_Source;
    PKDT11DS_SourceBuffer = ^TKDT11DS_SourceBuffer;

    TKDT11DSyanmicSourceBuffer = packed array of PKDT11DS_Source;
    PKDT11DSyanmicSourceBuffer = ^TKDT11DSyanmicSourceBuffer;

    TKDT11DSyanmicStoreBuffer = packed array of TKDT11DS_Source;
    PKDT11DSyanmicStoreBuffer = ^TKDT11DSyanmicStoreBuffer;

    PKDT11DS_Node = ^TKDT11DS_Node;

    TKDT11DS_Node = packed record
      Parent, Right, Left: PKDT11DS_Node;
      vec: PKDT11DS_Source;
    end;

    TKDT11DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT11DS_Source; const Data: Pointer);
    TKDT11DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT11DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT11DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT11DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT11DSyanmicStoreBuffer;
    KDBuff     : TKDT11DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT11DS_Node;
    TestBuff   : TKDT11DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DS_Node;
    function GetData(const index: NativeInt): PKDT11DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT11DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT11DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT11DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT11DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DS_Node; overload;
    function Search(const Buff: TKDT11DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DS_Node; overload;
    function Search(const Buff: TKDT11DS_Vec; var SearchedDistanceMin: Double): PKDT11DS_Node; overload;
    function Search(const Buff: TKDT11DS_Vec): PKDT11DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT11DS_DynamicVecBuffer; var OutBuff: TKDT11DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT11DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT11DS_Node);
    procedure PrintBuffer;

    class function KDT11DSVec(const s: string): TKDT11DS_Vec; overload;
    class function KDT11DSVec(const v: TKDT11DS_Vec): string; overload;
    class function KDT11DSPow(const v: TKDT11DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT11DSDistance(const v1, v2: TKDT11DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT12DS = class(TCoreClassObject)
  public type
    // code split
    TKDT12DS_Vec = packed array [0 .. KDT12DS_Axis - 1] of TKDT12DS_VecType;
    PKDT12DS_Vec = ^TKDT12DS_Vec;

    TKDT12DS_DynamicVecBuffer = array of TKDT12DS_Vec;
    PKDT12DS_DynamicVecBuffer = ^TKDT12DS_DynamicVecBuffer;

    TKDT12DS_Source = packed record
      Buff: TKDT12DS_Vec;
      index: Integer;
    end;

    PKDT12DS_Source       = ^TKDT12DS_Source;
    TKDT12DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT12DS_Source) - 1] of PKDT12DS_Source;
    PKDT12DS_SourceBuffer = ^TKDT12DS_SourceBuffer;

    TKDT12DSyanmicSourceBuffer = packed array of PKDT12DS_Source;
    PKDT12DSyanmicSourceBuffer = ^TKDT12DSyanmicSourceBuffer;

    TKDT12DSyanmicStoreBuffer = packed array of TKDT12DS_Source;
    PKDT12DSyanmicStoreBuffer = ^TKDT12DSyanmicStoreBuffer;

    PKDT12DS_Node = ^TKDT12DS_Node;

    TKDT12DS_Node = packed record
      Parent, Right, Left: PKDT12DS_Node;
      vec: PKDT12DS_Source;
    end;

    TKDT12DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT12DS_Source; const Data: Pointer);
    TKDT12DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT12DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT12DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT12DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT12DSyanmicStoreBuffer;
    KDBuff     : TKDT12DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT12DS_Node;
    TestBuff   : TKDT12DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DS_Node;
    function GetData(const index: NativeInt): PKDT12DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT12DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT12DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT12DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DS_Node; overload;
    function Search(const Buff: TKDT12DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DS_Node; overload;
    function Search(const Buff: TKDT12DS_Vec; var SearchedDistanceMin: Double): PKDT12DS_Node; overload;
    function Search(const Buff: TKDT12DS_Vec): PKDT12DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT12DS_DynamicVecBuffer; var OutBuff: TKDT12DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT12DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT12DS_Node);
    procedure PrintBuffer;

    class function KDT12DSVec(const s: string): TKDT12DS_Vec; overload;
    class function KDT12DSVec(const v: TKDT12DS_Vec): string; overload;
    class function KDT12DSPow(const v: TKDT12DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT12DSDistance(const v1, v2: TKDT12DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT13DS = class(TCoreClassObject)
  public type
    // code split
    TKDT13DS_Vec = packed array [0 .. KDT13DS_Axis - 1] of TKDT13DS_VecType;
    PKDT13DS_Vec = ^TKDT13DS_Vec;

    TKDT13DS_DynamicVecBuffer = array of TKDT13DS_Vec;
    PKDT13DS_DynamicVecBuffer = ^TKDT13DS_DynamicVecBuffer;

    TKDT13DS_Source = packed record
      Buff: TKDT13DS_Vec;
      index: Integer;
    end;

    PKDT13DS_Source       = ^TKDT13DS_Source;
    TKDT13DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT13DS_Source) - 1] of PKDT13DS_Source;
    PKDT13DS_SourceBuffer = ^TKDT13DS_SourceBuffer;

    TKDT13DSyanmicSourceBuffer = packed array of PKDT13DS_Source;
    PKDT13DSyanmicSourceBuffer = ^TKDT13DSyanmicSourceBuffer;

    TKDT13DSyanmicStoreBuffer = packed array of TKDT13DS_Source;
    PKDT13DSyanmicStoreBuffer = ^TKDT13DSyanmicStoreBuffer;

    PKDT13DS_Node = ^TKDT13DS_Node;

    TKDT13DS_Node = packed record
      Parent, Right, Left: PKDT13DS_Node;
      vec: PKDT13DS_Source;
    end;

    TKDT13DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT13DS_Source; const Data: Pointer);
    TKDT13DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT13DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT13DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT13DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT13DSyanmicStoreBuffer;
    KDBuff     : TKDT13DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT13DS_Node;
    TestBuff   : TKDT13DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DS_Node;
    function GetData(const index: NativeInt): PKDT13DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT13DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT13DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT13DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT13DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DS_Node; overload;
    function Search(const Buff: TKDT13DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DS_Node; overload;
    function Search(const Buff: TKDT13DS_Vec; var SearchedDistanceMin: Double): PKDT13DS_Node; overload;
    function Search(const Buff: TKDT13DS_Vec): PKDT13DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT13DS_DynamicVecBuffer; var OutBuff: TKDT13DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT13DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT13DS_Node);
    procedure PrintBuffer;

    class function KDT13DSVec(const s: string): TKDT13DS_Vec; overload;
    class function KDT13DSVec(const v: TKDT13DS_Vec): string; overload;
    class function KDT13DSPow(const v: TKDT13DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT13DSDistance(const v1, v2: TKDT13DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT14DS = class(TCoreClassObject)
  public type
    // code split
    TKDT14DS_Vec = packed array [0 .. KDT14DS_Axis - 1] of TKDT14DS_VecType;
    PKDT14DS_Vec = ^TKDT14DS_Vec;

    TKDT14DS_DynamicVecBuffer = array of TKDT14DS_Vec;
    PKDT14DS_DynamicVecBuffer = ^TKDT14DS_DynamicVecBuffer;

    TKDT14DS_Source = packed record
      Buff: TKDT14DS_Vec;
      index: Integer;
    end;

    PKDT14DS_Source       = ^TKDT14DS_Source;
    TKDT14DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT14DS_Source) - 1] of PKDT14DS_Source;
    PKDT14DS_SourceBuffer = ^TKDT14DS_SourceBuffer;

    TKDT14DSyanmicSourceBuffer = packed array of PKDT14DS_Source;
    PKDT14DSyanmicSourceBuffer = ^TKDT14DSyanmicSourceBuffer;

    TKDT14DSyanmicStoreBuffer = packed array of TKDT14DS_Source;
    PKDT14DSyanmicStoreBuffer = ^TKDT14DSyanmicStoreBuffer;

    PKDT14DS_Node = ^TKDT14DS_Node;

    TKDT14DS_Node = packed record
      Parent, Right, Left: PKDT14DS_Node;
      vec: PKDT14DS_Source;
    end;

    TKDT14DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT14DS_Source; const Data: Pointer);
    TKDT14DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT14DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT14DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT14DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT14DSyanmicStoreBuffer;
    KDBuff     : TKDT14DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT14DS_Node;
    TestBuff   : TKDT14DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DS_Node;
    function GetData(const index: NativeInt): PKDT14DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT14DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT14DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT14DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DS_Node; overload;
    function Search(const Buff: TKDT14DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DS_Node; overload;
    function Search(const Buff: TKDT14DS_Vec; var SearchedDistanceMin: Double): PKDT14DS_Node; overload;
    function Search(const Buff: TKDT14DS_Vec): PKDT14DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT14DS_DynamicVecBuffer; var OutBuff: TKDT14DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT14DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT14DS_Node);
    procedure PrintBuffer;

    class function KDT14DSVec(const s: string): TKDT14DS_Vec; overload;
    class function KDT14DSVec(const v: TKDT14DS_Vec): string; overload;
    class function KDT14DSPow(const v: TKDT14DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT14DSDistance(const v1, v2: TKDT14DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT15DS = class(TCoreClassObject)
  public type
    // code split
    TKDT15DS_Vec = packed array [0 .. KDT15DS_Axis - 1] of TKDT15DS_VecType;
    PKDT15DS_Vec = ^TKDT15DS_Vec;

    TKDT15DS_DynamicVecBuffer = array of TKDT15DS_Vec;
    PKDT15DS_DynamicVecBuffer = ^TKDT15DS_DynamicVecBuffer;

    TKDT15DS_Source = packed record
      Buff: TKDT15DS_Vec;
      index: Integer;
    end;

    PKDT15DS_Source       = ^TKDT15DS_Source;
    TKDT15DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT15DS_Source) - 1] of PKDT15DS_Source;
    PKDT15DS_SourceBuffer = ^TKDT15DS_SourceBuffer;

    TKDT15DSyanmicSourceBuffer = packed array of PKDT15DS_Source;
    PKDT15DSyanmicSourceBuffer = ^TKDT15DSyanmicSourceBuffer;

    TKDT15DSyanmicStoreBuffer = packed array of TKDT15DS_Source;
    PKDT15DSyanmicStoreBuffer = ^TKDT15DSyanmicStoreBuffer;

    PKDT15DS_Node = ^TKDT15DS_Node;

    TKDT15DS_Node = packed record
      Parent, Right, Left: PKDT15DS_Node;
      vec: PKDT15DS_Source;
    end;

    TKDT15DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT15DS_Source; const Data: Pointer);
    TKDT15DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT15DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT15DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT15DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT15DSyanmicStoreBuffer;
    KDBuff     : TKDT15DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT15DS_Node;
    TestBuff   : TKDT15DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DS_Node;
    function GetData(const index: NativeInt): PKDT15DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT15DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT15DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT15DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT15DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DS_Node; overload;
    function Search(const Buff: TKDT15DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DS_Node; overload;
    function Search(const Buff: TKDT15DS_Vec; var SearchedDistanceMin: Double): PKDT15DS_Node; overload;
    function Search(const Buff: TKDT15DS_Vec): PKDT15DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT15DS_DynamicVecBuffer; var OutBuff: TKDT15DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT15DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT15DS_Node);
    procedure PrintBuffer;

    class function KDT15DSVec(const s: string): TKDT15DS_Vec; overload;
    class function KDT15DSVec(const v: TKDT15DS_Vec): string; overload;
    class function KDT15DSPow(const v: TKDT15DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT15DSDistance(const v1, v2: TKDT15DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT16DS = class(TCoreClassObject)
  public type
    // code split
    TKDT16DS_Vec = packed array [0 .. KDT16DS_Axis - 1] of TKDT16DS_VecType;
    PKDT16DS_Vec = ^TKDT16DS_Vec;

    TKDT16DS_DynamicVecBuffer = array of TKDT16DS_Vec;
    PKDT16DS_DynamicVecBuffer = ^TKDT16DS_DynamicVecBuffer;

    TKDT16DS_Source = packed record
      Buff: TKDT16DS_Vec;
      index: Integer;
    end;

    PKDT16DS_Source       = ^TKDT16DS_Source;
    TKDT16DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT16DS_Source) - 1] of PKDT16DS_Source;
    PKDT16DS_SourceBuffer = ^TKDT16DS_SourceBuffer;

    TKDT16DSyanmicSourceBuffer = packed array of PKDT16DS_Source;
    PKDT16DSyanmicSourceBuffer = ^TKDT16DSyanmicSourceBuffer;

    TKDT16DSyanmicStoreBuffer = packed array of TKDT16DS_Source;
    PKDT16DSyanmicStoreBuffer = ^TKDT16DSyanmicStoreBuffer;

    PKDT16DS_Node = ^TKDT16DS_Node;

    TKDT16DS_Node = packed record
      Parent, Right, Left: PKDT16DS_Node;
      vec: PKDT16DS_Source;
    end;

    TKDT16DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT16DS_Source; const Data: Pointer);
    TKDT16DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT16DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT16DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT16DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT16DSyanmicStoreBuffer;
    KDBuff     : TKDT16DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT16DS_Node;
    TestBuff   : TKDT16DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DS_Node;
    function GetData(const index: NativeInt): PKDT16DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT16DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT16DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT16DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DS_Node; overload;
    function Search(const Buff: TKDT16DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DS_Node; overload;
    function Search(const Buff: TKDT16DS_Vec; var SearchedDistanceMin: Double): PKDT16DS_Node; overload;
    function Search(const Buff: TKDT16DS_Vec): PKDT16DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT16DS_DynamicVecBuffer; var OutBuff: TKDT16DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT16DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT16DS_Node);
    procedure PrintBuffer;

    class function KDT16DSVec(const s: string): TKDT16DS_Vec; overload;
    class function KDT16DSVec(const v: TKDT16DS_Vec): string; overload;
    class function KDT16DSPow(const v: TKDT16DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT16DSDistance(const v1, v2: TKDT16DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT17DS = class(TCoreClassObject)
  public type
    // code split
    TKDT17DS_Vec = packed array [0 .. KDT17DS_Axis - 1] of TKDT17DS_VecType;
    PKDT17DS_Vec = ^TKDT17DS_Vec;

    TKDT17DS_DynamicVecBuffer = array of TKDT17DS_Vec;
    PKDT17DS_DynamicVecBuffer = ^TKDT17DS_DynamicVecBuffer;

    TKDT17DS_Source = packed record
      Buff: TKDT17DS_Vec;
      index: Integer;
    end;

    PKDT17DS_Source       = ^TKDT17DS_Source;
    TKDT17DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT17DS_Source) - 1] of PKDT17DS_Source;
    PKDT17DS_SourceBuffer = ^TKDT17DS_SourceBuffer;

    TKDT17DSyanmicSourceBuffer = packed array of PKDT17DS_Source;
    PKDT17DSyanmicSourceBuffer = ^TKDT17DSyanmicSourceBuffer;

    TKDT17DSyanmicStoreBuffer = packed array of TKDT17DS_Source;
    PKDT17DSyanmicStoreBuffer = ^TKDT17DSyanmicStoreBuffer;

    PKDT17DS_Node = ^TKDT17DS_Node;

    TKDT17DS_Node = packed record
      Parent, Right, Left: PKDT17DS_Node;
      vec: PKDT17DS_Source;
    end;

    TKDT17DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT17DS_Source; const Data: Pointer);
    TKDT17DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT17DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT17DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT17DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT17DSyanmicStoreBuffer;
    KDBuff     : TKDT17DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT17DS_Node;
    TestBuff   : TKDT17DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DS_Node;
    function GetData(const index: NativeInt): PKDT17DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT17DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT17DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT17DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT17DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DS_Node; overload;
    function Search(const Buff: TKDT17DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DS_Node; overload;
    function Search(const Buff: TKDT17DS_Vec; var SearchedDistanceMin: Double): PKDT17DS_Node; overload;
    function Search(const Buff: TKDT17DS_Vec): PKDT17DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT17DS_DynamicVecBuffer; var OutBuff: TKDT17DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT17DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT17DS_Node);
    procedure PrintBuffer;

    class function KDT17DSVec(const s: string): TKDT17DS_Vec; overload;
    class function KDT17DSVec(const v: TKDT17DS_Vec): string; overload;
    class function KDT17DSPow(const v: TKDT17DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT17DSDistance(const v1, v2: TKDT17DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT18DS = class(TCoreClassObject)
  public type
    // code split
    TKDT18DS_Vec = packed array [0 .. KDT18DS_Axis - 1] of TKDT18DS_VecType;
    PKDT18DS_Vec = ^TKDT18DS_Vec;

    TKDT18DS_DynamicVecBuffer = array of TKDT18DS_Vec;
    PKDT18DS_DynamicVecBuffer = ^TKDT18DS_DynamicVecBuffer;

    TKDT18DS_Source = packed record
      Buff: TKDT18DS_Vec;
      index: Integer;
    end;

    PKDT18DS_Source       = ^TKDT18DS_Source;
    TKDT18DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT18DS_Source) - 1] of PKDT18DS_Source;
    PKDT18DS_SourceBuffer = ^TKDT18DS_SourceBuffer;

    TKDT18DSyanmicSourceBuffer = packed array of PKDT18DS_Source;
    PKDT18DSyanmicSourceBuffer = ^TKDT18DSyanmicSourceBuffer;

    TKDT18DSyanmicStoreBuffer = packed array of TKDT18DS_Source;
    PKDT18DSyanmicStoreBuffer = ^TKDT18DSyanmicStoreBuffer;

    PKDT18DS_Node = ^TKDT18DS_Node;

    TKDT18DS_Node = packed record
      Parent, Right, Left: PKDT18DS_Node;
      vec: PKDT18DS_Source;
    end;

    TKDT18DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT18DS_Source; const Data: Pointer);
    TKDT18DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT18DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT18DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT18DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT18DSyanmicStoreBuffer;
    KDBuff     : TKDT18DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT18DS_Node;
    TestBuff   : TKDT18DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DS_Node;
    function GetData(const index: NativeInt): PKDT18DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT18DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT18DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT18DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DS_Node; overload;
    function Search(const Buff: TKDT18DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DS_Node; overload;
    function Search(const Buff: TKDT18DS_Vec; var SearchedDistanceMin: Double): PKDT18DS_Node; overload;
    function Search(const Buff: TKDT18DS_Vec): PKDT18DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT18DS_DynamicVecBuffer; var OutBuff: TKDT18DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT18DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT18DS_Node);
    procedure PrintBuffer;

    class function KDT18DSVec(const s: string): TKDT18DS_Vec; overload;
    class function KDT18DSVec(const v: TKDT18DS_Vec): string; overload;
    class function KDT18DSPow(const v: TKDT18DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT18DSDistance(const v1, v2: TKDT18DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT19DS = class(TCoreClassObject)
  public type
    // code split
    TKDT19DS_Vec = packed array [0 .. KDT19DS_Axis - 1] of TKDT19DS_VecType;
    PKDT19DS_Vec = ^TKDT19DS_Vec;

    TKDT19DS_DynamicVecBuffer = array of TKDT19DS_Vec;
    PKDT19DS_DynamicVecBuffer = ^TKDT19DS_DynamicVecBuffer;

    TKDT19DS_Source = packed record
      Buff: TKDT19DS_Vec;
      index: Integer;
    end;

    PKDT19DS_Source       = ^TKDT19DS_Source;
    TKDT19DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT19DS_Source) - 1] of PKDT19DS_Source;
    PKDT19DS_SourceBuffer = ^TKDT19DS_SourceBuffer;

    TKDT19DSyanmicSourceBuffer = packed array of PKDT19DS_Source;
    PKDT19DSyanmicSourceBuffer = ^TKDT19DSyanmicSourceBuffer;

    TKDT19DSyanmicStoreBuffer = packed array of TKDT19DS_Source;
    PKDT19DSyanmicStoreBuffer = ^TKDT19DSyanmicStoreBuffer;

    PKDT19DS_Node = ^TKDT19DS_Node;

    TKDT19DS_Node = packed record
      Parent, Right, Left: PKDT19DS_Node;
      vec: PKDT19DS_Source;
    end;

    TKDT19DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT19DS_Source; const Data: Pointer);
    TKDT19DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT19DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT19DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT19DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT19DSyanmicStoreBuffer;
    KDBuff     : TKDT19DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT19DS_Node;
    TestBuff   : TKDT19DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DS_Node;
    function GetData(const index: NativeInt): PKDT19DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT19DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT19DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT19DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT19DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DS_Node; overload;
    function Search(const Buff: TKDT19DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DS_Node; overload;
    function Search(const Buff: TKDT19DS_Vec; var SearchedDistanceMin: Double): PKDT19DS_Node; overload;
    function Search(const Buff: TKDT19DS_Vec): PKDT19DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT19DS_DynamicVecBuffer; var OutBuff: TKDT19DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT19DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT19DS_Node);
    procedure PrintBuffer;

    class function KDT19DSVec(const s: string): TKDT19DS_Vec; overload;
    class function KDT19DSVec(const v: TKDT19DS_Vec): string; overload;
    class function KDT19DSPow(const v: TKDT19DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT19DSDistance(const v1, v2: TKDT19DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT20DS = class(TCoreClassObject)
  public type
    // code split
    TKDT20DS_Vec = packed array [0 .. KDT20DS_Axis - 1] of TKDT20DS_VecType;
    PKDT20DS_Vec = ^TKDT20DS_Vec;

    TKDT20DS_DynamicVecBuffer = array of TKDT20DS_Vec;
    PKDT20DS_DynamicVecBuffer = ^TKDT20DS_DynamicVecBuffer;

    TKDT20DS_Source = packed record
      Buff: TKDT20DS_Vec;
      index: Integer;
    end;

    PKDT20DS_Source       = ^TKDT20DS_Source;
    TKDT20DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT20DS_Source) - 1] of PKDT20DS_Source;
    PKDT20DS_SourceBuffer = ^TKDT20DS_SourceBuffer;

    TKDT20DSyanmicSourceBuffer = packed array of PKDT20DS_Source;
    PKDT20DSyanmicSourceBuffer = ^TKDT20DSyanmicSourceBuffer;

    TKDT20DSyanmicStoreBuffer = packed array of TKDT20DS_Source;
    PKDT20DSyanmicStoreBuffer = ^TKDT20DSyanmicStoreBuffer;

    PKDT20DS_Node = ^TKDT20DS_Node;

    TKDT20DS_Node = packed record
      Parent, Right, Left: PKDT20DS_Node;
      vec: PKDT20DS_Source;
    end;

    TKDT20DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT20DS_Source; const Data: Pointer);
    TKDT20DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT20DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT20DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT20DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT20DSyanmicStoreBuffer;
    KDBuff     : TKDT20DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT20DS_Node;
    TestBuff   : TKDT20DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DS_Node;
    function GetData(const index: NativeInt): PKDT20DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT20DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT20DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT20DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DS_Node; overload;
    function Search(const Buff: TKDT20DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DS_Node; overload;
    function Search(const Buff: TKDT20DS_Vec; var SearchedDistanceMin: Double): PKDT20DS_Node; overload;
    function Search(const Buff: TKDT20DS_Vec): PKDT20DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT20DS_DynamicVecBuffer; var OutBuff: TKDT20DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT20DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT20DS_Node);
    procedure PrintBuffer;

    class function KDT20DSVec(const s: string): TKDT20DS_Vec; overload;
    class function KDT20DSVec(const v: TKDT20DS_Vec): string; overload;
    class function KDT20DSPow(const v: TKDT20DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT20DSDistance(const v1, v2: TKDT20DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT21DS = class(TCoreClassObject)
  public type
    // code split
    TKDT21DS_Vec = packed array [0 .. KDT21DS_Axis - 1] of TKDT21DS_VecType;
    PKDT21DS_Vec = ^TKDT21DS_Vec;

    TKDT21DS_DynamicVecBuffer = array of TKDT21DS_Vec;
    PKDT21DS_DynamicVecBuffer = ^TKDT21DS_DynamicVecBuffer;

    TKDT21DS_Source = packed record
      Buff: TKDT21DS_Vec;
      index: Integer;
    end;

    PKDT21DS_Source       = ^TKDT21DS_Source;
    TKDT21DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT21DS_Source) - 1] of PKDT21DS_Source;
    PKDT21DS_SourceBuffer = ^TKDT21DS_SourceBuffer;

    TKDT21DSyanmicSourceBuffer = packed array of PKDT21DS_Source;
    PKDT21DSyanmicSourceBuffer = ^TKDT21DSyanmicSourceBuffer;

    TKDT21DSyanmicStoreBuffer = packed array of TKDT21DS_Source;
    PKDT21DSyanmicStoreBuffer = ^TKDT21DSyanmicStoreBuffer;

    PKDT21DS_Node = ^TKDT21DS_Node;

    TKDT21DS_Node = packed record
      Parent, Right, Left: PKDT21DS_Node;
      vec: PKDT21DS_Source;
    end;

    TKDT21DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT21DS_Source; const Data: Pointer);
    TKDT21DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT21DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT21DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT21DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT21DSyanmicStoreBuffer;
    KDBuff     : TKDT21DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT21DS_Node;
    TestBuff   : TKDT21DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DS_Node;
    function GetData(const index: NativeInt): PKDT21DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT21DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT21DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT21DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT21DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DS_Node; overload;
    function Search(const Buff: TKDT21DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DS_Node; overload;
    function Search(const Buff: TKDT21DS_Vec; var SearchedDistanceMin: Double): PKDT21DS_Node; overload;
    function Search(const Buff: TKDT21DS_Vec): PKDT21DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT21DS_DynamicVecBuffer; var OutBuff: TKDT21DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT21DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT21DS_Node);
    procedure PrintBuffer;

    class function KDT21DSVec(const s: string): TKDT21DS_Vec; overload;
    class function KDT21DSVec(const v: TKDT21DS_Vec): string; overload;
    class function KDT21DSPow(const v: TKDT21DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT21DSDistance(const v1, v2: TKDT21DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT22DS = class(TCoreClassObject)
  public type
    // code split
    TKDT22DS_Vec = packed array [0 .. KDT22DS_Axis - 1] of TKDT22DS_VecType;
    PKDT22DS_Vec = ^TKDT22DS_Vec;

    TKDT22DS_DynamicVecBuffer = array of TKDT22DS_Vec;
    PKDT22DS_DynamicVecBuffer = ^TKDT22DS_DynamicVecBuffer;

    TKDT22DS_Source = packed record
      Buff: TKDT22DS_Vec;
      index: Integer;
    end;

    PKDT22DS_Source       = ^TKDT22DS_Source;
    TKDT22DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT22DS_Source) - 1] of PKDT22DS_Source;
    PKDT22DS_SourceBuffer = ^TKDT22DS_SourceBuffer;

    TKDT22DSyanmicSourceBuffer = packed array of PKDT22DS_Source;
    PKDT22DSyanmicSourceBuffer = ^TKDT22DSyanmicSourceBuffer;

    TKDT22DSyanmicStoreBuffer = packed array of TKDT22DS_Source;
    PKDT22DSyanmicStoreBuffer = ^TKDT22DSyanmicStoreBuffer;

    PKDT22DS_Node = ^TKDT22DS_Node;

    TKDT22DS_Node = packed record
      Parent, Right, Left: PKDT22DS_Node;
      vec: PKDT22DS_Source;
    end;

    TKDT22DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT22DS_Source; const Data: Pointer);
    TKDT22DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT22DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT22DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT22DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT22DSyanmicStoreBuffer;
    KDBuff     : TKDT22DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT22DS_Node;
    TestBuff   : TKDT22DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DS_Node;
    function GetData(const index: NativeInt): PKDT22DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT22DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT22DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT22DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DS_Node; overload;
    function Search(const Buff: TKDT22DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DS_Node; overload;
    function Search(const Buff: TKDT22DS_Vec; var SearchedDistanceMin: Double): PKDT22DS_Node; overload;
    function Search(const Buff: TKDT22DS_Vec): PKDT22DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT22DS_DynamicVecBuffer; var OutBuff: TKDT22DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT22DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT22DS_Node);
    procedure PrintBuffer;

    class function KDT22DSVec(const s: string): TKDT22DS_Vec; overload;
    class function KDT22DSVec(const v: TKDT22DS_Vec): string; overload;
    class function KDT22DSPow(const v: TKDT22DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT22DSDistance(const v1, v2: TKDT22DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT23DS = class(TCoreClassObject)
  public type
    // code split
    TKDT23DS_Vec = packed array [0 .. KDT23DS_Axis - 1] of TKDT23DS_VecType;
    PKDT23DS_Vec = ^TKDT23DS_Vec;

    TKDT23DS_DynamicVecBuffer = array of TKDT23DS_Vec;
    PKDT23DS_DynamicVecBuffer = ^TKDT23DS_DynamicVecBuffer;

    TKDT23DS_Source = packed record
      Buff: TKDT23DS_Vec;
      index: Integer;
    end;

    PKDT23DS_Source       = ^TKDT23DS_Source;
    TKDT23DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT23DS_Source) - 1] of PKDT23DS_Source;
    PKDT23DS_SourceBuffer = ^TKDT23DS_SourceBuffer;

    TKDT23DSyanmicSourceBuffer = packed array of PKDT23DS_Source;
    PKDT23DSyanmicSourceBuffer = ^TKDT23DSyanmicSourceBuffer;

    TKDT23DSyanmicStoreBuffer = packed array of TKDT23DS_Source;
    PKDT23DSyanmicStoreBuffer = ^TKDT23DSyanmicStoreBuffer;

    PKDT23DS_Node = ^TKDT23DS_Node;

    TKDT23DS_Node = packed record
      Parent, Right, Left: PKDT23DS_Node;
      vec: PKDT23DS_Source;
    end;

    TKDT23DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT23DS_Source; const Data: Pointer);
    TKDT23DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT23DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT23DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT23DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT23DSyanmicStoreBuffer;
    KDBuff     : TKDT23DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT23DS_Node;
    TestBuff   : TKDT23DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DS_Node;
    function GetData(const index: NativeInt): PKDT23DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT23DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT23DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT23DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT23DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DS_Node; overload;
    function Search(const Buff: TKDT23DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DS_Node; overload;
    function Search(const Buff: TKDT23DS_Vec; var SearchedDistanceMin: Double): PKDT23DS_Node; overload;
    function Search(const Buff: TKDT23DS_Vec): PKDT23DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT23DS_DynamicVecBuffer; var OutBuff: TKDT23DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT23DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT23DS_Node);
    procedure PrintBuffer;

    class function KDT23DSVec(const s: string): TKDT23DS_Vec; overload;
    class function KDT23DSVec(const v: TKDT23DS_Vec): string; overload;
    class function KDT23DSPow(const v: TKDT23DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT23DSDistance(const v1, v2: TKDT23DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT24DS = class(TCoreClassObject)
  public type
    // code split
    TKDT24DS_Vec = packed array [0 .. KDT24DS_Axis - 1] of TKDT24DS_VecType;
    PKDT24DS_Vec = ^TKDT24DS_Vec;

    TKDT24DS_DynamicVecBuffer = array of TKDT24DS_Vec;
    PKDT24DS_DynamicVecBuffer = ^TKDT24DS_DynamicVecBuffer;

    TKDT24DS_Source = packed record
      Buff: TKDT24DS_Vec;
      index: Integer;
    end;

    PKDT24DS_Source       = ^TKDT24DS_Source;
    TKDT24DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT24DS_Source) - 1] of PKDT24DS_Source;
    PKDT24DS_SourceBuffer = ^TKDT24DS_SourceBuffer;

    TKDT24DSyanmicSourceBuffer = packed array of PKDT24DS_Source;
    PKDT24DSyanmicSourceBuffer = ^TKDT24DSyanmicSourceBuffer;

    TKDT24DSyanmicStoreBuffer = packed array of TKDT24DS_Source;
    PKDT24DSyanmicStoreBuffer = ^TKDT24DSyanmicStoreBuffer;

    PKDT24DS_Node = ^TKDT24DS_Node;

    TKDT24DS_Node = packed record
      Parent, Right, Left: PKDT24DS_Node;
      vec: PKDT24DS_Source;
    end;

    TKDT24DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT24DS_Source; const Data: Pointer);
    TKDT24DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT24DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT24DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT24DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT24DSyanmicStoreBuffer;
    KDBuff     : TKDT24DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT24DS_Node;
    TestBuff   : TKDT24DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DS_Node;
    function GetData(const index: NativeInt): PKDT24DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT24DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT24DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT24DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DS_Node; overload;
    function Search(const Buff: TKDT24DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DS_Node; overload;
    function Search(const Buff: TKDT24DS_Vec; var SearchedDistanceMin: Double): PKDT24DS_Node; overload;
    function Search(const Buff: TKDT24DS_Vec): PKDT24DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT24DS_DynamicVecBuffer; var OutBuff: TKDT24DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT24DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT24DS_Node);
    procedure PrintBuffer;

    class function KDT24DSVec(const s: string): TKDT24DS_Vec; overload;
    class function KDT24DSVec(const v: TKDT24DS_Vec): string; overload;
    class function KDT24DSPow(const v: TKDT24DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT24DSDistance(const v1, v2: TKDT24DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT25DS = class(TCoreClassObject)
  public type
    // code split
    TKDT25DS_Vec = packed array [0 .. KDT25DS_Axis - 1] of TKDT25DS_VecType;
    PKDT25DS_Vec = ^TKDT25DS_Vec;

    TKDT25DS_DynamicVecBuffer = array of TKDT25DS_Vec;
    PKDT25DS_DynamicVecBuffer = ^TKDT25DS_DynamicVecBuffer;

    TKDT25DS_Source = packed record
      Buff: TKDT25DS_Vec;
      index: Integer;
    end;

    PKDT25DS_Source       = ^TKDT25DS_Source;
    TKDT25DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT25DS_Source) - 1] of PKDT25DS_Source;
    PKDT25DS_SourceBuffer = ^TKDT25DS_SourceBuffer;

    TKDT25DSyanmicSourceBuffer = packed array of PKDT25DS_Source;
    PKDT25DSyanmicSourceBuffer = ^TKDT25DSyanmicSourceBuffer;

    TKDT25DSyanmicStoreBuffer = packed array of TKDT25DS_Source;
    PKDT25DSyanmicStoreBuffer = ^TKDT25DSyanmicStoreBuffer;

    PKDT25DS_Node = ^TKDT25DS_Node;

    TKDT25DS_Node = packed record
      Parent, Right, Left: PKDT25DS_Node;
      vec: PKDT25DS_Source;
    end;

    TKDT25DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT25DS_Source; const Data: Pointer);
    TKDT25DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT25DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT25DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT25DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT25DSyanmicStoreBuffer;
    KDBuff     : TKDT25DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT25DS_Node;
    TestBuff   : TKDT25DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DS_Node;
    function GetData(const index: NativeInt): PKDT25DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT25DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT25DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT25DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT25DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DS_Node; overload;
    function Search(const Buff: TKDT25DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DS_Node; overload;
    function Search(const Buff: TKDT25DS_Vec; var SearchedDistanceMin: Double): PKDT25DS_Node; overload;
    function Search(const Buff: TKDT25DS_Vec): PKDT25DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT25DS_DynamicVecBuffer; var OutBuff: TKDT25DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT25DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT25DS_Node);
    procedure PrintBuffer;

    class function KDT25DSVec(const s: string): TKDT25DS_Vec; overload;
    class function KDT25DSVec(const v: TKDT25DS_Vec): string; overload;
    class function KDT25DSPow(const v: TKDT25DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT25DSDistance(const v1, v2: TKDT25DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT25DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT26DS = class(TCoreClassObject)
  public type
    // code split
    TKDT26DS_Vec = packed array [0 .. KDT26DS_Axis - 1] of TKDT26DS_VecType;
    PKDT26DS_Vec = ^TKDT26DS_Vec;

    TKDT26DS_DynamicVecBuffer = array of TKDT26DS_Vec;
    PKDT26DS_DynamicVecBuffer = ^TKDT26DS_DynamicVecBuffer;

    TKDT26DS_Source = packed record
      Buff: TKDT26DS_Vec;
      index: Integer;
    end;

    PKDT26DS_Source       = ^TKDT26DS_Source;
    TKDT26DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT26DS_Source) - 1] of PKDT26DS_Source;
    PKDT26DS_SourceBuffer = ^TKDT26DS_SourceBuffer;

    TKDT26DSyanmicSourceBuffer = packed array of PKDT26DS_Source;
    PKDT26DSyanmicSourceBuffer = ^TKDT26DSyanmicSourceBuffer;

    TKDT26DSyanmicStoreBuffer = packed array of TKDT26DS_Source;
    PKDT26DSyanmicStoreBuffer = ^TKDT26DSyanmicStoreBuffer;

    PKDT26DS_Node = ^TKDT26DS_Node;

    TKDT26DS_Node = packed record
      Parent, Right, Left: PKDT26DS_Node;
      vec: PKDT26DS_Source;
    end;

    TKDT26DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT26DS_Source; const Data: Pointer);
    TKDT26DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT26DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT26DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT26DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT26DSyanmicStoreBuffer;
    KDBuff     : TKDT26DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT26DS_Node;
    TestBuff   : TKDT26DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DS_Node;
    function GetData(const index: NativeInt): PKDT26DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT26DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT26DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT26DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT26DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DS_Node; overload;
    function Search(const Buff: TKDT26DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DS_Node; overload;
    function Search(const Buff: TKDT26DS_Vec; var SearchedDistanceMin: Double): PKDT26DS_Node; overload;
    function Search(const Buff: TKDT26DS_Vec): PKDT26DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT26DS_DynamicVecBuffer; var OutBuff: TKDT26DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT26DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT26DS_Node);
    procedure PrintBuffer;

    class function KDT26DSVec(const s: string): TKDT26DS_Vec; overload;
    class function KDT26DSVec(const v: TKDT26DS_Vec): string; overload;
    class function KDT26DSPow(const v: TKDT26DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT26DSDistance(const v1, v2: TKDT26DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT26DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT27DS = class(TCoreClassObject)
  public type
    // code split
    TKDT27DS_Vec = packed array [0 .. KDT27DS_Axis - 1] of TKDT27DS_VecType;
    PKDT27DS_Vec = ^TKDT27DS_Vec;

    TKDT27DS_DynamicVecBuffer = array of TKDT27DS_Vec;
    PKDT27DS_DynamicVecBuffer = ^TKDT27DS_DynamicVecBuffer;

    TKDT27DS_Source = packed record
      Buff: TKDT27DS_Vec;
      index: Integer;
    end;

    PKDT27DS_Source       = ^TKDT27DS_Source;
    TKDT27DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT27DS_Source) - 1] of PKDT27DS_Source;
    PKDT27DS_SourceBuffer = ^TKDT27DS_SourceBuffer;

    TKDT27DSyanmicSourceBuffer = packed array of PKDT27DS_Source;
    PKDT27DSyanmicSourceBuffer = ^TKDT27DSyanmicSourceBuffer;

    TKDT27DSyanmicStoreBuffer = packed array of TKDT27DS_Source;
    PKDT27DSyanmicStoreBuffer = ^TKDT27DSyanmicStoreBuffer;

    PKDT27DS_Node = ^TKDT27DS_Node;

    TKDT27DS_Node = packed record
      Parent, Right, Left: PKDT27DS_Node;
      vec: PKDT27DS_Source;
    end;

    TKDT27DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT27DS_Source; const Data: Pointer);
    TKDT27DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT27DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT27DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT27DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT27DSyanmicStoreBuffer;
    KDBuff     : TKDT27DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT27DS_Node;
    TestBuff   : TKDT27DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DS_Node;
    function GetData(const index: NativeInt): PKDT27DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT27DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT27DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT27DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT27DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DS_Node; overload;
    function Search(const Buff: TKDT27DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DS_Node; overload;
    function Search(const Buff: TKDT27DS_Vec; var SearchedDistanceMin: Double): PKDT27DS_Node; overload;
    function Search(const Buff: TKDT27DS_Vec): PKDT27DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT27DS_DynamicVecBuffer; var OutBuff: TKDT27DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT27DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT27DS_Node);
    procedure PrintBuffer;

    class function KDT27DSVec(const s: string): TKDT27DS_Vec; overload;
    class function KDT27DSVec(const v: TKDT27DS_Vec): string; overload;
    class function KDT27DSPow(const v: TKDT27DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT27DSDistance(const v1, v2: TKDT27DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT27DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT28DS = class(TCoreClassObject)
  public type
    // code split
    TKDT28DS_Vec = packed array [0 .. KDT28DS_Axis - 1] of TKDT28DS_VecType;
    PKDT28DS_Vec = ^TKDT28DS_Vec;

    TKDT28DS_DynamicVecBuffer = array of TKDT28DS_Vec;
    PKDT28DS_DynamicVecBuffer = ^TKDT28DS_DynamicVecBuffer;

    TKDT28DS_Source = packed record
      Buff: TKDT28DS_Vec;
      index: Integer;
    end;

    PKDT28DS_Source       = ^TKDT28DS_Source;
    TKDT28DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT28DS_Source) - 1] of PKDT28DS_Source;
    PKDT28DS_SourceBuffer = ^TKDT28DS_SourceBuffer;

    TKDT28DSyanmicSourceBuffer = packed array of PKDT28DS_Source;
    PKDT28DSyanmicSourceBuffer = ^TKDT28DSyanmicSourceBuffer;

    TKDT28DSyanmicStoreBuffer = packed array of TKDT28DS_Source;
    PKDT28DSyanmicStoreBuffer = ^TKDT28DSyanmicStoreBuffer;

    PKDT28DS_Node = ^TKDT28DS_Node;

    TKDT28DS_Node = packed record
      Parent, Right, Left: PKDT28DS_Node;
      vec: PKDT28DS_Source;
    end;

    TKDT28DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT28DS_Source; const Data: Pointer);
    TKDT28DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT28DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT28DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT28DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT28DSyanmicStoreBuffer;
    KDBuff     : TKDT28DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT28DS_Node;
    TestBuff   : TKDT28DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DS_Node;
    function GetData(const index: NativeInt): PKDT28DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT28DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT28DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT28DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT28DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DS_Node; overload;
    function Search(const Buff: TKDT28DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DS_Node; overload;
    function Search(const Buff: TKDT28DS_Vec; var SearchedDistanceMin: Double): PKDT28DS_Node; overload;
    function Search(const Buff: TKDT28DS_Vec): PKDT28DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT28DS_DynamicVecBuffer; var OutBuff: TKDT28DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT28DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT28DS_Node);
    procedure PrintBuffer;

    class function KDT28DSVec(const s: string): TKDT28DS_Vec; overload;
    class function KDT28DSVec(const v: TKDT28DS_Vec): string; overload;
    class function KDT28DSPow(const v: TKDT28DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT28DSDistance(const v1, v2: TKDT28DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT28DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT29DS = class(TCoreClassObject)
  public type
    // code split
    TKDT29DS_Vec = packed array [0 .. KDT29DS_Axis - 1] of TKDT29DS_VecType;
    PKDT29DS_Vec = ^TKDT29DS_Vec;

    TKDT29DS_DynamicVecBuffer = array of TKDT29DS_Vec;
    PKDT29DS_DynamicVecBuffer = ^TKDT29DS_DynamicVecBuffer;

    TKDT29DS_Source = packed record
      Buff: TKDT29DS_Vec;
      index: Integer;
    end;

    PKDT29DS_Source       = ^TKDT29DS_Source;
    TKDT29DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT29DS_Source) - 1] of PKDT29DS_Source;
    PKDT29DS_SourceBuffer = ^TKDT29DS_SourceBuffer;

    TKDT29DSyanmicSourceBuffer = packed array of PKDT29DS_Source;
    PKDT29DSyanmicSourceBuffer = ^TKDT29DSyanmicSourceBuffer;

    TKDT29DSyanmicStoreBuffer = packed array of TKDT29DS_Source;
    PKDT29DSyanmicStoreBuffer = ^TKDT29DSyanmicStoreBuffer;

    PKDT29DS_Node = ^TKDT29DS_Node;

    TKDT29DS_Node = packed record
      Parent, Right, Left: PKDT29DS_Node;
      vec: PKDT29DS_Source;
    end;

    TKDT29DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT29DS_Source; const Data: Pointer);
    TKDT29DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT29DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT29DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT29DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT29DSyanmicStoreBuffer;
    KDBuff     : TKDT29DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT29DS_Node;
    TestBuff   : TKDT29DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DS_Node;
    function GetData(const index: NativeInt): PKDT29DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT29DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT29DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT29DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT29DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DS_Node; overload;
    function Search(const Buff: TKDT29DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DS_Node; overload;
    function Search(const Buff: TKDT29DS_Vec; var SearchedDistanceMin: Double): PKDT29DS_Node; overload;
    function Search(const Buff: TKDT29DS_Vec): PKDT29DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT29DS_DynamicVecBuffer; var OutBuff: TKDT29DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT29DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT29DS_Node);
    procedure PrintBuffer;

    class function KDT29DSVec(const s: string): TKDT29DS_Vec; overload;
    class function KDT29DSVec(const v: TKDT29DS_Vec): string; overload;
    class function KDT29DSPow(const v: TKDT29DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT29DSDistance(const v1, v2: TKDT29DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT29DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT30DS = class(TCoreClassObject)
  public type
    // code split
    TKDT30DS_Vec = packed array [0 .. KDT30DS_Axis - 1] of TKDT30DS_VecType;
    PKDT30DS_Vec = ^TKDT30DS_Vec;

    TKDT30DS_DynamicVecBuffer = array of TKDT30DS_Vec;
    PKDT30DS_DynamicVecBuffer = ^TKDT30DS_DynamicVecBuffer;

    TKDT30DS_Source = packed record
      Buff: TKDT30DS_Vec;
      index: Integer;
    end;

    PKDT30DS_Source       = ^TKDT30DS_Source;
    TKDT30DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT30DS_Source) - 1] of PKDT30DS_Source;
    PKDT30DS_SourceBuffer = ^TKDT30DS_SourceBuffer;

    TKDT30DSyanmicSourceBuffer = packed array of PKDT30DS_Source;
    PKDT30DSyanmicSourceBuffer = ^TKDT30DSyanmicSourceBuffer;

    TKDT30DSyanmicStoreBuffer = packed array of TKDT30DS_Source;
    PKDT30DSyanmicStoreBuffer = ^TKDT30DSyanmicStoreBuffer;

    PKDT30DS_Node = ^TKDT30DS_Node;

    TKDT30DS_Node = packed record
      Parent, Right, Left: PKDT30DS_Node;
      vec: PKDT30DS_Source;
    end;

    TKDT30DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT30DS_Source; const Data: Pointer);
    TKDT30DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT30DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT30DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT30DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT30DSyanmicStoreBuffer;
    KDBuff     : TKDT30DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT30DS_Node;
    TestBuff   : TKDT30DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DS_Node;
    function GetData(const index: NativeInt): PKDT30DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT30DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT30DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT30DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT30DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DS_Node; overload;
    function Search(const Buff: TKDT30DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DS_Node; overload;
    function Search(const Buff: TKDT30DS_Vec; var SearchedDistanceMin: Double): PKDT30DS_Node; overload;
    function Search(const Buff: TKDT30DS_Vec): PKDT30DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT30DS_DynamicVecBuffer; var OutBuff: TKDT30DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT30DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT30DS_Node);
    procedure PrintBuffer;

    class function KDT30DSVec(const s: string): TKDT30DS_Vec; overload;
    class function KDT30DSVec(const v: TKDT30DS_Vec): string; overload;
    class function KDT30DSPow(const v: TKDT30DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT30DSDistance(const v1, v2: TKDT30DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT30DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT31DS = class(TCoreClassObject)
  public type
    // code split
    TKDT31DS_Vec = packed array [0 .. KDT31DS_Axis - 1] of TKDT31DS_VecType;
    PKDT31DS_Vec = ^TKDT31DS_Vec;

    TKDT31DS_DynamicVecBuffer = array of TKDT31DS_Vec;
    PKDT31DS_DynamicVecBuffer = ^TKDT31DS_DynamicVecBuffer;

    TKDT31DS_Source = packed record
      Buff: TKDT31DS_Vec;
      index: Integer;
    end;

    PKDT31DS_Source       = ^TKDT31DS_Source;
    TKDT31DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT31DS_Source) - 1] of PKDT31DS_Source;
    PKDT31DS_SourceBuffer = ^TKDT31DS_SourceBuffer;

    TKDT31DSyanmicSourceBuffer = packed array of PKDT31DS_Source;
    PKDT31DSyanmicSourceBuffer = ^TKDT31DSyanmicSourceBuffer;

    TKDT31DSyanmicStoreBuffer = packed array of TKDT31DS_Source;
    PKDT31DSyanmicStoreBuffer = ^TKDT31DSyanmicStoreBuffer;

    PKDT31DS_Node = ^TKDT31DS_Node;

    TKDT31DS_Node = packed record
      Parent, Right, Left: PKDT31DS_Node;
      vec: PKDT31DS_Source;
    end;

    TKDT31DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT31DS_Source; const Data: Pointer);
    TKDT31DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT31DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT31DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT31DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT31DSyanmicStoreBuffer;
    KDBuff     : TKDT31DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT31DS_Node;
    TestBuff   : TKDT31DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT31DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT31DS_Node;
    function GetData(const index: NativeInt): PKDT31DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT31DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT31DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT31DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT31DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT31DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT31DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT31DS_Node; overload;
    function Search(const Buff: TKDT31DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT31DS_Node; overload;
    function Search(const Buff: TKDT31DS_Vec; var SearchedDistanceMin: Double): PKDT31DS_Node; overload;
    function Search(const Buff: TKDT31DS_Vec): PKDT31DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT31DS_DynamicVecBuffer; var OutBuff: TKDT31DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT31DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT31DS_Node);
    procedure PrintBuffer;

    class function KDT31DSVec(const s: string): TKDT31DS_Vec; overload;
    class function KDT31DSVec(const v: TKDT31DS_Vec): string; overload;
    class function KDT31DSPow(const v: TKDT31DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT31DSDistance(const v1, v2: TKDT31DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT31DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT32DS = class(TCoreClassObject)
  public type
    // code split
    TKDT32DS_Vec = packed array [0 .. KDT32DS_Axis - 1] of TKDT32DS_VecType;
    PKDT32DS_Vec = ^TKDT32DS_Vec;

    TKDT32DS_DynamicVecBuffer = array of TKDT32DS_Vec;
    PKDT32DS_DynamicVecBuffer = ^TKDT32DS_DynamicVecBuffer;

    TKDT32DS_Source = packed record
      Buff: TKDT32DS_Vec;
      index: Integer;
    end;

    PKDT32DS_Source       = ^TKDT32DS_Source;
    TKDT32DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT32DS_Source) - 1] of PKDT32DS_Source;
    PKDT32DS_SourceBuffer = ^TKDT32DS_SourceBuffer;

    TKDT32DSyanmicSourceBuffer = packed array of PKDT32DS_Source;
    PKDT32DSyanmicSourceBuffer = ^TKDT32DSyanmicSourceBuffer;

    TKDT32DSyanmicStoreBuffer = packed array of TKDT32DS_Source;
    PKDT32DSyanmicStoreBuffer = ^TKDT32DSyanmicStoreBuffer;

    PKDT32DS_Node = ^TKDT32DS_Node;

    TKDT32DS_Node = packed record
      Parent, Right, Left: PKDT32DS_Node;
      vec: PKDT32DS_Source;
    end;

    TKDT32DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT32DS_Source; const Data: Pointer);
    TKDT32DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT32DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT32DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT32DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT32DSyanmicStoreBuffer;
    KDBuff     : TKDT32DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT32DS_Node;
    TestBuff   : TKDT32DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DS_Node;
    function GetData(const index: NativeInt): PKDT32DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT32DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT32DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT32DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT32DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DS_Node; overload;
    function Search(const Buff: TKDT32DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DS_Node; overload;
    function Search(const Buff: TKDT32DS_Vec; var SearchedDistanceMin: Double): PKDT32DS_Node; overload;
    function Search(const Buff: TKDT32DS_Vec): PKDT32DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT32DS_DynamicVecBuffer; var OutBuff: TKDT32DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT32DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT32DS_Node);
    procedure PrintBuffer;

    class function KDT32DSVec(const s: string): TKDT32DS_Vec; overload;
    class function KDT32DSVec(const v: TKDT32DS_Vec): string; overload;
    class function KDT32DSPow(const v: TKDT32DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT32DSDistance(const v1, v2: TKDT32DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT32DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT33DS = class(TCoreClassObject)
  public type
    // code split
    TKDT33DS_Vec = packed array [0 .. KDT33DS_Axis - 1] of TKDT33DS_VecType;
    PKDT33DS_Vec = ^TKDT33DS_Vec;

    TKDT33DS_DynamicVecBuffer = array of TKDT33DS_Vec;
    PKDT33DS_DynamicVecBuffer = ^TKDT33DS_DynamicVecBuffer;

    TKDT33DS_Source = packed record
      Buff: TKDT33DS_Vec;
      index: Integer;
    end;

    PKDT33DS_Source       = ^TKDT33DS_Source;
    TKDT33DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT33DS_Source) - 1] of PKDT33DS_Source;
    PKDT33DS_SourceBuffer = ^TKDT33DS_SourceBuffer;

    TKDT33DSyanmicSourceBuffer = packed array of PKDT33DS_Source;
    PKDT33DSyanmicSourceBuffer = ^TKDT33DSyanmicSourceBuffer;

    TKDT33DSyanmicStoreBuffer = packed array of TKDT33DS_Source;
    PKDT33DSyanmicStoreBuffer = ^TKDT33DSyanmicStoreBuffer;

    PKDT33DS_Node = ^TKDT33DS_Node;

    TKDT33DS_Node = packed record
      Parent, Right, Left: PKDT33DS_Node;
      vec: PKDT33DS_Source;
    end;

    TKDT33DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT33DS_Source; const Data: Pointer);
    TKDT33DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT33DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT33DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT33DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT33DSyanmicStoreBuffer;
    KDBuff     : TKDT33DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT33DS_Node;
    TestBuff   : TKDT33DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT33DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT33DS_Node;
    function GetData(const index: NativeInt): PKDT33DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT33DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT33DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT33DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT33DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT33DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT33DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT33DS_Node; overload;
    function Search(const Buff: TKDT33DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT33DS_Node; overload;
    function Search(const Buff: TKDT33DS_Vec; var SearchedDistanceMin: Double): PKDT33DS_Node; overload;
    function Search(const Buff: TKDT33DS_Vec): PKDT33DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT33DS_DynamicVecBuffer; var OutBuff: TKDT33DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT33DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT33DS_Node);
    procedure PrintBuffer;

    class function KDT33DSVec(const s: string): TKDT33DS_Vec; overload;
    class function KDT33DSVec(const v: TKDT33DS_Vec): string; overload;
    class function KDT33DSPow(const v: TKDT33DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT33DSDistance(const v1, v2: TKDT33DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT33DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT34DS = class(TCoreClassObject)
  public type
    // code split
    TKDT34DS_Vec = packed array [0 .. KDT34DS_Axis - 1] of TKDT34DS_VecType;
    PKDT34DS_Vec = ^TKDT34DS_Vec;

    TKDT34DS_DynamicVecBuffer = array of TKDT34DS_Vec;
    PKDT34DS_DynamicVecBuffer = ^TKDT34DS_DynamicVecBuffer;

    TKDT34DS_Source = packed record
      Buff: TKDT34DS_Vec;
      index: Integer;
    end;

    PKDT34DS_Source       = ^TKDT34DS_Source;
    TKDT34DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT34DS_Source) - 1] of PKDT34DS_Source;
    PKDT34DS_SourceBuffer = ^TKDT34DS_SourceBuffer;

    TKDT34DSyanmicSourceBuffer = packed array of PKDT34DS_Source;
    PKDT34DSyanmicSourceBuffer = ^TKDT34DSyanmicSourceBuffer;

    TKDT34DSyanmicStoreBuffer = packed array of TKDT34DS_Source;
    PKDT34DSyanmicStoreBuffer = ^TKDT34DSyanmicStoreBuffer;

    PKDT34DS_Node = ^TKDT34DS_Node;

    TKDT34DS_Node = packed record
      Parent, Right, Left: PKDT34DS_Node;
      vec: PKDT34DS_Source;
    end;

    TKDT34DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT34DS_Source; const Data: Pointer);
    TKDT34DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT34DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT34DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT34DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT34DSyanmicStoreBuffer;
    KDBuff     : TKDT34DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT34DS_Node;
    TestBuff   : TKDT34DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DS_Node;
    function GetData(const index: NativeInt): PKDT34DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT34DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT34DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT34DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT34DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DS_Node; overload;
    function Search(const Buff: TKDT34DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DS_Node; overload;
    function Search(const Buff: TKDT34DS_Vec; var SearchedDistanceMin: Double): PKDT34DS_Node; overload;
    function Search(const Buff: TKDT34DS_Vec): PKDT34DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT34DS_DynamicVecBuffer; var OutBuff: TKDT34DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT34DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT34DS_Node);
    procedure PrintBuffer;

    class function KDT34DSVec(const s: string): TKDT34DS_Vec; overload;
    class function KDT34DSVec(const v: TKDT34DS_Vec): string; overload;
    class function KDT34DSPow(const v: TKDT34DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT34DSDistance(const v1, v2: TKDT34DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT34DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT35DS = class(TCoreClassObject)
  public type
    // code split
    TKDT35DS_Vec = packed array [0 .. KDT35DS_Axis - 1] of TKDT35DS_VecType;
    PKDT35DS_Vec = ^TKDT35DS_Vec;

    TKDT35DS_DynamicVecBuffer = array of TKDT35DS_Vec;
    PKDT35DS_DynamicVecBuffer = ^TKDT35DS_DynamicVecBuffer;

    TKDT35DS_Source = packed record
      Buff: TKDT35DS_Vec;
      index: Integer;
    end;

    PKDT35DS_Source       = ^TKDT35DS_Source;
    TKDT35DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT35DS_Source) - 1] of PKDT35DS_Source;
    PKDT35DS_SourceBuffer = ^TKDT35DS_SourceBuffer;

    TKDT35DSyanmicSourceBuffer = packed array of PKDT35DS_Source;
    PKDT35DSyanmicSourceBuffer = ^TKDT35DSyanmicSourceBuffer;

    TKDT35DSyanmicStoreBuffer = packed array of TKDT35DS_Source;
    PKDT35DSyanmicStoreBuffer = ^TKDT35DSyanmicStoreBuffer;

    PKDT35DS_Node = ^TKDT35DS_Node;

    TKDT35DS_Node = packed record
      Parent, Right, Left: PKDT35DS_Node;
      vec: PKDT35DS_Source;
    end;

    TKDT35DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT35DS_Source; const Data: Pointer);
    TKDT35DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT35DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT35DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT35DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT35DSyanmicStoreBuffer;
    KDBuff     : TKDT35DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT35DS_Node;
    TestBuff   : TKDT35DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT35DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT35DS_Node;
    function GetData(const index: NativeInt): PKDT35DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT35DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT35DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT35DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT35DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT35DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT35DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT35DS_Node; overload;
    function Search(const Buff: TKDT35DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT35DS_Node; overload;
    function Search(const Buff: TKDT35DS_Vec; var SearchedDistanceMin: Double): PKDT35DS_Node; overload;
    function Search(const Buff: TKDT35DS_Vec): PKDT35DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT35DS_DynamicVecBuffer; var OutBuff: TKDT35DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT35DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT35DS_Node);
    procedure PrintBuffer;

    class function KDT35DSVec(const s: string): TKDT35DS_Vec; overload;
    class function KDT35DSVec(const v: TKDT35DS_Vec): string; overload;
    class function KDT35DSPow(const v: TKDT35DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT35DSDistance(const v1, v2: TKDT35DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT35DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT36DS = class(TCoreClassObject)
  public type
    // code split
    TKDT36DS_Vec = packed array [0 .. KDT36DS_Axis - 1] of TKDT36DS_VecType;
    PKDT36DS_Vec = ^TKDT36DS_Vec;

    TKDT36DS_DynamicVecBuffer = array of TKDT36DS_Vec;
    PKDT36DS_DynamicVecBuffer = ^TKDT36DS_DynamicVecBuffer;

    TKDT36DS_Source = packed record
      Buff: TKDT36DS_Vec;
      index: Integer;
    end;

    PKDT36DS_Source       = ^TKDT36DS_Source;
    TKDT36DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT36DS_Source) - 1] of PKDT36DS_Source;
    PKDT36DS_SourceBuffer = ^TKDT36DS_SourceBuffer;

    TKDT36DSyanmicSourceBuffer = packed array of PKDT36DS_Source;
    PKDT36DSyanmicSourceBuffer = ^TKDT36DSyanmicSourceBuffer;

    TKDT36DSyanmicStoreBuffer = packed array of TKDT36DS_Source;
    PKDT36DSyanmicStoreBuffer = ^TKDT36DSyanmicStoreBuffer;

    PKDT36DS_Node = ^TKDT36DS_Node;

    TKDT36DS_Node = packed record
      Parent, Right, Left: PKDT36DS_Node;
      vec: PKDT36DS_Source;
    end;

    TKDT36DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT36DS_Source; const Data: Pointer);
    TKDT36DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT36DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT36DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT36DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT36DSyanmicStoreBuffer;
    KDBuff     : TKDT36DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT36DS_Node;
    TestBuff   : TKDT36DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DS_Node;
    function GetData(const index: NativeInt): PKDT36DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT36DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT36DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT36DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT36DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DS_Node; overload;
    function Search(const Buff: TKDT36DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DS_Node; overload;
    function Search(const Buff: TKDT36DS_Vec; var SearchedDistanceMin: Double): PKDT36DS_Node; overload;
    function Search(const Buff: TKDT36DS_Vec): PKDT36DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT36DS_DynamicVecBuffer; var OutBuff: TKDT36DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT36DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT36DS_Node);
    procedure PrintBuffer;

    class function KDT36DSVec(const s: string): TKDT36DS_Vec; overload;
    class function KDT36DSVec(const v: TKDT36DS_Vec): string; overload;
    class function KDT36DSPow(const v: TKDT36DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT36DSDistance(const v1, v2: TKDT36DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT36DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT37DS = class(TCoreClassObject)
  public type
    // code split
    TKDT37DS_Vec = packed array [0 .. KDT37DS_Axis - 1] of TKDT37DS_VecType;
    PKDT37DS_Vec = ^TKDT37DS_Vec;

    TKDT37DS_DynamicVecBuffer = array of TKDT37DS_Vec;
    PKDT37DS_DynamicVecBuffer = ^TKDT37DS_DynamicVecBuffer;

    TKDT37DS_Source = packed record
      Buff: TKDT37DS_Vec;
      index: Integer;
    end;

    PKDT37DS_Source       = ^TKDT37DS_Source;
    TKDT37DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT37DS_Source) - 1] of PKDT37DS_Source;
    PKDT37DS_SourceBuffer = ^TKDT37DS_SourceBuffer;

    TKDT37DSyanmicSourceBuffer = packed array of PKDT37DS_Source;
    PKDT37DSyanmicSourceBuffer = ^TKDT37DSyanmicSourceBuffer;

    TKDT37DSyanmicStoreBuffer = packed array of TKDT37DS_Source;
    PKDT37DSyanmicStoreBuffer = ^TKDT37DSyanmicStoreBuffer;

    PKDT37DS_Node = ^TKDT37DS_Node;

    TKDT37DS_Node = packed record
      Parent, Right, Left: PKDT37DS_Node;
      vec: PKDT37DS_Source;
    end;

    TKDT37DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT37DS_Source; const Data: Pointer);
    TKDT37DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT37DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT37DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT37DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT37DSyanmicStoreBuffer;
    KDBuff     : TKDT37DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT37DS_Node;
    TestBuff   : TKDT37DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT37DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT37DS_Node;
    function GetData(const index: NativeInt): PKDT37DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT37DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT37DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT37DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT37DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT37DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT37DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT37DS_Node; overload;
    function Search(const Buff: TKDT37DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT37DS_Node; overload;
    function Search(const Buff: TKDT37DS_Vec; var SearchedDistanceMin: Double): PKDT37DS_Node; overload;
    function Search(const Buff: TKDT37DS_Vec): PKDT37DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT37DS_DynamicVecBuffer; var OutBuff: TKDT37DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT37DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT37DS_Node);
    procedure PrintBuffer;

    class function KDT37DSVec(const s: string): TKDT37DS_Vec; overload;
    class function KDT37DSVec(const v: TKDT37DS_Vec): string; overload;
    class function KDT37DSPow(const v: TKDT37DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT37DSDistance(const v1, v2: TKDT37DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT37DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT38DS = class(TCoreClassObject)
  public type
    // code split
    TKDT38DS_Vec = packed array [0 .. KDT38DS_Axis - 1] of TKDT38DS_VecType;
    PKDT38DS_Vec = ^TKDT38DS_Vec;

    TKDT38DS_DynamicVecBuffer = array of TKDT38DS_Vec;
    PKDT38DS_DynamicVecBuffer = ^TKDT38DS_DynamicVecBuffer;

    TKDT38DS_Source = packed record
      Buff: TKDT38DS_Vec;
      index: Integer;
    end;

    PKDT38DS_Source       = ^TKDT38DS_Source;
    TKDT38DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT38DS_Source) - 1] of PKDT38DS_Source;
    PKDT38DS_SourceBuffer = ^TKDT38DS_SourceBuffer;

    TKDT38DSyanmicSourceBuffer = packed array of PKDT38DS_Source;
    PKDT38DSyanmicSourceBuffer = ^TKDT38DSyanmicSourceBuffer;

    TKDT38DSyanmicStoreBuffer = packed array of TKDT38DS_Source;
    PKDT38DSyanmicStoreBuffer = ^TKDT38DSyanmicStoreBuffer;

    PKDT38DS_Node = ^TKDT38DS_Node;

    TKDT38DS_Node = packed record
      Parent, Right, Left: PKDT38DS_Node;
      vec: PKDT38DS_Source;
    end;

    TKDT38DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT38DS_Source; const Data: Pointer);
    TKDT38DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT38DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT38DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT38DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT38DSyanmicStoreBuffer;
    KDBuff     : TKDT38DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT38DS_Node;
    TestBuff   : TKDT38DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DS_Node;
    function GetData(const index: NativeInt): PKDT38DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT38DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT38DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT38DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT38DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DS_Node; overload;
    function Search(const Buff: TKDT38DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DS_Node; overload;
    function Search(const Buff: TKDT38DS_Vec; var SearchedDistanceMin: Double): PKDT38DS_Node; overload;
    function Search(const Buff: TKDT38DS_Vec): PKDT38DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT38DS_DynamicVecBuffer; var OutBuff: TKDT38DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT38DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT38DS_Node);
    procedure PrintBuffer;

    class function KDT38DSVec(const s: string): TKDT38DS_Vec; overload;
    class function KDT38DSVec(const v: TKDT38DS_Vec): string; overload;
    class function KDT38DSPow(const v: TKDT38DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT38DSDistance(const v1, v2: TKDT38DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT38DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT39DS = class(TCoreClassObject)
  public type
    // code split
    TKDT39DS_Vec = packed array [0 .. KDT39DS_Axis - 1] of TKDT39DS_VecType;
    PKDT39DS_Vec = ^TKDT39DS_Vec;

    TKDT39DS_DynamicVecBuffer = array of TKDT39DS_Vec;
    PKDT39DS_DynamicVecBuffer = ^TKDT39DS_DynamicVecBuffer;

    TKDT39DS_Source = packed record
      Buff: TKDT39DS_Vec;
      index: Integer;
    end;

    PKDT39DS_Source       = ^TKDT39DS_Source;
    TKDT39DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT39DS_Source) - 1] of PKDT39DS_Source;
    PKDT39DS_SourceBuffer = ^TKDT39DS_SourceBuffer;

    TKDT39DSyanmicSourceBuffer = packed array of PKDT39DS_Source;
    PKDT39DSyanmicSourceBuffer = ^TKDT39DSyanmicSourceBuffer;

    TKDT39DSyanmicStoreBuffer = packed array of TKDT39DS_Source;
    PKDT39DSyanmicStoreBuffer = ^TKDT39DSyanmicStoreBuffer;

    PKDT39DS_Node = ^TKDT39DS_Node;

    TKDT39DS_Node = packed record
      Parent, Right, Left: PKDT39DS_Node;
      vec: PKDT39DS_Source;
    end;

    TKDT39DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT39DS_Source; const Data: Pointer);
    TKDT39DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT39DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT39DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT39DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT39DSyanmicStoreBuffer;
    KDBuff     : TKDT39DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT39DS_Node;
    TestBuff   : TKDT39DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT39DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT39DS_Node;
    function GetData(const index: NativeInt): PKDT39DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT39DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT39DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT39DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT39DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT39DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT39DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT39DS_Node; overload;
    function Search(const Buff: TKDT39DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT39DS_Node; overload;
    function Search(const Buff: TKDT39DS_Vec; var SearchedDistanceMin: Double): PKDT39DS_Node; overload;
    function Search(const Buff: TKDT39DS_Vec): PKDT39DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT39DS_DynamicVecBuffer; var OutBuff: TKDT39DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT39DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT39DS_Node);
    procedure PrintBuffer;

    class function KDT39DSVec(const s: string): TKDT39DS_Vec; overload;
    class function KDT39DSVec(const v: TKDT39DS_Vec): string; overload;
    class function KDT39DSPow(const v: TKDT39DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT39DSDistance(const v1, v2: TKDT39DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT39DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT40DS = class(TCoreClassObject)
  public type
    // code split
    TKDT40DS_Vec = packed array [0 .. KDT40DS_Axis - 1] of TKDT40DS_VecType;
    PKDT40DS_Vec = ^TKDT40DS_Vec;

    TKDT40DS_DynamicVecBuffer = array of TKDT40DS_Vec;
    PKDT40DS_DynamicVecBuffer = ^TKDT40DS_DynamicVecBuffer;

    TKDT40DS_Source = packed record
      Buff: TKDT40DS_Vec;
      index: Integer;
    end;

    PKDT40DS_Source       = ^TKDT40DS_Source;
    TKDT40DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT40DS_Source) - 1] of PKDT40DS_Source;
    PKDT40DS_SourceBuffer = ^TKDT40DS_SourceBuffer;

    TKDT40DSyanmicSourceBuffer = packed array of PKDT40DS_Source;
    PKDT40DSyanmicSourceBuffer = ^TKDT40DSyanmicSourceBuffer;

    TKDT40DSyanmicStoreBuffer = packed array of TKDT40DS_Source;
    PKDT40DSyanmicStoreBuffer = ^TKDT40DSyanmicStoreBuffer;

    PKDT40DS_Node = ^TKDT40DS_Node;

    TKDT40DS_Node = packed record
      Parent, Right, Left: PKDT40DS_Node;
      vec: PKDT40DS_Source;
    end;

    TKDT40DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT40DS_Source; const Data: Pointer);
    TKDT40DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT40DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT40DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT40DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT40DSyanmicStoreBuffer;
    KDBuff     : TKDT40DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT40DS_Node;
    TestBuff   : TKDT40DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DS_Node;
    function GetData(const index: NativeInt): PKDT40DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT40DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT40DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT40DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT40DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DS_Node; overload;
    function Search(const Buff: TKDT40DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DS_Node; overload;
    function Search(const Buff: TKDT40DS_Vec; var SearchedDistanceMin: Double): PKDT40DS_Node; overload;
    function Search(const Buff: TKDT40DS_Vec): PKDT40DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT40DS_DynamicVecBuffer; var OutBuff: TKDT40DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT40DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT40DS_Node);
    procedure PrintBuffer;

    class function KDT40DSVec(const s: string): TKDT40DS_Vec; overload;
    class function KDT40DSVec(const v: TKDT40DS_Vec): string; overload;
    class function KDT40DSPow(const v: TKDT40DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT40DSDistance(const v1, v2: TKDT40DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT40DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT41DS = class(TCoreClassObject)
  public type
    // code split
    TKDT41DS_Vec = packed array [0 .. KDT41DS_Axis - 1] of TKDT41DS_VecType;
    PKDT41DS_Vec = ^TKDT41DS_Vec;

    TKDT41DS_DynamicVecBuffer = array of TKDT41DS_Vec;
    PKDT41DS_DynamicVecBuffer = ^TKDT41DS_DynamicVecBuffer;

    TKDT41DS_Source = packed record
      Buff: TKDT41DS_Vec;
      index: Integer;
    end;

    PKDT41DS_Source       = ^TKDT41DS_Source;
    TKDT41DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT41DS_Source) - 1] of PKDT41DS_Source;
    PKDT41DS_SourceBuffer = ^TKDT41DS_SourceBuffer;

    TKDT41DSyanmicSourceBuffer = packed array of PKDT41DS_Source;
    PKDT41DSyanmicSourceBuffer = ^TKDT41DSyanmicSourceBuffer;

    TKDT41DSyanmicStoreBuffer = packed array of TKDT41DS_Source;
    PKDT41DSyanmicStoreBuffer = ^TKDT41DSyanmicStoreBuffer;

    PKDT41DS_Node = ^TKDT41DS_Node;

    TKDT41DS_Node = packed record
      Parent, Right, Left: PKDT41DS_Node;
      vec: PKDT41DS_Source;
    end;

    TKDT41DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT41DS_Source; const Data: Pointer);
    TKDT41DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT41DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT41DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT41DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT41DSyanmicStoreBuffer;
    KDBuff     : TKDT41DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT41DS_Node;
    TestBuff   : TKDT41DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT41DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT41DS_Node;
    function GetData(const index: NativeInt): PKDT41DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT41DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT41DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT41DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT41DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT41DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT41DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT41DS_Node; overload;
    function Search(const Buff: TKDT41DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT41DS_Node; overload;
    function Search(const Buff: TKDT41DS_Vec; var SearchedDistanceMin: Double): PKDT41DS_Node; overload;
    function Search(const Buff: TKDT41DS_Vec): PKDT41DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT41DS_DynamicVecBuffer; var OutBuff: TKDT41DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT41DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT41DS_Node);
    procedure PrintBuffer;

    class function KDT41DSVec(const s: string): TKDT41DS_Vec; overload;
    class function KDT41DSVec(const v: TKDT41DS_Vec): string; overload;
    class function KDT41DSPow(const v: TKDT41DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT41DSDistance(const v1, v2: TKDT41DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT41DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT42DS = class(TCoreClassObject)
  public type
    // code split
    TKDT42DS_Vec = packed array [0 .. KDT42DS_Axis - 1] of TKDT42DS_VecType;
    PKDT42DS_Vec = ^TKDT42DS_Vec;

    TKDT42DS_DynamicVecBuffer = array of TKDT42DS_Vec;
    PKDT42DS_DynamicVecBuffer = ^TKDT42DS_DynamicVecBuffer;

    TKDT42DS_Source = packed record
      Buff: TKDT42DS_Vec;
      index: Integer;
    end;

    PKDT42DS_Source       = ^TKDT42DS_Source;
    TKDT42DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT42DS_Source) - 1] of PKDT42DS_Source;
    PKDT42DS_SourceBuffer = ^TKDT42DS_SourceBuffer;

    TKDT42DSyanmicSourceBuffer = packed array of PKDT42DS_Source;
    PKDT42DSyanmicSourceBuffer = ^TKDT42DSyanmicSourceBuffer;

    TKDT42DSyanmicStoreBuffer = packed array of TKDT42DS_Source;
    PKDT42DSyanmicStoreBuffer = ^TKDT42DSyanmicStoreBuffer;

    PKDT42DS_Node = ^TKDT42DS_Node;

    TKDT42DS_Node = packed record
      Parent, Right, Left: PKDT42DS_Node;
      vec: PKDT42DS_Source;
    end;

    TKDT42DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT42DS_Source; const Data: Pointer);
    TKDT42DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT42DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT42DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT42DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT42DSyanmicStoreBuffer;
    KDBuff     : TKDT42DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT42DS_Node;
    TestBuff   : TKDT42DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT42DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT42DS_Node;
    function GetData(const index: NativeInt): PKDT42DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT42DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT42DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT42DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT42DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT42DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT42DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT42DS_Node; overload;
    function Search(const Buff: TKDT42DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT42DS_Node; overload;
    function Search(const Buff: TKDT42DS_Vec; var SearchedDistanceMin: Double): PKDT42DS_Node; overload;
    function Search(const Buff: TKDT42DS_Vec): PKDT42DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT42DS_DynamicVecBuffer; var OutBuff: TKDT42DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT42DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT42DS_Node);
    procedure PrintBuffer;

    class function KDT42DSVec(const s: string): TKDT42DS_Vec; overload;
    class function KDT42DSVec(const v: TKDT42DS_Vec): string; overload;
    class function KDT42DSPow(const v: TKDT42DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT42DSDistance(const v1, v2: TKDT42DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT42DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT43DS = class(TCoreClassObject)
  public type
    // code split
    TKDT43DS_Vec = packed array [0 .. KDT43DS_Axis - 1] of TKDT43DS_VecType;
    PKDT43DS_Vec = ^TKDT43DS_Vec;

    TKDT43DS_DynamicVecBuffer = array of TKDT43DS_Vec;
    PKDT43DS_DynamicVecBuffer = ^TKDT43DS_DynamicVecBuffer;

    TKDT43DS_Source = packed record
      Buff: TKDT43DS_Vec;
      index: Integer;
    end;

    PKDT43DS_Source       = ^TKDT43DS_Source;
    TKDT43DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT43DS_Source) - 1] of PKDT43DS_Source;
    PKDT43DS_SourceBuffer = ^TKDT43DS_SourceBuffer;

    TKDT43DSyanmicSourceBuffer = packed array of PKDT43DS_Source;
    PKDT43DSyanmicSourceBuffer = ^TKDT43DSyanmicSourceBuffer;

    TKDT43DSyanmicStoreBuffer = packed array of TKDT43DS_Source;
    PKDT43DSyanmicStoreBuffer = ^TKDT43DSyanmicStoreBuffer;

    PKDT43DS_Node = ^TKDT43DS_Node;

    TKDT43DS_Node = packed record
      Parent, Right, Left: PKDT43DS_Node;
      vec: PKDT43DS_Source;
    end;

    TKDT43DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT43DS_Source; const Data: Pointer);
    TKDT43DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT43DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT43DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT43DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT43DSyanmicStoreBuffer;
    KDBuff     : TKDT43DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT43DS_Node;
    TestBuff   : TKDT43DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT43DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT43DS_Node;
    function GetData(const index: NativeInt): PKDT43DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT43DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT43DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT43DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT43DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT43DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT43DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT43DS_Node; overload;
    function Search(const Buff: TKDT43DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT43DS_Node; overload;
    function Search(const Buff: TKDT43DS_Vec; var SearchedDistanceMin: Double): PKDT43DS_Node; overload;
    function Search(const Buff: TKDT43DS_Vec): PKDT43DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT43DS_DynamicVecBuffer; var OutBuff: TKDT43DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT43DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT43DS_Node);
    procedure PrintBuffer;

    class function KDT43DSVec(const s: string): TKDT43DS_Vec; overload;
    class function KDT43DSVec(const v: TKDT43DS_Vec): string; overload;
    class function KDT43DSPow(const v: TKDT43DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT43DSDistance(const v1, v2: TKDT43DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT43DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT44DS = class(TCoreClassObject)
  public type
    // code split
    TKDT44DS_Vec = packed array [0 .. KDT44DS_Axis - 1] of TKDT44DS_VecType;
    PKDT44DS_Vec = ^TKDT44DS_Vec;

    TKDT44DS_DynamicVecBuffer = array of TKDT44DS_Vec;
    PKDT44DS_DynamicVecBuffer = ^TKDT44DS_DynamicVecBuffer;

    TKDT44DS_Source = packed record
      Buff: TKDT44DS_Vec;
      index: Integer;
    end;

    PKDT44DS_Source       = ^TKDT44DS_Source;
    TKDT44DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT44DS_Source) - 1] of PKDT44DS_Source;
    PKDT44DS_SourceBuffer = ^TKDT44DS_SourceBuffer;

    TKDT44DSyanmicSourceBuffer = packed array of PKDT44DS_Source;
    PKDT44DSyanmicSourceBuffer = ^TKDT44DSyanmicSourceBuffer;

    TKDT44DSyanmicStoreBuffer = packed array of TKDT44DS_Source;
    PKDT44DSyanmicStoreBuffer = ^TKDT44DSyanmicStoreBuffer;

    PKDT44DS_Node = ^TKDT44DS_Node;

    TKDT44DS_Node = packed record
      Parent, Right, Left: PKDT44DS_Node;
      vec: PKDT44DS_Source;
    end;

    TKDT44DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT44DS_Source; const Data: Pointer);
    TKDT44DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT44DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT44DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT44DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT44DSyanmicStoreBuffer;
    KDBuff     : TKDT44DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT44DS_Node;
    TestBuff   : TKDT44DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DS_Node;
    function GetData(const index: NativeInt): PKDT44DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT44DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT44DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT44DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT44DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DS_Node; overload;
    function Search(const Buff: TKDT44DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DS_Node; overload;
    function Search(const Buff: TKDT44DS_Vec; var SearchedDistanceMin: Double): PKDT44DS_Node; overload;
    function Search(const Buff: TKDT44DS_Vec): PKDT44DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT44DS_DynamicVecBuffer; var OutBuff: TKDT44DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT44DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT44DS_Node);
    procedure PrintBuffer;

    class function KDT44DSVec(const s: string): TKDT44DS_Vec; overload;
    class function KDT44DSVec(const v: TKDT44DS_Vec): string; overload;
    class function KDT44DSPow(const v: TKDT44DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT44DSDistance(const v1, v2: TKDT44DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT44DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT45DS = class(TCoreClassObject)
  public type
    // code split
    TKDT45DS_Vec = packed array [0 .. KDT45DS_Axis - 1] of TKDT45DS_VecType;
    PKDT45DS_Vec = ^TKDT45DS_Vec;

    TKDT45DS_DynamicVecBuffer = array of TKDT45DS_Vec;
    PKDT45DS_DynamicVecBuffer = ^TKDT45DS_DynamicVecBuffer;

    TKDT45DS_Source = packed record
      Buff: TKDT45DS_Vec;
      index: Integer;
    end;

    PKDT45DS_Source       = ^TKDT45DS_Source;
    TKDT45DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT45DS_Source) - 1] of PKDT45DS_Source;
    PKDT45DS_SourceBuffer = ^TKDT45DS_SourceBuffer;

    TKDT45DSyanmicSourceBuffer = packed array of PKDT45DS_Source;
    PKDT45DSyanmicSourceBuffer = ^TKDT45DSyanmicSourceBuffer;

    TKDT45DSyanmicStoreBuffer = packed array of TKDT45DS_Source;
    PKDT45DSyanmicStoreBuffer = ^TKDT45DSyanmicStoreBuffer;

    PKDT45DS_Node = ^TKDT45DS_Node;

    TKDT45DS_Node = packed record
      Parent, Right, Left: PKDT45DS_Node;
      vec: PKDT45DS_Source;
    end;

    TKDT45DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT45DS_Source; const Data: Pointer);
    TKDT45DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT45DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT45DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT45DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT45DSyanmicStoreBuffer;
    KDBuff     : TKDT45DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT45DS_Node;
    TestBuff   : TKDT45DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT45DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT45DS_Node;
    function GetData(const index: NativeInt): PKDT45DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT45DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT45DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT45DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT45DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT45DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT45DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT45DS_Node; overload;
    function Search(const Buff: TKDT45DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT45DS_Node; overload;
    function Search(const Buff: TKDT45DS_Vec; var SearchedDistanceMin: Double): PKDT45DS_Node; overload;
    function Search(const Buff: TKDT45DS_Vec): PKDT45DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT45DS_DynamicVecBuffer; var OutBuff: TKDT45DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT45DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT45DS_Node);
    procedure PrintBuffer;

    class function KDT45DSVec(const s: string): TKDT45DS_Vec; overload;
    class function KDT45DSVec(const v: TKDT45DS_Vec): string; overload;
    class function KDT45DSPow(const v: TKDT45DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT45DSDistance(const v1, v2: TKDT45DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT45DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT46DS = class(TCoreClassObject)
  public type
    // code split
    TKDT46DS_Vec = packed array [0 .. KDT46DS_Axis - 1] of TKDT46DS_VecType;
    PKDT46DS_Vec = ^TKDT46DS_Vec;

    TKDT46DS_DynamicVecBuffer = array of TKDT46DS_Vec;
    PKDT46DS_DynamicVecBuffer = ^TKDT46DS_DynamicVecBuffer;

    TKDT46DS_Source = packed record
      Buff: TKDT46DS_Vec;
      index: Integer;
    end;

    PKDT46DS_Source       = ^TKDT46DS_Source;
    TKDT46DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT46DS_Source) - 1] of PKDT46DS_Source;
    PKDT46DS_SourceBuffer = ^TKDT46DS_SourceBuffer;

    TKDT46DSyanmicSourceBuffer = packed array of PKDT46DS_Source;
    PKDT46DSyanmicSourceBuffer = ^TKDT46DSyanmicSourceBuffer;

    TKDT46DSyanmicStoreBuffer = packed array of TKDT46DS_Source;
    PKDT46DSyanmicStoreBuffer = ^TKDT46DSyanmicStoreBuffer;

    PKDT46DS_Node = ^TKDT46DS_Node;

    TKDT46DS_Node = packed record
      Parent, Right, Left: PKDT46DS_Node;
      vec: PKDT46DS_Source;
    end;

    TKDT46DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT46DS_Source; const Data: Pointer);
    TKDT46DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT46DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT46DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT46DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT46DSyanmicStoreBuffer;
    KDBuff     : TKDT46DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT46DS_Node;
    TestBuff   : TKDT46DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT46DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT46DS_Node;
    function GetData(const index: NativeInt): PKDT46DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT46DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT46DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT46DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT46DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT46DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT46DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT46DS_Node; overload;
    function Search(const Buff: TKDT46DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT46DS_Node; overload;
    function Search(const Buff: TKDT46DS_Vec; var SearchedDistanceMin: Double): PKDT46DS_Node; overload;
    function Search(const Buff: TKDT46DS_Vec): PKDT46DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT46DS_DynamicVecBuffer; var OutBuff: TKDT46DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT46DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT46DS_Node);
    procedure PrintBuffer;

    class function KDT46DSVec(const s: string): TKDT46DS_Vec; overload;
    class function KDT46DSVec(const v: TKDT46DS_Vec): string; overload;
    class function KDT46DSPow(const v: TKDT46DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT46DSDistance(const v1, v2: TKDT46DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT46DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT47DS = class(TCoreClassObject)
  public type
    // code split
    TKDT47DS_Vec = packed array [0 .. KDT47DS_Axis - 1] of TKDT47DS_VecType;
    PKDT47DS_Vec = ^TKDT47DS_Vec;

    TKDT47DS_DynamicVecBuffer = array of TKDT47DS_Vec;
    PKDT47DS_DynamicVecBuffer = ^TKDT47DS_DynamicVecBuffer;

    TKDT47DS_Source = packed record
      Buff: TKDT47DS_Vec;
      index: Integer;
    end;

    PKDT47DS_Source       = ^TKDT47DS_Source;
    TKDT47DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT47DS_Source) - 1] of PKDT47DS_Source;
    PKDT47DS_SourceBuffer = ^TKDT47DS_SourceBuffer;

    TKDT47DSyanmicSourceBuffer = packed array of PKDT47DS_Source;
    PKDT47DSyanmicSourceBuffer = ^TKDT47DSyanmicSourceBuffer;

    TKDT47DSyanmicStoreBuffer = packed array of TKDT47DS_Source;
    PKDT47DSyanmicStoreBuffer = ^TKDT47DSyanmicStoreBuffer;

    PKDT47DS_Node = ^TKDT47DS_Node;

    TKDT47DS_Node = packed record
      Parent, Right, Left: PKDT47DS_Node;
      vec: PKDT47DS_Source;
    end;

    TKDT47DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT47DS_Source; const Data: Pointer);
    TKDT47DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT47DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT47DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT47DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT47DSyanmicStoreBuffer;
    KDBuff     : TKDT47DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT47DS_Node;
    TestBuff   : TKDT47DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT47DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT47DS_Node;
    function GetData(const index: NativeInt): PKDT47DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT47DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT47DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT47DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT47DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT47DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT47DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT47DS_Node; overload;
    function Search(const Buff: TKDT47DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT47DS_Node; overload;
    function Search(const Buff: TKDT47DS_Vec; var SearchedDistanceMin: Double): PKDT47DS_Node; overload;
    function Search(const Buff: TKDT47DS_Vec): PKDT47DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT47DS_DynamicVecBuffer; var OutBuff: TKDT47DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT47DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT47DS_Node);
    procedure PrintBuffer;

    class function KDT47DSVec(const s: string): TKDT47DS_Vec; overload;
    class function KDT47DSVec(const v: TKDT47DS_Vec): string; overload;
    class function KDT47DSPow(const v: TKDT47DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT47DSDistance(const v1, v2: TKDT47DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT47DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT48DS = class(TCoreClassObject)
  public type
    // code split
    TKDT48DS_Vec = packed array [0 .. KDT48DS_Axis - 1] of TKDT48DS_VecType;
    PKDT48DS_Vec = ^TKDT48DS_Vec;

    TKDT48DS_DynamicVecBuffer = array of TKDT48DS_Vec;
    PKDT48DS_DynamicVecBuffer = ^TKDT48DS_DynamicVecBuffer;

    TKDT48DS_Source = packed record
      Buff: TKDT48DS_Vec;
      index: Integer;
    end;

    PKDT48DS_Source       = ^TKDT48DS_Source;
    TKDT48DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT48DS_Source) - 1] of PKDT48DS_Source;
    PKDT48DS_SourceBuffer = ^TKDT48DS_SourceBuffer;

    TKDT48DSyanmicSourceBuffer = packed array of PKDT48DS_Source;
    PKDT48DSyanmicSourceBuffer = ^TKDT48DSyanmicSourceBuffer;

    TKDT48DSyanmicStoreBuffer = packed array of TKDT48DS_Source;
    PKDT48DSyanmicStoreBuffer = ^TKDT48DSyanmicStoreBuffer;

    PKDT48DS_Node = ^TKDT48DS_Node;

    TKDT48DS_Node = packed record
      Parent, Right, Left: PKDT48DS_Node;
      vec: PKDT48DS_Source;
    end;

    TKDT48DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT48DS_Source; const Data: Pointer);
    TKDT48DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT48DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT48DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT48DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT48DSyanmicStoreBuffer;
    KDBuff     : TKDT48DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT48DS_Node;
    TestBuff   : TKDT48DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DS_Node;
    function GetData(const index: NativeInt): PKDT48DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT48DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT48DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT48DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DS_Node; overload;
    function Search(const Buff: TKDT48DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DS_Node; overload;
    function Search(const Buff: TKDT48DS_Vec; var SearchedDistanceMin: Double): PKDT48DS_Node; overload;
    function Search(const Buff: TKDT48DS_Vec): PKDT48DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT48DS_DynamicVecBuffer; var OutBuff: TKDT48DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT48DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT48DS_Node);
    procedure PrintBuffer;

    class function KDT48DSVec(const s: string): TKDT48DS_Vec; overload;
    class function KDT48DSVec(const v: TKDT48DS_Vec): string; overload;
    class function KDT48DSPow(const v: TKDT48DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT48DSDistance(const v1, v2: TKDT48DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT49DS = class(TCoreClassObject)
  public type
    // code split
    TKDT49DS_Vec = packed array [0 .. KDT49DS_Axis - 1] of TKDT49DS_VecType;
    PKDT49DS_Vec = ^TKDT49DS_Vec;

    TKDT49DS_DynamicVecBuffer = array of TKDT49DS_Vec;
    PKDT49DS_DynamicVecBuffer = ^TKDT49DS_DynamicVecBuffer;

    TKDT49DS_Source = packed record
      Buff: TKDT49DS_Vec;
      index: Integer;
    end;

    PKDT49DS_Source       = ^TKDT49DS_Source;
    TKDT49DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT49DS_Source) - 1] of PKDT49DS_Source;
    PKDT49DS_SourceBuffer = ^TKDT49DS_SourceBuffer;

    TKDT49DSyanmicSourceBuffer = packed array of PKDT49DS_Source;
    PKDT49DSyanmicSourceBuffer = ^TKDT49DSyanmicSourceBuffer;

    TKDT49DSyanmicStoreBuffer = packed array of TKDT49DS_Source;
    PKDT49DSyanmicStoreBuffer = ^TKDT49DSyanmicStoreBuffer;

    PKDT49DS_Node = ^TKDT49DS_Node;

    TKDT49DS_Node = packed record
      Parent, Right, Left: PKDT49DS_Node;
      vec: PKDT49DS_Source;
    end;

    TKDT49DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT49DS_Source; const Data: Pointer);
    TKDT49DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT49DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT49DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT49DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT49DSyanmicStoreBuffer;
    KDBuff     : TKDT49DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT49DS_Node;
    TestBuff   : TKDT49DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT49DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT49DS_Node;
    function GetData(const index: NativeInt): PKDT49DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT49DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT49DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT49DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT49DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT49DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT49DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT49DS_Node; overload;
    function Search(const Buff: TKDT49DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT49DS_Node; overload;
    function Search(const Buff: TKDT49DS_Vec; var SearchedDistanceMin: Double): PKDT49DS_Node; overload;
    function Search(const Buff: TKDT49DS_Vec): PKDT49DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT49DS_DynamicVecBuffer; var OutBuff: TKDT49DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT49DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT49DS_Node);
    procedure PrintBuffer;

    class function KDT49DSVec(const s: string): TKDT49DS_Vec; overload;
    class function KDT49DSVec(const v: TKDT49DS_Vec): string; overload;
    class function KDT49DSPow(const v: TKDT49DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT49DSDistance(const v1, v2: TKDT49DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT49DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT50DS = class(TCoreClassObject)
  public type
    // code split
    TKDT50DS_Vec = packed array [0 .. KDT50DS_Axis - 1] of TKDT50DS_VecType;
    PKDT50DS_Vec = ^TKDT50DS_Vec;

    TKDT50DS_DynamicVecBuffer = array of TKDT50DS_Vec;
    PKDT50DS_DynamicVecBuffer = ^TKDT50DS_DynamicVecBuffer;

    TKDT50DS_Source = packed record
      Buff: TKDT50DS_Vec;
      index: Integer;
    end;

    PKDT50DS_Source       = ^TKDT50DS_Source;
    TKDT50DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT50DS_Source) - 1] of PKDT50DS_Source;
    PKDT50DS_SourceBuffer = ^TKDT50DS_SourceBuffer;

    TKDT50DSyanmicSourceBuffer = packed array of PKDT50DS_Source;
    PKDT50DSyanmicSourceBuffer = ^TKDT50DSyanmicSourceBuffer;

    TKDT50DSyanmicStoreBuffer = packed array of TKDT50DS_Source;
    PKDT50DSyanmicStoreBuffer = ^TKDT50DSyanmicStoreBuffer;

    PKDT50DS_Node = ^TKDT50DS_Node;

    TKDT50DS_Node = packed record
      Parent, Right, Left: PKDT50DS_Node;
      vec: PKDT50DS_Source;
    end;

    TKDT50DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT50DS_Source; const Data: Pointer);
    TKDT50DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT50DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT50DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT50DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT50DSyanmicStoreBuffer;
    KDBuff     : TKDT50DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT50DS_Node;
    TestBuff   : TKDT50DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DS_Node;
    function GetData(const index: NativeInt): PKDT50DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT50DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT50DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT50DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT50DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DS_Node; overload;
    function Search(const Buff: TKDT50DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DS_Node; overload;
    function Search(const Buff: TKDT50DS_Vec; var SearchedDistanceMin: Double): PKDT50DS_Node; overload;
    function Search(const Buff: TKDT50DS_Vec): PKDT50DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT50DS_DynamicVecBuffer; var OutBuff: TKDT50DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT50DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT50DS_Node);
    procedure PrintBuffer;

    class function KDT50DSVec(const s: string): TKDT50DS_Vec; overload;
    class function KDT50DSVec(const v: TKDT50DS_Vec): string; overload;
    class function KDT50DSPow(const v: TKDT50DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT50DSDistance(const v1, v2: TKDT50DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT50DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT51DS = class(TCoreClassObject)
  public type
    // code split
    TKDT51DS_Vec = packed array [0 .. KDT51DS_Axis - 1] of TKDT51DS_VecType;
    PKDT51DS_Vec = ^TKDT51DS_Vec;

    TKDT51DS_DynamicVecBuffer = array of TKDT51DS_Vec;
    PKDT51DS_DynamicVecBuffer = ^TKDT51DS_DynamicVecBuffer;

    TKDT51DS_Source = packed record
      Buff: TKDT51DS_Vec;
      index: Integer;
    end;

    PKDT51DS_Source       = ^TKDT51DS_Source;
    TKDT51DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT51DS_Source) - 1] of PKDT51DS_Source;
    PKDT51DS_SourceBuffer = ^TKDT51DS_SourceBuffer;

    TKDT51DSyanmicSourceBuffer = packed array of PKDT51DS_Source;
    PKDT51DSyanmicSourceBuffer = ^TKDT51DSyanmicSourceBuffer;

    TKDT51DSyanmicStoreBuffer = packed array of TKDT51DS_Source;
    PKDT51DSyanmicStoreBuffer = ^TKDT51DSyanmicStoreBuffer;

    PKDT51DS_Node = ^TKDT51DS_Node;

    TKDT51DS_Node = packed record
      Parent, Right, Left: PKDT51DS_Node;
      vec: PKDT51DS_Source;
    end;

    TKDT51DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT51DS_Source; const Data: Pointer);
    TKDT51DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT51DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT51DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT51DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT51DSyanmicStoreBuffer;
    KDBuff     : TKDT51DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT51DS_Node;
    TestBuff   : TKDT51DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT51DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT51DS_Node;
    function GetData(const index: NativeInt): PKDT51DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT51DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT51DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT51DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT51DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT51DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT51DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT51DS_Node; overload;
    function Search(const Buff: TKDT51DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT51DS_Node; overload;
    function Search(const Buff: TKDT51DS_Vec; var SearchedDistanceMin: Double): PKDT51DS_Node; overload;
    function Search(const Buff: TKDT51DS_Vec): PKDT51DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT51DS_DynamicVecBuffer; var OutBuff: TKDT51DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT51DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT51DS_Node);
    procedure PrintBuffer;

    class function KDT51DSVec(const s: string): TKDT51DS_Vec; overload;
    class function KDT51DSVec(const v: TKDT51DS_Vec): string; overload;
    class function KDT51DSPow(const v: TKDT51DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT51DSDistance(const v1, v2: TKDT51DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT51DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT52DS = class(TCoreClassObject)
  public type
    // code split
    TKDT52DS_Vec = packed array [0 .. KDT52DS_Axis - 1] of TKDT52DS_VecType;
    PKDT52DS_Vec = ^TKDT52DS_Vec;

    TKDT52DS_DynamicVecBuffer = array of TKDT52DS_Vec;
    PKDT52DS_DynamicVecBuffer = ^TKDT52DS_DynamicVecBuffer;

    TKDT52DS_Source = packed record
      Buff: TKDT52DS_Vec;
      index: Integer;
    end;

    PKDT52DS_Source       = ^TKDT52DS_Source;
    TKDT52DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT52DS_Source) - 1] of PKDT52DS_Source;
    PKDT52DS_SourceBuffer = ^TKDT52DS_SourceBuffer;

    TKDT52DSyanmicSourceBuffer = packed array of PKDT52DS_Source;
    PKDT52DSyanmicSourceBuffer = ^TKDT52DSyanmicSourceBuffer;

    TKDT52DSyanmicStoreBuffer = packed array of TKDT52DS_Source;
    PKDT52DSyanmicStoreBuffer = ^TKDT52DSyanmicStoreBuffer;

    PKDT52DS_Node = ^TKDT52DS_Node;

    TKDT52DS_Node = packed record
      Parent, Right, Left: PKDT52DS_Node;
      vec: PKDT52DS_Source;
    end;

    TKDT52DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT52DS_Source; const Data: Pointer);
    TKDT52DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT52DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT52DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT52DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT52DSyanmicStoreBuffer;
    KDBuff     : TKDT52DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT52DS_Node;
    TestBuff   : TKDT52DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DS_Node;
    function GetData(const index: NativeInt): PKDT52DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT52DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT52DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT52DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT52DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DS_Node; overload;
    function Search(const Buff: TKDT52DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DS_Node; overload;
    function Search(const Buff: TKDT52DS_Vec; var SearchedDistanceMin: Double): PKDT52DS_Node; overload;
    function Search(const Buff: TKDT52DS_Vec): PKDT52DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT52DS_DynamicVecBuffer; var OutBuff: TKDT52DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT52DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT52DS_Node);
    procedure PrintBuffer;

    class function KDT52DSVec(const s: string): TKDT52DS_Vec; overload;
    class function KDT52DSVec(const v: TKDT52DS_Vec): string; overload;
    class function KDT52DSPow(const v: TKDT52DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT52DSDistance(const v1, v2: TKDT52DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT53DS = class(TCoreClassObject)
  public type
    // code split
    TKDT53DS_Vec = packed array [0 .. KDT53DS_Axis - 1] of TKDT53DS_VecType;
    PKDT53DS_Vec = ^TKDT53DS_Vec;

    TKDT53DS_DynamicVecBuffer = array of TKDT53DS_Vec;
    PKDT53DS_DynamicVecBuffer = ^TKDT53DS_DynamicVecBuffer;

    TKDT53DS_Source = packed record
      Buff: TKDT53DS_Vec;
      index: Integer;
    end;

    PKDT53DS_Source       = ^TKDT53DS_Source;
    TKDT53DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT53DS_Source) - 1] of PKDT53DS_Source;
    PKDT53DS_SourceBuffer = ^TKDT53DS_SourceBuffer;

    TKDT53DSyanmicSourceBuffer = packed array of PKDT53DS_Source;
    PKDT53DSyanmicSourceBuffer = ^TKDT53DSyanmicSourceBuffer;

    TKDT53DSyanmicStoreBuffer = packed array of TKDT53DS_Source;
    PKDT53DSyanmicStoreBuffer = ^TKDT53DSyanmicStoreBuffer;

    PKDT53DS_Node = ^TKDT53DS_Node;

    TKDT53DS_Node = packed record
      Parent, Right, Left: PKDT53DS_Node;
      vec: PKDT53DS_Source;
    end;

    TKDT53DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT53DS_Source; const Data: Pointer);
    TKDT53DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT53DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT53DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT53DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT53DSyanmicStoreBuffer;
    KDBuff     : TKDT53DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT53DS_Node;
    TestBuff   : TKDT53DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT53DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT53DS_Node;
    function GetData(const index: NativeInt): PKDT53DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT53DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT53DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT53DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT53DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT53DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT53DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT53DS_Node; overload;
    function Search(const Buff: TKDT53DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT53DS_Node; overload;
    function Search(const Buff: TKDT53DS_Vec; var SearchedDistanceMin: Double): PKDT53DS_Node; overload;
    function Search(const Buff: TKDT53DS_Vec): PKDT53DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT53DS_DynamicVecBuffer; var OutBuff: TKDT53DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT53DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT53DS_Node);
    procedure PrintBuffer;

    class function KDT53DSVec(const s: string): TKDT53DS_Vec; overload;
    class function KDT53DSVec(const v: TKDT53DS_Vec): string; overload;
    class function KDT53DSPow(const v: TKDT53DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT53DSDistance(const v1, v2: TKDT53DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT53DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT54DS = class(TCoreClassObject)
  public type
    // code split
    TKDT54DS_Vec = packed array [0 .. KDT54DS_Axis - 1] of TKDT54DS_VecType;
    PKDT54DS_Vec = ^TKDT54DS_Vec;

    TKDT54DS_DynamicVecBuffer = array of TKDT54DS_Vec;
    PKDT54DS_DynamicVecBuffer = ^TKDT54DS_DynamicVecBuffer;

    TKDT54DS_Source = packed record
      Buff: TKDT54DS_Vec;
      index: Integer;
    end;

    PKDT54DS_Source       = ^TKDT54DS_Source;
    TKDT54DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT54DS_Source) - 1] of PKDT54DS_Source;
    PKDT54DS_SourceBuffer = ^TKDT54DS_SourceBuffer;

    TKDT54DSyanmicSourceBuffer = packed array of PKDT54DS_Source;
    PKDT54DSyanmicSourceBuffer = ^TKDT54DSyanmicSourceBuffer;

    TKDT54DSyanmicStoreBuffer = packed array of TKDT54DS_Source;
    PKDT54DSyanmicStoreBuffer = ^TKDT54DSyanmicStoreBuffer;

    PKDT54DS_Node = ^TKDT54DS_Node;

    TKDT54DS_Node = packed record
      Parent, Right, Left: PKDT54DS_Node;
      vec: PKDT54DS_Source;
    end;

    TKDT54DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT54DS_Source; const Data: Pointer);
    TKDT54DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT54DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT54DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT54DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT54DSyanmicStoreBuffer;
    KDBuff     : TKDT54DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT54DS_Node;
    TestBuff   : TKDT54DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT54DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT54DS_Node;
    function GetData(const index: NativeInt): PKDT54DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT54DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT54DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT54DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT54DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT54DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT54DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT54DS_Node; overload;
    function Search(const Buff: TKDT54DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT54DS_Node; overload;
    function Search(const Buff: TKDT54DS_Vec; var SearchedDistanceMin: Double): PKDT54DS_Node; overload;
    function Search(const Buff: TKDT54DS_Vec): PKDT54DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT54DS_DynamicVecBuffer; var OutBuff: TKDT54DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT54DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT54DS_Node);
    procedure PrintBuffer;

    class function KDT54DSVec(const s: string): TKDT54DS_Vec; overload;
    class function KDT54DSVec(const v: TKDT54DS_Vec): string; overload;
    class function KDT54DSPow(const v: TKDT54DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT54DSDistance(const v1, v2: TKDT54DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT54DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT55DS = class(TCoreClassObject)
  public type
    // code split
    TKDT55DS_Vec = packed array [0 .. KDT55DS_Axis - 1] of TKDT55DS_VecType;
    PKDT55DS_Vec = ^TKDT55DS_Vec;

    TKDT55DS_DynamicVecBuffer = array of TKDT55DS_Vec;
    PKDT55DS_DynamicVecBuffer = ^TKDT55DS_DynamicVecBuffer;

    TKDT55DS_Source = packed record
      Buff: TKDT55DS_Vec;
      index: Integer;
    end;

    PKDT55DS_Source       = ^TKDT55DS_Source;
    TKDT55DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT55DS_Source) - 1] of PKDT55DS_Source;
    PKDT55DS_SourceBuffer = ^TKDT55DS_SourceBuffer;

    TKDT55DSyanmicSourceBuffer = packed array of PKDT55DS_Source;
    PKDT55DSyanmicSourceBuffer = ^TKDT55DSyanmicSourceBuffer;

    TKDT55DSyanmicStoreBuffer = packed array of TKDT55DS_Source;
    PKDT55DSyanmicStoreBuffer = ^TKDT55DSyanmicStoreBuffer;

    PKDT55DS_Node = ^TKDT55DS_Node;

    TKDT55DS_Node = packed record
      Parent, Right, Left: PKDT55DS_Node;
      vec: PKDT55DS_Source;
    end;

    TKDT55DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT55DS_Source; const Data: Pointer);
    TKDT55DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT55DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT55DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT55DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT55DSyanmicStoreBuffer;
    KDBuff     : TKDT55DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT55DS_Node;
    TestBuff   : TKDT55DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT55DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT55DS_Node;
    function GetData(const index: NativeInt): PKDT55DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT55DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT55DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT55DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT55DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT55DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT55DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT55DS_Node; overload;
    function Search(const Buff: TKDT55DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT55DS_Node; overload;
    function Search(const Buff: TKDT55DS_Vec; var SearchedDistanceMin: Double): PKDT55DS_Node; overload;
    function Search(const Buff: TKDT55DS_Vec): PKDT55DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT55DS_DynamicVecBuffer; var OutBuff: TKDT55DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT55DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT55DS_Node);
    procedure PrintBuffer;

    class function KDT55DSVec(const s: string): TKDT55DS_Vec; overload;
    class function KDT55DSVec(const v: TKDT55DS_Vec): string; overload;
    class function KDT55DSPow(const v: TKDT55DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT55DSDistance(const v1, v2: TKDT55DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT55DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT56DS = class(TCoreClassObject)
  public type
    // code split
    TKDT56DS_Vec = packed array [0 .. KDT56DS_Axis - 1] of TKDT56DS_VecType;
    PKDT56DS_Vec = ^TKDT56DS_Vec;

    TKDT56DS_DynamicVecBuffer = array of TKDT56DS_Vec;
    PKDT56DS_DynamicVecBuffer = ^TKDT56DS_DynamicVecBuffer;

    TKDT56DS_Source = packed record
      Buff: TKDT56DS_Vec;
      index: Integer;
    end;

    PKDT56DS_Source       = ^TKDT56DS_Source;
    TKDT56DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT56DS_Source) - 1] of PKDT56DS_Source;
    PKDT56DS_SourceBuffer = ^TKDT56DS_SourceBuffer;

    TKDT56DSyanmicSourceBuffer = packed array of PKDT56DS_Source;
    PKDT56DSyanmicSourceBuffer = ^TKDT56DSyanmicSourceBuffer;

    TKDT56DSyanmicStoreBuffer = packed array of TKDT56DS_Source;
    PKDT56DSyanmicStoreBuffer = ^TKDT56DSyanmicStoreBuffer;

    PKDT56DS_Node = ^TKDT56DS_Node;

    TKDT56DS_Node = packed record
      Parent, Right, Left: PKDT56DS_Node;
      vec: PKDT56DS_Source;
    end;

    TKDT56DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT56DS_Source; const Data: Pointer);
    TKDT56DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT56DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT56DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT56DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT56DSyanmicStoreBuffer;
    KDBuff     : TKDT56DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT56DS_Node;
    TestBuff   : TKDT56DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DS_Node;
    function GetData(const index: NativeInt): PKDT56DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT56DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT56DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT56DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT56DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DS_Node; overload;
    function Search(const Buff: TKDT56DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DS_Node; overload;
    function Search(const Buff: TKDT56DS_Vec; var SearchedDistanceMin: Double): PKDT56DS_Node; overload;
    function Search(const Buff: TKDT56DS_Vec): PKDT56DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT56DS_DynamicVecBuffer; var OutBuff: TKDT56DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT56DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT56DS_Node);
    procedure PrintBuffer;

    class function KDT56DSVec(const s: string): TKDT56DS_Vec; overload;
    class function KDT56DSVec(const v: TKDT56DS_Vec): string; overload;
    class function KDT56DSPow(const v: TKDT56DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT56DSDistance(const v1, v2: TKDT56DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT56DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT57DS = class(TCoreClassObject)
  public type
    // code split
    TKDT57DS_Vec = packed array [0 .. KDT57DS_Axis - 1] of TKDT57DS_VecType;
    PKDT57DS_Vec = ^TKDT57DS_Vec;

    TKDT57DS_DynamicVecBuffer = array of TKDT57DS_Vec;
    PKDT57DS_DynamicVecBuffer = ^TKDT57DS_DynamicVecBuffer;

    TKDT57DS_Source = packed record
      Buff: TKDT57DS_Vec;
      index: Integer;
    end;

    PKDT57DS_Source       = ^TKDT57DS_Source;
    TKDT57DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT57DS_Source) - 1] of PKDT57DS_Source;
    PKDT57DS_SourceBuffer = ^TKDT57DS_SourceBuffer;

    TKDT57DSyanmicSourceBuffer = packed array of PKDT57DS_Source;
    PKDT57DSyanmicSourceBuffer = ^TKDT57DSyanmicSourceBuffer;

    TKDT57DSyanmicStoreBuffer = packed array of TKDT57DS_Source;
    PKDT57DSyanmicStoreBuffer = ^TKDT57DSyanmicStoreBuffer;

    PKDT57DS_Node = ^TKDT57DS_Node;

    TKDT57DS_Node = packed record
      Parent, Right, Left: PKDT57DS_Node;
      vec: PKDT57DS_Source;
    end;

    TKDT57DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT57DS_Source; const Data: Pointer);
    TKDT57DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT57DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT57DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT57DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT57DSyanmicStoreBuffer;
    KDBuff     : TKDT57DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT57DS_Node;
    TestBuff   : TKDT57DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT57DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT57DS_Node;
    function GetData(const index: NativeInt): PKDT57DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT57DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT57DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT57DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT57DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT57DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT57DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT57DS_Node; overload;
    function Search(const Buff: TKDT57DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT57DS_Node; overload;
    function Search(const Buff: TKDT57DS_Vec; var SearchedDistanceMin: Double): PKDT57DS_Node; overload;
    function Search(const Buff: TKDT57DS_Vec): PKDT57DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT57DS_DynamicVecBuffer; var OutBuff: TKDT57DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT57DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT57DS_Node);
    procedure PrintBuffer;

    class function KDT57DSVec(const s: string): TKDT57DS_Vec; overload;
    class function KDT57DSVec(const v: TKDT57DS_Vec): string; overload;
    class function KDT57DSPow(const v: TKDT57DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT57DSDistance(const v1, v2: TKDT57DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT57DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT58DS = class(TCoreClassObject)
  public type
    // code split
    TKDT58DS_Vec = packed array [0 .. KDT58DS_Axis - 1] of TKDT58DS_VecType;
    PKDT58DS_Vec = ^TKDT58DS_Vec;

    TKDT58DS_DynamicVecBuffer = array of TKDT58DS_Vec;
    PKDT58DS_DynamicVecBuffer = ^TKDT58DS_DynamicVecBuffer;

    TKDT58DS_Source = packed record
      Buff: TKDT58DS_Vec;
      index: Integer;
    end;

    PKDT58DS_Source       = ^TKDT58DS_Source;
    TKDT58DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT58DS_Source) - 1] of PKDT58DS_Source;
    PKDT58DS_SourceBuffer = ^TKDT58DS_SourceBuffer;

    TKDT58DSyanmicSourceBuffer = packed array of PKDT58DS_Source;
    PKDT58DSyanmicSourceBuffer = ^TKDT58DSyanmicSourceBuffer;

    TKDT58DSyanmicStoreBuffer = packed array of TKDT58DS_Source;
    PKDT58DSyanmicStoreBuffer = ^TKDT58DSyanmicStoreBuffer;

    PKDT58DS_Node = ^TKDT58DS_Node;

    TKDT58DS_Node = packed record
      Parent, Right, Left: PKDT58DS_Node;
      vec: PKDT58DS_Source;
    end;

    TKDT58DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT58DS_Source; const Data: Pointer);
    TKDT58DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT58DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT58DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT58DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT58DSyanmicStoreBuffer;
    KDBuff     : TKDT58DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT58DS_Node;
    TestBuff   : TKDT58DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT58DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT58DS_Node;
    function GetData(const index: NativeInt): PKDT58DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT58DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT58DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT58DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT58DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT58DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT58DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT58DS_Node; overload;
    function Search(const Buff: TKDT58DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT58DS_Node; overload;
    function Search(const Buff: TKDT58DS_Vec; var SearchedDistanceMin: Double): PKDT58DS_Node; overload;
    function Search(const Buff: TKDT58DS_Vec): PKDT58DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT58DS_DynamicVecBuffer; var OutBuff: TKDT58DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT58DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT58DS_Node);
    procedure PrintBuffer;

    class function KDT58DSVec(const s: string): TKDT58DS_Vec; overload;
    class function KDT58DSVec(const v: TKDT58DS_Vec): string; overload;
    class function KDT58DSPow(const v: TKDT58DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT58DSDistance(const v1, v2: TKDT58DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT58DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT59DS = class(TCoreClassObject)
  public type
    // code split
    TKDT59DS_Vec = packed array [0 .. KDT59DS_Axis - 1] of TKDT59DS_VecType;
    PKDT59DS_Vec = ^TKDT59DS_Vec;

    TKDT59DS_DynamicVecBuffer = array of TKDT59DS_Vec;
    PKDT59DS_DynamicVecBuffer = ^TKDT59DS_DynamicVecBuffer;

    TKDT59DS_Source = packed record
      Buff: TKDT59DS_Vec;
      index: Integer;
    end;

    PKDT59DS_Source       = ^TKDT59DS_Source;
    TKDT59DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT59DS_Source) - 1] of PKDT59DS_Source;
    PKDT59DS_SourceBuffer = ^TKDT59DS_SourceBuffer;

    TKDT59DSyanmicSourceBuffer = packed array of PKDT59DS_Source;
    PKDT59DSyanmicSourceBuffer = ^TKDT59DSyanmicSourceBuffer;

    TKDT59DSyanmicStoreBuffer = packed array of TKDT59DS_Source;
    PKDT59DSyanmicStoreBuffer = ^TKDT59DSyanmicStoreBuffer;

    PKDT59DS_Node = ^TKDT59DS_Node;

    TKDT59DS_Node = packed record
      Parent, Right, Left: PKDT59DS_Node;
      vec: PKDT59DS_Source;
    end;

    TKDT59DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT59DS_Source; const Data: Pointer);
    TKDT59DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT59DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT59DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT59DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT59DSyanmicStoreBuffer;
    KDBuff     : TKDT59DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT59DS_Node;
    TestBuff   : TKDT59DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT59DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT59DS_Node;
    function GetData(const index: NativeInt): PKDT59DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT59DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT59DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT59DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT59DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT59DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT59DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT59DS_Node; overload;
    function Search(const Buff: TKDT59DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT59DS_Node; overload;
    function Search(const Buff: TKDT59DS_Vec; var SearchedDistanceMin: Double): PKDT59DS_Node; overload;
    function Search(const Buff: TKDT59DS_Vec): PKDT59DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT59DS_DynamicVecBuffer; var OutBuff: TKDT59DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT59DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT59DS_Node);
    procedure PrintBuffer;

    class function KDT59DSVec(const s: string): TKDT59DS_Vec; overload;
    class function KDT59DSVec(const v: TKDT59DS_Vec): string; overload;
    class function KDT59DSPow(const v: TKDT59DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT59DSDistance(const v1, v2: TKDT59DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT59DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT60DS = class(TCoreClassObject)
  public type
    // code split
    TKDT60DS_Vec = packed array [0 .. KDT60DS_Axis - 1] of TKDT60DS_VecType;
    PKDT60DS_Vec = ^TKDT60DS_Vec;

    TKDT60DS_DynamicVecBuffer = array of TKDT60DS_Vec;
    PKDT60DS_DynamicVecBuffer = ^TKDT60DS_DynamicVecBuffer;

    TKDT60DS_Source = packed record
      Buff: TKDT60DS_Vec;
      index: Integer;
    end;

    PKDT60DS_Source       = ^TKDT60DS_Source;
    TKDT60DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT60DS_Source) - 1] of PKDT60DS_Source;
    PKDT60DS_SourceBuffer = ^TKDT60DS_SourceBuffer;

    TKDT60DSyanmicSourceBuffer = packed array of PKDT60DS_Source;
    PKDT60DSyanmicSourceBuffer = ^TKDT60DSyanmicSourceBuffer;

    TKDT60DSyanmicStoreBuffer = packed array of TKDT60DS_Source;
    PKDT60DSyanmicStoreBuffer = ^TKDT60DSyanmicStoreBuffer;

    PKDT60DS_Node = ^TKDT60DS_Node;

    TKDT60DS_Node = packed record
      Parent, Right, Left: PKDT60DS_Node;
      vec: PKDT60DS_Source;
    end;

    TKDT60DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT60DS_Source; const Data: Pointer);
    TKDT60DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT60DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT60DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT60DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT60DSyanmicStoreBuffer;
    KDBuff     : TKDT60DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT60DS_Node;
    TestBuff   : TKDT60DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DS_Node;
    function GetData(const index: NativeInt): PKDT60DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT60DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT60DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT60DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT60DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DS_Node; overload;
    function Search(const Buff: TKDT60DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DS_Node; overload;
    function Search(const Buff: TKDT60DS_Vec; var SearchedDistanceMin: Double): PKDT60DS_Node; overload;
    function Search(const Buff: TKDT60DS_Vec): PKDT60DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT60DS_DynamicVecBuffer; var OutBuff: TKDT60DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT60DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT60DS_Node);
    procedure PrintBuffer;

    class function KDT60DSVec(const s: string): TKDT60DS_Vec; overload;
    class function KDT60DSVec(const v: TKDT60DS_Vec): string; overload;
    class function KDT60DSPow(const v: TKDT60DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT60DSDistance(const v1, v2: TKDT60DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT60DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT61DS = class(TCoreClassObject)
  public type
    // code split
    TKDT61DS_Vec = packed array [0 .. KDT61DS_Axis - 1] of TKDT61DS_VecType;
    PKDT61DS_Vec = ^TKDT61DS_Vec;

    TKDT61DS_DynamicVecBuffer = array of TKDT61DS_Vec;
    PKDT61DS_DynamicVecBuffer = ^TKDT61DS_DynamicVecBuffer;

    TKDT61DS_Source = packed record
      Buff: TKDT61DS_Vec;
      index: Integer;
    end;

    PKDT61DS_Source       = ^TKDT61DS_Source;
    TKDT61DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT61DS_Source) - 1] of PKDT61DS_Source;
    PKDT61DS_SourceBuffer = ^TKDT61DS_SourceBuffer;

    TKDT61DSyanmicSourceBuffer = packed array of PKDT61DS_Source;
    PKDT61DSyanmicSourceBuffer = ^TKDT61DSyanmicSourceBuffer;

    TKDT61DSyanmicStoreBuffer = packed array of TKDT61DS_Source;
    PKDT61DSyanmicStoreBuffer = ^TKDT61DSyanmicStoreBuffer;

    PKDT61DS_Node = ^TKDT61DS_Node;

    TKDT61DS_Node = packed record
      Parent, Right, Left: PKDT61DS_Node;
      vec: PKDT61DS_Source;
    end;

    TKDT61DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT61DS_Source; const Data: Pointer);
    TKDT61DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT61DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT61DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT61DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT61DSyanmicStoreBuffer;
    KDBuff     : TKDT61DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT61DS_Node;
    TestBuff   : TKDT61DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT61DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT61DS_Node;
    function GetData(const index: NativeInt): PKDT61DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT61DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT61DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT61DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT61DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT61DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT61DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT61DS_Node; overload;
    function Search(const Buff: TKDT61DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT61DS_Node; overload;
    function Search(const Buff: TKDT61DS_Vec; var SearchedDistanceMin: Double): PKDT61DS_Node; overload;
    function Search(const Buff: TKDT61DS_Vec): PKDT61DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT61DS_DynamicVecBuffer; var OutBuff: TKDT61DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT61DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT61DS_Node);
    procedure PrintBuffer;

    class function KDT61DSVec(const s: string): TKDT61DS_Vec; overload;
    class function KDT61DSVec(const v: TKDT61DS_Vec): string; overload;
    class function KDT61DSPow(const v: TKDT61DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT61DSDistance(const v1, v2: TKDT61DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT61DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT62DS = class(TCoreClassObject)
  public type
    // code split
    TKDT62DS_Vec = packed array [0 .. KDT62DS_Axis - 1] of TKDT62DS_VecType;
    PKDT62DS_Vec = ^TKDT62DS_Vec;

    TKDT62DS_DynamicVecBuffer = array of TKDT62DS_Vec;
    PKDT62DS_DynamicVecBuffer = ^TKDT62DS_DynamicVecBuffer;

    TKDT62DS_Source = packed record
      Buff: TKDT62DS_Vec;
      index: Integer;
    end;

    PKDT62DS_Source       = ^TKDT62DS_Source;
    TKDT62DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT62DS_Source) - 1] of PKDT62DS_Source;
    PKDT62DS_SourceBuffer = ^TKDT62DS_SourceBuffer;

    TKDT62DSyanmicSourceBuffer = packed array of PKDT62DS_Source;
    PKDT62DSyanmicSourceBuffer = ^TKDT62DSyanmicSourceBuffer;

    TKDT62DSyanmicStoreBuffer = packed array of TKDT62DS_Source;
    PKDT62DSyanmicStoreBuffer = ^TKDT62DSyanmicStoreBuffer;

    PKDT62DS_Node = ^TKDT62DS_Node;

    TKDT62DS_Node = packed record
      Parent, Right, Left: PKDT62DS_Node;
      vec: PKDT62DS_Source;
    end;

    TKDT62DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT62DS_Source; const Data: Pointer);
    TKDT62DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT62DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT62DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT62DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT62DSyanmicStoreBuffer;
    KDBuff     : TKDT62DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT62DS_Node;
    TestBuff   : TKDT62DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT62DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT62DS_Node;
    function GetData(const index: NativeInt): PKDT62DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT62DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT62DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT62DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT62DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT62DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT62DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT62DS_Node; overload;
    function Search(const Buff: TKDT62DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT62DS_Node; overload;
    function Search(const Buff: TKDT62DS_Vec; var SearchedDistanceMin: Double): PKDT62DS_Node; overload;
    function Search(const Buff: TKDT62DS_Vec): PKDT62DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT62DS_DynamicVecBuffer; var OutBuff: TKDT62DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT62DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT62DS_Node);
    procedure PrintBuffer;

    class function KDT62DSVec(const s: string): TKDT62DS_Vec; overload;
    class function KDT62DSVec(const v: TKDT62DS_Vec): string; overload;
    class function KDT62DSPow(const v: TKDT62DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT62DSDistance(const v1, v2: TKDT62DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT62DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT63DS = class(TCoreClassObject)
  public type
    // code split
    TKDT63DS_Vec = packed array [0 .. KDT63DS_Axis - 1] of TKDT63DS_VecType;
    PKDT63DS_Vec = ^TKDT63DS_Vec;

    TKDT63DS_DynamicVecBuffer = array of TKDT63DS_Vec;
    PKDT63DS_DynamicVecBuffer = ^TKDT63DS_DynamicVecBuffer;

    TKDT63DS_Source = packed record
      Buff: TKDT63DS_Vec;
      index: Integer;
    end;

    PKDT63DS_Source       = ^TKDT63DS_Source;
    TKDT63DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT63DS_Source) - 1] of PKDT63DS_Source;
    PKDT63DS_SourceBuffer = ^TKDT63DS_SourceBuffer;

    TKDT63DSyanmicSourceBuffer = packed array of PKDT63DS_Source;
    PKDT63DSyanmicSourceBuffer = ^TKDT63DSyanmicSourceBuffer;

    TKDT63DSyanmicStoreBuffer = packed array of TKDT63DS_Source;
    PKDT63DSyanmicStoreBuffer = ^TKDT63DSyanmicStoreBuffer;

    PKDT63DS_Node = ^TKDT63DS_Node;

    TKDT63DS_Node = packed record
      Parent, Right, Left: PKDT63DS_Node;
      vec: PKDT63DS_Source;
    end;

    TKDT63DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT63DS_Source; const Data: Pointer);
    TKDT63DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT63DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT63DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT63DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT63DSyanmicStoreBuffer;
    KDBuff     : TKDT63DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT63DS_Node;
    TestBuff   : TKDT63DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT63DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT63DS_Node;
    function GetData(const index: NativeInt): PKDT63DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT63DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT63DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT63DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT63DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT63DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT63DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT63DS_Node; overload;
    function Search(const Buff: TKDT63DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT63DS_Node; overload;
    function Search(const Buff: TKDT63DS_Vec; var SearchedDistanceMin: Double): PKDT63DS_Node; overload;
    function Search(const Buff: TKDT63DS_Vec): PKDT63DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT63DS_DynamicVecBuffer; var OutBuff: TKDT63DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT63DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT63DS_Node);
    procedure PrintBuffer;

    class function KDT63DSVec(const s: string): TKDT63DS_Vec; overload;
    class function KDT63DSVec(const v: TKDT63DS_Vec): string; overload;
    class function KDT63DSPow(const v: TKDT63DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT63DSDistance(const v1, v2: TKDT63DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT63DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT64DS = class(TCoreClassObject)
  public type
    // code split
    TKDT64DS_Vec = packed array [0 .. KDT64DS_Axis - 1] of TKDT64DS_VecType;
    PKDT64DS_Vec = ^TKDT64DS_Vec;

    TKDT64DS_DynamicVecBuffer = array of TKDT64DS_Vec;
    PKDT64DS_DynamicVecBuffer = ^TKDT64DS_DynamicVecBuffer;

    TKDT64DS_Source = packed record
      Buff: TKDT64DS_Vec;
      index: Integer;
    end;

    PKDT64DS_Source       = ^TKDT64DS_Source;
    TKDT64DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT64DS_Source) - 1] of PKDT64DS_Source;
    PKDT64DS_SourceBuffer = ^TKDT64DS_SourceBuffer;

    TKDT64DSyanmicSourceBuffer = packed array of PKDT64DS_Source;
    PKDT64DSyanmicSourceBuffer = ^TKDT64DSyanmicSourceBuffer;

    TKDT64DSyanmicStoreBuffer = packed array of TKDT64DS_Source;
    PKDT64DSyanmicStoreBuffer = ^TKDT64DSyanmicStoreBuffer;

    PKDT64DS_Node = ^TKDT64DS_Node;

    TKDT64DS_Node = packed record
      Parent, Right, Left: PKDT64DS_Node;
      vec: PKDT64DS_Source;
    end;

    TKDT64DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT64DS_Source; const Data: Pointer);
    TKDT64DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT64DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT64DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT64DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT64DSyanmicStoreBuffer;
    KDBuff     : TKDT64DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT64DS_Node;
    TestBuff   : TKDT64DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DS_Node;
    function GetData(const index: NativeInt): PKDT64DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT64DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT64DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT64DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DS_Node; overload;
    function Search(const Buff: TKDT64DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DS_Node; overload;
    function Search(const Buff: TKDT64DS_Vec; var SearchedDistanceMin: Double): PKDT64DS_Node; overload;
    function Search(const Buff: TKDT64DS_Vec): PKDT64DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT64DS_DynamicVecBuffer; var OutBuff: TKDT64DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT64DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT64DS_Node);
    procedure PrintBuffer;

    class function KDT64DSVec(const s: string): TKDT64DS_Vec; overload;
    class function KDT64DSVec(const v: TKDT64DS_Vec): string; overload;
    class function KDT64DSPow(const v: TKDT64DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT64DSDistance(const v1, v2: TKDT64DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT65DS = class(TCoreClassObject)
  public type
    // code split
    TKDT65DS_Vec = packed array [0 .. KDT65DS_Axis - 1] of TKDT65DS_VecType;
    PKDT65DS_Vec = ^TKDT65DS_Vec;

    TKDT65DS_DynamicVecBuffer = array of TKDT65DS_Vec;
    PKDT65DS_DynamicVecBuffer = ^TKDT65DS_DynamicVecBuffer;

    TKDT65DS_Source = packed record
      Buff: TKDT65DS_Vec;
      index: Integer;
    end;

    PKDT65DS_Source       = ^TKDT65DS_Source;
    TKDT65DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT65DS_Source) - 1] of PKDT65DS_Source;
    PKDT65DS_SourceBuffer = ^TKDT65DS_SourceBuffer;

    TKDT65DSyanmicSourceBuffer = packed array of PKDT65DS_Source;
    PKDT65DSyanmicSourceBuffer = ^TKDT65DSyanmicSourceBuffer;

    TKDT65DSyanmicStoreBuffer = packed array of TKDT65DS_Source;
    PKDT65DSyanmicStoreBuffer = ^TKDT65DSyanmicStoreBuffer;

    PKDT65DS_Node = ^TKDT65DS_Node;

    TKDT65DS_Node = packed record
      Parent, Right, Left: PKDT65DS_Node;
      vec: PKDT65DS_Source;
    end;

    TKDT65DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT65DS_Source; const Data: Pointer);
    TKDT65DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT65DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT65DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT65DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT65DSyanmicStoreBuffer;
    KDBuff     : TKDT65DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT65DS_Node;
    TestBuff   : TKDT65DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT65DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT65DS_Node;
    function GetData(const index: NativeInt): PKDT65DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT65DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT65DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT65DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT65DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT65DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT65DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT65DS_Node; overload;
    function Search(const Buff: TKDT65DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT65DS_Node; overload;
    function Search(const Buff: TKDT65DS_Vec; var SearchedDistanceMin: Double): PKDT65DS_Node; overload;
    function Search(const Buff: TKDT65DS_Vec): PKDT65DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT65DS_DynamicVecBuffer; var OutBuff: TKDT65DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT65DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT65DS_Node);
    procedure PrintBuffer;

    class function KDT65DSVec(const s: string): TKDT65DS_Vec; overload;
    class function KDT65DSVec(const v: TKDT65DS_Vec): string; overload;
    class function KDT65DSPow(const v: TKDT65DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT65DSDistance(const v1, v2: TKDT65DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT65DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT66DS = class(TCoreClassObject)
  public type
    // code split
    TKDT66DS_Vec = packed array [0 .. KDT66DS_Axis - 1] of TKDT66DS_VecType;
    PKDT66DS_Vec = ^TKDT66DS_Vec;

    TKDT66DS_DynamicVecBuffer = array of TKDT66DS_Vec;
    PKDT66DS_DynamicVecBuffer = ^TKDT66DS_DynamicVecBuffer;

    TKDT66DS_Source = packed record
      Buff: TKDT66DS_Vec;
      index: Integer;
    end;

    PKDT66DS_Source       = ^TKDT66DS_Source;
    TKDT66DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT66DS_Source) - 1] of PKDT66DS_Source;
    PKDT66DS_SourceBuffer = ^TKDT66DS_SourceBuffer;

    TKDT66DSyanmicSourceBuffer = packed array of PKDT66DS_Source;
    PKDT66DSyanmicSourceBuffer = ^TKDT66DSyanmicSourceBuffer;

    TKDT66DSyanmicStoreBuffer = packed array of TKDT66DS_Source;
    PKDT66DSyanmicStoreBuffer = ^TKDT66DSyanmicStoreBuffer;

    PKDT66DS_Node = ^TKDT66DS_Node;

    TKDT66DS_Node = packed record
      Parent, Right, Left: PKDT66DS_Node;
      vec: PKDT66DS_Source;
    end;

    TKDT66DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT66DS_Source; const Data: Pointer);
    TKDT66DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT66DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT66DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT66DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT66DSyanmicStoreBuffer;
    KDBuff     : TKDT66DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT66DS_Node;
    TestBuff   : TKDT66DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT66DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT66DS_Node;
    function GetData(const index: NativeInt): PKDT66DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT66DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT66DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT66DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT66DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT66DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT66DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT66DS_Node; overload;
    function Search(const Buff: TKDT66DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT66DS_Node; overload;
    function Search(const Buff: TKDT66DS_Vec; var SearchedDistanceMin: Double): PKDT66DS_Node; overload;
    function Search(const Buff: TKDT66DS_Vec): PKDT66DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT66DS_DynamicVecBuffer; var OutBuff: TKDT66DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT66DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT66DS_Node);
    procedure PrintBuffer;

    class function KDT66DSVec(const s: string): TKDT66DS_Vec; overload;
    class function KDT66DSVec(const v: TKDT66DS_Vec): string; overload;
    class function KDT66DSPow(const v: TKDT66DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT66DSDistance(const v1, v2: TKDT66DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT66DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT67DS = class(TCoreClassObject)
  public type
    // code split
    TKDT67DS_Vec = packed array [0 .. KDT67DS_Axis - 1] of TKDT67DS_VecType;
    PKDT67DS_Vec = ^TKDT67DS_Vec;

    TKDT67DS_DynamicVecBuffer = array of TKDT67DS_Vec;
    PKDT67DS_DynamicVecBuffer = ^TKDT67DS_DynamicVecBuffer;

    TKDT67DS_Source = packed record
      Buff: TKDT67DS_Vec;
      index: Integer;
    end;

    PKDT67DS_Source       = ^TKDT67DS_Source;
    TKDT67DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT67DS_Source) - 1] of PKDT67DS_Source;
    PKDT67DS_SourceBuffer = ^TKDT67DS_SourceBuffer;

    TKDT67DSyanmicSourceBuffer = packed array of PKDT67DS_Source;
    PKDT67DSyanmicSourceBuffer = ^TKDT67DSyanmicSourceBuffer;

    TKDT67DSyanmicStoreBuffer = packed array of TKDT67DS_Source;
    PKDT67DSyanmicStoreBuffer = ^TKDT67DSyanmicStoreBuffer;

    PKDT67DS_Node = ^TKDT67DS_Node;

    TKDT67DS_Node = packed record
      Parent, Right, Left: PKDT67DS_Node;
      vec: PKDT67DS_Source;
    end;

    TKDT67DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT67DS_Source; const Data: Pointer);
    TKDT67DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT67DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT67DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT67DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT67DSyanmicStoreBuffer;
    KDBuff     : TKDT67DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT67DS_Node;
    TestBuff   : TKDT67DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT67DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT67DS_Node;
    function GetData(const index: NativeInt): PKDT67DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT67DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT67DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT67DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT67DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT67DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT67DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT67DS_Node; overload;
    function Search(const Buff: TKDT67DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT67DS_Node; overload;
    function Search(const Buff: TKDT67DS_Vec; var SearchedDistanceMin: Double): PKDT67DS_Node; overload;
    function Search(const Buff: TKDT67DS_Vec): PKDT67DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT67DS_DynamicVecBuffer; var OutBuff: TKDT67DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT67DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT67DS_Node);
    procedure PrintBuffer;

    class function KDT67DSVec(const s: string): TKDT67DS_Vec; overload;
    class function KDT67DSVec(const v: TKDT67DS_Vec): string; overload;
    class function KDT67DSPow(const v: TKDT67DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT67DSDistance(const v1, v2: TKDT67DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT67DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT68DS = class(TCoreClassObject)
  public type
    // code split
    TKDT68DS_Vec = packed array [0 .. KDT68DS_Axis - 1] of TKDT68DS_VecType;
    PKDT68DS_Vec = ^TKDT68DS_Vec;

    TKDT68DS_DynamicVecBuffer = array of TKDT68DS_Vec;
    PKDT68DS_DynamicVecBuffer = ^TKDT68DS_DynamicVecBuffer;

    TKDT68DS_Source = packed record
      Buff: TKDT68DS_Vec;
      index: Integer;
    end;

    PKDT68DS_Source       = ^TKDT68DS_Source;
    TKDT68DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT68DS_Source) - 1] of PKDT68DS_Source;
    PKDT68DS_SourceBuffer = ^TKDT68DS_SourceBuffer;

    TKDT68DSyanmicSourceBuffer = packed array of PKDT68DS_Source;
    PKDT68DSyanmicSourceBuffer = ^TKDT68DSyanmicSourceBuffer;

    TKDT68DSyanmicStoreBuffer = packed array of TKDT68DS_Source;
    PKDT68DSyanmicStoreBuffer = ^TKDT68DSyanmicStoreBuffer;

    PKDT68DS_Node = ^TKDT68DS_Node;

    TKDT68DS_Node = packed record
      Parent, Right, Left: PKDT68DS_Node;
      vec: PKDT68DS_Source;
    end;

    TKDT68DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT68DS_Source; const Data: Pointer);
    TKDT68DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT68DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT68DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT68DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT68DSyanmicStoreBuffer;
    KDBuff     : TKDT68DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT68DS_Node;
    TestBuff   : TKDT68DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT68DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT68DS_Node;
    function GetData(const index: NativeInt): PKDT68DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT68DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT68DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT68DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT68DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT68DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT68DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT68DS_Node; overload;
    function Search(const Buff: TKDT68DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT68DS_Node; overload;
    function Search(const Buff: TKDT68DS_Vec; var SearchedDistanceMin: Double): PKDT68DS_Node; overload;
    function Search(const Buff: TKDT68DS_Vec): PKDT68DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT68DS_DynamicVecBuffer; var OutBuff: TKDT68DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT68DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT68DS_Node);
    procedure PrintBuffer;

    class function KDT68DSVec(const s: string): TKDT68DS_Vec; overload;
    class function KDT68DSVec(const v: TKDT68DS_Vec): string; overload;
    class function KDT68DSPow(const v: TKDT68DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT68DSDistance(const v1, v2: TKDT68DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT68DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT69DS = class(TCoreClassObject)
  public type
    // code split
    TKDT69DS_Vec = packed array [0 .. KDT69DS_Axis - 1] of TKDT69DS_VecType;
    PKDT69DS_Vec = ^TKDT69DS_Vec;

    TKDT69DS_DynamicVecBuffer = array of TKDT69DS_Vec;
    PKDT69DS_DynamicVecBuffer = ^TKDT69DS_DynamicVecBuffer;

    TKDT69DS_Source = packed record
      Buff: TKDT69DS_Vec;
      index: Integer;
    end;

    PKDT69DS_Source       = ^TKDT69DS_Source;
    TKDT69DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT69DS_Source) - 1] of PKDT69DS_Source;
    PKDT69DS_SourceBuffer = ^TKDT69DS_SourceBuffer;

    TKDT69DSyanmicSourceBuffer = packed array of PKDT69DS_Source;
    PKDT69DSyanmicSourceBuffer = ^TKDT69DSyanmicSourceBuffer;

    TKDT69DSyanmicStoreBuffer = packed array of TKDT69DS_Source;
    PKDT69DSyanmicStoreBuffer = ^TKDT69DSyanmicStoreBuffer;

    PKDT69DS_Node = ^TKDT69DS_Node;

    TKDT69DS_Node = packed record
      Parent, Right, Left: PKDT69DS_Node;
      vec: PKDT69DS_Source;
    end;

    TKDT69DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT69DS_Source; const Data: Pointer);
    TKDT69DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT69DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT69DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT69DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT69DSyanmicStoreBuffer;
    KDBuff     : TKDT69DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT69DS_Node;
    TestBuff   : TKDT69DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT69DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT69DS_Node;
    function GetData(const index: NativeInt): PKDT69DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT69DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT69DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT69DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT69DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT69DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT69DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT69DS_Node; overload;
    function Search(const Buff: TKDT69DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT69DS_Node; overload;
    function Search(const Buff: TKDT69DS_Vec; var SearchedDistanceMin: Double): PKDT69DS_Node; overload;
    function Search(const Buff: TKDT69DS_Vec): PKDT69DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT69DS_DynamicVecBuffer; var OutBuff: TKDT69DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT69DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT69DS_Node);
    procedure PrintBuffer;

    class function KDT69DSVec(const s: string): TKDT69DS_Vec; overload;
    class function KDT69DSVec(const v: TKDT69DS_Vec): string; overload;
    class function KDT69DSPow(const v: TKDT69DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT69DSDistance(const v1, v2: TKDT69DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT69DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT70DS = class(TCoreClassObject)
  public type
    // code split
    TKDT70DS_Vec = packed array [0 .. KDT70DS_Axis - 1] of TKDT70DS_VecType;
    PKDT70DS_Vec = ^TKDT70DS_Vec;

    TKDT70DS_DynamicVecBuffer = array of TKDT70DS_Vec;
    PKDT70DS_DynamicVecBuffer = ^TKDT70DS_DynamicVecBuffer;

    TKDT70DS_Source = packed record
      Buff: TKDT70DS_Vec;
      index: Integer;
    end;

    PKDT70DS_Source       = ^TKDT70DS_Source;
    TKDT70DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT70DS_Source) - 1] of PKDT70DS_Source;
    PKDT70DS_SourceBuffer = ^TKDT70DS_SourceBuffer;

    TKDT70DSyanmicSourceBuffer = packed array of PKDT70DS_Source;
    PKDT70DSyanmicSourceBuffer = ^TKDT70DSyanmicSourceBuffer;

    TKDT70DSyanmicStoreBuffer = packed array of TKDT70DS_Source;
    PKDT70DSyanmicStoreBuffer = ^TKDT70DSyanmicStoreBuffer;

    PKDT70DS_Node = ^TKDT70DS_Node;

    TKDT70DS_Node = packed record
      Parent, Right, Left: PKDT70DS_Node;
      vec: PKDT70DS_Source;
    end;

    TKDT70DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT70DS_Source; const Data: Pointer);
    TKDT70DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT70DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT70DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT70DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT70DSyanmicStoreBuffer;
    KDBuff     : TKDT70DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT70DS_Node;
    TestBuff   : TKDT70DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT70DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT70DS_Node;
    function GetData(const index: NativeInt): PKDT70DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT70DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT70DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT70DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT70DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT70DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT70DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT70DS_Node; overload;
    function Search(const Buff: TKDT70DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT70DS_Node; overload;
    function Search(const Buff: TKDT70DS_Vec; var SearchedDistanceMin: Double): PKDT70DS_Node; overload;
    function Search(const Buff: TKDT70DS_Vec): PKDT70DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT70DS_DynamicVecBuffer; var OutBuff: TKDT70DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT70DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT70DS_Node);
    procedure PrintBuffer;

    class function KDT70DSVec(const s: string): TKDT70DS_Vec; overload;
    class function KDT70DSVec(const v: TKDT70DS_Vec): string; overload;
    class function KDT70DSPow(const v: TKDT70DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT70DSDistance(const v1, v2: TKDT70DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT70DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT71DS = class(TCoreClassObject)
  public type
    // code split
    TKDT71DS_Vec = packed array [0 .. KDT71DS_Axis - 1] of TKDT71DS_VecType;
    PKDT71DS_Vec = ^TKDT71DS_Vec;

    TKDT71DS_DynamicVecBuffer = array of TKDT71DS_Vec;
    PKDT71DS_DynamicVecBuffer = ^TKDT71DS_DynamicVecBuffer;

    TKDT71DS_Source = packed record
      Buff: TKDT71DS_Vec;
      index: Integer;
    end;

    PKDT71DS_Source       = ^TKDT71DS_Source;
    TKDT71DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT71DS_Source) - 1] of PKDT71DS_Source;
    PKDT71DS_SourceBuffer = ^TKDT71DS_SourceBuffer;

    TKDT71DSyanmicSourceBuffer = packed array of PKDT71DS_Source;
    PKDT71DSyanmicSourceBuffer = ^TKDT71DSyanmicSourceBuffer;

    TKDT71DSyanmicStoreBuffer = packed array of TKDT71DS_Source;
    PKDT71DSyanmicStoreBuffer = ^TKDT71DSyanmicStoreBuffer;

    PKDT71DS_Node = ^TKDT71DS_Node;

    TKDT71DS_Node = packed record
      Parent, Right, Left: PKDT71DS_Node;
      vec: PKDT71DS_Source;
    end;

    TKDT71DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT71DS_Source; const Data: Pointer);
    TKDT71DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT71DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT71DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT71DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT71DSyanmicStoreBuffer;
    KDBuff     : TKDT71DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT71DS_Node;
    TestBuff   : TKDT71DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT71DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT71DS_Node;
    function GetData(const index: NativeInt): PKDT71DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT71DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT71DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT71DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT71DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT71DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT71DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT71DS_Node; overload;
    function Search(const Buff: TKDT71DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT71DS_Node; overload;
    function Search(const Buff: TKDT71DS_Vec; var SearchedDistanceMin: Double): PKDT71DS_Node; overload;
    function Search(const Buff: TKDT71DS_Vec): PKDT71DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT71DS_DynamicVecBuffer; var OutBuff: TKDT71DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT71DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT71DS_Node);
    procedure PrintBuffer;

    class function KDT71DSVec(const s: string): TKDT71DS_Vec; overload;
    class function KDT71DSVec(const v: TKDT71DS_Vec): string; overload;
    class function KDT71DSPow(const v: TKDT71DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT71DSDistance(const v1, v2: TKDT71DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT71DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT72DS = class(TCoreClassObject)
  public type
    // code split
    TKDT72DS_Vec = packed array [0 .. KDT72DS_Axis - 1] of TKDT72DS_VecType;
    PKDT72DS_Vec = ^TKDT72DS_Vec;

    TKDT72DS_DynamicVecBuffer = array of TKDT72DS_Vec;
    PKDT72DS_DynamicVecBuffer = ^TKDT72DS_DynamicVecBuffer;

    TKDT72DS_Source = packed record
      Buff: TKDT72DS_Vec;
      index: Integer;
    end;

    PKDT72DS_Source       = ^TKDT72DS_Source;
    TKDT72DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT72DS_Source) - 1] of PKDT72DS_Source;
    PKDT72DS_SourceBuffer = ^TKDT72DS_SourceBuffer;

    TKDT72DSyanmicSourceBuffer = packed array of PKDT72DS_Source;
    PKDT72DSyanmicSourceBuffer = ^TKDT72DSyanmicSourceBuffer;

    TKDT72DSyanmicStoreBuffer = packed array of TKDT72DS_Source;
    PKDT72DSyanmicStoreBuffer = ^TKDT72DSyanmicStoreBuffer;

    PKDT72DS_Node = ^TKDT72DS_Node;

    TKDT72DS_Node = packed record
      Parent, Right, Left: PKDT72DS_Node;
      vec: PKDT72DS_Source;
    end;

    TKDT72DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT72DS_Source; const Data: Pointer);
    TKDT72DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT72DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT72DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT72DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT72DSyanmicStoreBuffer;
    KDBuff     : TKDT72DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT72DS_Node;
    TestBuff   : TKDT72DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DS_Node;
    function GetData(const index: NativeInt): PKDT72DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT72DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT72DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT72DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT72DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DS_Node; overload;
    function Search(const Buff: TKDT72DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DS_Node; overload;
    function Search(const Buff: TKDT72DS_Vec; var SearchedDistanceMin: Double): PKDT72DS_Node; overload;
    function Search(const Buff: TKDT72DS_Vec): PKDT72DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT72DS_DynamicVecBuffer; var OutBuff: TKDT72DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT72DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT72DS_Node);
    procedure PrintBuffer;

    class function KDT72DSVec(const s: string): TKDT72DS_Vec; overload;
    class function KDT72DSVec(const v: TKDT72DS_Vec): string; overload;
    class function KDT72DSPow(const v: TKDT72DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT72DSDistance(const v1, v2: TKDT72DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT72DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT84DS = class(TCoreClassObject)
  public type
    // code split
    TKDT84DS_Vec = packed array [0 .. KDT84DS_Axis - 1] of TKDT84DS_VecType;
    PKDT84DS_Vec = ^TKDT84DS_Vec;

    TKDT84DS_DynamicVecBuffer = array of TKDT84DS_Vec;
    PKDT84DS_DynamicVecBuffer = ^TKDT84DS_DynamicVecBuffer;

    TKDT84DS_Source = packed record
      Buff: TKDT84DS_Vec;
      index: Integer;
    end;

    PKDT84DS_Source       = ^TKDT84DS_Source;
    TKDT84DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT84DS_Source) - 1] of PKDT84DS_Source;
    PKDT84DS_SourceBuffer = ^TKDT84DS_SourceBuffer;

    TKDT84DSyanmicSourceBuffer = packed array of PKDT84DS_Source;
    PKDT84DSyanmicSourceBuffer = ^TKDT84DSyanmicSourceBuffer;

    TKDT84DSyanmicStoreBuffer = packed array of TKDT84DS_Source;
    PKDT84DSyanmicStoreBuffer = ^TKDT84DSyanmicStoreBuffer;

    PKDT84DS_Node = ^TKDT84DS_Node;

    TKDT84DS_Node = packed record
      Parent, Right, Left: PKDT84DS_Node;
      vec: PKDT84DS_Source;
    end;

    TKDT84DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT84DS_Source; const Data: Pointer);
    TKDT84DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT84DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT84DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT84DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT84DSyanmicStoreBuffer;
    KDBuff     : TKDT84DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT84DS_Node;
    TestBuff   : TKDT84DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DS_Node;
    function GetData(const index: NativeInt): PKDT84DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT84DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT84DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT84DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT84DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DS_Node; overload;
    function Search(const Buff: TKDT84DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DS_Node; overload;
    function Search(const Buff: TKDT84DS_Vec; var SearchedDistanceMin: Double): PKDT84DS_Node; overload;
    function Search(const Buff: TKDT84DS_Vec): PKDT84DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT84DS_DynamicVecBuffer; var OutBuff: TKDT84DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT84DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT84DS_Node);
    procedure PrintBuffer;

    class function KDT84DSVec(const s: string): TKDT84DS_Vec; overload;
    class function KDT84DSVec(const v: TKDT84DS_Vec): string; overload;
    class function KDT84DSPow(const v: TKDT84DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT84DSDistance(const v1, v2: TKDT84DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT84DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT96DS = class(TCoreClassObject)
  public type
    // code split
    TKDT96DS_Vec = packed array [0 .. KDT96DS_Axis - 1] of TKDT96DS_VecType;
    PKDT96DS_Vec = ^TKDT96DS_Vec;

    TKDT96DS_DynamicVecBuffer = array of TKDT96DS_Vec;
    PKDT96DS_DynamicVecBuffer = ^TKDT96DS_DynamicVecBuffer;

    TKDT96DS_Source = packed record
      Buff: TKDT96DS_Vec;
      index: Integer;
    end;

    PKDT96DS_Source       = ^TKDT96DS_Source;
    TKDT96DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT96DS_Source) - 1] of PKDT96DS_Source;
    PKDT96DS_SourceBuffer = ^TKDT96DS_SourceBuffer;

    TKDT96DSyanmicSourceBuffer = packed array of PKDT96DS_Source;
    PKDT96DSyanmicSourceBuffer = ^TKDT96DSyanmicSourceBuffer;

    TKDT96DSyanmicStoreBuffer = packed array of TKDT96DS_Source;
    PKDT96DSyanmicStoreBuffer = ^TKDT96DSyanmicStoreBuffer;

    PKDT96DS_Node = ^TKDT96DS_Node;

    TKDT96DS_Node = packed record
      Parent, Right, Left: PKDT96DS_Node;
      vec: PKDT96DS_Source;
    end;

    TKDT96DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT96DS_Source; const Data: Pointer);
    TKDT96DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT96DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT96DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT96DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT96DSyanmicStoreBuffer;
    KDBuff     : TKDT96DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT96DS_Node;
    TestBuff   : TKDT96DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DS_Node;
    function GetData(const index: NativeInt): PKDT96DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT96DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT96DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT96DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DS_Node; overload;
    function Search(const Buff: TKDT96DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DS_Node; overload;
    function Search(const Buff: TKDT96DS_Vec; var SearchedDistanceMin: Double): PKDT96DS_Node; overload;
    function Search(const Buff: TKDT96DS_Vec): PKDT96DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT96DS_DynamicVecBuffer; var OutBuff: TKDT96DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT96DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT96DS_Node);
    procedure PrintBuffer;

    class function KDT96DSVec(const s: string): TKDT96DS_Vec; overload;
    class function KDT96DSVec(const v: TKDT96DS_Vec): string; overload;
    class function KDT96DSPow(const v: TKDT96DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT96DSDistance(const v1, v2: TKDT96DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT128DS = class(TCoreClassObject)
  public type
    // code split
    TKDT128DS_Vec = packed array [0 .. KDT128DS_Axis - 1] of TKDT128DS_VecType;
    PKDT128DS_Vec = ^TKDT128DS_Vec;

    TKDT128DS_DynamicVecBuffer = array of TKDT128DS_Vec;
    PKDT128DS_DynamicVecBuffer = ^TKDT128DS_DynamicVecBuffer;

    TKDT128DS_Source = packed record
      Buff: TKDT128DS_Vec;
      index: Integer;
    end;

    PKDT128DS_Source       = ^TKDT128DS_Source;
    TKDT128DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT128DS_Source) - 1] of PKDT128DS_Source;
    PKDT128DS_SourceBuffer = ^TKDT128DS_SourceBuffer;

    TKDT128DSyanmicSourceBuffer = packed array of PKDT128DS_Source;
    PKDT128DSyanmicSourceBuffer = ^TKDT128DSyanmicSourceBuffer;

    TKDT128DSyanmicStoreBuffer = packed array of TKDT128DS_Source;
    PKDT128DSyanmicStoreBuffer = ^TKDT128DSyanmicStoreBuffer;

    PKDT128DS_Node = ^TKDT128DS_Node;

    TKDT128DS_Node = packed record
      Parent, Right, Left: PKDT128DS_Node;
      vec: PKDT128DS_Source;
    end;

    TKDT128DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT128DS_Source; const Data: Pointer);
    TKDT128DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT128DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT128DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT128DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT128DSyanmicStoreBuffer;
    KDBuff     : TKDT128DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT128DS_Node;
    TestBuff   : TKDT128DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DS_Node;
    function GetData(const index: NativeInt): PKDT128DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT128DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT128DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT128DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DS_Node; overload;
    function Search(const Buff: TKDT128DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DS_Node; overload;
    function Search(const Buff: TKDT128DS_Vec; var SearchedDistanceMin: Double): PKDT128DS_Node; overload;
    function Search(const Buff: TKDT128DS_Vec): PKDT128DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT128DS_DynamicVecBuffer; var OutBuff: TKDT128DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT128DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT128DS_Node);
    procedure PrintBuffer;

    class function KDT128DSVec(const s: string): TKDT128DS_Vec; overload;
    class function KDT128DSVec(const v: TKDT128DS_Vec): string; overload;
    class function KDT128DSPow(const v: TKDT128DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT128DSDistance(const v1, v2: TKDT128DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT140DS = class(TCoreClassObject)
  public type
    // code split
    TKDT140DS_Vec = packed array [0 .. KDT140DS_Axis - 1] of TKDT140DS_VecType;
    PKDT140DS_Vec = ^TKDT140DS_Vec;

    TKDT140DS_DynamicVecBuffer = array of TKDT140DS_Vec;
    PKDT140DS_DynamicVecBuffer = ^TKDT140DS_DynamicVecBuffer;

    TKDT140DS_Source = packed record
      Buff: TKDT140DS_Vec;
      index: Integer;
    end;

    PKDT140DS_Source       = ^TKDT140DS_Source;
    TKDT140DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT140DS_Source) - 1] of PKDT140DS_Source;
    PKDT140DS_SourceBuffer = ^TKDT140DS_SourceBuffer;

    TKDT140DSyanmicSourceBuffer = packed array of PKDT140DS_Source;
    PKDT140DSyanmicSourceBuffer = ^TKDT140DSyanmicSourceBuffer;

    TKDT140DSyanmicStoreBuffer = packed array of TKDT140DS_Source;
    PKDT140DSyanmicStoreBuffer = ^TKDT140DSyanmicStoreBuffer;

    PKDT140DS_Node = ^TKDT140DS_Node;

    TKDT140DS_Node = packed record
      Parent, Right, Left: PKDT140DS_Node;
      vec: PKDT140DS_Source;
    end;

    TKDT140DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT140DS_Source; const Data: Pointer);
    TKDT140DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT140DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT140DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT140DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT140DSyanmicStoreBuffer;
    KDBuff     : TKDT140DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT140DS_Node;
    TestBuff   : TKDT140DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DS_Node;
    function GetData(const index: NativeInt): PKDT140DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT140DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT140DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT140DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT140DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DS_Node; overload;
    function Search(const Buff: TKDT140DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DS_Node; overload;
    function Search(const Buff: TKDT140DS_Vec; var SearchedDistanceMin: Double): PKDT140DS_Node; overload;
    function Search(const Buff: TKDT140DS_Vec): PKDT140DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT140DS_DynamicVecBuffer; var OutBuff: TKDT140DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT140DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT140DS_Node);
    procedure PrintBuffer;

    class function KDT140DSVec(const s: string): TKDT140DS_Vec; overload;
    class function KDT140DSVec(const v: TKDT140DS_Vec): string; overload;
    class function KDT140DSPow(const v: TKDT140DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT140DSDistance(const v1, v2: TKDT140DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT140DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT160DS = class(TCoreClassObject)
  public type
    // code split
    TKDT160DS_Vec = packed array [0 .. KDT160DS_Axis - 1] of TKDT160DS_VecType;
    PKDT160DS_Vec = ^TKDT160DS_Vec;

    TKDT160DS_DynamicVecBuffer = array of TKDT160DS_Vec;
    PKDT160DS_DynamicVecBuffer = ^TKDT160DS_DynamicVecBuffer;

    TKDT160DS_Source = packed record
      Buff: TKDT160DS_Vec;
      index: Integer;
    end;

    PKDT160DS_Source       = ^TKDT160DS_Source;
    TKDT160DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT160DS_Source) - 1] of PKDT160DS_Source;
    PKDT160DS_SourceBuffer = ^TKDT160DS_SourceBuffer;

    TKDT160DSyanmicSourceBuffer = packed array of PKDT160DS_Source;
    PKDT160DSyanmicSourceBuffer = ^TKDT160DSyanmicSourceBuffer;

    TKDT160DSyanmicStoreBuffer = packed array of TKDT160DS_Source;
    PKDT160DSyanmicStoreBuffer = ^TKDT160DSyanmicStoreBuffer;

    PKDT160DS_Node = ^TKDT160DS_Node;

    TKDT160DS_Node = packed record
      Parent, Right, Left: PKDT160DS_Node;
      vec: PKDT160DS_Source;
    end;

    TKDT160DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT160DS_Source; const Data: Pointer);
    TKDT160DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT160DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT160DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT160DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT160DSyanmicStoreBuffer;
    KDBuff     : TKDT160DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT160DS_Node;
    TestBuff   : TKDT160DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DS_Node;
    function GetData(const index: NativeInt): PKDT160DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT160DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT160DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT160DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT160DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DS_Node; overload;
    function Search(const Buff: TKDT160DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DS_Node; overload;
    function Search(const Buff: TKDT160DS_Vec; var SearchedDistanceMin: Double): PKDT160DS_Node; overload;
    function Search(const Buff: TKDT160DS_Vec): PKDT160DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT160DS_DynamicVecBuffer; var OutBuff: TKDT160DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT160DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT160DS_Node);
    procedure PrintBuffer;

    class function KDT160DSVec(const s: string): TKDT160DS_Vec; overload;
    class function KDT160DSVec(const v: TKDT160DS_Vec): string; overload;
    class function KDT160DSPow(const v: TKDT160DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT160DSDistance(const v1, v2: TKDT160DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT160DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT196DS = class(TCoreClassObject)
  public type
    // code split
    TKDT196DS_Vec = packed array [0 .. KDT196DS_Axis - 1] of TKDT196DS_VecType;
    PKDT196DS_Vec = ^TKDT196DS_Vec;

    TKDT196DS_DynamicVecBuffer = array of TKDT196DS_Vec;
    PKDT196DS_DynamicVecBuffer = ^TKDT196DS_DynamicVecBuffer;

    TKDT196DS_Source = packed record
      Buff: TKDT196DS_Vec;
      index: Integer;
    end;

    PKDT196DS_Source       = ^TKDT196DS_Source;
    TKDT196DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT196DS_Source) - 1] of PKDT196DS_Source;
    PKDT196DS_SourceBuffer = ^TKDT196DS_SourceBuffer;

    TKDT196DSyanmicSourceBuffer = packed array of PKDT196DS_Source;
    PKDT196DSyanmicSourceBuffer = ^TKDT196DSyanmicSourceBuffer;

    TKDT196DSyanmicStoreBuffer = packed array of TKDT196DS_Source;
    PKDT196DSyanmicStoreBuffer = ^TKDT196DSyanmicStoreBuffer;

    PKDT196DS_Node = ^TKDT196DS_Node;

    TKDT196DS_Node = packed record
      Parent, Right, Left: PKDT196DS_Node;
      vec: PKDT196DS_Source;
    end;

    TKDT196DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT196DS_Source; const Data: Pointer);
    TKDT196DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT196DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT196DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT196DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT196DSyanmicStoreBuffer;
    KDBuff     : TKDT196DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT196DS_Node;
    TestBuff   : TKDT196DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DS_Node;
    function GetData(const index: NativeInt): PKDT196DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT196DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT196DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT196DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT196DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DS_Node; overload;
    function Search(const Buff: TKDT196DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DS_Node; overload;
    function Search(const Buff: TKDT196DS_Vec; var SearchedDistanceMin: Double): PKDT196DS_Node; overload;
    function Search(const Buff: TKDT196DS_Vec): PKDT196DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT196DS_DynamicVecBuffer; var OutBuff: TKDT196DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT196DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT196DS_Node);
    procedure PrintBuffer;

    class function KDT196DSVec(const s: string): TKDT196DS_Vec; overload;
    class function KDT196DSVec(const v: TKDT196DS_Vec): string; overload;
    class function KDT196DSPow(const v: TKDT196DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT196DSDistance(const v1, v2: TKDT196DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT196DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT256DS = class(TCoreClassObject)
  public type
    // code split
    TKDT256DS_Vec = packed array [0 .. KDT256DS_Axis - 1] of TKDT256DS_VecType;
    PKDT256DS_Vec = ^TKDT256DS_Vec;

    TKDT256DS_DynamicVecBuffer = array of TKDT256DS_Vec;
    PKDT256DS_DynamicVecBuffer = ^TKDT256DS_DynamicVecBuffer;

    TKDT256DS_Source = packed record
      Buff: TKDT256DS_Vec;
      index: Integer;
    end;

    PKDT256DS_Source       = ^TKDT256DS_Source;
    TKDT256DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT256DS_Source) - 1] of PKDT256DS_Source;
    PKDT256DS_SourceBuffer = ^TKDT256DS_SourceBuffer;

    TKDT256DSyanmicSourceBuffer = packed array of PKDT256DS_Source;
    PKDT256DSyanmicSourceBuffer = ^TKDT256DSyanmicSourceBuffer;

    TKDT256DSyanmicStoreBuffer = packed array of TKDT256DS_Source;
    PKDT256DSyanmicStoreBuffer = ^TKDT256DSyanmicStoreBuffer;

    PKDT256DS_Node = ^TKDT256DS_Node;

    TKDT256DS_Node = packed record
      Parent, Right, Left: PKDT256DS_Node;
      vec: PKDT256DS_Source;
    end;

    TKDT256DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT256DS_Source; const Data: Pointer);
    TKDT256DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT256DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT256DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT256DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT256DSyanmicStoreBuffer;
    KDBuff     : TKDT256DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT256DS_Node;
    TestBuff   : TKDT256DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DS_Node;
    function GetData(const index: NativeInt): PKDT256DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT256DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT256DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT256DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DS_Node; overload;
    function Search(const Buff: TKDT256DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DS_Node; overload;
    function Search(const Buff: TKDT256DS_Vec; var SearchedDistanceMin: Double): PKDT256DS_Node; overload;
    function Search(const Buff: TKDT256DS_Vec): PKDT256DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT256DS_DynamicVecBuffer; var OutBuff: TKDT256DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT256DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT256DS_Node);
    procedure PrintBuffer;

    class function KDT256DSVec(const s: string): TKDT256DS_Vec; overload;
    class function KDT256DSVec(const v: TKDT256DS_Vec): string; overload;
    class function KDT256DSPow(const v: TKDT256DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT256DSDistance(const v1, v2: TKDT256DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT272DS = class(TCoreClassObject)
  public type
    // code split
    TKDT272DS_Vec = packed array [0 .. KDT272DS_Axis - 1] of TKDT272DS_VecType;
    PKDT272DS_Vec = ^TKDT272DS_Vec;

    TKDT272DS_DynamicVecBuffer = array of TKDT272DS_Vec;
    PKDT272DS_DynamicVecBuffer = ^TKDT272DS_DynamicVecBuffer;

    TKDT272DS_Source = packed record
      Buff: TKDT272DS_Vec;
      index: Integer;
    end;

    PKDT272DS_Source       = ^TKDT272DS_Source;
    TKDT272DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT272DS_Source) - 1] of PKDT272DS_Source;
    PKDT272DS_SourceBuffer = ^TKDT272DS_SourceBuffer;

    TKDT272DSyanmicSourceBuffer = packed array of PKDT272DS_Source;
    PKDT272DSyanmicSourceBuffer = ^TKDT272DSyanmicSourceBuffer;

    TKDT272DSyanmicStoreBuffer = packed array of TKDT272DS_Source;
    PKDT272DSyanmicStoreBuffer = ^TKDT272DSyanmicStoreBuffer;

    PKDT272DS_Node = ^TKDT272DS_Node;

    TKDT272DS_Node = packed record
      Parent, Right, Left: PKDT272DS_Node;
      vec: PKDT272DS_Source;
    end;

    TKDT272DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT272DS_Source; const Data: Pointer);
    TKDT272DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT272DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT272DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT272DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT272DSyanmicStoreBuffer;
    KDBuff     : TKDT272DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT272DS_Node;
    TestBuff   : TKDT272DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DS_Node;
    function GetData(const index: NativeInt): PKDT272DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT272DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT272DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT272DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT272DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DS_Node; overload;
    function Search(const Buff: TKDT272DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DS_Node; overload;
    function Search(const Buff: TKDT272DS_Vec; var SearchedDistanceMin: Double): PKDT272DS_Node; overload;
    function Search(const Buff: TKDT272DS_Vec): PKDT272DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT272DS_DynamicVecBuffer; var OutBuff: TKDT272DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT272DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT272DS_Node);
    procedure PrintBuffer;

    class function KDT272DSVec(const s: string): TKDT272DS_Vec; overload;
    class function KDT272DSVec(const v: TKDT272DS_Vec): string; overload;
    class function KDT272DSPow(const v: TKDT272DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT272DSDistance(const v1, v2: TKDT272DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT272DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT288DS = class(TCoreClassObject)
  public type
    // code split
    TKDT288DS_Vec = packed array [0 .. KDT288DS_Axis - 1] of TKDT288DS_VecType;
    PKDT288DS_Vec = ^TKDT288DS_Vec;

    TKDT288DS_DynamicVecBuffer = array of TKDT288DS_Vec;
    PKDT288DS_DynamicVecBuffer = ^TKDT288DS_DynamicVecBuffer;

    TKDT288DS_Source = packed record
      Buff: TKDT288DS_Vec;
      index: Integer;
    end;

    PKDT288DS_Source       = ^TKDT288DS_Source;
    TKDT288DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT288DS_Source) - 1] of PKDT288DS_Source;
    PKDT288DS_SourceBuffer = ^TKDT288DS_SourceBuffer;

    TKDT288DSyanmicSourceBuffer = packed array of PKDT288DS_Source;
    PKDT288DSyanmicSourceBuffer = ^TKDT288DSyanmicSourceBuffer;

    TKDT288DSyanmicStoreBuffer = packed array of TKDT288DS_Source;
    PKDT288DSyanmicStoreBuffer = ^TKDT288DSyanmicStoreBuffer;

    PKDT288DS_Node = ^TKDT288DS_Node;

    TKDT288DS_Node = packed record
      Parent, Right, Left: PKDT288DS_Node;
      vec: PKDT288DS_Source;
    end;

    TKDT288DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT288DS_Source; const Data: Pointer);
    TKDT288DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT288DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT288DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT288DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT288DSyanmicStoreBuffer;
    KDBuff     : TKDT288DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT288DS_Node;
    TestBuff   : TKDT288DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DS_Node;
    function GetData(const index: NativeInt): PKDT288DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT288DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT288DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT288DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT288DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DS_Node; overload;
    function Search(const Buff: TKDT288DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DS_Node; overload;
    function Search(const Buff: TKDT288DS_Vec; var SearchedDistanceMin: Double): PKDT288DS_Node; overload;
    function Search(const Buff: TKDT288DS_Vec): PKDT288DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT288DS_DynamicVecBuffer; var OutBuff: TKDT288DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT288DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT288DS_Node);
    procedure PrintBuffer;

    class function KDT288DSVec(const s: string): TKDT288DS_Vec; overload;
    class function KDT288DSVec(const v: TKDT288DS_Vec): string; overload;
    class function KDT288DSPow(const v: TKDT288DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT288DSDistance(const v1, v2: TKDT288DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT288DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT372DS = class(TCoreClassObject)
  public type
    // code split
    TKDT372DS_Vec = packed array [0 .. KDT372DS_Axis - 1] of TKDT372DS_VecType;
    PKDT372DS_Vec = ^TKDT372DS_Vec;

    TKDT372DS_DynamicVecBuffer = array of TKDT372DS_Vec;
    PKDT372DS_DynamicVecBuffer = ^TKDT372DS_DynamicVecBuffer;

    TKDT372DS_Source = packed record
      Buff: TKDT372DS_Vec;
      index: Integer;
    end;

    PKDT372DS_Source       = ^TKDT372DS_Source;
    TKDT372DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT372DS_Source) - 1] of PKDT372DS_Source;
    PKDT372DS_SourceBuffer = ^TKDT372DS_SourceBuffer;

    TKDT372DSyanmicSourceBuffer = packed array of PKDT372DS_Source;
    PKDT372DSyanmicSourceBuffer = ^TKDT372DSyanmicSourceBuffer;

    TKDT372DSyanmicStoreBuffer = packed array of TKDT372DS_Source;
    PKDT372DSyanmicStoreBuffer = ^TKDT372DSyanmicStoreBuffer;

    PKDT372DS_Node = ^TKDT372DS_Node;

    TKDT372DS_Node = packed record
      Parent, Right, Left: PKDT372DS_Node;
      vec: PKDT372DS_Source;
    end;

    TKDT372DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT372DS_Source; const Data: Pointer);
    TKDT372DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT372DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT372DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT372DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT372DSyanmicStoreBuffer;
    KDBuff     : TKDT372DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT372DS_Node;
    TestBuff   : TKDT372DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DS_Node;
    function GetData(const index: NativeInt): PKDT372DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT372DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT372DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT372DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT372DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DS_Node; overload;
    function Search(const Buff: TKDT372DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DS_Node; overload;
    function Search(const Buff: TKDT372DS_Vec; var SearchedDistanceMin: Double): PKDT372DS_Node; overload;
    function Search(const Buff: TKDT372DS_Vec): PKDT372DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT372DS_DynamicVecBuffer; var OutBuff: TKDT372DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT372DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT372DS_Node);
    procedure PrintBuffer;

    class function KDT372DSVec(const s: string): TKDT372DS_Vec; overload;
    class function KDT372DSVec(const v: TKDT372DS_Vec): string; overload;
    class function KDT372DSPow(const v: TKDT372DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT372DSDistance(const v1, v2: TKDT372DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT372DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT512DS = class(TCoreClassObject)
  public type
    // code split
    TKDT512DS_Vec = packed array [0 .. KDT512DS_Axis - 1] of TKDT512DS_VecType;
    PKDT512DS_Vec = ^TKDT512DS_Vec;

    TKDT512DS_DynamicVecBuffer = array of TKDT512DS_Vec;
    PKDT512DS_DynamicVecBuffer = ^TKDT512DS_DynamicVecBuffer;

    TKDT512DS_Source = packed record
      Buff: TKDT512DS_Vec;
      index: Integer;
    end;

    PKDT512DS_Source       = ^TKDT512DS_Source;
    TKDT512DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT512DS_Source) - 1] of PKDT512DS_Source;
    PKDT512DS_SourceBuffer = ^TKDT512DS_SourceBuffer;

    TKDT512DSyanmicSourceBuffer = packed array of PKDT512DS_Source;
    PKDT512DSyanmicSourceBuffer = ^TKDT512DSyanmicSourceBuffer;

    TKDT512DSyanmicStoreBuffer = packed array of TKDT512DS_Source;
    PKDT512DSyanmicStoreBuffer = ^TKDT512DSyanmicStoreBuffer;

    PKDT512DS_Node = ^TKDT512DS_Node;

    TKDT512DS_Node = packed record
      Parent, Right, Left: PKDT512DS_Node;
      vec: PKDT512DS_Source;
    end;

    TKDT512DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT512DS_Source; const Data: Pointer);
    TKDT512DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT512DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT512DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT512DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT512DSyanmicStoreBuffer;
    KDBuff     : TKDT512DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT512DS_Node;
    TestBuff   : TKDT512DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DS_Node;
    function GetData(const index: NativeInt): PKDT512DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT512DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT512DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT512DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DS_Node; overload;
    function Search(const Buff: TKDT512DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DS_Node; overload;
    function Search(const Buff: TKDT512DS_Vec; var SearchedDistanceMin: Double): PKDT512DS_Node; overload;
    function Search(const Buff: TKDT512DS_Vec): PKDT512DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT512DS_DynamicVecBuffer; var OutBuff: TKDT512DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT512DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT512DS_Node);
    procedure PrintBuffer;

    class function KDT512DSVec(const s: string): TKDT512DS_Vec; overload;
    class function KDT512DSVec(const v: TKDT512DS_Vec): string; overload;
    class function KDT512DSPow(const v: TKDT512DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT512DSDistance(const v1, v2: TKDT512DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT576DS = class(TCoreClassObject)
  public type
    // code split
    TKDT576DS_Vec = packed array [0 .. KDT576DS_Axis - 1] of TKDT576DS_VecType;
    PKDT576DS_Vec = ^TKDT576DS_Vec;

    TKDT576DS_DynamicVecBuffer = array of TKDT576DS_Vec;
    PKDT576DS_DynamicVecBuffer = ^TKDT576DS_DynamicVecBuffer;

    TKDT576DS_Source = packed record
      Buff: TKDT576DS_Vec;
      index: Integer;
    end;

    PKDT576DS_Source       = ^TKDT576DS_Source;
    TKDT576DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT576DS_Source) - 1] of PKDT576DS_Source;
    PKDT576DS_SourceBuffer = ^TKDT576DS_SourceBuffer;

    TKDT576DSyanmicSourceBuffer = packed array of PKDT576DS_Source;
    PKDT576DSyanmicSourceBuffer = ^TKDT576DSyanmicSourceBuffer;

    TKDT576DSyanmicStoreBuffer = packed array of TKDT576DS_Source;
    PKDT576DSyanmicStoreBuffer = ^TKDT576DSyanmicStoreBuffer;

    PKDT576DS_Node = ^TKDT576DS_Node;

    TKDT576DS_Node = packed record
      Parent, Right, Left: PKDT576DS_Node;
      vec: PKDT576DS_Source;
    end;

    TKDT576DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT576DS_Source; const Data: Pointer);
    TKDT576DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT576DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT576DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT576DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT576DSyanmicStoreBuffer;
    KDBuff     : TKDT576DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT576DS_Node;
    TestBuff   : TKDT576DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DS_Node;
    function GetData(const index: NativeInt): PKDT576DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT576DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT576DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT576DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT576DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DS_Node; overload;
    function Search(const Buff: TKDT576DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DS_Node; overload;
    function Search(const Buff: TKDT576DS_Vec; var SearchedDistanceMin: Double): PKDT576DS_Node; overload;
    function Search(const Buff: TKDT576DS_Vec): PKDT576DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT576DS_DynamicVecBuffer; var OutBuff: TKDT576DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT576DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT576DS_Node);
    procedure PrintBuffer;

    class function KDT576DSVec(const s: string): TKDT576DS_Vec; overload;
    class function KDT576DSVec(const v: TKDT576DS_Vec): string; overload;
    class function KDT576DSPow(const v: TKDT576DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT576DSDistance(const v1, v2: TKDT576DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT576DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT768DS = class(TCoreClassObject)
  public type
    // code split
    TKDT768DS_Vec = packed array [0 .. KDT768DS_Axis - 1] of TKDT768DS_VecType;
    PKDT768DS_Vec = ^TKDT768DS_Vec;

    TKDT768DS_DynamicVecBuffer = array of TKDT768DS_Vec;
    PKDT768DS_DynamicVecBuffer = ^TKDT768DS_DynamicVecBuffer;

    TKDT768DS_Source = packed record
      Buff: TKDT768DS_Vec;
      index: Integer;
    end;

    PKDT768DS_Source       = ^TKDT768DS_Source;
    TKDT768DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT768DS_Source) - 1] of PKDT768DS_Source;
    PKDT768DS_SourceBuffer = ^TKDT768DS_SourceBuffer;

    TKDT768DSyanmicSourceBuffer = packed array of PKDT768DS_Source;
    PKDT768DSyanmicSourceBuffer = ^TKDT768DSyanmicSourceBuffer;

    TKDT768DSyanmicStoreBuffer = packed array of TKDT768DS_Source;
    PKDT768DSyanmicStoreBuffer = ^TKDT768DSyanmicStoreBuffer;

    PKDT768DS_Node = ^TKDT768DS_Node;

    TKDT768DS_Node = packed record
      Parent, Right, Left: PKDT768DS_Node;
      vec: PKDT768DS_Source;
    end;

    TKDT768DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT768DS_Source; const Data: Pointer);
    TKDT768DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT768DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT768DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT768DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT768DSyanmicStoreBuffer;
    KDBuff     : TKDT768DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT768DS_Node;
    TestBuff   : TKDT768DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DS_Node;
    function GetData(const index: NativeInt): PKDT768DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT768DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT768DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT768DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT768DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DS_Node; overload;
    function Search(const Buff: TKDT768DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DS_Node; overload;
    function Search(const Buff: TKDT768DS_Vec; var SearchedDistanceMin: Double): PKDT768DS_Node; overload;
    function Search(const Buff: TKDT768DS_Vec): PKDT768DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT768DS_DynamicVecBuffer; var OutBuff: TKDT768DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT768DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT768DS_Node);
    procedure PrintBuffer;

    class function KDT768DSVec(const s: string): TKDT768DS_Vec; overload;
    class function KDT768DSVec(const v: TKDT768DS_Vec): string; overload;
    class function KDT768DSPow(const v: TKDT768DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT768DSDistance(const v1, v2: TKDT768DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT768DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1024DS = class(TCoreClassObject)
  public type
    // code split
    TKDT1024DS_Vec = packed array [0 .. KDT1024DS_Axis - 1] of TKDT1024DS_VecType;
    PKDT1024DS_Vec = ^TKDT1024DS_Vec;

    TKDT1024DS_DynamicVecBuffer = array of TKDT1024DS_Vec;
    PKDT1024DS_DynamicVecBuffer = ^TKDT1024DS_DynamicVecBuffer;

    TKDT1024DS_Source = packed record
      Buff: TKDT1024DS_Vec;
      index: Integer;
    end;

    PKDT1024DS_Source       = ^TKDT1024DS_Source;
    TKDT1024DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1024DS_Source) - 1] of PKDT1024DS_Source;
    PKDT1024DS_SourceBuffer = ^TKDT1024DS_SourceBuffer;

    TKDT1024DSyanmicSourceBuffer = packed array of PKDT1024DS_Source;
    PKDT1024DSyanmicSourceBuffer = ^TKDT1024DSyanmicSourceBuffer;

    TKDT1024DSyanmicStoreBuffer = packed array of TKDT1024DS_Source;
    PKDT1024DSyanmicStoreBuffer = ^TKDT1024DSyanmicStoreBuffer;

    PKDT1024DS_Node = ^TKDT1024DS_Node;

    TKDT1024DS_Node = packed record
      Parent, Right, Left: PKDT1024DS_Node;
      vec: PKDT1024DS_Source;
    end;

    TKDT1024DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1024DS_Source; const Data: Pointer);
    TKDT1024DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1024DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1024DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1024DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1024DSyanmicStoreBuffer;
    KDBuff     : TKDT1024DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1024DS_Node;
    TestBuff   : TKDT1024DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DS_Node;
    function GetData(const index: NativeInt): PKDT1024DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1024DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1024DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1024DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DS_Node; overload;
    function Search(const Buff: TKDT1024DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DS_Node; overload;
    function Search(const Buff: TKDT1024DS_Vec; var SearchedDistanceMin: Double): PKDT1024DS_Node; overload;
    function Search(const Buff: TKDT1024DS_Vec): PKDT1024DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1024DS_DynamicVecBuffer; var OutBuff: TKDT1024DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1024DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1024DS_Node);
    procedure PrintBuffer;

    class function KDT1024DSVec(const s: string): TKDT1024DS_Vec; overload;
    class function KDT1024DSVec(const v: TKDT1024DS_Vec): string; overload;
    class function KDT1024DSPow(const v: TKDT1024DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1024DSDistance(const v1, v2: TKDT1024DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1040DS = class(TCoreClassObject)
  public type
    // code split
    TKDT1040DS_Vec = packed array [0 .. KDT1040DS_Axis - 1] of TKDT1040DS_VecType;
    PKDT1040DS_Vec = ^TKDT1040DS_Vec;

    TKDT1040DS_DynamicVecBuffer = array of TKDT1040DS_Vec;
    PKDT1040DS_DynamicVecBuffer = ^TKDT1040DS_DynamicVecBuffer;

    TKDT1040DS_Source = packed record
      Buff: TKDT1040DS_Vec;
      index: Integer;
    end;

    PKDT1040DS_Source       = ^TKDT1040DS_Source;
    TKDT1040DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1040DS_Source) - 1] of PKDT1040DS_Source;
    PKDT1040DS_SourceBuffer = ^TKDT1040DS_SourceBuffer;

    TKDT1040DSyanmicSourceBuffer = packed array of PKDT1040DS_Source;
    PKDT1040DSyanmicSourceBuffer = ^TKDT1040DSyanmicSourceBuffer;

    TKDT1040DSyanmicStoreBuffer = packed array of TKDT1040DS_Source;
    PKDT1040DSyanmicStoreBuffer = ^TKDT1040DSyanmicStoreBuffer;

    PKDT1040DS_Node = ^TKDT1040DS_Node;

    TKDT1040DS_Node = packed record
      Parent, Right, Left: PKDT1040DS_Node;
      vec: PKDT1040DS_Source;
    end;

    TKDT1040DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1040DS_Source; const Data: Pointer);
    TKDT1040DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1040DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1040DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1040DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1040DSyanmicStoreBuffer;
    KDBuff     : TKDT1040DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1040DS_Node;
    TestBuff   : TKDT1040DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DS_Node;
    function GetData(const index: NativeInt): PKDT1040DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1040DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1040DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1040DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1040DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DS_Node; overload;
    function Search(const Buff: TKDT1040DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DS_Node; overload;
    function Search(const Buff: TKDT1040DS_Vec; var SearchedDistanceMin: Double): PKDT1040DS_Node; overload;
    function Search(const Buff: TKDT1040DS_Vec): PKDT1040DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1040DS_DynamicVecBuffer; var OutBuff: TKDT1040DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1040DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1040DS_Node);
    procedure PrintBuffer;

    class function KDT1040DSVec(const s: string): TKDT1040DS_Vec; overload;
    class function KDT1040DSVec(const v: TKDT1040DS_Vec): string; overload;
    class function KDT1040DSPow(const v: TKDT1040DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1040DSDistance(const v1, v2: TKDT1040DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1040DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1056DS = class(TCoreClassObject)
  public type
    // code split
    TKDT1056DS_Vec = packed array [0 .. KDT1056DS_Axis - 1] of TKDT1056DS_VecType;
    PKDT1056DS_Vec = ^TKDT1056DS_Vec;

    TKDT1056DS_DynamicVecBuffer = array of TKDT1056DS_Vec;
    PKDT1056DS_DynamicVecBuffer = ^TKDT1056DS_DynamicVecBuffer;

    TKDT1056DS_Source = packed record
      Buff: TKDT1056DS_Vec;
      index: Integer;
    end;

    PKDT1056DS_Source       = ^TKDT1056DS_Source;
    TKDT1056DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1056DS_Source) - 1] of PKDT1056DS_Source;
    PKDT1056DS_SourceBuffer = ^TKDT1056DS_SourceBuffer;

    TKDT1056DSyanmicSourceBuffer = packed array of PKDT1056DS_Source;
    PKDT1056DSyanmicSourceBuffer = ^TKDT1056DSyanmicSourceBuffer;

    TKDT1056DSyanmicStoreBuffer = packed array of TKDT1056DS_Source;
    PKDT1056DSyanmicStoreBuffer = ^TKDT1056DSyanmicStoreBuffer;

    PKDT1056DS_Node = ^TKDT1056DS_Node;

    TKDT1056DS_Node = packed record
      Parent, Right, Left: PKDT1056DS_Node;
      vec: PKDT1056DS_Source;
    end;

    TKDT1056DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1056DS_Source; const Data: Pointer);
    TKDT1056DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1056DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1056DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1056DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1056DSyanmicStoreBuffer;
    KDBuff     : TKDT1056DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1056DS_Node;
    TestBuff   : TKDT1056DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DS_Node;
    function GetData(const index: NativeInt): PKDT1056DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1056DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1056DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1056DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1056DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DS_Node; overload;
    function Search(const Buff: TKDT1056DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DS_Node; overload;
    function Search(const Buff: TKDT1056DS_Vec; var SearchedDistanceMin: Double): PKDT1056DS_Node; overload;
    function Search(const Buff: TKDT1056DS_Vec): PKDT1056DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1056DS_DynamicVecBuffer; var OutBuff: TKDT1056DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1056DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1056DS_Node);
    procedure PrintBuffer;

    class function KDT1056DSVec(const s: string): TKDT1056DS_Vec; overload;
    class function KDT1056DSVec(const v: TKDT1056DS_Vec): string; overload;
    class function KDT1056DSPow(const v: TKDT1056DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1056DSDistance(const v1, v2: TKDT1056DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1056DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1536DS = class(TCoreClassObject)
  public type
    // code split
    TKDT1536DS_Vec = packed array [0 .. KDT1536DS_Axis - 1] of TKDT1536DS_VecType;
    PKDT1536DS_Vec = ^TKDT1536DS_Vec;

    TKDT1536DS_DynamicVecBuffer = array of TKDT1536DS_Vec;
    PKDT1536DS_DynamicVecBuffer = ^TKDT1536DS_DynamicVecBuffer;

    TKDT1536DS_Source = packed record
      Buff: TKDT1536DS_Vec;
      index: Integer;
    end;

    PKDT1536DS_Source       = ^TKDT1536DS_Source;
    TKDT1536DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1536DS_Source) - 1] of PKDT1536DS_Source;
    PKDT1536DS_SourceBuffer = ^TKDT1536DS_SourceBuffer;

    TKDT1536DSyanmicSourceBuffer = packed array of PKDT1536DS_Source;
    PKDT1536DSyanmicSourceBuffer = ^TKDT1536DSyanmicSourceBuffer;

    TKDT1536DSyanmicStoreBuffer = packed array of TKDT1536DS_Source;
    PKDT1536DSyanmicStoreBuffer = ^TKDT1536DSyanmicStoreBuffer;

    PKDT1536DS_Node = ^TKDT1536DS_Node;

    TKDT1536DS_Node = packed record
      Parent, Right, Left: PKDT1536DS_Node;
      vec: PKDT1536DS_Source;
    end;

    TKDT1536DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1536DS_Source; const Data: Pointer);
    TKDT1536DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1536DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1536DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1536DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1536DSyanmicStoreBuffer;
    KDBuff     : TKDT1536DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1536DS_Node;
    TestBuff   : TKDT1536DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DS_Node;
    function GetData(const index: NativeInt): PKDT1536DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1536DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1536DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1536DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1536DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DS_Node; overload;
    function Search(const Buff: TKDT1536DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DS_Node; overload;
    function Search(const Buff: TKDT1536DS_Vec; var SearchedDistanceMin: Double): PKDT1536DS_Node; overload;
    function Search(const Buff: TKDT1536DS_Vec): PKDT1536DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1536DS_DynamicVecBuffer; var OutBuff: TKDT1536DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1536DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1536DS_Node);
    procedure PrintBuffer;

    class function KDT1536DSVec(const s: string): TKDT1536DS_Vec; overload;
    class function KDT1536DSVec(const v: TKDT1536DS_Vec): string; overload;
    class function KDT1536DSPow(const v: TKDT1536DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1536DSDistance(const v1, v2: TKDT1536DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1536DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1920DS = class(TCoreClassObject)
  public type
    // code split
    TKDT1920DS_Vec = packed array [0 .. KDT1920DS_Axis - 1] of TKDT1920DS_VecType;
    PKDT1920DS_Vec = ^TKDT1920DS_Vec;

    TKDT1920DS_DynamicVecBuffer = array of TKDT1920DS_Vec;
    PKDT1920DS_DynamicVecBuffer = ^TKDT1920DS_DynamicVecBuffer;

    TKDT1920DS_Source = packed record
      Buff: TKDT1920DS_Vec;
      index: Integer;
    end;

    PKDT1920DS_Source       = ^TKDT1920DS_Source;
    TKDT1920DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1920DS_Source) - 1] of PKDT1920DS_Source;
    PKDT1920DS_SourceBuffer = ^TKDT1920DS_SourceBuffer;

    TKDT1920DSyanmicSourceBuffer = packed array of PKDT1920DS_Source;
    PKDT1920DSyanmicSourceBuffer = ^TKDT1920DSyanmicSourceBuffer;

    TKDT1920DSyanmicStoreBuffer = packed array of TKDT1920DS_Source;
    PKDT1920DSyanmicStoreBuffer = ^TKDT1920DSyanmicStoreBuffer;

    PKDT1920DS_Node = ^TKDT1920DS_Node;

    TKDT1920DS_Node = packed record
      Parent, Right, Left: PKDT1920DS_Node;
      vec: PKDT1920DS_Source;
    end;

    TKDT1920DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1920DS_Source; const Data: Pointer);
    TKDT1920DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1920DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1920DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1920DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1920DSyanmicStoreBuffer;
    KDBuff     : TKDT1920DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1920DS_Node;
    TestBuff   : TKDT1920DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DS_Node;
    function GetData(const index: NativeInt): PKDT1920DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1920DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1920DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1920DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1920DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DS_Node; overload;
    function Search(const Buff: TKDT1920DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DS_Node; overload;
    function Search(const Buff: TKDT1920DS_Vec; var SearchedDistanceMin: Double): PKDT1920DS_Node; overload;
    function Search(const Buff: TKDT1920DS_Vec): PKDT1920DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1920DS_DynamicVecBuffer; var OutBuff: TKDT1920DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1920DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1920DS_Node);
    procedure PrintBuffer;

    class function KDT1920DSVec(const s: string): TKDT1920DS_Vec; overload;
    class function KDT1920DSVec(const v: TKDT1920DS_Vec): string; overload;
    class function KDT1920DSPow(const v: TKDT1920DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1920DSDistance(const v1, v2: TKDT1920DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1920DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1980DS = class(TCoreClassObject)
  public type
    // code split
    TKDT1980DS_Vec = packed array [0 .. KDT1980DS_Axis - 1] of TKDT1980DS_VecType;
    PKDT1980DS_Vec = ^TKDT1980DS_Vec;

    TKDT1980DS_DynamicVecBuffer = array of TKDT1980DS_Vec;
    PKDT1980DS_DynamicVecBuffer = ^TKDT1980DS_DynamicVecBuffer;

    TKDT1980DS_Source = packed record
      Buff: TKDT1980DS_Vec;
      index: Integer;
    end;

    PKDT1980DS_Source       = ^TKDT1980DS_Source;
    TKDT1980DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1980DS_Source) - 1] of PKDT1980DS_Source;
    PKDT1980DS_SourceBuffer = ^TKDT1980DS_SourceBuffer;

    TKDT1980DSyanmicSourceBuffer = packed array of PKDT1980DS_Source;
    PKDT1980DSyanmicSourceBuffer = ^TKDT1980DSyanmicSourceBuffer;

    TKDT1980DSyanmicStoreBuffer = packed array of TKDT1980DS_Source;
    PKDT1980DSyanmicStoreBuffer = ^TKDT1980DSyanmicStoreBuffer;

    PKDT1980DS_Node = ^TKDT1980DS_Node;

    TKDT1980DS_Node = packed record
      Parent, Right, Left: PKDT1980DS_Node;
      vec: PKDT1980DS_Source;
    end;

    TKDT1980DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1980DS_Source; const Data: Pointer);
    TKDT1980DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1980DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1980DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1980DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1980DSyanmicStoreBuffer;
    KDBuff     : TKDT1980DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1980DS_Node;
    TestBuff   : TKDT1980DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DS_Node;
    function GetData(const index: NativeInt): PKDT1980DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1980DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1980DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1980DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1980DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DS_Node; overload;
    function Search(const Buff: TKDT1980DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DS_Node; overload;
    function Search(const Buff: TKDT1980DS_Vec; var SearchedDistanceMin: Double): PKDT1980DS_Node; overload;
    function Search(const Buff: TKDT1980DS_Vec): PKDT1980DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1980DS_DynamicVecBuffer; var OutBuff: TKDT1980DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1980DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1980DS_Node);
    procedure PrintBuffer;

    class function KDT1980DSVec(const s: string): TKDT1980DS_Vec; overload;
    class function KDT1980DSVec(const v: TKDT1980DS_Vec): string; overload;
    class function KDT1980DSPow(const v: TKDT1980DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1980DSDistance(const v1, v2: TKDT1980DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1980DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT2048DS = class(TCoreClassObject)
  public type
    // code split
    TKDT2048DS_Vec = packed array [0 .. KDT2048DS_Axis - 1] of TKDT2048DS_VecType;
    PKDT2048DS_Vec = ^TKDT2048DS_Vec;

    TKDT2048DS_DynamicVecBuffer = array of TKDT2048DS_Vec;
    PKDT2048DS_DynamicVecBuffer = ^TKDT2048DS_DynamicVecBuffer;

    TKDT2048DS_Source = packed record
      Buff: TKDT2048DS_Vec;
      index: Integer;
    end;

    PKDT2048DS_Source       = ^TKDT2048DS_Source;
    TKDT2048DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT2048DS_Source) - 1] of PKDT2048DS_Source;
    PKDT2048DS_SourceBuffer = ^TKDT2048DS_SourceBuffer;

    TKDT2048DSyanmicSourceBuffer = packed array of PKDT2048DS_Source;
    PKDT2048DSyanmicSourceBuffer = ^TKDT2048DSyanmicSourceBuffer;

    TKDT2048DSyanmicStoreBuffer = packed array of TKDT2048DS_Source;
    PKDT2048DSyanmicStoreBuffer = ^TKDT2048DSyanmicStoreBuffer;

    PKDT2048DS_Node = ^TKDT2048DS_Node;

    TKDT2048DS_Node = packed record
      Parent, Right, Left: PKDT2048DS_Node;
      vec: PKDT2048DS_Source;
    end;

    TKDT2048DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT2048DS_Source; const Data: Pointer);
    TKDT2048DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT2048DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT2048DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT2048DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT2048DSyanmicStoreBuffer;
    KDBuff     : TKDT2048DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2048DS_Node;
    TestBuff   : TKDT2048DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DS_Node;
    function GetData(const index: NativeInt): PKDT2048DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2048DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2048DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT2048DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2048DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DS_Node; overload;
    function Search(const Buff: TKDT2048DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DS_Node; overload;
    function Search(const Buff: TKDT2048DS_Vec; var SearchedDistanceMin: Double): PKDT2048DS_Node; overload;
    function Search(const Buff: TKDT2048DS_Vec): PKDT2048DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2048DS_DynamicVecBuffer; var OutBuff: TKDT2048DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT2048DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT2048DS_Node);
    procedure PrintBuffer;

    class function KDT2048DSVec(const s: string): TKDT2048DS_Vec; overload;
    class function KDT2048DSVec(const v: TKDT2048DS_Vec): string; overload;
    class function KDT2048DSPow(const v: TKDT2048DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT2048DSDistance(const v1, v2: TKDT2048DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2048DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3072DS = class(TCoreClassObject)
  public type
    // code split
    TKDT3072DS_Vec = packed array [0 .. KDT3072DS_Axis - 1] of TKDT3072DS_VecType;
    PKDT3072DS_Vec = ^TKDT3072DS_Vec;

    TKDT3072DS_DynamicVecBuffer = array of TKDT3072DS_Vec;
    PKDT3072DS_DynamicVecBuffer = ^TKDT3072DS_DynamicVecBuffer;

    TKDT3072DS_Source = packed record
      Buff: TKDT3072DS_Vec;
      index: Integer;
    end;

    PKDT3072DS_Source       = ^TKDT3072DS_Source;
    TKDT3072DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT3072DS_Source) - 1] of PKDT3072DS_Source;
    PKDT3072DS_SourceBuffer = ^TKDT3072DS_SourceBuffer;

    TKDT3072DSyanmicSourceBuffer = packed array of PKDT3072DS_Source;
    PKDT3072DSyanmicSourceBuffer = ^TKDT3072DSyanmicSourceBuffer;

    TKDT3072DSyanmicStoreBuffer = packed array of TKDT3072DS_Source;
    PKDT3072DSyanmicStoreBuffer = ^TKDT3072DSyanmicStoreBuffer;

    PKDT3072DS_Node = ^TKDT3072DS_Node;

    TKDT3072DS_Node = packed record
      Parent, Right, Left: PKDT3072DS_Node;
      vec: PKDT3072DS_Source;
    end;

    TKDT3072DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3072DS_Source; const Data: Pointer);
    TKDT3072DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3072DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3072DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3072DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3072DSyanmicStoreBuffer;
    KDBuff     : TKDT3072DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3072DS_Node;
    TestBuff   : TKDT3072DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DS_Node;
    function GetData(const index: NativeInt): PKDT3072DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3072DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3072DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3072DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3072DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DS_Node; overload;
    function Search(const Buff: TKDT3072DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DS_Node; overload;
    function Search(const Buff: TKDT3072DS_Vec; var SearchedDistanceMin: Double): PKDT3072DS_Node; overload;
    function Search(const Buff: TKDT3072DS_Vec): PKDT3072DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3072DS_DynamicVecBuffer; var OutBuff: TKDT3072DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3072DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3072DS_Node);
    procedure PrintBuffer;

    class function KDT3072DSVec(const s: string): TKDT3072DS_Vec; overload;
    class function KDT3072DSVec(const v: TKDT3072DS_Vec): string; overload;
    class function KDT3072DSPow(const v: TKDT3072DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3072DSDistance(const v1, v2: TKDT3072DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3072DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3088DS = class(TCoreClassObject)
  public type
    // code split
    TKDT3088DS_Vec = packed array [0 .. KDT3088DS_Axis - 1] of TKDT3088DS_VecType;
    PKDT3088DS_Vec = ^TKDT3088DS_Vec;

    TKDT3088DS_DynamicVecBuffer = array of TKDT3088DS_Vec;
    PKDT3088DS_DynamicVecBuffer = ^TKDT3088DS_DynamicVecBuffer;

    TKDT3088DS_Source = packed record
      Buff: TKDT3088DS_Vec;
      index: Integer;
    end;

    PKDT3088DS_Source       = ^TKDT3088DS_Source;
    TKDT3088DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT3088DS_Source) - 1] of PKDT3088DS_Source;
    PKDT3088DS_SourceBuffer = ^TKDT3088DS_SourceBuffer;

    TKDT3088DSyanmicSourceBuffer = packed array of PKDT3088DS_Source;
    PKDT3088DSyanmicSourceBuffer = ^TKDT3088DSyanmicSourceBuffer;

    TKDT3088DSyanmicStoreBuffer = packed array of TKDT3088DS_Source;
    PKDT3088DSyanmicStoreBuffer = ^TKDT3088DSyanmicStoreBuffer;

    PKDT3088DS_Node = ^TKDT3088DS_Node;

    TKDT3088DS_Node = packed record
      Parent, Right, Left: PKDT3088DS_Node;
      vec: PKDT3088DS_Source;
    end;

    TKDT3088DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3088DS_Source; const Data: Pointer);
    TKDT3088DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3088DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3088DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3088DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3088DSyanmicStoreBuffer;
    KDBuff     : TKDT3088DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3088DS_Node;
    TestBuff   : TKDT3088DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DS_Node;
    function GetData(const index: NativeInt): PKDT3088DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3088DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3088DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3088DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3088DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DS_Node; overload;
    function Search(const Buff: TKDT3088DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DS_Node; overload;
    function Search(const Buff: TKDT3088DS_Vec; var SearchedDistanceMin: Double): PKDT3088DS_Node; overload;
    function Search(const Buff: TKDT3088DS_Vec): PKDT3088DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3088DS_DynamicVecBuffer; var OutBuff: TKDT3088DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3088DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3088DS_Node);
    procedure PrintBuffer;

    class function KDT3088DSVec(const s: string): TKDT3088DS_Vec; overload;
    class function KDT3088DSVec(const v: TKDT3088DS_Vec): string; overload;
    class function KDT3088DSPow(const v: TKDT3088DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3088DSDistance(const v1, v2: TKDT3088DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3088DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3104DS = class(TCoreClassObject)
  public type
    // code split
    TKDT3104DS_Vec = packed array [0 .. KDT3104DS_Axis - 1] of TKDT3104DS_VecType;
    PKDT3104DS_Vec = ^TKDT3104DS_Vec;

    TKDT3104DS_DynamicVecBuffer = array of TKDT3104DS_Vec;
    PKDT3104DS_DynamicVecBuffer = ^TKDT3104DS_DynamicVecBuffer;

    TKDT3104DS_Source = packed record
      Buff: TKDT3104DS_Vec;
      index: Integer;
    end;

    PKDT3104DS_Source       = ^TKDT3104DS_Source;
    TKDT3104DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT3104DS_Source) - 1] of PKDT3104DS_Source;
    PKDT3104DS_SourceBuffer = ^TKDT3104DS_SourceBuffer;

    TKDT3104DSyanmicSourceBuffer = packed array of PKDT3104DS_Source;
    PKDT3104DSyanmicSourceBuffer = ^TKDT3104DSyanmicSourceBuffer;

    TKDT3104DSyanmicStoreBuffer = packed array of TKDT3104DS_Source;
    PKDT3104DSyanmicStoreBuffer = ^TKDT3104DSyanmicStoreBuffer;

    PKDT3104DS_Node = ^TKDT3104DS_Node;

    TKDT3104DS_Node = packed record
      Parent, Right, Left: PKDT3104DS_Node;
      vec: PKDT3104DS_Source;
    end;

    TKDT3104DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3104DS_Source; const Data: Pointer);
    TKDT3104DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3104DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3104DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3104DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3104DSyanmicStoreBuffer;
    KDBuff     : TKDT3104DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3104DS_Node;
    TestBuff   : TKDT3104DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DS_Node;
    function GetData(const index: NativeInt): PKDT3104DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3104DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3104DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3104DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3104DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DS_Node; overload;
    function Search(const Buff: TKDT3104DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DS_Node; overload;
    function Search(const Buff: TKDT3104DS_Vec; var SearchedDistanceMin: Double): PKDT3104DS_Node; overload;
    function Search(const Buff: TKDT3104DS_Vec): PKDT3104DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3104DS_DynamicVecBuffer; var OutBuff: TKDT3104DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3104DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3104DS_Node);
    procedure PrintBuffer;

    class function KDT3104DSVec(const s: string): TKDT3104DS_Vec; overload;
    class function KDT3104DSVec(const v: TKDT3104DS_Vec): string; overload;
    class function KDT3104DSPow(const v: TKDT3104DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3104DSDistance(const v1, v2: TKDT3104DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3104DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT4096DS = class(TCoreClassObject)
  public type
    // code split
    TKDT4096DS_Vec = packed array [0 .. KDT4096DS_Axis - 1] of TKDT4096DS_VecType;
    PKDT4096DS_Vec = ^TKDT4096DS_Vec;

    TKDT4096DS_DynamicVecBuffer = array of TKDT4096DS_Vec;
    PKDT4096DS_DynamicVecBuffer = ^TKDT4096DS_DynamicVecBuffer;

    TKDT4096DS_Source = packed record
      Buff: TKDT4096DS_Vec;
      index: Integer;
    end;

    PKDT4096DS_Source       = ^TKDT4096DS_Source;
    TKDT4096DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT4096DS_Source) - 1] of PKDT4096DS_Source;
    PKDT4096DS_SourceBuffer = ^TKDT4096DS_SourceBuffer;

    TKDT4096DSyanmicSourceBuffer = packed array of PKDT4096DS_Source;
    PKDT4096DSyanmicSourceBuffer = ^TKDT4096DSyanmicSourceBuffer;

    TKDT4096DSyanmicStoreBuffer = packed array of TKDT4096DS_Source;
    PKDT4096DSyanmicStoreBuffer = ^TKDT4096DSyanmicStoreBuffer;

    PKDT4096DS_Node = ^TKDT4096DS_Node;

    TKDT4096DS_Node = packed record
      Parent, Right, Left: PKDT4096DS_Node;
      vec: PKDT4096DS_Source;
    end;

    TKDT4096DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT4096DS_Source; const Data: Pointer);
    TKDT4096DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT4096DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT4096DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT4096DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT4096DSyanmicStoreBuffer;
    KDBuff     : TKDT4096DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4096DS_Node;
    TestBuff   : TKDT4096DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DS_Node;
    function GetData(const index: NativeInt): PKDT4096DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4096DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4096DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT4096DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4096DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DS_Node; overload;
    function Search(const Buff: TKDT4096DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DS_Node; overload;
    function Search(const Buff: TKDT4096DS_Vec; var SearchedDistanceMin: Double): PKDT4096DS_Node; overload;
    function Search(const Buff: TKDT4096DS_Vec): PKDT4096DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4096DS_DynamicVecBuffer; var OutBuff: TKDT4096DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT4096DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT4096DS_Node);
    procedure PrintBuffer;

    class function KDT4096DSVec(const s: string): TKDT4096DS_Vec; overload;
    class function KDT4096DSVec(const v: TKDT4096DS_Vec): string; overload;
    class function KDT4096DSPow(const v: TKDT4096DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT4096DSDistance(const v1, v2: TKDT4096DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4096DS_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT8192DS = class(TCoreClassObject)
  public type
    // code split
    TKDT8192DS_Vec = packed array [0 .. KDT8192DS_Axis - 1] of TKDT8192DS_VecType;
    PKDT8192DS_Vec = ^TKDT8192DS_Vec;

    TKDT8192DS_DynamicVecBuffer = array of TKDT8192DS_Vec;
    PKDT8192DS_DynamicVecBuffer = ^TKDT8192DS_DynamicVecBuffer;

    TKDT8192DS_Source = packed record
      Buff: TKDT8192DS_Vec;
      index: Integer;
    end;

    PKDT8192DS_Source       = ^TKDT8192DS_Source;
    TKDT8192DS_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT8192DS_Source) - 1] of PKDT8192DS_Source;
    PKDT8192DS_SourceBuffer = ^TKDT8192DS_SourceBuffer;

    TKDT8192DSyanmicSourceBuffer = packed array of PKDT8192DS_Source;
    PKDT8192DSyanmicSourceBuffer = ^TKDT8192DSyanmicSourceBuffer;

    TKDT8192DSyanmicStoreBuffer = packed array of TKDT8192DS_Source;
    PKDT8192DSyanmicStoreBuffer = ^TKDT8192DSyanmicStoreBuffer;

    PKDT8192DS_Node = ^TKDT8192DS_Node;

    TKDT8192DS_Node = packed record
      Parent, Right, Left: PKDT8192DS_Node;
      vec: PKDT8192DS_Source;
    end;

    TKDT8192DS_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT8192DS_Source; const Data: Pointer);
    TKDT8192DS_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT8192DS_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT8192DS_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT8192DS_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT8192DSyanmicStoreBuffer;
    KDBuff     : TKDT8192DSyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8192DS_Node;
    TestBuff   : TKDT8192DS_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DS_Node;
    function GetData(const index: NativeInt): PKDT8192DS_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8192DS_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8192DSyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT8192DS_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DS_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8192DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DS_Node; overload;
    function Search(const Buff: TKDT8192DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DS_Node; overload;
    function Search(const Buff: TKDT8192DS_Vec; var SearchedDistanceMin: Double): PKDT8192DS_Node; overload;
    function Search(const Buff: TKDT8192DS_Vec): PKDT8192DS_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8192DS_DynamicVecBuffer; var OutBuff: TKDT8192DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT8192DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT8192DS_Node);
    procedure PrintBuffer;

    class function KDT8192DSVec(const s: string): TKDT8192DS_Vec; overload;
    class function KDT8192DSVec(const v: TKDT8192DS_Vec): string; overload;
    class function KDT8192DSPow(const v: TKDT8192DS_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT8192DSDistance(const v1, v2: TKDT8192DS_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8192DS_Source; const Data: Pointer);
    class procedure Test;
  end;






procedure Test_All;



implementation

uses
  {$IFDEF FPC}
  mtprocs,
  {$ELSE FPC}
  Threading,
  {$ENDIF FPC}
  PascalStrings, TextParsing, UnicodeMixedLib, DoStatusIO;





const
  SaveToken = $33;



function TKDT1DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DS_Node;
  function SortCompare(const p1, p2: PKDT1DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1DS_SourceBuffer;
  dynBuff  : PKDT1DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DS.GetData(const index: NativeInt): PKDT1DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DS.StoreBuffPtr: PKDT1DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1DS.BuildKDTreeWithCluster(const inBuff: TKDT1DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DS.BuildKDTreeWithCluster(const inBuff: TKDT1DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DS_BuildCall);
var
  TempStoreBuff: TKDT1DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DS_BuildMethod);
var
  TempStoreBuff: TKDT1DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DS_BuildProc);
var
  TempStoreBuff: TKDT1DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1DS.Search(const Buff: TKDT1DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DS_Node;

var
  NearestNeighbour: PKDT1DS_Node;

  function FindParentNode(const BuffPtr: PKDT1DS_Vec; NodePtr: PKDT1DS_Node): PKDT1DS_Node;
  var
    Next       : PKDT1DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DS_Node; const BuffPtr: PKDT1DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1DS_Vec; const p1, p2: PKDT1DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DS_Node(NearestNodes[0]);
    end;
end;

function TKDT1DS.Search(const Buff: TKDT1DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DS.Search(const Buff: TKDT1DS_Vec; var SearchedDistanceMin: Double): PKDT1DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DS.Search(const Buff: TKDT1DS_Vec): PKDT1DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1DS.Search(const inBuff: TKDT1DS_DynamicVecBuffer; var OutBuff: TKDT1DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DS_DynamicVecBuffer;
  outBuffPtr : PKDT1DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DS.Search(const inBuff: TKDT1DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1DS_Source));
end;

procedure TKDT1DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DS.PrintNodeTree(const NodePtr: PKDT1DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1DS.KDT1DSVec(const s: string): TKDT1DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1DS.KDT1DSVec(const v: TKDT1DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1DS.KDT1DSPow(const v: TKDT1DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1DS.KDT1DSDistance(const v1, v2: TKDT1DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1DS_Axis - 1 do
      Result := Result + KDT1DSPow(v2[i] - v1[i]);
end;

procedure TKDT1DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1DS.Test;
var
  TKDT1DS_Test    : TKDT1DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1DS_Test := TKDT1DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT1DS_Test.TestBuff) - 1 do
    for j := 0 to KDT1DS_Axis - 1 do
        TKDT1DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1DS_Test.TestBuff), length(TKDT1DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1DS_Test.BuildKDTreeM(length(TKDT1DS_Test.TestBuff), nil, @TKDT1DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1DS_Test.BuildKDTreeM(length(TKDT1DS_Test.TestBuff), nil, TKDT1DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1DS_Test.TestBuff));
  TKDT1DS_Test.Search(TKDT1DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1DSDistance(TKDT1DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1DS_Test.Clear;
  { kMean test }
  TKDT1DS_Test.BuildKDTreeWithCluster(TKDT1DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1DS_Test.Search(TKDT1DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1DS_Test);
end;


function TKDT2DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DS_Node;
  function SortCompare(const p1, p2: PKDT2DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2DS_SourceBuffer;
  dynBuff  : PKDT2DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT2DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DS.GetData(const index: NativeInt): PKDT2DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DS.StoreBuffPtr: PKDT2DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2DS.BuildKDTreeWithCluster(const inBuff: TKDT2DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT2DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT2DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT2DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DS.BuildKDTreeWithCluster(const inBuff: TKDT2DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DS_BuildCall);
var
  TempStoreBuff: TKDT2DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DS_BuildMethod);
var
  TempStoreBuff: TKDT2DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DS_BuildProc);
var
  TempStoreBuff: TKDT2DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT2DS.Search(const Buff: TKDT2DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DS_Node;

var
  NearestNeighbour: PKDT2DS_Node;

  function FindParentNode(const BuffPtr: PKDT2DS_Vec; NodePtr: PKDT2DS_Node): PKDT2DS_Node;
  var
    Next       : PKDT2DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT2DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DS_Node; const BuffPtr: PKDT2DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT2DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2DS_Vec; const p1, p2: PKDT2DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DS_Node(NearestNodes[0]);
    end;
end;

function TKDT2DS.Search(const Buff: TKDT2DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DS.Search(const Buff: TKDT2DS_Vec; var SearchedDistanceMin: Double): PKDT2DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DS.Search(const Buff: TKDT2DS_Vec): PKDT2DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2DS.Search(const inBuff: TKDT2DS_DynamicVecBuffer; var OutBuff: TKDT2DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DS_DynamicVecBuffer;
  outBuffPtr : PKDT2DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DS.Search(const inBuff: TKDT2DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT2DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2DS_Source));
end;

procedure TKDT2DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT2DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DS.PrintNodeTree(const NodePtr: PKDT2DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT2DS.KDT2DSVec(const s: string): TKDT2DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT2DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT2DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT2DS.KDT2DSVec(const v: TKDT2DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT2DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT2DS.KDT2DSPow(const v: TKDT2DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT2DS.KDT2DSDistance(const v1, v2: TKDT2DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT2DS_Axis - 1 do
      Result := Result + KDT2DSPow(v2[i] - v1[i]);
end;

procedure TKDT2DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2DS.Test;
var
  TKDT2DS_Test    : TKDT2DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2DS_Test := TKDT2DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT2DS_Test.TestBuff) - 1 do
    for j := 0 to KDT2DS_Axis - 1 do
        TKDT2DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2DS_Test.TestBuff), length(TKDT2DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2DS_Test.BuildKDTreeM(length(TKDT2DS_Test.TestBuff), nil, @TKDT2DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2DS_Test.BuildKDTreeM(length(TKDT2DS_Test.TestBuff), nil, TKDT2DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2DS_Test.TestBuff));
  TKDT2DS_Test.Search(TKDT2DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2DSDistance(TKDT2DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2DS_Test.Clear;
  { kMean test }
  TKDT2DS_Test.BuildKDTreeWithCluster(TKDT2DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2DS_Test.Search(TKDT2DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2DS_Test);
end;


function TKDT3DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DS_Node;
  function SortCompare(const p1, p2: PKDT3DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3DS_SourceBuffer;
  dynBuff  : PKDT3DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DS.GetData(const index: NativeInt): PKDT3DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DS.StoreBuffPtr: PKDT3DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3DS.BuildKDTreeWithCluster(const inBuff: TKDT3DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DS.BuildKDTreeWithCluster(const inBuff: TKDT3DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DS_BuildCall);
var
  TempStoreBuff: TKDT3DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DS_BuildMethod);
var
  TempStoreBuff: TKDT3DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DS_BuildProc);
var
  TempStoreBuff: TKDT3DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3DS.Search(const Buff: TKDT3DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DS_Node;

var
  NearestNeighbour: PKDT3DS_Node;

  function FindParentNode(const BuffPtr: PKDT3DS_Vec; NodePtr: PKDT3DS_Node): PKDT3DS_Node;
  var
    Next       : PKDT3DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DS_Node; const BuffPtr: PKDT3DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3DS_Vec; const p1, p2: PKDT3DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DS_Node(NearestNodes[0]);
    end;
end;

function TKDT3DS.Search(const Buff: TKDT3DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DS.Search(const Buff: TKDT3DS_Vec; var SearchedDistanceMin: Double): PKDT3DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DS.Search(const Buff: TKDT3DS_Vec): PKDT3DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3DS.Search(const inBuff: TKDT3DS_DynamicVecBuffer; var OutBuff: TKDT3DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DS_DynamicVecBuffer;
  outBuffPtr : PKDT3DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DS.Search(const inBuff: TKDT3DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3DS_Source));
end;

procedure TKDT3DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DS.PrintNodeTree(const NodePtr: PKDT3DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3DS.KDT3DSVec(const s: string): TKDT3DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3DS.KDT3DSVec(const v: TKDT3DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3DS.KDT3DSPow(const v: TKDT3DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3DS.KDT3DSDistance(const v1, v2: TKDT3DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3DS_Axis - 1 do
      Result := Result + KDT3DSPow(v2[i] - v1[i]);
end;

procedure TKDT3DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3DS.Test;
var
  TKDT3DS_Test    : TKDT3DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3DS_Test := TKDT3DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT3DS_Test.TestBuff) - 1 do
    for j := 0 to KDT3DS_Axis - 1 do
        TKDT3DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3DS_Test.TestBuff), length(TKDT3DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3DS_Test.BuildKDTreeM(length(TKDT3DS_Test.TestBuff), nil, @TKDT3DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3DS_Test.BuildKDTreeM(length(TKDT3DS_Test.TestBuff), nil, TKDT3DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3DS_Test.TestBuff));
  TKDT3DS_Test.Search(TKDT3DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3DSDistance(TKDT3DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3DS_Test.Clear;
  { kMean test }
  TKDT3DS_Test.BuildKDTreeWithCluster(TKDT3DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3DS_Test.Search(TKDT3DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3DS_Test);
end;


function TKDT4DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DS_Node;
  function SortCompare(const p1, p2: PKDT4DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4DS_SourceBuffer;
  dynBuff  : PKDT4DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT4DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DS.GetData(const index: NativeInt): PKDT4DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DS.StoreBuffPtr: PKDT4DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4DS.BuildKDTreeWithCluster(const inBuff: TKDT4DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT4DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT4DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT4DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DS.BuildKDTreeWithCluster(const inBuff: TKDT4DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DS_BuildCall);
var
  TempStoreBuff: TKDT4DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DS_BuildMethod);
var
  TempStoreBuff: TKDT4DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DS_BuildProc);
var
  TempStoreBuff: TKDT4DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT4DS.Search(const Buff: TKDT4DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DS_Node;

var
  NearestNeighbour: PKDT4DS_Node;

  function FindParentNode(const BuffPtr: PKDT4DS_Vec; NodePtr: PKDT4DS_Node): PKDT4DS_Node;
  var
    Next       : PKDT4DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT4DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DS_Node; const BuffPtr: PKDT4DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT4DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4DS_Vec; const p1, p2: PKDT4DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DS_Node(NearestNodes[0]);
    end;
end;

function TKDT4DS.Search(const Buff: TKDT4DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DS.Search(const Buff: TKDT4DS_Vec; var SearchedDistanceMin: Double): PKDT4DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DS.Search(const Buff: TKDT4DS_Vec): PKDT4DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4DS.Search(const inBuff: TKDT4DS_DynamicVecBuffer; var OutBuff: TKDT4DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DS_DynamicVecBuffer;
  outBuffPtr : PKDT4DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DS.Search(const inBuff: TKDT4DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT4DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4DS_Source));
end;

procedure TKDT4DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT4DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DS.PrintNodeTree(const NodePtr: PKDT4DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT4DS.KDT4DSVec(const s: string): TKDT4DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT4DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT4DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT4DS.KDT4DSVec(const v: TKDT4DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT4DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT4DS.KDT4DSPow(const v: TKDT4DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT4DS.KDT4DSDistance(const v1, v2: TKDT4DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT4DS_Axis - 1 do
      Result := Result + KDT4DSPow(v2[i] - v1[i]);
end;

procedure TKDT4DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4DS.Test;
var
  TKDT4DS_Test    : TKDT4DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4DS_Test := TKDT4DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT4DS_Test.TestBuff) - 1 do
    for j := 0 to KDT4DS_Axis - 1 do
        TKDT4DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT4DS_Test.TestBuff), length(TKDT4DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4DS_Test.BuildKDTreeM(length(TKDT4DS_Test.TestBuff), nil, @TKDT4DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4DS_Test.BuildKDTreeM(length(TKDT4DS_Test.TestBuff), nil, TKDT4DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4DS_Test.TestBuff));
  TKDT4DS_Test.Search(TKDT4DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4DSDistance(TKDT4DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4DS_Test.Clear;
  { kMean test }
  TKDT4DS_Test.BuildKDTreeWithCluster(TKDT4DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4DS_Test.Search(TKDT4DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4DS_Test);
end;


function TKDT5DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DS_Node;
  function SortCompare(const p1, p2: PKDT5DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT5DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT5DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT5DS_SourceBuffer;
  dynBuff  : PKDT5DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT5DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT5DS.GetData(const index: NativeInt): PKDT5DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT5DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT5DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT5DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT5DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT5DS.StoreBuffPtr: PKDT5DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT5DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT5DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT5DS.BuildKDTreeWithCluster(const inBuff: TKDT5DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT5DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT5DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT5DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT5DS.BuildKDTreeWithCluster(const inBuff: TKDT5DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DS_BuildCall);
var
  TempStoreBuff: TKDT5DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DS_BuildMethod);
var
  TempStoreBuff: TKDT5DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DS_BuildProc);
var
  TempStoreBuff: TKDT5DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT5DS.Search(const Buff: TKDT5DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DS_Node;

var
  NearestNeighbour: PKDT5DS_Node;

  function FindParentNode(const BuffPtr: PKDT5DS_Vec; NodePtr: PKDT5DS_Node): PKDT5DS_Node;
  var
    Next       : PKDT5DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT5DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT5DS_Node; const BuffPtr: PKDT5DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT5DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT5DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT5DS_Vec; const p1, p2: PKDT5DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT5DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT5DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT5DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT5DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT5DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT5DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT5DS_Node(NearestNodes[0]);
    end;
end;

function TKDT5DS.Search(const Buff: TKDT5DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT5DS.Search(const Buff: TKDT5DS_Vec; var SearchedDistanceMin: Double): PKDT5DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT5DS.Search(const Buff: TKDT5DS_Vec): PKDT5DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT5DS.Search(const inBuff: TKDT5DS_DynamicVecBuffer; var OutBuff: TKDT5DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT5DS_DynamicVecBuffer;
  outBuffPtr : PKDT5DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT5DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT5DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DS.Search(const inBuff: TKDT5DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT5DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT5DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT5DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT5DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT5DS_Source));
end;

procedure TKDT5DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT5DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT5DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT5DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DS.PrintNodeTree(const NodePtr: PKDT5DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT5DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT5DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT5DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT5DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT5DS.KDT5DSVec(const s: string): TKDT5DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT5DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT5DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT5DS.KDT5DSVec(const v: TKDT5DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT5DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT5DS.KDT5DSPow(const v: TKDT5DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT5DS.KDT5DSDistance(const v1, v2: TKDT5DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT5DS_Axis - 1 do
      Result := Result + KDT5DSPow(v2[i] - v1[i]);
end;

procedure TKDT5DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT5DS.Test;
var
  TKDT5DS_Test    : TKDT5DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT5DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT5DS_Test := TKDT5DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT5DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT5DS_Test.TestBuff) - 1 do
    for j := 0 to KDT5DS_Axis - 1 do
        TKDT5DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT5DS_Test.TestBuff), length(TKDT5DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT5DS_Test.BuildKDTreeM(length(TKDT5DS_Test.TestBuff), nil, @TKDT5DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT5DS_Test.BuildKDTreeM(length(TKDT5DS_Test.TestBuff), nil, TKDT5DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT5DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT5DS_Test.TestBuff));
  TKDT5DS_Test.Search(TKDT5DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT5DSDistance(TKDT5DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT5DS_Test.Clear;
  { kMean test }
  TKDT5DS_Test.BuildKDTreeWithCluster(TKDT5DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT5DS_Test.Search(TKDT5DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT5DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT5DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT5DS_Test);
end;


function TKDT6DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DS_Node;
  function SortCompare(const p1, p2: PKDT6DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT6DS_SourceBuffer;
  dynBuff  : PKDT6DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT6DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DS.GetData(const index: NativeInt): PKDT6DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT6DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DS.StoreBuffPtr: PKDT6DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT6DS.BuildKDTreeWithCluster(const inBuff: TKDT6DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT6DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT6DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT6DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DS.BuildKDTreeWithCluster(const inBuff: TKDT6DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DS_BuildCall);
var
  TempStoreBuff: TKDT6DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DS_BuildMethod);
var
  TempStoreBuff: TKDT6DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DS_BuildProc);
var
  TempStoreBuff: TKDT6DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT6DS.Search(const Buff: TKDT6DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DS_Node;

var
  NearestNeighbour: PKDT6DS_Node;

  function FindParentNode(const BuffPtr: PKDT6DS_Vec; NodePtr: PKDT6DS_Node): PKDT6DS_Node;
  var
    Next       : PKDT6DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT6DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DS_Node; const BuffPtr: PKDT6DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT6DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT6DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT6DS_Vec; const p1, p2: PKDT6DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT6DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT6DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT6DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT6DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT6DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DS_Node(NearestNodes[0]);
    end;
end;

function TKDT6DS.Search(const Buff: TKDT6DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DS.Search(const Buff: TKDT6DS_Vec; var SearchedDistanceMin: Double): PKDT6DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DS.Search(const Buff: TKDT6DS_Vec): PKDT6DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT6DS.Search(const inBuff: TKDT6DS_DynamicVecBuffer; var OutBuff: TKDT6DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DS_DynamicVecBuffer;
  outBuffPtr : PKDT6DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DS.Search(const inBuff: TKDT6DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT6DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT6DS_Source));
end;

procedure TKDT6DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT6DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT6DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DS.PrintNodeTree(const NodePtr: PKDT6DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT6DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT6DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT6DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT6DS.KDT6DSVec(const s: string): TKDT6DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT6DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT6DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT6DS.KDT6DSVec(const v: TKDT6DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT6DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT6DS.KDT6DSPow(const v: TKDT6DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT6DS.KDT6DSDistance(const v1, v2: TKDT6DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT6DS_Axis - 1 do
      Result := Result + KDT6DSPow(v2[i] - v1[i]);
end;

procedure TKDT6DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT6DS.Test;
var
  TKDT6DS_Test    : TKDT6DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT6DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT6DS_Test := TKDT6DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT6DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT6DS_Test.TestBuff) - 1 do
    for j := 0 to KDT6DS_Axis - 1 do
        TKDT6DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT6DS_Test.TestBuff), length(TKDT6DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT6DS_Test.BuildKDTreeM(length(TKDT6DS_Test.TestBuff), nil, @TKDT6DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT6DS_Test.BuildKDTreeM(length(TKDT6DS_Test.TestBuff), nil, TKDT6DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT6DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT6DS_Test.TestBuff));
  TKDT6DS_Test.Search(TKDT6DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT6DSDistance(TKDT6DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT6DS_Test.Clear;
  { kMean test }
  TKDT6DS_Test.BuildKDTreeWithCluster(TKDT6DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT6DS_Test.Search(TKDT6DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT6DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT6DS_Test);
end;


function TKDT7DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DS_Node;
  function SortCompare(const p1, p2: PKDT7DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT7DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT7DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT7DS_SourceBuffer;
  dynBuff  : PKDT7DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT7DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT7DS.GetData(const index: NativeInt): PKDT7DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT7DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT7DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT7DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT7DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT7DS.StoreBuffPtr: PKDT7DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT7DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT7DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT7DS.BuildKDTreeWithCluster(const inBuff: TKDT7DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT7DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT7DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT7DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT7DS.BuildKDTreeWithCluster(const inBuff: TKDT7DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DS_BuildCall);
var
  TempStoreBuff: TKDT7DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DS_BuildMethod);
var
  TempStoreBuff: TKDT7DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DS_BuildProc);
var
  TempStoreBuff: TKDT7DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT7DS.Search(const Buff: TKDT7DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DS_Node;

var
  NearestNeighbour: PKDT7DS_Node;

  function FindParentNode(const BuffPtr: PKDT7DS_Vec; NodePtr: PKDT7DS_Node): PKDT7DS_Node;
  var
    Next       : PKDT7DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT7DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT7DS_Node; const BuffPtr: PKDT7DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT7DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT7DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT7DS_Vec; const p1, p2: PKDT7DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT7DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT7DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT7DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT7DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT7DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT7DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT7DS_Node(NearestNodes[0]);
    end;
end;

function TKDT7DS.Search(const Buff: TKDT7DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT7DS.Search(const Buff: TKDT7DS_Vec; var SearchedDistanceMin: Double): PKDT7DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT7DS.Search(const Buff: TKDT7DS_Vec): PKDT7DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT7DS.Search(const inBuff: TKDT7DS_DynamicVecBuffer; var OutBuff: TKDT7DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT7DS_DynamicVecBuffer;
  outBuffPtr : PKDT7DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT7DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT7DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DS.Search(const inBuff: TKDT7DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT7DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT7DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT7DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT7DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT7DS_Source));
end;

procedure TKDT7DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT7DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT7DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT7DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DS.PrintNodeTree(const NodePtr: PKDT7DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT7DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT7DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT7DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT7DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT7DS.KDT7DSVec(const s: string): TKDT7DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT7DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT7DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT7DS.KDT7DSVec(const v: TKDT7DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT7DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT7DS.KDT7DSPow(const v: TKDT7DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT7DS.KDT7DSDistance(const v1, v2: TKDT7DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT7DS_Axis - 1 do
      Result := Result + KDT7DSPow(v2[i] - v1[i]);
end;

procedure TKDT7DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT7DS.Test;
var
  TKDT7DS_Test    : TKDT7DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT7DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT7DS_Test := TKDT7DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT7DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT7DS_Test.TestBuff) - 1 do
    for j := 0 to KDT7DS_Axis - 1 do
        TKDT7DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT7DS_Test.TestBuff), length(TKDT7DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT7DS_Test.BuildKDTreeM(length(TKDT7DS_Test.TestBuff), nil, @TKDT7DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT7DS_Test.BuildKDTreeM(length(TKDT7DS_Test.TestBuff), nil, TKDT7DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT7DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT7DS_Test.TestBuff));
  TKDT7DS_Test.Search(TKDT7DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT7DSDistance(TKDT7DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT7DS_Test.Clear;
  { kMean test }
  TKDT7DS_Test.BuildKDTreeWithCluster(TKDT7DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT7DS_Test.Search(TKDT7DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT7DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT7DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT7DS_Test);
end;


function TKDT8DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DS_Node;
  function SortCompare(const p1, p2: PKDT8DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8DS_SourceBuffer;
  dynBuff  : PKDT8DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT8DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DS.GetData(const index: NativeInt): PKDT8DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DS.StoreBuffPtr: PKDT8DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8DS.BuildKDTreeWithCluster(const inBuff: TKDT8DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT8DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT8DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT8DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DS.BuildKDTreeWithCluster(const inBuff: TKDT8DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DS_BuildCall);
var
  TempStoreBuff: TKDT8DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DS_BuildMethod);
var
  TempStoreBuff: TKDT8DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DS_BuildProc);
var
  TempStoreBuff: TKDT8DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT8DS.Search(const Buff: TKDT8DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DS_Node;

var
  NearestNeighbour: PKDT8DS_Node;

  function FindParentNode(const BuffPtr: PKDT8DS_Vec; NodePtr: PKDT8DS_Node): PKDT8DS_Node;
  var
    Next       : PKDT8DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT8DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DS_Node; const BuffPtr: PKDT8DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT8DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8DS_Vec; const p1, p2: PKDT8DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DS_Node(NearestNodes[0]);
    end;
end;

function TKDT8DS.Search(const Buff: TKDT8DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DS.Search(const Buff: TKDT8DS_Vec; var SearchedDistanceMin: Double): PKDT8DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DS.Search(const Buff: TKDT8DS_Vec): PKDT8DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8DS.Search(const inBuff: TKDT8DS_DynamicVecBuffer; var OutBuff: TKDT8DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DS_DynamicVecBuffer;
  outBuffPtr : PKDT8DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DS.Search(const inBuff: TKDT8DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT8DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8DS_Source));
end;

procedure TKDT8DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT8DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DS.PrintNodeTree(const NodePtr: PKDT8DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT8DS.KDT8DSVec(const s: string): TKDT8DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT8DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT8DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT8DS.KDT8DSVec(const v: TKDT8DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT8DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT8DS.KDT8DSPow(const v: TKDT8DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT8DS.KDT8DSDistance(const v1, v2: TKDT8DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT8DS_Axis - 1 do
      Result := Result + KDT8DSPow(v2[i] - v1[i]);
end;

procedure TKDT8DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8DS.Test;
var
  TKDT8DS_Test    : TKDT8DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8DS_Test := TKDT8DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT8DS_Test.TestBuff) - 1 do
    for j := 0 to KDT8DS_Axis - 1 do
        TKDT8DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT8DS_Test.TestBuff), length(TKDT8DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8DS_Test.BuildKDTreeM(length(TKDT8DS_Test.TestBuff), nil, @TKDT8DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8DS_Test.BuildKDTreeM(length(TKDT8DS_Test.TestBuff), nil, TKDT8DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8DS_Test.TestBuff));
  TKDT8DS_Test.Search(TKDT8DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8DSDistance(TKDT8DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8DS_Test.Clear;
  { kMean test }
  TKDT8DS_Test.BuildKDTreeWithCluster(TKDT8DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8DS_Test.Search(TKDT8DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8DS_Test);
end;


function TKDT9DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DS_Node;
  function SortCompare(const p1, p2: PKDT9DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT9DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT9DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT9DS_SourceBuffer;
  dynBuff  : PKDT9DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT9DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT9DS.GetData(const index: NativeInt): PKDT9DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT9DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT9DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT9DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT9DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT9DS.StoreBuffPtr: PKDT9DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT9DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT9DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT9DS.BuildKDTreeWithCluster(const inBuff: TKDT9DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT9DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT9DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT9DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT9DS.BuildKDTreeWithCluster(const inBuff: TKDT9DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DS_BuildCall);
var
  TempStoreBuff: TKDT9DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DS_BuildMethod);
var
  TempStoreBuff: TKDT9DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DS_BuildProc);
var
  TempStoreBuff: TKDT9DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT9DS.Search(const Buff: TKDT9DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DS_Node;

var
  NearestNeighbour: PKDT9DS_Node;

  function FindParentNode(const BuffPtr: PKDT9DS_Vec; NodePtr: PKDT9DS_Node): PKDT9DS_Node;
  var
    Next       : PKDT9DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT9DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT9DS_Node; const BuffPtr: PKDT9DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT9DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT9DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT9DS_Vec; const p1, p2: PKDT9DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT9DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT9DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT9DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT9DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT9DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT9DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT9DS_Node(NearestNodes[0]);
    end;
end;

function TKDT9DS.Search(const Buff: TKDT9DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT9DS.Search(const Buff: TKDT9DS_Vec; var SearchedDistanceMin: Double): PKDT9DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT9DS.Search(const Buff: TKDT9DS_Vec): PKDT9DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT9DS.Search(const inBuff: TKDT9DS_DynamicVecBuffer; var OutBuff: TKDT9DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT9DS_DynamicVecBuffer;
  outBuffPtr : PKDT9DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT9DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT9DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DS.Search(const inBuff: TKDT9DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT9DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT9DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT9DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT9DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT9DS_Source));
end;

procedure TKDT9DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT9DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT9DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT9DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DS.PrintNodeTree(const NodePtr: PKDT9DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT9DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT9DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT9DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT9DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT9DS.KDT9DSVec(const s: string): TKDT9DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT9DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT9DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT9DS.KDT9DSVec(const v: TKDT9DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT9DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT9DS.KDT9DSPow(const v: TKDT9DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT9DS.KDT9DSDistance(const v1, v2: TKDT9DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT9DS_Axis - 1 do
      Result := Result + KDT9DSPow(v2[i] - v1[i]);
end;

procedure TKDT9DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT9DS.Test;
var
  TKDT9DS_Test    : TKDT9DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT9DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT9DS_Test := TKDT9DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT9DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT9DS_Test.TestBuff) - 1 do
    for j := 0 to KDT9DS_Axis - 1 do
        TKDT9DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT9DS_Test.TestBuff), length(TKDT9DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT9DS_Test.BuildKDTreeM(length(TKDT9DS_Test.TestBuff), nil, @TKDT9DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT9DS_Test.BuildKDTreeM(length(TKDT9DS_Test.TestBuff), nil, TKDT9DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT9DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT9DS_Test.TestBuff));
  TKDT9DS_Test.Search(TKDT9DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT9DSDistance(TKDT9DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT9DS_Test.Clear;
  { kMean test }
  TKDT9DS_Test.BuildKDTreeWithCluster(TKDT9DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT9DS_Test.Search(TKDT9DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT9DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT9DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT9DS_Test);
end;


function TKDT10DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DS_Node;
  function SortCompare(const p1, p2: PKDT10DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT10DS_SourceBuffer;
  dynBuff  : PKDT10DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT10DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DS.GetData(const index: NativeInt): PKDT10DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT10DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DS.StoreBuffPtr: PKDT10DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT10DS.BuildKDTreeWithCluster(const inBuff: TKDT10DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT10DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT10DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT10DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DS.BuildKDTreeWithCluster(const inBuff: TKDT10DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DS_BuildCall);
var
  TempStoreBuff: TKDT10DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DS_BuildMethod);
var
  TempStoreBuff: TKDT10DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DS_BuildProc);
var
  TempStoreBuff: TKDT10DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT10DS.Search(const Buff: TKDT10DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DS_Node;

var
  NearestNeighbour: PKDT10DS_Node;

  function FindParentNode(const BuffPtr: PKDT10DS_Vec; NodePtr: PKDT10DS_Node): PKDT10DS_Node;
  var
    Next       : PKDT10DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT10DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DS_Node; const BuffPtr: PKDT10DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT10DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT10DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT10DS_Vec; const p1, p2: PKDT10DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT10DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT10DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT10DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT10DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT10DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DS_Node(NearestNodes[0]);
    end;
end;

function TKDT10DS.Search(const Buff: TKDT10DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DS.Search(const Buff: TKDT10DS_Vec; var SearchedDistanceMin: Double): PKDT10DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DS.Search(const Buff: TKDT10DS_Vec): PKDT10DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT10DS.Search(const inBuff: TKDT10DS_DynamicVecBuffer; var OutBuff: TKDT10DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DS_DynamicVecBuffer;
  outBuffPtr : PKDT10DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DS.Search(const inBuff: TKDT10DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT10DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT10DS_Source));
end;

procedure TKDT10DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT10DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT10DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DS.PrintNodeTree(const NodePtr: PKDT10DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT10DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT10DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT10DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT10DS.KDT10DSVec(const s: string): TKDT10DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT10DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT10DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT10DS.KDT10DSVec(const v: TKDT10DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT10DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT10DS.KDT10DSPow(const v: TKDT10DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT10DS.KDT10DSDistance(const v1, v2: TKDT10DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT10DS_Axis - 1 do
      Result := Result + KDT10DSPow(v2[i] - v1[i]);
end;

procedure TKDT10DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT10DS.Test;
var
  TKDT10DS_Test    : TKDT10DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT10DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT10DS_Test := TKDT10DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT10DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT10DS_Test.TestBuff) - 1 do
    for j := 0 to KDT10DS_Axis - 1 do
        TKDT10DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT10DS_Test.TestBuff), length(TKDT10DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT10DS_Test.BuildKDTreeM(length(TKDT10DS_Test.TestBuff), nil, @TKDT10DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT10DS_Test.BuildKDTreeM(length(TKDT10DS_Test.TestBuff), nil, TKDT10DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT10DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT10DS_Test.TestBuff));
  TKDT10DS_Test.Search(TKDT10DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT10DSDistance(TKDT10DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT10DS_Test.Clear;
  { kMean test }
  TKDT10DS_Test.BuildKDTreeWithCluster(TKDT10DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT10DS_Test.Search(TKDT10DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT10DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT10DS_Test);
end;


function TKDT11DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DS_Node;
  function SortCompare(const p1, p2: PKDT11DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT11DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT11DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT11DS_SourceBuffer;
  dynBuff  : PKDT11DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT11DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT11DS.GetData(const index: NativeInt): PKDT11DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT11DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT11DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT11DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT11DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT11DS.StoreBuffPtr: PKDT11DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT11DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT11DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT11DS.BuildKDTreeWithCluster(const inBuff: TKDT11DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT11DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT11DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT11DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT11DS.BuildKDTreeWithCluster(const inBuff: TKDT11DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DS_BuildCall);
var
  TempStoreBuff: TKDT11DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DS_BuildMethod);
var
  TempStoreBuff: TKDT11DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DS_BuildProc);
var
  TempStoreBuff: TKDT11DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT11DS.Search(const Buff: TKDT11DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DS_Node;

var
  NearestNeighbour: PKDT11DS_Node;

  function FindParentNode(const BuffPtr: PKDT11DS_Vec; NodePtr: PKDT11DS_Node): PKDT11DS_Node;
  var
    Next       : PKDT11DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT11DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT11DS_Node; const BuffPtr: PKDT11DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT11DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT11DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT11DS_Vec; const p1, p2: PKDT11DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT11DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT11DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT11DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT11DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT11DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT11DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT11DS_Node(NearestNodes[0]);
    end;
end;

function TKDT11DS.Search(const Buff: TKDT11DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT11DS.Search(const Buff: TKDT11DS_Vec; var SearchedDistanceMin: Double): PKDT11DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT11DS.Search(const Buff: TKDT11DS_Vec): PKDT11DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT11DS.Search(const inBuff: TKDT11DS_DynamicVecBuffer; var OutBuff: TKDT11DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT11DS_DynamicVecBuffer;
  outBuffPtr : PKDT11DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT11DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT11DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DS.Search(const inBuff: TKDT11DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT11DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT11DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT11DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT11DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT11DS_Source));
end;

procedure TKDT11DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT11DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT11DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT11DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DS.PrintNodeTree(const NodePtr: PKDT11DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT11DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT11DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT11DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT11DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT11DS.KDT11DSVec(const s: string): TKDT11DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT11DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT11DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT11DS.KDT11DSVec(const v: TKDT11DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT11DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT11DS.KDT11DSPow(const v: TKDT11DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT11DS.KDT11DSDistance(const v1, v2: TKDT11DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT11DS_Axis - 1 do
      Result := Result + KDT11DSPow(v2[i] - v1[i]);
end;

procedure TKDT11DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT11DS.Test;
var
  TKDT11DS_Test    : TKDT11DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT11DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT11DS_Test := TKDT11DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT11DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT11DS_Test.TestBuff) - 1 do
    for j := 0 to KDT11DS_Axis - 1 do
        TKDT11DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT11DS_Test.TestBuff), length(TKDT11DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT11DS_Test.BuildKDTreeM(length(TKDT11DS_Test.TestBuff), nil, @TKDT11DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT11DS_Test.BuildKDTreeM(length(TKDT11DS_Test.TestBuff), nil, TKDT11DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT11DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT11DS_Test.TestBuff));
  TKDT11DS_Test.Search(TKDT11DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT11DSDistance(TKDT11DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT11DS_Test.Clear;
  { kMean test }
  TKDT11DS_Test.BuildKDTreeWithCluster(TKDT11DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT11DS_Test.Search(TKDT11DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT11DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT11DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT11DS_Test);
end;


function TKDT12DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DS_Node;
  function SortCompare(const p1, p2: PKDT12DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT12DS_SourceBuffer;
  dynBuff  : PKDT12DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT12DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DS.GetData(const index: NativeInt): PKDT12DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT12DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DS.StoreBuffPtr: PKDT12DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT12DS.BuildKDTreeWithCluster(const inBuff: TKDT12DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT12DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT12DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT12DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DS.BuildKDTreeWithCluster(const inBuff: TKDT12DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DS_BuildCall);
var
  TempStoreBuff: TKDT12DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DS_BuildMethod);
var
  TempStoreBuff: TKDT12DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DS_BuildProc);
var
  TempStoreBuff: TKDT12DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT12DS.Search(const Buff: TKDT12DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DS_Node;

var
  NearestNeighbour: PKDT12DS_Node;

  function FindParentNode(const BuffPtr: PKDT12DS_Vec; NodePtr: PKDT12DS_Node): PKDT12DS_Node;
  var
    Next       : PKDT12DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT12DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DS_Node; const BuffPtr: PKDT12DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT12DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT12DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT12DS_Vec; const p1, p2: PKDT12DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT12DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT12DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT12DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT12DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT12DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DS_Node(NearestNodes[0]);
    end;
end;

function TKDT12DS.Search(const Buff: TKDT12DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DS.Search(const Buff: TKDT12DS_Vec; var SearchedDistanceMin: Double): PKDT12DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DS.Search(const Buff: TKDT12DS_Vec): PKDT12DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT12DS.Search(const inBuff: TKDT12DS_DynamicVecBuffer; var OutBuff: TKDT12DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DS_DynamicVecBuffer;
  outBuffPtr : PKDT12DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DS.Search(const inBuff: TKDT12DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT12DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT12DS_Source));
end;

procedure TKDT12DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT12DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT12DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DS.PrintNodeTree(const NodePtr: PKDT12DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT12DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT12DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT12DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT12DS.KDT12DSVec(const s: string): TKDT12DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT12DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT12DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT12DS.KDT12DSVec(const v: TKDT12DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT12DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT12DS.KDT12DSPow(const v: TKDT12DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT12DS.KDT12DSDistance(const v1, v2: TKDT12DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT12DS_Axis - 1 do
      Result := Result + KDT12DSPow(v2[i] - v1[i]);
end;

procedure TKDT12DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT12DS.Test;
var
  TKDT12DS_Test    : TKDT12DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT12DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT12DS_Test := TKDT12DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT12DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT12DS_Test.TestBuff) - 1 do
    for j := 0 to KDT12DS_Axis - 1 do
        TKDT12DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT12DS_Test.TestBuff), length(TKDT12DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT12DS_Test.BuildKDTreeM(length(TKDT12DS_Test.TestBuff), nil, @TKDT12DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT12DS_Test.BuildKDTreeM(length(TKDT12DS_Test.TestBuff), nil, TKDT12DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT12DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT12DS_Test.TestBuff));
  TKDT12DS_Test.Search(TKDT12DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT12DSDistance(TKDT12DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT12DS_Test.Clear;
  { kMean test }
  TKDT12DS_Test.BuildKDTreeWithCluster(TKDT12DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT12DS_Test.Search(TKDT12DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT12DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT12DS_Test);
end;


function TKDT13DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DS_Node;
  function SortCompare(const p1, p2: PKDT13DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT13DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT13DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT13DS_SourceBuffer;
  dynBuff  : PKDT13DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT13DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT13DS.GetData(const index: NativeInt): PKDT13DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT13DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT13DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT13DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT13DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT13DS.StoreBuffPtr: PKDT13DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT13DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT13DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT13DS.BuildKDTreeWithCluster(const inBuff: TKDT13DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT13DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT13DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT13DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT13DS.BuildKDTreeWithCluster(const inBuff: TKDT13DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DS_BuildCall);
var
  TempStoreBuff: TKDT13DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DS_BuildMethod);
var
  TempStoreBuff: TKDT13DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DS_BuildProc);
var
  TempStoreBuff: TKDT13DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT13DS.Search(const Buff: TKDT13DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DS_Node;

var
  NearestNeighbour: PKDT13DS_Node;

  function FindParentNode(const BuffPtr: PKDT13DS_Vec; NodePtr: PKDT13DS_Node): PKDT13DS_Node;
  var
    Next       : PKDT13DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT13DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT13DS_Node; const BuffPtr: PKDT13DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT13DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT13DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT13DS_Vec; const p1, p2: PKDT13DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT13DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT13DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT13DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT13DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT13DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT13DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT13DS_Node(NearestNodes[0]);
    end;
end;

function TKDT13DS.Search(const Buff: TKDT13DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT13DS.Search(const Buff: TKDT13DS_Vec; var SearchedDistanceMin: Double): PKDT13DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT13DS.Search(const Buff: TKDT13DS_Vec): PKDT13DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT13DS.Search(const inBuff: TKDT13DS_DynamicVecBuffer; var OutBuff: TKDT13DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT13DS_DynamicVecBuffer;
  outBuffPtr : PKDT13DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT13DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT13DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DS.Search(const inBuff: TKDT13DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT13DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT13DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT13DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT13DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT13DS_Source));
end;

procedure TKDT13DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT13DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT13DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT13DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DS.PrintNodeTree(const NodePtr: PKDT13DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT13DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT13DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT13DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT13DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT13DS.KDT13DSVec(const s: string): TKDT13DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT13DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT13DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT13DS.KDT13DSVec(const v: TKDT13DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT13DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT13DS.KDT13DSPow(const v: TKDT13DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT13DS.KDT13DSDistance(const v1, v2: TKDT13DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT13DS_Axis - 1 do
      Result := Result + KDT13DSPow(v2[i] - v1[i]);
end;

procedure TKDT13DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT13DS.Test;
var
  TKDT13DS_Test    : TKDT13DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT13DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT13DS_Test := TKDT13DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT13DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT13DS_Test.TestBuff) - 1 do
    for j := 0 to KDT13DS_Axis - 1 do
        TKDT13DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT13DS_Test.TestBuff), length(TKDT13DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT13DS_Test.BuildKDTreeM(length(TKDT13DS_Test.TestBuff), nil, @TKDT13DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT13DS_Test.BuildKDTreeM(length(TKDT13DS_Test.TestBuff), nil, TKDT13DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT13DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT13DS_Test.TestBuff));
  TKDT13DS_Test.Search(TKDT13DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT13DSDistance(TKDT13DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT13DS_Test.Clear;
  { kMean test }
  TKDT13DS_Test.BuildKDTreeWithCluster(TKDT13DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT13DS_Test.Search(TKDT13DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT13DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT13DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT13DS_Test);
end;


function TKDT14DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DS_Node;
  function SortCompare(const p1, p2: PKDT14DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT14DS_SourceBuffer;
  dynBuff  : PKDT14DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT14DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DS.GetData(const index: NativeInt): PKDT14DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT14DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DS.StoreBuffPtr: PKDT14DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT14DS.BuildKDTreeWithCluster(const inBuff: TKDT14DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT14DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT14DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT14DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DS.BuildKDTreeWithCluster(const inBuff: TKDT14DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DS_BuildCall);
var
  TempStoreBuff: TKDT14DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DS_BuildMethod);
var
  TempStoreBuff: TKDT14DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DS_BuildProc);
var
  TempStoreBuff: TKDT14DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT14DS.Search(const Buff: TKDT14DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DS_Node;

var
  NearestNeighbour: PKDT14DS_Node;

  function FindParentNode(const BuffPtr: PKDT14DS_Vec; NodePtr: PKDT14DS_Node): PKDT14DS_Node;
  var
    Next       : PKDT14DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT14DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DS_Node; const BuffPtr: PKDT14DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT14DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT14DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT14DS_Vec; const p1, p2: PKDT14DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT14DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT14DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT14DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT14DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT14DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DS_Node(NearestNodes[0]);
    end;
end;

function TKDT14DS.Search(const Buff: TKDT14DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DS.Search(const Buff: TKDT14DS_Vec; var SearchedDistanceMin: Double): PKDT14DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DS.Search(const Buff: TKDT14DS_Vec): PKDT14DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT14DS.Search(const inBuff: TKDT14DS_DynamicVecBuffer; var OutBuff: TKDT14DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DS_DynamicVecBuffer;
  outBuffPtr : PKDT14DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DS.Search(const inBuff: TKDT14DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT14DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT14DS_Source));
end;

procedure TKDT14DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT14DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT14DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DS.PrintNodeTree(const NodePtr: PKDT14DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT14DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT14DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT14DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT14DS.KDT14DSVec(const s: string): TKDT14DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT14DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT14DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT14DS.KDT14DSVec(const v: TKDT14DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT14DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT14DS.KDT14DSPow(const v: TKDT14DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT14DS.KDT14DSDistance(const v1, v2: TKDT14DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT14DS_Axis - 1 do
      Result := Result + KDT14DSPow(v2[i] - v1[i]);
end;

procedure TKDT14DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT14DS.Test;
var
  TKDT14DS_Test    : TKDT14DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT14DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT14DS_Test := TKDT14DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT14DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT14DS_Test.TestBuff) - 1 do
    for j := 0 to KDT14DS_Axis - 1 do
        TKDT14DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT14DS_Test.TestBuff), length(TKDT14DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT14DS_Test.BuildKDTreeM(length(TKDT14DS_Test.TestBuff), nil, @TKDT14DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT14DS_Test.BuildKDTreeM(length(TKDT14DS_Test.TestBuff), nil, TKDT14DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT14DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT14DS_Test.TestBuff));
  TKDT14DS_Test.Search(TKDT14DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT14DSDistance(TKDT14DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT14DS_Test.Clear;
  { kMean test }
  TKDT14DS_Test.BuildKDTreeWithCluster(TKDT14DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT14DS_Test.Search(TKDT14DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT14DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT14DS_Test);
end;


function TKDT15DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DS_Node;
  function SortCompare(const p1, p2: PKDT15DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT15DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT15DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT15DS_SourceBuffer;
  dynBuff  : PKDT15DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT15DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT15DS.GetData(const index: NativeInt): PKDT15DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT15DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT15DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT15DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT15DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT15DS.StoreBuffPtr: PKDT15DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT15DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT15DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT15DS.BuildKDTreeWithCluster(const inBuff: TKDT15DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT15DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT15DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT15DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT15DS.BuildKDTreeWithCluster(const inBuff: TKDT15DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DS_BuildCall);
var
  TempStoreBuff: TKDT15DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DS_BuildMethod);
var
  TempStoreBuff: TKDT15DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DS_BuildProc);
var
  TempStoreBuff: TKDT15DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT15DS.Search(const Buff: TKDT15DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DS_Node;

var
  NearestNeighbour: PKDT15DS_Node;

  function FindParentNode(const BuffPtr: PKDT15DS_Vec; NodePtr: PKDT15DS_Node): PKDT15DS_Node;
  var
    Next       : PKDT15DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT15DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT15DS_Node; const BuffPtr: PKDT15DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT15DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT15DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT15DS_Vec; const p1, p2: PKDT15DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT15DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT15DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT15DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT15DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT15DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT15DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT15DS_Node(NearestNodes[0]);
    end;
end;

function TKDT15DS.Search(const Buff: TKDT15DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT15DS.Search(const Buff: TKDT15DS_Vec; var SearchedDistanceMin: Double): PKDT15DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT15DS.Search(const Buff: TKDT15DS_Vec): PKDT15DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT15DS.Search(const inBuff: TKDT15DS_DynamicVecBuffer; var OutBuff: TKDT15DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT15DS_DynamicVecBuffer;
  outBuffPtr : PKDT15DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT15DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT15DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DS.Search(const inBuff: TKDT15DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT15DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT15DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT15DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT15DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT15DS_Source));
end;

procedure TKDT15DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT15DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT15DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT15DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DS.PrintNodeTree(const NodePtr: PKDT15DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT15DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT15DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT15DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT15DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT15DS.KDT15DSVec(const s: string): TKDT15DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT15DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT15DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT15DS.KDT15DSVec(const v: TKDT15DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT15DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT15DS.KDT15DSPow(const v: TKDT15DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT15DS.KDT15DSDistance(const v1, v2: TKDT15DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT15DS_Axis - 1 do
      Result := Result + KDT15DSPow(v2[i] - v1[i]);
end;

procedure TKDT15DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT15DS.Test;
var
  TKDT15DS_Test    : TKDT15DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT15DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT15DS_Test := TKDT15DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT15DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT15DS_Test.TestBuff) - 1 do
    for j := 0 to KDT15DS_Axis - 1 do
        TKDT15DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT15DS_Test.TestBuff), length(TKDT15DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT15DS_Test.BuildKDTreeM(length(TKDT15DS_Test.TestBuff), nil, @TKDT15DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT15DS_Test.BuildKDTreeM(length(TKDT15DS_Test.TestBuff), nil, TKDT15DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT15DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT15DS_Test.TestBuff));
  TKDT15DS_Test.Search(TKDT15DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT15DSDistance(TKDT15DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT15DS_Test.Clear;
  { kMean test }
  TKDT15DS_Test.BuildKDTreeWithCluster(TKDT15DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT15DS_Test.Search(TKDT15DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT15DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT15DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT15DS_Test);
end;


function TKDT16DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DS_Node;
  function SortCompare(const p1, p2: PKDT16DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT16DS_SourceBuffer;
  dynBuff  : PKDT16DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT16DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DS.GetData(const index: NativeInt): PKDT16DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT16DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DS.StoreBuffPtr: PKDT16DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT16DS.BuildKDTreeWithCluster(const inBuff: TKDT16DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT16DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT16DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT16DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DS.BuildKDTreeWithCluster(const inBuff: TKDT16DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DS_BuildCall);
var
  TempStoreBuff: TKDT16DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DS_BuildMethod);
var
  TempStoreBuff: TKDT16DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DS_BuildProc);
var
  TempStoreBuff: TKDT16DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT16DS.Search(const Buff: TKDT16DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DS_Node;

var
  NearestNeighbour: PKDT16DS_Node;

  function FindParentNode(const BuffPtr: PKDT16DS_Vec; NodePtr: PKDT16DS_Node): PKDT16DS_Node;
  var
    Next       : PKDT16DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT16DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DS_Node; const BuffPtr: PKDT16DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT16DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT16DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT16DS_Vec; const p1, p2: PKDT16DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT16DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT16DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT16DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT16DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT16DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DS_Node(NearestNodes[0]);
    end;
end;

function TKDT16DS.Search(const Buff: TKDT16DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DS.Search(const Buff: TKDT16DS_Vec; var SearchedDistanceMin: Double): PKDT16DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DS.Search(const Buff: TKDT16DS_Vec): PKDT16DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT16DS.Search(const inBuff: TKDT16DS_DynamicVecBuffer; var OutBuff: TKDT16DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DS_DynamicVecBuffer;
  outBuffPtr : PKDT16DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DS.Search(const inBuff: TKDT16DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT16DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT16DS_Source));
end;

procedure TKDT16DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT16DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT16DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DS.PrintNodeTree(const NodePtr: PKDT16DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT16DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT16DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT16DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT16DS.KDT16DSVec(const s: string): TKDT16DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT16DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT16DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT16DS.KDT16DSVec(const v: TKDT16DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT16DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT16DS.KDT16DSPow(const v: TKDT16DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT16DS.KDT16DSDistance(const v1, v2: TKDT16DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT16DS_Axis - 1 do
      Result := Result + KDT16DSPow(v2[i] - v1[i]);
end;

procedure TKDT16DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT16DS.Test;
var
  TKDT16DS_Test    : TKDT16DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT16DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT16DS_Test := TKDT16DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT16DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT16DS_Test.TestBuff) - 1 do
    for j := 0 to KDT16DS_Axis - 1 do
        TKDT16DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT16DS_Test.TestBuff), length(TKDT16DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT16DS_Test.BuildKDTreeM(length(TKDT16DS_Test.TestBuff), nil, @TKDT16DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT16DS_Test.BuildKDTreeM(length(TKDT16DS_Test.TestBuff), nil, TKDT16DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT16DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT16DS_Test.TestBuff));
  TKDT16DS_Test.Search(TKDT16DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT16DSDistance(TKDT16DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT16DS_Test.Clear;
  { kMean test }
  TKDT16DS_Test.BuildKDTreeWithCluster(TKDT16DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT16DS_Test.Search(TKDT16DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT16DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT16DS_Test);
end;


function TKDT17DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DS_Node;
  function SortCompare(const p1, p2: PKDT17DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT17DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT17DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT17DS_SourceBuffer;
  dynBuff  : PKDT17DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT17DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT17DS.GetData(const index: NativeInt): PKDT17DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT17DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT17DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT17DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT17DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT17DS.StoreBuffPtr: PKDT17DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT17DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT17DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT17DS.BuildKDTreeWithCluster(const inBuff: TKDT17DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT17DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT17DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT17DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT17DS.BuildKDTreeWithCluster(const inBuff: TKDT17DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DS_BuildCall);
var
  TempStoreBuff: TKDT17DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DS_BuildMethod);
var
  TempStoreBuff: TKDT17DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DS_BuildProc);
var
  TempStoreBuff: TKDT17DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT17DS.Search(const Buff: TKDT17DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DS_Node;

var
  NearestNeighbour: PKDT17DS_Node;

  function FindParentNode(const BuffPtr: PKDT17DS_Vec; NodePtr: PKDT17DS_Node): PKDT17DS_Node;
  var
    Next       : PKDT17DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT17DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT17DS_Node; const BuffPtr: PKDT17DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT17DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT17DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT17DS_Vec; const p1, p2: PKDT17DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT17DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT17DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT17DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT17DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT17DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT17DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT17DS_Node(NearestNodes[0]);
    end;
end;

function TKDT17DS.Search(const Buff: TKDT17DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT17DS.Search(const Buff: TKDT17DS_Vec; var SearchedDistanceMin: Double): PKDT17DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT17DS.Search(const Buff: TKDT17DS_Vec): PKDT17DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT17DS.Search(const inBuff: TKDT17DS_DynamicVecBuffer; var OutBuff: TKDT17DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT17DS_DynamicVecBuffer;
  outBuffPtr : PKDT17DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT17DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT17DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DS.Search(const inBuff: TKDT17DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT17DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT17DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT17DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT17DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT17DS_Source));
end;

procedure TKDT17DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT17DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT17DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT17DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DS.PrintNodeTree(const NodePtr: PKDT17DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT17DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT17DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT17DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT17DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT17DS.KDT17DSVec(const s: string): TKDT17DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT17DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT17DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT17DS.KDT17DSVec(const v: TKDT17DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT17DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT17DS.KDT17DSPow(const v: TKDT17DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT17DS.KDT17DSDistance(const v1, v2: TKDT17DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT17DS_Axis - 1 do
      Result := Result + KDT17DSPow(v2[i] - v1[i]);
end;

procedure TKDT17DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT17DS.Test;
var
  TKDT17DS_Test    : TKDT17DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT17DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT17DS_Test := TKDT17DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT17DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT17DS_Test.TestBuff) - 1 do
    for j := 0 to KDT17DS_Axis - 1 do
        TKDT17DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT17DS_Test.TestBuff), length(TKDT17DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT17DS_Test.BuildKDTreeM(length(TKDT17DS_Test.TestBuff), nil, @TKDT17DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT17DS_Test.BuildKDTreeM(length(TKDT17DS_Test.TestBuff), nil, TKDT17DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT17DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT17DS_Test.TestBuff));
  TKDT17DS_Test.Search(TKDT17DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT17DSDistance(TKDT17DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT17DS_Test.Clear;
  { kMean test }
  TKDT17DS_Test.BuildKDTreeWithCluster(TKDT17DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT17DS_Test.Search(TKDT17DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT17DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT17DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT17DS_Test);
end;


function TKDT18DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DS_Node;
  function SortCompare(const p1, p2: PKDT18DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT18DS_SourceBuffer;
  dynBuff  : PKDT18DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT18DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DS.GetData(const index: NativeInt): PKDT18DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT18DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DS.StoreBuffPtr: PKDT18DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT18DS.BuildKDTreeWithCluster(const inBuff: TKDT18DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT18DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT18DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT18DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DS.BuildKDTreeWithCluster(const inBuff: TKDT18DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DS_BuildCall);
var
  TempStoreBuff: TKDT18DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DS_BuildMethod);
var
  TempStoreBuff: TKDT18DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DS_BuildProc);
var
  TempStoreBuff: TKDT18DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT18DS.Search(const Buff: TKDT18DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DS_Node;

var
  NearestNeighbour: PKDT18DS_Node;

  function FindParentNode(const BuffPtr: PKDT18DS_Vec; NodePtr: PKDT18DS_Node): PKDT18DS_Node;
  var
    Next       : PKDT18DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT18DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DS_Node; const BuffPtr: PKDT18DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT18DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT18DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT18DS_Vec; const p1, p2: PKDT18DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT18DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT18DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT18DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT18DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT18DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DS_Node(NearestNodes[0]);
    end;
end;

function TKDT18DS.Search(const Buff: TKDT18DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DS.Search(const Buff: TKDT18DS_Vec; var SearchedDistanceMin: Double): PKDT18DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DS.Search(const Buff: TKDT18DS_Vec): PKDT18DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT18DS.Search(const inBuff: TKDT18DS_DynamicVecBuffer; var OutBuff: TKDT18DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DS_DynamicVecBuffer;
  outBuffPtr : PKDT18DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DS.Search(const inBuff: TKDT18DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT18DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT18DS_Source));
end;

procedure TKDT18DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT18DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT18DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DS.PrintNodeTree(const NodePtr: PKDT18DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT18DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT18DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT18DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT18DS.KDT18DSVec(const s: string): TKDT18DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT18DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT18DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT18DS.KDT18DSVec(const v: TKDT18DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT18DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT18DS.KDT18DSPow(const v: TKDT18DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT18DS.KDT18DSDistance(const v1, v2: TKDT18DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT18DS_Axis - 1 do
      Result := Result + KDT18DSPow(v2[i] - v1[i]);
end;

procedure TKDT18DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT18DS.Test;
var
  TKDT18DS_Test    : TKDT18DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT18DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT18DS_Test := TKDT18DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT18DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT18DS_Test.TestBuff) - 1 do
    for j := 0 to KDT18DS_Axis - 1 do
        TKDT18DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT18DS_Test.TestBuff), length(TKDT18DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT18DS_Test.BuildKDTreeM(length(TKDT18DS_Test.TestBuff), nil, @TKDT18DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT18DS_Test.BuildKDTreeM(length(TKDT18DS_Test.TestBuff), nil, TKDT18DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT18DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT18DS_Test.TestBuff));
  TKDT18DS_Test.Search(TKDT18DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT18DSDistance(TKDT18DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT18DS_Test.Clear;
  { kMean test }
  TKDT18DS_Test.BuildKDTreeWithCluster(TKDT18DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT18DS_Test.Search(TKDT18DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT18DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT18DS_Test);
end;


function TKDT19DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DS_Node;
  function SortCompare(const p1, p2: PKDT19DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT19DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT19DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT19DS_SourceBuffer;
  dynBuff  : PKDT19DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT19DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT19DS.GetData(const index: NativeInt): PKDT19DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT19DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT19DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT19DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT19DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT19DS.StoreBuffPtr: PKDT19DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT19DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT19DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT19DS.BuildKDTreeWithCluster(const inBuff: TKDT19DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT19DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT19DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT19DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT19DS.BuildKDTreeWithCluster(const inBuff: TKDT19DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DS_BuildCall);
var
  TempStoreBuff: TKDT19DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DS_BuildMethod);
var
  TempStoreBuff: TKDT19DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DS_BuildProc);
var
  TempStoreBuff: TKDT19DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT19DS.Search(const Buff: TKDT19DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DS_Node;

var
  NearestNeighbour: PKDT19DS_Node;

  function FindParentNode(const BuffPtr: PKDT19DS_Vec; NodePtr: PKDT19DS_Node): PKDT19DS_Node;
  var
    Next       : PKDT19DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT19DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT19DS_Node; const BuffPtr: PKDT19DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT19DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT19DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT19DS_Vec; const p1, p2: PKDT19DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT19DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT19DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT19DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT19DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT19DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT19DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT19DS_Node(NearestNodes[0]);
    end;
end;

function TKDT19DS.Search(const Buff: TKDT19DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT19DS.Search(const Buff: TKDT19DS_Vec; var SearchedDistanceMin: Double): PKDT19DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT19DS.Search(const Buff: TKDT19DS_Vec): PKDT19DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT19DS.Search(const inBuff: TKDT19DS_DynamicVecBuffer; var OutBuff: TKDT19DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT19DS_DynamicVecBuffer;
  outBuffPtr : PKDT19DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT19DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT19DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DS.Search(const inBuff: TKDT19DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT19DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT19DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT19DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT19DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT19DS_Source));
end;

procedure TKDT19DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT19DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT19DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT19DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DS.PrintNodeTree(const NodePtr: PKDT19DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT19DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT19DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT19DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT19DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT19DS.KDT19DSVec(const s: string): TKDT19DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT19DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT19DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT19DS.KDT19DSVec(const v: TKDT19DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT19DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT19DS.KDT19DSPow(const v: TKDT19DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT19DS.KDT19DSDistance(const v1, v2: TKDT19DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT19DS_Axis - 1 do
      Result := Result + KDT19DSPow(v2[i] - v1[i]);
end;

procedure TKDT19DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT19DS.Test;
var
  TKDT19DS_Test    : TKDT19DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT19DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT19DS_Test := TKDT19DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT19DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT19DS_Test.TestBuff) - 1 do
    for j := 0 to KDT19DS_Axis - 1 do
        TKDT19DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT19DS_Test.TestBuff), length(TKDT19DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT19DS_Test.BuildKDTreeM(length(TKDT19DS_Test.TestBuff), nil, @TKDT19DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT19DS_Test.BuildKDTreeM(length(TKDT19DS_Test.TestBuff), nil, TKDT19DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT19DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT19DS_Test.TestBuff));
  TKDT19DS_Test.Search(TKDT19DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT19DSDistance(TKDT19DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT19DS_Test.Clear;
  { kMean test }
  TKDT19DS_Test.BuildKDTreeWithCluster(TKDT19DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT19DS_Test.Search(TKDT19DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT19DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT19DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT19DS_Test);
end;


function TKDT20DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DS_Node;
  function SortCompare(const p1, p2: PKDT20DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT20DS_SourceBuffer;
  dynBuff  : PKDT20DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT20DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DS.GetData(const index: NativeInt): PKDT20DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT20DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DS.StoreBuffPtr: PKDT20DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT20DS.BuildKDTreeWithCluster(const inBuff: TKDT20DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT20DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT20DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT20DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DS.BuildKDTreeWithCluster(const inBuff: TKDT20DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DS_BuildCall);
var
  TempStoreBuff: TKDT20DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DS_BuildMethod);
var
  TempStoreBuff: TKDT20DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DS_BuildProc);
var
  TempStoreBuff: TKDT20DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT20DS.Search(const Buff: TKDT20DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DS_Node;

var
  NearestNeighbour: PKDT20DS_Node;

  function FindParentNode(const BuffPtr: PKDT20DS_Vec; NodePtr: PKDT20DS_Node): PKDT20DS_Node;
  var
    Next       : PKDT20DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT20DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DS_Node; const BuffPtr: PKDT20DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT20DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT20DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT20DS_Vec; const p1, p2: PKDT20DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT20DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT20DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT20DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT20DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT20DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DS_Node(NearestNodes[0]);
    end;
end;

function TKDT20DS.Search(const Buff: TKDT20DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DS.Search(const Buff: TKDT20DS_Vec; var SearchedDistanceMin: Double): PKDT20DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DS.Search(const Buff: TKDT20DS_Vec): PKDT20DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT20DS.Search(const inBuff: TKDT20DS_DynamicVecBuffer; var OutBuff: TKDT20DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DS_DynamicVecBuffer;
  outBuffPtr : PKDT20DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DS.Search(const inBuff: TKDT20DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT20DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT20DS_Source));
end;

procedure TKDT20DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT20DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT20DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DS.PrintNodeTree(const NodePtr: PKDT20DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT20DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT20DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT20DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT20DS.KDT20DSVec(const s: string): TKDT20DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT20DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT20DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT20DS.KDT20DSVec(const v: TKDT20DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT20DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT20DS.KDT20DSPow(const v: TKDT20DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT20DS.KDT20DSDistance(const v1, v2: TKDT20DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT20DS_Axis - 1 do
      Result := Result + KDT20DSPow(v2[i] - v1[i]);
end;

procedure TKDT20DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT20DS.Test;
var
  TKDT20DS_Test    : TKDT20DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT20DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT20DS_Test := TKDT20DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT20DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT20DS_Test.TestBuff) - 1 do
    for j := 0 to KDT20DS_Axis - 1 do
        TKDT20DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT20DS_Test.TestBuff), length(TKDT20DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT20DS_Test.BuildKDTreeM(length(TKDT20DS_Test.TestBuff), nil, @TKDT20DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT20DS_Test.BuildKDTreeM(length(TKDT20DS_Test.TestBuff), nil, TKDT20DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT20DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT20DS_Test.TestBuff));
  TKDT20DS_Test.Search(TKDT20DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT20DSDistance(TKDT20DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT20DS_Test.Clear;
  { kMean test }
  TKDT20DS_Test.BuildKDTreeWithCluster(TKDT20DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT20DS_Test.Search(TKDT20DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT20DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT20DS_Test);
end;


function TKDT21DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DS_Node;
  function SortCompare(const p1, p2: PKDT21DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT21DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT21DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT21DS_SourceBuffer;
  dynBuff  : PKDT21DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT21DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT21DS.GetData(const index: NativeInt): PKDT21DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT21DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT21DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT21DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT21DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT21DS.StoreBuffPtr: PKDT21DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT21DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT21DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT21DS.BuildKDTreeWithCluster(const inBuff: TKDT21DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT21DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT21DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT21DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT21DS.BuildKDTreeWithCluster(const inBuff: TKDT21DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DS_BuildCall);
var
  TempStoreBuff: TKDT21DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DS_BuildMethod);
var
  TempStoreBuff: TKDT21DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DS_BuildProc);
var
  TempStoreBuff: TKDT21DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT21DS.Search(const Buff: TKDT21DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DS_Node;

var
  NearestNeighbour: PKDT21DS_Node;

  function FindParentNode(const BuffPtr: PKDT21DS_Vec; NodePtr: PKDT21DS_Node): PKDT21DS_Node;
  var
    Next       : PKDT21DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT21DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT21DS_Node; const BuffPtr: PKDT21DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT21DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT21DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT21DS_Vec; const p1, p2: PKDT21DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT21DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT21DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT21DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT21DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT21DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT21DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT21DS_Node(NearestNodes[0]);
    end;
end;

function TKDT21DS.Search(const Buff: TKDT21DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT21DS.Search(const Buff: TKDT21DS_Vec; var SearchedDistanceMin: Double): PKDT21DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT21DS.Search(const Buff: TKDT21DS_Vec): PKDT21DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT21DS.Search(const inBuff: TKDT21DS_DynamicVecBuffer; var OutBuff: TKDT21DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT21DS_DynamicVecBuffer;
  outBuffPtr : PKDT21DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT21DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT21DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DS.Search(const inBuff: TKDT21DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT21DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT21DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT21DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT21DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT21DS_Source));
end;

procedure TKDT21DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT21DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT21DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT21DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DS.PrintNodeTree(const NodePtr: PKDT21DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT21DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT21DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT21DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT21DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT21DS.KDT21DSVec(const s: string): TKDT21DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT21DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT21DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT21DS.KDT21DSVec(const v: TKDT21DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT21DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT21DS.KDT21DSPow(const v: TKDT21DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT21DS.KDT21DSDistance(const v1, v2: TKDT21DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT21DS_Axis - 1 do
      Result := Result + KDT21DSPow(v2[i] - v1[i]);
end;

procedure TKDT21DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT21DS.Test;
var
  TKDT21DS_Test    : TKDT21DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT21DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT21DS_Test := TKDT21DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT21DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT21DS_Test.TestBuff) - 1 do
    for j := 0 to KDT21DS_Axis - 1 do
        TKDT21DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT21DS_Test.TestBuff), length(TKDT21DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT21DS_Test.BuildKDTreeM(length(TKDT21DS_Test.TestBuff), nil, @TKDT21DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT21DS_Test.BuildKDTreeM(length(TKDT21DS_Test.TestBuff), nil, TKDT21DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT21DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT21DS_Test.TestBuff));
  TKDT21DS_Test.Search(TKDT21DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT21DSDistance(TKDT21DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT21DS_Test.Clear;
  { kMean test }
  TKDT21DS_Test.BuildKDTreeWithCluster(TKDT21DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT21DS_Test.Search(TKDT21DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT21DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT21DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT21DS_Test);
end;


function TKDT22DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DS_Node;
  function SortCompare(const p1, p2: PKDT22DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT22DS_SourceBuffer;
  dynBuff  : PKDT22DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT22DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DS.GetData(const index: NativeInt): PKDT22DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT22DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DS.StoreBuffPtr: PKDT22DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT22DS.BuildKDTreeWithCluster(const inBuff: TKDT22DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT22DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT22DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT22DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DS.BuildKDTreeWithCluster(const inBuff: TKDT22DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DS_BuildCall);
var
  TempStoreBuff: TKDT22DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DS_BuildMethod);
var
  TempStoreBuff: TKDT22DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DS_BuildProc);
var
  TempStoreBuff: TKDT22DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT22DS.Search(const Buff: TKDT22DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DS_Node;

var
  NearestNeighbour: PKDT22DS_Node;

  function FindParentNode(const BuffPtr: PKDT22DS_Vec; NodePtr: PKDT22DS_Node): PKDT22DS_Node;
  var
    Next       : PKDT22DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT22DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DS_Node; const BuffPtr: PKDT22DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT22DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT22DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT22DS_Vec; const p1, p2: PKDT22DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT22DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT22DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT22DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT22DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT22DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DS_Node(NearestNodes[0]);
    end;
end;

function TKDT22DS.Search(const Buff: TKDT22DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DS.Search(const Buff: TKDT22DS_Vec; var SearchedDistanceMin: Double): PKDT22DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DS.Search(const Buff: TKDT22DS_Vec): PKDT22DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT22DS.Search(const inBuff: TKDT22DS_DynamicVecBuffer; var OutBuff: TKDT22DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DS_DynamicVecBuffer;
  outBuffPtr : PKDT22DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DS.Search(const inBuff: TKDT22DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT22DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT22DS_Source));
end;

procedure TKDT22DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT22DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT22DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DS.PrintNodeTree(const NodePtr: PKDT22DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT22DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT22DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT22DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT22DS.KDT22DSVec(const s: string): TKDT22DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT22DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT22DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT22DS.KDT22DSVec(const v: TKDT22DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT22DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT22DS.KDT22DSPow(const v: TKDT22DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT22DS.KDT22DSDistance(const v1, v2: TKDT22DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT22DS_Axis - 1 do
      Result := Result + KDT22DSPow(v2[i] - v1[i]);
end;

procedure TKDT22DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT22DS.Test;
var
  TKDT22DS_Test    : TKDT22DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT22DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT22DS_Test := TKDT22DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT22DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT22DS_Test.TestBuff) - 1 do
    for j := 0 to KDT22DS_Axis - 1 do
        TKDT22DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT22DS_Test.TestBuff), length(TKDT22DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT22DS_Test.BuildKDTreeM(length(TKDT22DS_Test.TestBuff), nil, @TKDT22DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT22DS_Test.BuildKDTreeM(length(TKDT22DS_Test.TestBuff), nil, TKDT22DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT22DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT22DS_Test.TestBuff));
  TKDT22DS_Test.Search(TKDT22DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT22DSDistance(TKDT22DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT22DS_Test.Clear;
  { kMean test }
  TKDT22DS_Test.BuildKDTreeWithCluster(TKDT22DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT22DS_Test.Search(TKDT22DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT22DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT22DS_Test);
end;


function TKDT23DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DS_Node;
  function SortCompare(const p1, p2: PKDT23DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT23DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT23DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT23DS_SourceBuffer;
  dynBuff  : PKDT23DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT23DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT23DS.GetData(const index: NativeInt): PKDT23DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT23DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT23DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT23DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT23DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT23DS.StoreBuffPtr: PKDT23DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT23DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT23DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT23DS.BuildKDTreeWithCluster(const inBuff: TKDT23DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT23DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT23DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT23DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT23DS.BuildKDTreeWithCluster(const inBuff: TKDT23DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DS_BuildCall);
var
  TempStoreBuff: TKDT23DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DS_BuildMethod);
var
  TempStoreBuff: TKDT23DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DS_BuildProc);
var
  TempStoreBuff: TKDT23DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT23DS.Search(const Buff: TKDT23DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DS_Node;

var
  NearestNeighbour: PKDT23DS_Node;

  function FindParentNode(const BuffPtr: PKDT23DS_Vec; NodePtr: PKDT23DS_Node): PKDT23DS_Node;
  var
    Next       : PKDT23DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT23DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT23DS_Node; const BuffPtr: PKDT23DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT23DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT23DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT23DS_Vec; const p1, p2: PKDT23DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT23DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT23DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT23DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT23DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT23DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT23DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT23DS_Node(NearestNodes[0]);
    end;
end;

function TKDT23DS.Search(const Buff: TKDT23DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT23DS.Search(const Buff: TKDT23DS_Vec; var SearchedDistanceMin: Double): PKDT23DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT23DS.Search(const Buff: TKDT23DS_Vec): PKDT23DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT23DS.Search(const inBuff: TKDT23DS_DynamicVecBuffer; var OutBuff: TKDT23DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT23DS_DynamicVecBuffer;
  outBuffPtr : PKDT23DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT23DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT23DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DS.Search(const inBuff: TKDT23DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT23DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT23DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT23DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT23DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT23DS_Source));
end;

procedure TKDT23DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT23DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT23DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT23DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DS.PrintNodeTree(const NodePtr: PKDT23DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT23DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT23DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT23DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT23DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT23DS.KDT23DSVec(const s: string): TKDT23DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT23DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT23DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT23DS.KDT23DSVec(const v: TKDT23DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT23DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT23DS.KDT23DSPow(const v: TKDT23DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT23DS.KDT23DSDistance(const v1, v2: TKDT23DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT23DS_Axis - 1 do
      Result := Result + KDT23DSPow(v2[i] - v1[i]);
end;

procedure TKDT23DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT23DS.Test;
var
  TKDT23DS_Test    : TKDT23DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT23DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT23DS_Test := TKDT23DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT23DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT23DS_Test.TestBuff) - 1 do
    for j := 0 to KDT23DS_Axis - 1 do
        TKDT23DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT23DS_Test.TestBuff), length(TKDT23DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT23DS_Test.BuildKDTreeM(length(TKDT23DS_Test.TestBuff), nil, @TKDT23DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT23DS_Test.BuildKDTreeM(length(TKDT23DS_Test.TestBuff), nil, TKDT23DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT23DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT23DS_Test.TestBuff));
  TKDT23DS_Test.Search(TKDT23DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT23DSDistance(TKDT23DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT23DS_Test.Clear;
  { kMean test }
  TKDT23DS_Test.BuildKDTreeWithCluster(TKDT23DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT23DS_Test.Search(TKDT23DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT23DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT23DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT23DS_Test);
end;


function TKDT24DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DS_Node;
  function SortCompare(const p1, p2: PKDT24DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT24DS_SourceBuffer;
  dynBuff  : PKDT24DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT24DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DS.GetData(const index: NativeInt): PKDT24DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT24DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DS.StoreBuffPtr: PKDT24DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT24DS.BuildKDTreeWithCluster(const inBuff: TKDT24DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT24DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT24DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT24DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DS.BuildKDTreeWithCluster(const inBuff: TKDT24DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DS_BuildCall);
var
  TempStoreBuff: TKDT24DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DS_BuildMethod);
var
  TempStoreBuff: TKDT24DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DS_BuildProc);
var
  TempStoreBuff: TKDT24DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT24DS.Search(const Buff: TKDT24DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DS_Node;

var
  NearestNeighbour: PKDT24DS_Node;

  function FindParentNode(const BuffPtr: PKDT24DS_Vec; NodePtr: PKDT24DS_Node): PKDT24DS_Node;
  var
    Next       : PKDT24DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT24DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DS_Node; const BuffPtr: PKDT24DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT24DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT24DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT24DS_Vec; const p1, p2: PKDT24DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT24DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT24DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT24DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT24DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT24DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DS_Node(NearestNodes[0]);
    end;
end;

function TKDT24DS.Search(const Buff: TKDT24DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DS.Search(const Buff: TKDT24DS_Vec; var SearchedDistanceMin: Double): PKDT24DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DS.Search(const Buff: TKDT24DS_Vec): PKDT24DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT24DS.Search(const inBuff: TKDT24DS_DynamicVecBuffer; var OutBuff: TKDT24DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DS_DynamicVecBuffer;
  outBuffPtr : PKDT24DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DS.Search(const inBuff: TKDT24DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT24DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT24DS_Source));
end;

procedure TKDT24DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT24DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT24DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DS.PrintNodeTree(const NodePtr: PKDT24DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT24DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT24DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT24DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT24DS.KDT24DSVec(const s: string): TKDT24DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT24DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT24DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT24DS.KDT24DSVec(const v: TKDT24DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT24DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT24DS.KDT24DSPow(const v: TKDT24DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT24DS.KDT24DSDistance(const v1, v2: TKDT24DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT24DS_Axis - 1 do
      Result := Result + KDT24DSPow(v2[i] - v1[i]);
end;

procedure TKDT24DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT24DS.Test;
var
  TKDT24DS_Test    : TKDT24DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT24DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT24DS_Test := TKDT24DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT24DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT24DS_Test.TestBuff) - 1 do
    for j := 0 to KDT24DS_Axis - 1 do
        TKDT24DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT24DS_Test.TestBuff), length(TKDT24DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT24DS_Test.BuildKDTreeM(length(TKDT24DS_Test.TestBuff), nil, @TKDT24DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT24DS_Test.BuildKDTreeM(length(TKDT24DS_Test.TestBuff), nil, TKDT24DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT24DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT24DS_Test.TestBuff));
  TKDT24DS_Test.Search(TKDT24DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT24DSDistance(TKDT24DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT24DS_Test.Clear;
  { kMean test }
  TKDT24DS_Test.BuildKDTreeWithCluster(TKDT24DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT24DS_Test.Search(TKDT24DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT24DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT24DS_Test);
end;


function TKDT25DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DS_Node;
  function SortCompare(const p1, p2: PKDT25DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT25DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT25DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT25DS_SourceBuffer;
  dynBuff  : PKDT25DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT25DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT25DS.GetData(const index: NativeInt): PKDT25DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT25DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT25DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT25DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT25DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT25DS.StoreBuffPtr: PKDT25DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT25DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT25DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT25DS.BuildKDTreeWithCluster(const inBuff: TKDT25DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT25DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT25DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT25DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT25DS.BuildKDTreeWithCluster(const inBuff: TKDT25DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT25DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DS_BuildCall);
var
  TempStoreBuff: TKDT25DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DS_BuildMethod);
var
  TempStoreBuff: TKDT25DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DS_BuildProc);
var
  TempStoreBuff: TKDT25DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT25DS.Search(const Buff: TKDT25DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DS_Node;

var
  NearestNeighbour: PKDT25DS_Node;

  function FindParentNode(const BuffPtr: PKDT25DS_Vec; NodePtr: PKDT25DS_Node): PKDT25DS_Node;
  var
    Next       : PKDT25DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT25DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT25DS_Node; const BuffPtr: PKDT25DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT25DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT25DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT25DS_Vec; const p1, p2: PKDT25DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT25DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT25DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT25DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT25DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT25DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT25DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT25DS_Node(NearestNodes[0]);
    end;
end;

function TKDT25DS.Search(const Buff: TKDT25DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT25DS.Search(const Buff: TKDT25DS_Vec; var SearchedDistanceMin: Double): PKDT25DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT25DS.Search(const Buff: TKDT25DS_Vec): PKDT25DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT25DS.Search(const inBuff: TKDT25DS_DynamicVecBuffer; var OutBuff: TKDT25DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT25DS_DynamicVecBuffer;
  outBuffPtr : PKDT25DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT25DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT25DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT25DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT25DS.Search(const inBuff: TKDT25DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT25DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT25DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT25DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT25DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT25DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT25DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT25DS_Source));
end;

procedure TKDT25DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT25DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT25DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT25DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT25DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT25DS.PrintNodeTree(const NodePtr: PKDT25DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT25DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT25DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT25DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT25DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT25DS.KDT25DSVec(const s: string): TKDT25DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT25DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT25DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT25DS.KDT25DSVec(const v: TKDT25DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT25DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT25DS.KDT25DSPow(const v: TKDT25DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT25DS.KDT25DSDistance(const v1, v2: TKDT25DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT25DS_Axis - 1 do
      Result := Result + KDT25DSPow(v2[i] - v1[i]);
end;

procedure TKDT25DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT25DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT25DS.Test;
var
  TKDT25DS_Test    : TKDT25DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT25DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT25DS_Test := TKDT25DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT25DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT25DS_Test.TestBuff) - 1 do
    for j := 0 to KDT25DS_Axis - 1 do
        TKDT25DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT25DS_Test.TestBuff), length(TKDT25DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT25DS_Test.BuildKDTreeM(length(TKDT25DS_Test.TestBuff), nil, @TKDT25DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT25DS_Test.BuildKDTreeM(length(TKDT25DS_Test.TestBuff), nil, TKDT25DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT25DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT25DS_Test.TestBuff));
  TKDT25DS_Test.Search(TKDT25DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT25DSDistance(TKDT25DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT25DS_Test.Clear;
  { kMean test }
  TKDT25DS_Test.BuildKDTreeWithCluster(TKDT25DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT25DS_Test.Search(TKDT25DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT25DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT25DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT25DS_Test);
end;


function TKDT26DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DS_Node;
  function SortCompare(const p1, p2: PKDT26DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT26DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT26DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT26DS_SourceBuffer;
  dynBuff  : PKDT26DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT26DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT26DS.GetData(const index: NativeInt): PKDT26DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT26DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT26DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT26DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT26DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT26DS.StoreBuffPtr: PKDT26DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT26DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT26DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT26DS.BuildKDTreeWithCluster(const inBuff: TKDT26DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT26DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT26DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT26DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT26DS.BuildKDTreeWithCluster(const inBuff: TKDT26DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT26DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DS_BuildCall);
var
  TempStoreBuff: TKDT26DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DS_BuildMethod);
var
  TempStoreBuff: TKDT26DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DS_BuildProc);
var
  TempStoreBuff: TKDT26DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT26DS.Search(const Buff: TKDT26DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DS_Node;

var
  NearestNeighbour: PKDT26DS_Node;

  function FindParentNode(const BuffPtr: PKDT26DS_Vec; NodePtr: PKDT26DS_Node): PKDT26DS_Node;
  var
    Next       : PKDT26DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT26DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT26DS_Node; const BuffPtr: PKDT26DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT26DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT26DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT26DS_Vec; const p1, p2: PKDT26DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT26DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT26DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT26DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT26DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT26DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT26DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT26DS_Node(NearestNodes[0]);
    end;
end;

function TKDT26DS.Search(const Buff: TKDT26DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT26DS.Search(const Buff: TKDT26DS_Vec; var SearchedDistanceMin: Double): PKDT26DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT26DS.Search(const Buff: TKDT26DS_Vec): PKDT26DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT26DS.Search(const inBuff: TKDT26DS_DynamicVecBuffer; var OutBuff: TKDT26DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT26DS_DynamicVecBuffer;
  outBuffPtr : PKDT26DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT26DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT26DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT26DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT26DS.Search(const inBuff: TKDT26DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT26DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT26DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT26DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT26DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT26DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT26DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT26DS_Source));
end;

procedure TKDT26DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT26DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT26DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT26DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT26DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT26DS.PrintNodeTree(const NodePtr: PKDT26DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT26DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT26DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT26DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT26DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT26DS.KDT26DSVec(const s: string): TKDT26DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT26DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT26DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT26DS.KDT26DSVec(const v: TKDT26DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT26DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT26DS.KDT26DSPow(const v: TKDT26DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT26DS.KDT26DSDistance(const v1, v2: TKDT26DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT26DS_Axis - 1 do
      Result := Result + KDT26DSPow(v2[i] - v1[i]);
end;

procedure TKDT26DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT26DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT26DS.Test;
var
  TKDT26DS_Test    : TKDT26DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT26DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT26DS_Test := TKDT26DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT26DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT26DS_Test.TestBuff) - 1 do
    for j := 0 to KDT26DS_Axis - 1 do
        TKDT26DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT26DS_Test.TestBuff), length(TKDT26DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT26DS_Test.BuildKDTreeM(length(TKDT26DS_Test.TestBuff), nil, @TKDT26DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT26DS_Test.BuildKDTreeM(length(TKDT26DS_Test.TestBuff), nil, TKDT26DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT26DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT26DS_Test.TestBuff));
  TKDT26DS_Test.Search(TKDT26DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT26DSDistance(TKDT26DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT26DS_Test.Clear;
  { kMean test }
  TKDT26DS_Test.BuildKDTreeWithCluster(TKDT26DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT26DS_Test.Search(TKDT26DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT26DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT26DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT26DS_Test);
end;


function TKDT27DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DS_Node;
  function SortCompare(const p1, p2: PKDT27DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT27DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT27DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT27DS_SourceBuffer;
  dynBuff  : PKDT27DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT27DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT27DS.GetData(const index: NativeInt): PKDT27DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT27DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT27DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT27DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT27DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT27DS.StoreBuffPtr: PKDT27DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT27DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT27DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT27DS.BuildKDTreeWithCluster(const inBuff: TKDT27DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT27DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT27DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT27DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT27DS.BuildKDTreeWithCluster(const inBuff: TKDT27DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT27DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DS_BuildCall);
var
  TempStoreBuff: TKDT27DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DS_BuildMethod);
var
  TempStoreBuff: TKDT27DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DS_BuildProc);
var
  TempStoreBuff: TKDT27DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT27DS.Search(const Buff: TKDT27DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DS_Node;

var
  NearestNeighbour: PKDT27DS_Node;

  function FindParentNode(const BuffPtr: PKDT27DS_Vec; NodePtr: PKDT27DS_Node): PKDT27DS_Node;
  var
    Next       : PKDT27DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT27DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT27DS_Node; const BuffPtr: PKDT27DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT27DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT27DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT27DS_Vec; const p1, p2: PKDT27DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT27DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT27DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT27DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT27DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT27DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT27DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT27DS_Node(NearestNodes[0]);
    end;
end;

function TKDT27DS.Search(const Buff: TKDT27DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT27DS.Search(const Buff: TKDT27DS_Vec; var SearchedDistanceMin: Double): PKDT27DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT27DS.Search(const Buff: TKDT27DS_Vec): PKDT27DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT27DS.Search(const inBuff: TKDT27DS_DynamicVecBuffer; var OutBuff: TKDT27DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT27DS_DynamicVecBuffer;
  outBuffPtr : PKDT27DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT27DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT27DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT27DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT27DS.Search(const inBuff: TKDT27DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT27DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT27DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT27DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT27DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT27DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT27DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT27DS_Source));
end;

procedure TKDT27DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT27DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT27DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT27DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT27DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT27DS.PrintNodeTree(const NodePtr: PKDT27DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT27DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT27DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT27DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT27DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT27DS.KDT27DSVec(const s: string): TKDT27DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT27DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT27DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT27DS.KDT27DSVec(const v: TKDT27DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT27DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT27DS.KDT27DSPow(const v: TKDT27DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT27DS.KDT27DSDistance(const v1, v2: TKDT27DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT27DS_Axis - 1 do
      Result := Result + KDT27DSPow(v2[i] - v1[i]);
end;

procedure TKDT27DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT27DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT27DS.Test;
var
  TKDT27DS_Test    : TKDT27DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT27DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT27DS_Test := TKDT27DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT27DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT27DS_Test.TestBuff) - 1 do
    for j := 0 to KDT27DS_Axis - 1 do
        TKDT27DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT27DS_Test.TestBuff), length(TKDT27DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT27DS_Test.BuildKDTreeM(length(TKDT27DS_Test.TestBuff), nil, @TKDT27DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT27DS_Test.BuildKDTreeM(length(TKDT27DS_Test.TestBuff), nil, TKDT27DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT27DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT27DS_Test.TestBuff));
  TKDT27DS_Test.Search(TKDT27DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT27DSDistance(TKDT27DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT27DS_Test.Clear;
  { kMean test }
  TKDT27DS_Test.BuildKDTreeWithCluster(TKDT27DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT27DS_Test.Search(TKDT27DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT27DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT27DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT27DS_Test);
end;


function TKDT28DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DS_Node;
  function SortCompare(const p1, p2: PKDT28DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT28DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT28DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT28DS_SourceBuffer;
  dynBuff  : PKDT28DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT28DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT28DS.GetData(const index: NativeInt): PKDT28DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT28DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT28DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT28DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT28DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT28DS.StoreBuffPtr: PKDT28DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT28DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT28DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT28DS.BuildKDTreeWithCluster(const inBuff: TKDT28DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT28DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT28DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT28DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT28DS.BuildKDTreeWithCluster(const inBuff: TKDT28DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DS_BuildCall);
var
  TempStoreBuff: TKDT28DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DS_BuildMethod);
var
  TempStoreBuff: TKDT28DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DS_BuildProc);
var
  TempStoreBuff: TKDT28DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT28DS.Search(const Buff: TKDT28DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DS_Node;

var
  NearestNeighbour: PKDT28DS_Node;

  function FindParentNode(const BuffPtr: PKDT28DS_Vec; NodePtr: PKDT28DS_Node): PKDT28DS_Node;
  var
    Next       : PKDT28DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT28DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT28DS_Node; const BuffPtr: PKDT28DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT28DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT28DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT28DS_Vec; const p1, p2: PKDT28DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT28DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT28DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT28DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT28DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT28DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT28DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT28DS_Node(NearestNodes[0]);
    end;
end;

function TKDT28DS.Search(const Buff: TKDT28DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT28DS.Search(const Buff: TKDT28DS_Vec; var SearchedDistanceMin: Double): PKDT28DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT28DS.Search(const Buff: TKDT28DS_Vec): PKDT28DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT28DS.Search(const inBuff: TKDT28DS_DynamicVecBuffer; var OutBuff: TKDT28DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DS_DynamicVecBuffer;
  outBuffPtr : PKDT28DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DS.Search(const inBuff: TKDT28DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT28DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT28DS_Source));
end;

procedure TKDT28DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT28DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT28DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT28DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DS.PrintNodeTree(const NodePtr: PKDT28DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT28DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT28DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT28DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT28DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT28DS.KDT28DSVec(const s: string): TKDT28DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT28DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT28DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT28DS.KDT28DSVec(const v: TKDT28DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT28DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT28DS.KDT28DSPow(const v: TKDT28DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT28DS.KDT28DSDistance(const v1, v2: TKDT28DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT28DS_Axis - 1 do
      Result := Result + KDT28DSPow(v2[i] - v1[i]);
end;

procedure TKDT28DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT28DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT28DS.Test;
var
  TKDT28DS_Test    : TKDT28DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT28DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT28DS_Test := TKDT28DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT28DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT28DS_Test.TestBuff) - 1 do
    for j := 0 to KDT28DS_Axis - 1 do
        TKDT28DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT28DS_Test.TestBuff), length(TKDT28DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT28DS_Test.BuildKDTreeM(length(TKDT28DS_Test.TestBuff), nil, @TKDT28DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT28DS_Test.BuildKDTreeM(length(TKDT28DS_Test.TestBuff), nil, TKDT28DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT28DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT28DS_Test.TestBuff));
  TKDT28DS_Test.Search(TKDT28DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT28DSDistance(TKDT28DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT28DS_Test.Clear;
  { kMean test }
  TKDT28DS_Test.BuildKDTreeWithCluster(TKDT28DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT28DS_Test.Search(TKDT28DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT28DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT28DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT28DS_Test);
end;


function TKDT29DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DS_Node;
  function SortCompare(const p1, p2: PKDT29DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT29DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT29DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT29DS_SourceBuffer;
  dynBuff  : PKDT29DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT29DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT29DS.GetData(const index: NativeInt): PKDT29DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT29DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT29DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT29DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT29DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT29DS.StoreBuffPtr: PKDT29DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT29DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT29DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT29DS.BuildKDTreeWithCluster(const inBuff: TKDT29DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT29DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT29DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT29DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT29DS.BuildKDTreeWithCluster(const inBuff: TKDT29DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT29DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DS_BuildCall);
var
  TempStoreBuff: TKDT29DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DS_BuildMethod);
var
  TempStoreBuff: TKDT29DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DS_BuildProc);
var
  TempStoreBuff: TKDT29DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT29DS.Search(const Buff: TKDT29DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DS_Node;

var
  NearestNeighbour: PKDT29DS_Node;

  function FindParentNode(const BuffPtr: PKDT29DS_Vec; NodePtr: PKDT29DS_Node): PKDT29DS_Node;
  var
    Next       : PKDT29DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT29DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT29DS_Node; const BuffPtr: PKDT29DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT29DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT29DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT29DS_Vec; const p1, p2: PKDT29DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT29DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT29DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT29DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT29DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT29DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT29DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT29DS_Node(NearestNodes[0]);
    end;
end;

function TKDT29DS.Search(const Buff: TKDT29DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT29DS.Search(const Buff: TKDT29DS_Vec; var SearchedDistanceMin: Double): PKDT29DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT29DS.Search(const Buff: TKDT29DS_Vec): PKDT29DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT29DS.Search(const inBuff: TKDT29DS_DynamicVecBuffer; var OutBuff: TKDT29DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT29DS_DynamicVecBuffer;
  outBuffPtr : PKDT29DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT29DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT29DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT29DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT29DS.Search(const inBuff: TKDT29DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT29DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT29DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT29DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT29DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT29DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT29DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT29DS_Source));
end;

procedure TKDT29DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT29DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT29DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT29DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT29DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT29DS.PrintNodeTree(const NodePtr: PKDT29DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT29DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT29DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT29DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT29DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT29DS.KDT29DSVec(const s: string): TKDT29DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT29DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT29DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT29DS.KDT29DSVec(const v: TKDT29DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT29DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT29DS.KDT29DSPow(const v: TKDT29DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT29DS.KDT29DSDistance(const v1, v2: TKDT29DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT29DS_Axis - 1 do
      Result := Result + KDT29DSPow(v2[i] - v1[i]);
end;

procedure TKDT29DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT29DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT29DS.Test;
var
  TKDT29DS_Test    : TKDT29DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT29DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT29DS_Test := TKDT29DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT29DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT29DS_Test.TestBuff) - 1 do
    for j := 0 to KDT29DS_Axis - 1 do
        TKDT29DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT29DS_Test.TestBuff), length(TKDT29DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT29DS_Test.BuildKDTreeM(length(TKDT29DS_Test.TestBuff), nil, @TKDT29DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT29DS_Test.BuildKDTreeM(length(TKDT29DS_Test.TestBuff), nil, TKDT29DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT29DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT29DS_Test.TestBuff));
  TKDT29DS_Test.Search(TKDT29DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT29DSDistance(TKDT29DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT29DS_Test.Clear;
  { kMean test }
  TKDT29DS_Test.BuildKDTreeWithCluster(TKDT29DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT29DS_Test.Search(TKDT29DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT29DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT29DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT29DS_Test);
end;


function TKDT30DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DS_Node;
  function SortCompare(const p1, p2: PKDT30DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT30DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT30DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT30DS_SourceBuffer;
  dynBuff  : PKDT30DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT30DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT30DS.GetData(const index: NativeInt): PKDT30DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT30DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT30DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT30DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT30DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT30DS.StoreBuffPtr: PKDT30DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT30DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT30DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT30DS.BuildKDTreeWithCluster(const inBuff: TKDT30DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT30DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT30DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT30DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT30DS.BuildKDTreeWithCluster(const inBuff: TKDT30DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DS_BuildCall);
var
  TempStoreBuff: TKDT30DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DS_BuildMethod);
var
  TempStoreBuff: TKDT30DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DS_BuildProc);
var
  TempStoreBuff: TKDT30DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT30DS.Search(const Buff: TKDT30DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DS_Node;

var
  NearestNeighbour: PKDT30DS_Node;

  function FindParentNode(const BuffPtr: PKDT30DS_Vec; NodePtr: PKDT30DS_Node): PKDT30DS_Node;
  var
    Next       : PKDT30DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT30DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT30DS_Node; const BuffPtr: PKDT30DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT30DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT30DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT30DS_Vec; const p1, p2: PKDT30DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT30DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT30DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT30DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT30DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT30DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT30DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT30DS_Node(NearestNodes[0]);
    end;
end;

function TKDT30DS.Search(const Buff: TKDT30DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT30DS.Search(const Buff: TKDT30DS_Vec; var SearchedDistanceMin: Double): PKDT30DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT30DS.Search(const Buff: TKDT30DS_Vec): PKDT30DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT30DS.Search(const inBuff: TKDT30DS_DynamicVecBuffer; var OutBuff: TKDT30DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DS_DynamicVecBuffer;
  outBuffPtr : PKDT30DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DS.Search(const inBuff: TKDT30DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT30DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT30DS_Source));
end;

procedure TKDT30DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT30DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT30DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT30DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DS.PrintNodeTree(const NodePtr: PKDT30DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT30DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT30DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT30DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT30DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT30DS.KDT30DSVec(const s: string): TKDT30DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT30DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT30DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT30DS.KDT30DSVec(const v: TKDT30DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT30DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT30DS.KDT30DSPow(const v: TKDT30DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT30DS.KDT30DSDistance(const v1, v2: TKDT30DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT30DS_Axis - 1 do
      Result := Result + KDT30DSPow(v2[i] - v1[i]);
end;

procedure TKDT30DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT30DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT30DS.Test;
var
  TKDT30DS_Test    : TKDT30DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT30DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT30DS_Test := TKDT30DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT30DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT30DS_Test.TestBuff) - 1 do
    for j := 0 to KDT30DS_Axis - 1 do
        TKDT30DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT30DS_Test.TestBuff), length(TKDT30DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT30DS_Test.BuildKDTreeM(length(TKDT30DS_Test.TestBuff), nil, @TKDT30DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT30DS_Test.BuildKDTreeM(length(TKDT30DS_Test.TestBuff), nil, TKDT30DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT30DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT30DS_Test.TestBuff));
  TKDT30DS_Test.Search(TKDT30DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT30DSDistance(TKDT30DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT30DS_Test.Clear;
  { kMean test }
  TKDT30DS_Test.BuildKDTreeWithCluster(TKDT30DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT30DS_Test.Search(TKDT30DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT30DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT30DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT30DS_Test);
end;


function TKDT31DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT31DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT31DS_Node;
  function SortCompare(const p1, p2: PKDT31DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT31DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT31DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT31DS_SourceBuffer;
  dynBuff  : PKDT31DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT31DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT31DS.GetData(const index: NativeInt): PKDT31DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT31DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT31DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT31DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT31DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT31DS.StoreBuffPtr: PKDT31DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT31DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT31DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT31DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT31DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT31DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT31DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT31DS.BuildKDTreeWithCluster(const inBuff: TKDT31DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT31DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT31DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT31DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT31DS.BuildKDTreeWithCluster(const inBuff: TKDT31DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT31DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DS_BuildCall);
var
  TempStoreBuff: TKDT31DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT31DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DS_BuildMethod);
var
  TempStoreBuff: TKDT31DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT31DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DS_BuildProc);
var
  TempStoreBuff: TKDT31DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT31DS.Search(const Buff: TKDT31DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT31DS_Node;

var
  NearestNeighbour: PKDT31DS_Node;

  function FindParentNode(const BuffPtr: PKDT31DS_Vec; NodePtr: PKDT31DS_Node): PKDT31DS_Node;
  var
    Next       : PKDT31DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT31DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT31DS_Node; const BuffPtr: PKDT31DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT31DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT31DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT31DS_Vec; const p1, p2: PKDT31DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT31DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT31DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT31DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT31DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT31DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT31DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT31DS_Node(NearestNodes[0]);
    end;
end;

function TKDT31DS.Search(const Buff: TKDT31DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT31DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT31DS.Search(const Buff: TKDT31DS_Vec; var SearchedDistanceMin: Double): PKDT31DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT31DS.Search(const Buff: TKDT31DS_Vec): PKDT31DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT31DS.Search(const inBuff: TKDT31DS_DynamicVecBuffer; var OutBuff: TKDT31DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT31DS_DynamicVecBuffer;
  outBuffPtr : PKDT31DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT31DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT31DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT31DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT31DS.Search(const inBuff: TKDT31DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT31DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT31DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT31DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT31DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT31DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT31DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT31DS_Source));
end;

procedure TKDT31DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT31DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT31DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT31DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT31DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT31DS.PrintNodeTree(const NodePtr: PKDT31DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT31DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT31DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT31DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT31DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT31DS.KDT31DSVec(const s: string): TKDT31DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT31DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT31DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT31DS.KDT31DSVec(const v: TKDT31DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT31DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT31DS.KDT31DSPow(const v: TKDT31DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT31DS.KDT31DSDistance(const v1, v2: TKDT31DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT31DS_Axis - 1 do
      Result := Result + KDT31DSPow(v2[i] - v1[i]);
end;

procedure TKDT31DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT31DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT31DS.Test;
var
  TKDT31DS_Test    : TKDT31DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT31DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT31DS_Test := TKDT31DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT31DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT31DS_Test.TestBuff) - 1 do
    for j := 0 to KDT31DS_Axis - 1 do
        TKDT31DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT31DS_Test.TestBuff), length(TKDT31DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT31DS_Test.BuildKDTreeM(length(TKDT31DS_Test.TestBuff), nil, @TKDT31DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT31DS_Test.BuildKDTreeM(length(TKDT31DS_Test.TestBuff), nil, TKDT31DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT31DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT31DS_Test.TestBuff));
  TKDT31DS_Test.Search(TKDT31DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT31DSDistance(TKDT31DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT31DS_Test.Clear;
  { kMean test }
  TKDT31DS_Test.BuildKDTreeWithCluster(TKDT31DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT31DS_Test.Search(TKDT31DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT31DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT31DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT31DS_Test);
end;


function TKDT32DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DS_Node;
  function SortCompare(const p1, p2: PKDT32DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT32DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT32DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT32DS_SourceBuffer;
  dynBuff  : PKDT32DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT32DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT32DS.GetData(const index: NativeInt): PKDT32DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT32DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT32DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT32DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT32DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT32DS.StoreBuffPtr: PKDT32DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT32DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT32DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT32DS.BuildKDTreeWithCluster(const inBuff: TKDT32DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT32DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT32DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT32DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT32DS.BuildKDTreeWithCluster(const inBuff: TKDT32DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DS_BuildCall);
var
  TempStoreBuff: TKDT32DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DS_BuildMethod);
var
  TempStoreBuff: TKDT32DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DS_BuildProc);
var
  TempStoreBuff: TKDT32DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT32DS.Search(const Buff: TKDT32DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DS_Node;

var
  NearestNeighbour: PKDT32DS_Node;

  function FindParentNode(const BuffPtr: PKDT32DS_Vec; NodePtr: PKDT32DS_Node): PKDT32DS_Node;
  var
    Next       : PKDT32DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT32DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT32DS_Node; const BuffPtr: PKDT32DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT32DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT32DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT32DS_Vec; const p1, p2: PKDT32DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT32DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT32DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT32DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT32DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT32DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT32DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT32DS_Node(NearestNodes[0]);
    end;
end;

function TKDT32DS.Search(const Buff: TKDT32DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT32DS.Search(const Buff: TKDT32DS_Vec; var SearchedDistanceMin: Double): PKDT32DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT32DS.Search(const Buff: TKDT32DS_Vec): PKDT32DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT32DS.Search(const inBuff: TKDT32DS_DynamicVecBuffer; var OutBuff: TKDT32DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DS_DynamicVecBuffer;
  outBuffPtr : PKDT32DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DS.Search(const inBuff: TKDT32DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT32DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT32DS_Source));
end;

procedure TKDT32DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT32DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT32DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT32DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DS.PrintNodeTree(const NodePtr: PKDT32DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT32DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT32DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT32DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT32DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT32DS.KDT32DSVec(const s: string): TKDT32DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT32DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT32DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT32DS.KDT32DSVec(const v: TKDT32DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT32DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT32DS.KDT32DSPow(const v: TKDT32DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT32DS.KDT32DSDistance(const v1, v2: TKDT32DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT32DS_Axis - 1 do
      Result := Result + KDT32DSPow(v2[i] - v1[i]);
end;

procedure TKDT32DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT32DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT32DS.Test;
var
  TKDT32DS_Test    : TKDT32DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT32DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT32DS_Test := TKDT32DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT32DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT32DS_Test.TestBuff) - 1 do
    for j := 0 to KDT32DS_Axis - 1 do
        TKDT32DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT32DS_Test.TestBuff), length(TKDT32DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT32DS_Test.BuildKDTreeM(length(TKDT32DS_Test.TestBuff), nil, @TKDT32DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT32DS_Test.BuildKDTreeM(length(TKDT32DS_Test.TestBuff), nil, TKDT32DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT32DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT32DS_Test.TestBuff));
  TKDT32DS_Test.Search(TKDT32DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT32DSDistance(TKDT32DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT32DS_Test.Clear;
  { kMean test }
  TKDT32DS_Test.BuildKDTreeWithCluster(TKDT32DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT32DS_Test.Search(TKDT32DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT32DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT32DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT32DS_Test);
end;


function TKDT33DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT33DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT33DS_Node;
  function SortCompare(const p1, p2: PKDT33DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT33DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT33DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT33DS_SourceBuffer;
  dynBuff  : PKDT33DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT33DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT33DS.GetData(const index: NativeInt): PKDT33DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT33DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT33DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT33DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT33DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT33DS.StoreBuffPtr: PKDT33DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT33DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT33DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT33DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT33DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT33DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT33DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT33DS.BuildKDTreeWithCluster(const inBuff: TKDT33DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT33DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT33DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT33DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT33DS.BuildKDTreeWithCluster(const inBuff: TKDT33DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT33DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DS_BuildCall);
var
  TempStoreBuff: TKDT33DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT33DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DS_BuildMethod);
var
  TempStoreBuff: TKDT33DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT33DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DS_BuildProc);
var
  TempStoreBuff: TKDT33DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT33DS.Search(const Buff: TKDT33DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT33DS_Node;

var
  NearestNeighbour: PKDT33DS_Node;

  function FindParentNode(const BuffPtr: PKDT33DS_Vec; NodePtr: PKDT33DS_Node): PKDT33DS_Node;
  var
    Next       : PKDT33DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT33DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT33DS_Node; const BuffPtr: PKDT33DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT33DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT33DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT33DS_Vec; const p1, p2: PKDT33DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT33DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT33DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT33DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT33DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT33DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT33DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT33DS_Node(NearestNodes[0]);
    end;
end;

function TKDT33DS.Search(const Buff: TKDT33DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT33DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT33DS.Search(const Buff: TKDT33DS_Vec; var SearchedDistanceMin: Double): PKDT33DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT33DS.Search(const Buff: TKDT33DS_Vec): PKDT33DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT33DS.Search(const inBuff: TKDT33DS_DynamicVecBuffer; var OutBuff: TKDT33DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT33DS_DynamicVecBuffer;
  outBuffPtr : PKDT33DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT33DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT33DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT33DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT33DS.Search(const inBuff: TKDT33DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT33DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT33DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT33DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT33DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT33DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT33DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT33DS_Source));
end;

procedure TKDT33DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT33DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT33DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT33DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT33DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT33DS.PrintNodeTree(const NodePtr: PKDT33DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT33DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT33DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT33DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT33DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT33DS.KDT33DSVec(const s: string): TKDT33DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT33DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT33DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT33DS.KDT33DSVec(const v: TKDT33DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT33DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT33DS.KDT33DSPow(const v: TKDT33DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT33DS.KDT33DSDistance(const v1, v2: TKDT33DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT33DS_Axis - 1 do
      Result := Result + KDT33DSPow(v2[i] - v1[i]);
end;

procedure TKDT33DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT33DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT33DS.Test;
var
  TKDT33DS_Test    : TKDT33DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT33DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT33DS_Test := TKDT33DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT33DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT33DS_Test.TestBuff) - 1 do
    for j := 0 to KDT33DS_Axis - 1 do
        TKDT33DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT33DS_Test.TestBuff), length(TKDT33DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT33DS_Test.BuildKDTreeM(length(TKDT33DS_Test.TestBuff), nil, @TKDT33DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT33DS_Test.BuildKDTreeM(length(TKDT33DS_Test.TestBuff), nil, TKDT33DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT33DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT33DS_Test.TestBuff));
  TKDT33DS_Test.Search(TKDT33DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT33DSDistance(TKDT33DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT33DS_Test.Clear;
  { kMean test }
  TKDT33DS_Test.BuildKDTreeWithCluster(TKDT33DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT33DS_Test.Search(TKDT33DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT33DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT33DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT33DS_Test);
end;


function TKDT34DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DS_Node;
  function SortCompare(const p1, p2: PKDT34DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT34DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT34DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT34DS_SourceBuffer;
  dynBuff  : PKDT34DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT34DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT34DS.GetData(const index: NativeInt): PKDT34DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT34DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT34DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT34DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT34DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT34DS.StoreBuffPtr: PKDT34DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT34DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT34DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT34DS.BuildKDTreeWithCluster(const inBuff: TKDT34DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT34DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT34DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT34DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT34DS.BuildKDTreeWithCluster(const inBuff: TKDT34DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DS_BuildCall);
var
  TempStoreBuff: TKDT34DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DS_BuildMethod);
var
  TempStoreBuff: TKDT34DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DS_BuildProc);
var
  TempStoreBuff: TKDT34DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT34DS.Search(const Buff: TKDT34DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DS_Node;

var
  NearestNeighbour: PKDT34DS_Node;

  function FindParentNode(const BuffPtr: PKDT34DS_Vec; NodePtr: PKDT34DS_Node): PKDT34DS_Node;
  var
    Next       : PKDT34DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT34DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT34DS_Node; const BuffPtr: PKDT34DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT34DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT34DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT34DS_Vec; const p1, p2: PKDT34DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT34DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT34DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT34DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT34DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT34DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT34DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT34DS_Node(NearestNodes[0]);
    end;
end;

function TKDT34DS.Search(const Buff: TKDT34DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT34DS.Search(const Buff: TKDT34DS_Vec; var SearchedDistanceMin: Double): PKDT34DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT34DS.Search(const Buff: TKDT34DS_Vec): PKDT34DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT34DS.Search(const inBuff: TKDT34DS_DynamicVecBuffer; var OutBuff: TKDT34DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DS_DynamicVecBuffer;
  outBuffPtr : PKDT34DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DS.Search(const inBuff: TKDT34DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT34DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT34DS_Source));
end;

procedure TKDT34DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT34DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT34DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT34DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DS.PrintNodeTree(const NodePtr: PKDT34DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT34DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT34DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT34DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT34DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT34DS.KDT34DSVec(const s: string): TKDT34DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT34DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT34DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT34DS.KDT34DSVec(const v: TKDT34DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT34DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT34DS.KDT34DSPow(const v: TKDT34DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT34DS.KDT34DSDistance(const v1, v2: TKDT34DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT34DS_Axis - 1 do
      Result := Result + KDT34DSPow(v2[i] - v1[i]);
end;

procedure TKDT34DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT34DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT34DS.Test;
var
  TKDT34DS_Test    : TKDT34DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT34DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT34DS_Test := TKDT34DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT34DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT34DS_Test.TestBuff) - 1 do
    for j := 0 to KDT34DS_Axis - 1 do
        TKDT34DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT34DS_Test.TestBuff), length(TKDT34DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT34DS_Test.BuildKDTreeM(length(TKDT34DS_Test.TestBuff), nil, @TKDT34DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT34DS_Test.BuildKDTreeM(length(TKDT34DS_Test.TestBuff), nil, TKDT34DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT34DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT34DS_Test.TestBuff));
  TKDT34DS_Test.Search(TKDT34DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT34DSDistance(TKDT34DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT34DS_Test.Clear;
  { kMean test }
  TKDT34DS_Test.BuildKDTreeWithCluster(TKDT34DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT34DS_Test.Search(TKDT34DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT34DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT34DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT34DS_Test);
end;


function TKDT35DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT35DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT35DS_Node;
  function SortCompare(const p1, p2: PKDT35DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT35DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT35DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT35DS_SourceBuffer;
  dynBuff  : PKDT35DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT35DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT35DS.GetData(const index: NativeInt): PKDT35DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT35DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT35DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT35DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT35DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT35DS.StoreBuffPtr: PKDT35DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT35DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT35DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT35DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT35DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT35DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT35DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT35DS.BuildKDTreeWithCluster(const inBuff: TKDT35DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT35DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT35DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT35DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT35DS.BuildKDTreeWithCluster(const inBuff: TKDT35DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT35DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DS_BuildCall);
var
  TempStoreBuff: TKDT35DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT35DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DS_BuildMethod);
var
  TempStoreBuff: TKDT35DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT35DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DS_BuildProc);
var
  TempStoreBuff: TKDT35DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT35DS.Search(const Buff: TKDT35DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT35DS_Node;

var
  NearestNeighbour: PKDT35DS_Node;

  function FindParentNode(const BuffPtr: PKDT35DS_Vec; NodePtr: PKDT35DS_Node): PKDT35DS_Node;
  var
    Next       : PKDT35DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT35DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT35DS_Node; const BuffPtr: PKDT35DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT35DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT35DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT35DS_Vec; const p1, p2: PKDT35DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT35DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT35DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT35DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT35DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT35DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT35DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT35DS_Node(NearestNodes[0]);
    end;
end;

function TKDT35DS.Search(const Buff: TKDT35DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT35DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT35DS.Search(const Buff: TKDT35DS_Vec; var SearchedDistanceMin: Double): PKDT35DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT35DS.Search(const Buff: TKDT35DS_Vec): PKDT35DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT35DS.Search(const inBuff: TKDT35DS_DynamicVecBuffer; var OutBuff: TKDT35DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT35DS_DynamicVecBuffer;
  outBuffPtr : PKDT35DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT35DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT35DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT35DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT35DS.Search(const inBuff: TKDT35DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT35DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT35DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT35DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT35DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT35DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT35DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT35DS_Source));
end;

procedure TKDT35DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT35DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT35DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT35DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT35DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT35DS.PrintNodeTree(const NodePtr: PKDT35DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT35DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT35DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT35DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT35DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT35DS.KDT35DSVec(const s: string): TKDT35DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT35DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT35DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT35DS.KDT35DSVec(const v: TKDT35DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT35DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT35DS.KDT35DSPow(const v: TKDT35DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT35DS.KDT35DSDistance(const v1, v2: TKDT35DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT35DS_Axis - 1 do
      Result := Result + KDT35DSPow(v2[i] - v1[i]);
end;

procedure TKDT35DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT35DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT35DS.Test;
var
  TKDT35DS_Test    : TKDT35DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT35DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT35DS_Test := TKDT35DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT35DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT35DS_Test.TestBuff) - 1 do
    for j := 0 to KDT35DS_Axis - 1 do
        TKDT35DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT35DS_Test.TestBuff), length(TKDT35DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT35DS_Test.BuildKDTreeM(length(TKDT35DS_Test.TestBuff), nil, @TKDT35DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT35DS_Test.BuildKDTreeM(length(TKDT35DS_Test.TestBuff), nil, TKDT35DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT35DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT35DS_Test.TestBuff));
  TKDT35DS_Test.Search(TKDT35DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT35DSDistance(TKDT35DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT35DS_Test.Clear;
  { kMean test }
  TKDT35DS_Test.BuildKDTreeWithCluster(TKDT35DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT35DS_Test.Search(TKDT35DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT35DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT35DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT35DS_Test);
end;


function TKDT36DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DS_Node;
  function SortCompare(const p1, p2: PKDT36DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT36DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT36DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT36DS_SourceBuffer;
  dynBuff  : PKDT36DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT36DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT36DS.GetData(const index: NativeInt): PKDT36DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT36DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT36DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT36DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT36DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT36DS.StoreBuffPtr: PKDT36DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT36DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT36DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT36DS.BuildKDTreeWithCluster(const inBuff: TKDT36DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT36DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT36DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT36DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT36DS.BuildKDTreeWithCluster(const inBuff: TKDT36DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DS_BuildCall);
var
  TempStoreBuff: TKDT36DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DS_BuildMethod);
var
  TempStoreBuff: TKDT36DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DS_BuildProc);
var
  TempStoreBuff: TKDT36DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT36DS.Search(const Buff: TKDT36DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DS_Node;

var
  NearestNeighbour: PKDT36DS_Node;

  function FindParentNode(const BuffPtr: PKDT36DS_Vec; NodePtr: PKDT36DS_Node): PKDT36DS_Node;
  var
    Next       : PKDT36DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT36DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT36DS_Node; const BuffPtr: PKDT36DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT36DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT36DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT36DS_Vec; const p1, p2: PKDT36DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT36DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT36DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT36DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT36DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT36DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT36DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT36DS_Node(NearestNodes[0]);
    end;
end;

function TKDT36DS.Search(const Buff: TKDT36DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT36DS.Search(const Buff: TKDT36DS_Vec; var SearchedDistanceMin: Double): PKDT36DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT36DS.Search(const Buff: TKDT36DS_Vec): PKDT36DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT36DS.Search(const inBuff: TKDT36DS_DynamicVecBuffer; var OutBuff: TKDT36DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DS_DynamicVecBuffer;
  outBuffPtr : PKDT36DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DS.Search(const inBuff: TKDT36DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT36DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT36DS_Source));
end;

procedure TKDT36DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT36DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT36DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT36DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DS.PrintNodeTree(const NodePtr: PKDT36DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT36DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT36DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT36DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT36DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT36DS.KDT36DSVec(const s: string): TKDT36DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT36DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT36DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT36DS.KDT36DSVec(const v: TKDT36DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT36DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT36DS.KDT36DSPow(const v: TKDT36DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT36DS.KDT36DSDistance(const v1, v2: TKDT36DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT36DS_Axis - 1 do
      Result := Result + KDT36DSPow(v2[i] - v1[i]);
end;

procedure TKDT36DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT36DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT36DS.Test;
var
  TKDT36DS_Test    : TKDT36DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT36DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT36DS_Test := TKDT36DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT36DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT36DS_Test.TestBuff) - 1 do
    for j := 0 to KDT36DS_Axis - 1 do
        TKDT36DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT36DS_Test.TestBuff), length(TKDT36DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT36DS_Test.BuildKDTreeM(length(TKDT36DS_Test.TestBuff), nil, @TKDT36DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT36DS_Test.BuildKDTreeM(length(TKDT36DS_Test.TestBuff), nil, TKDT36DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT36DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT36DS_Test.TestBuff));
  TKDT36DS_Test.Search(TKDT36DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT36DSDistance(TKDT36DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT36DS_Test.Clear;
  { kMean test }
  TKDT36DS_Test.BuildKDTreeWithCluster(TKDT36DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT36DS_Test.Search(TKDT36DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT36DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT36DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT36DS_Test);
end;


function TKDT37DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT37DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT37DS_Node;
  function SortCompare(const p1, p2: PKDT37DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT37DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT37DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT37DS_SourceBuffer;
  dynBuff  : PKDT37DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT37DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT37DS.GetData(const index: NativeInt): PKDT37DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT37DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT37DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT37DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT37DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT37DS.StoreBuffPtr: PKDT37DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT37DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT37DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT37DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT37DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT37DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT37DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT37DS.BuildKDTreeWithCluster(const inBuff: TKDT37DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT37DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT37DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT37DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT37DS.BuildKDTreeWithCluster(const inBuff: TKDT37DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT37DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DS_BuildCall);
var
  TempStoreBuff: TKDT37DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT37DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DS_BuildMethod);
var
  TempStoreBuff: TKDT37DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT37DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DS_BuildProc);
var
  TempStoreBuff: TKDT37DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT37DS.Search(const Buff: TKDT37DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT37DS_Node;

var
  NearestNeighbour: PKDT37DS_Node;

  function FindParentNode(const BuffPtr: PKDT37DS_Vec; NodePtr: PKDT37DS_Node): PKDT37DS_Node;
  var
    Next       : PKDT37DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT37DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT37DS_Node; const BuffPtr: PKDT37DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT37DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT37DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT37DS_Vec; const p1, p2: PKDT37DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT37DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT37DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT37DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT37DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT37DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT37DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT37DS_Node(NearestNodes[0]);
    end;
end;

function TKDT37DS.Search(const Buff: TKDT37DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT37DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT37DS.Search(const Buff: TKDT37DS_Vec; var SearchedDistanceMin: Double): PKDT37DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT37DS.Search(const Buff: TKDT37DS_Vec): PKDT37DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT37DS.Search(const inBuff: TKDT37DS_DynamicVecBuffer; var OutBuff: TKDT37DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT37DS_DynamicVecBuffer;
  outBuffPtr : PKDT37DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT37DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT37DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT37DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT37DS.Search(const inBuff: TKDT37DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT37DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT37DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT37DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT37DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT37DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT37DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT37DS_Source));
end;

procedure TKDT37DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT37DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT37DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT37DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT37DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT37DS.PrintNodeTree(const NodePtr: PKDT37DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT37DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT37DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT37DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT37DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT37DS.KDT37DSVec(const s: string): TKDT37DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT37DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT37DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT37DS.KDT37DSVec(const v: TKDT37DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT37DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT37DS.KDT37DSPow(const v: TKDT37DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT37DS.KDT37DSDistance(const v1, v2: TKDT37DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT37DS_Axis - 1 do
      Result := Result + KDT37DSPow(v2[i] - v1[i]);
end;

procedure TKDT37DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT37DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT37DS.Test;
var
  TKDT37DS_Test    : TKDT37DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT37DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT37DS_Test := TKDT37DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT37DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT37DS_Test.TestBuff) - 1 do
    for j := 0 to KDT37DS_Axis - 1 do
        TKDT37DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT37DS_Test.TestBuff), length(TKDT37DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT37DS_Test.BuildKDTreeM(length(TKDT37DS_Test.TestBuff), nil, @TKDT37DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT37DS_Test.BuildKDTreeM(length(TKDT37DS_Test.TestBuff), nil, TKDT37DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT37DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT37DS_Test.TestBuff));
  TKDT37DS_Test.Search(TKDT37DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT37DSDistance(TKDT37DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT37DS_Test.Clear;
  { kMean test }
  TKDT37DS_Test.BuildKDTreeWithCluster(TKDT37DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT37DS_Test.Search(TKDT37DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT37DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT37DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT37DS_Test);
end;


function TKDT38DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DS_Node;
  function SortCompare(const p1, p2: PKDT38DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT38DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT38DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT38DS_SourceBuffer;
  dynBuff  : PKDT38DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT38DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT38DS.GetData(const index: NativeInt): PKDT38DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT38DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT38DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT38DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT38DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT38DS.StoreBuffPtr: PKDT38DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT38DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT38DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT38DS.BuildKDTreeWithCluster(const inBuff: TKDT38DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT38DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT38DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT38DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT38DS.BuildKDTreeWithCluster(const inBuff: TKDT38DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT38DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DS_BuildCall);
var
  TempStoreBuff: TKDT38DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DS_BuildMethod);
var
  TempStoreBuff: TKDT38DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DS_BuildProc);
var
  TempStoreBuff: TKDT38DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT38DS.Search(const Buff: TKDT38DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DS_Node;

var
  NearestNeighbour: PKDT38DS_Node;

  function FindParentNode(const BuffPtr: PKDT38DS_Vec; NodePtr: PKDT38DS_Node): PKDT38DS_Node;
  var
    Next       : PKDT38DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT38DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT38DS_Node; const BuffPtr: PKDT38DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT38DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT38DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT38DS_Vec; const p1, p2: PKDT38DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT38DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT38DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT38DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT38DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT38DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT38DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT38DS_Node(NearestNodes[0]);
    end;
end;

function TKDT38DS.Search(const Buff: TKDT38DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT38DS.Search(const Buff: TKDT38DS_Vec; var SearchedDistanceMin: Double): PKDT38DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT38DS.Search(const Buff: TKDT38DS_Vec): PKDT38DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT38DS.Search(const inBuff: TKDT38DS_DynamicVecBuffer; var OutBuff: TKDT38DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT38DS_DynamicVecBuffer;
  outBuffPtr : PKDT38DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT38DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT38DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT38DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT38DS.Search(const inBuff: TKDT38DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT38DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT38DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT38DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT38DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT38DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT38DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT38DS_Source));
end;

procedure TKDT38DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT38DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT38DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT38DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT38DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT38DS.PrintNodeTree(const NodePtr: PKDT38DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT38DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT38DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT38DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT38DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT38DS.KDT38DSVec(const s: string): TKDT38DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT38DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT38DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT38DS.KDT38DSVec(const v: TKDT38DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT38DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT38DS.KDT38DSPow(const v: TKDT38DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT38DS.KDT38DSDistance(const v1, v2: TKDT38DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT38DS_Axis - 1 do
      Result := Result + KDT38DSPow(v2[i] - v1[i]);
end;

procedure TKDT38DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT38DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT38DS.Test;
var
  TKDT38DS_Test    : TKDT38DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT38DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT38DS_Test := TKDT38DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT38DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT38DS_Test.TestBuff) - 1 do
    for j := 0 to KDT38DS_Axis - 1 do
        TKDT38DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT38DS_Test.TestBuff), length(TKDT38DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT38DS_Test.BuildKDTreeM(length(TKDT38DS_Test.TestBuff), nil, @TKDT38DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT38DS_Test.BuildKDTreeM(length(TKDT38DS_Test.TestBuff), nil, TKDT38DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT38DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT38DS_Test.TestBuff));
  TKDT38DS_Test.Search(TKDT38DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT38DSDistance(TKDT38DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT38DS_Test.Clear;
  { kMean test }
  TKDT38DS_Test.BuildKDTreeWithCluster(TKDT38DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT38DS_Test.Search(TKDT38DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT38DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT38DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT38DS_Test);
end;


function TKDT39DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT39DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT39DS_Node;
  function SortCompare(const p1, p2: PKDT39DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT39DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT39DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT39DS_SourceBuffer;
  dynBuff  : PKDT39DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT39DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT39DS.GetData(const index: NativeInt): PKDT39DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT39DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT39DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT39DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT39DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT39DS.StoreBuffPtr: PKDT39DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT39DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT39DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT39DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT39DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT39DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT39DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT39DS.BuildKDTreeWithCluster(const inBuff: TKDT39DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT39DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT39DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT39DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT39DS.BuildKDTreeWithCluster(const inBuff: TKDT39DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT39DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DS_BuildCall);
var
  TempStoreBuff: TKDT39DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT39DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DS_BuildMethod);
var
  TempStoreBuff: TKDT39DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT39DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DS_BuildProc);
var
  TempStoreBuff: TKDT39DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT39DS.Search(const Buff: TKDT39DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT39DS_Node;

var
  NearestNeighbour: PKDT39DS_Node;

  function FindParentNode(const BuffPtr: PKDT39DS_Vec; NodePtr: PKDT39DS_Node): PKDT39DS_Node;
  var
    Next       : PKDT39DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT39DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT39DS_Node; const BuffPtr: PKDT39DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT39DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT39DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT39DS_Vec; const p1, p2: PKDT39DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT39DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT39DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT39DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT39DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT39DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT39DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT39DS_Node(NearestNodes[0]);
    end;
end;

function TKDT39DS.Search(const Buff: TKDT39DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT39DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT39DS.Search(const Buff: TKDT39DS_Vec; var SearchedDistanceMin: Double): PKDT39DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT39DS.Search(const Buff: TKDT39DS_Vec): PKDT39DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT39DS.Search(const inBuff: TKDT39DS_DynamicVecBuffer; var OutBuff: TKDT39DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT39DS_DynamicVecBuffer;
  outBuffPtr : PKDT39DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT39DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT39DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT39DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT39DS.Search(const inBuff: TKDT39DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT39DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT39DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT39DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT39DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT39DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT39DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT39DS_Source));
end;

procedure TKDT39DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT39DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT39DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT39DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT39DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT39DS.PrintNodeTree(const NodePtr: PKDT39DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT39DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT39DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT39DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT39DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT39DS.KDT39DSVec(const s: string): TKDT39DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT39DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT39DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT39DS.KDT39DSVec(const v: TKDT39DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT39DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT39DS.KDT39DSPow(const v: TKDT39DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT39DS.KDT39DSDistance(const v1, v2: TKDT39DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT39DS_Axis - 1 do
      Result := Result + KDT39DSPow(v2[i] - v1[i]);
end;

procedure TKDT39DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT39DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT39DS.Test;
var
  TKDT39DS_Test    : TKDT39DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT39DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT39DS_Test := TKDT39DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT39DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT39DS_Test.TestBuff) - 1 do
    for j := 0 to KDT39DS_Axis - 1 do
        TKDT39DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT39DS_Test.TestBuff), length(TKDT39DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT39DS_Test.BuildKDTreeM(length(TKDT39DS_Test.TestBuff), nil, @TKDT39DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT39DS_Test.BuildKDTreeM(length(TKDT39DS_Test.TestBuff), nil, TKDT39DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT39DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT39DS_Test.TestBuff));
  TKDT39DS_Test.Search(TKDT39DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT39DSDistance(TKDT39DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT39DS_Test.Clear;
  { kMean test }
  TKDT39DS_Test.BuildKDTreeWithCluster(TKDT39DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT39DS_Test.Search(TKDT39DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT39DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT39DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT39DS_Test);
end;


function TKDT40DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DS_Node;
  function SortCompare(const p1, p2: PKDT40DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT40DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT40DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT40DS_SourceBuffer;
  dynBuff  : PKDT40DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT40DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT40DS.GetData(const index: NativeInt): PKDT40DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT40DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT40DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT40DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT40DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT40DS.StoreBuffPtr: PKDT40DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT40DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT40DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT40DS.BuildKDTreeWithCluster(const inBuff: TKDT40DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT40DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT40DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT40DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT40DS.BuildKDTreeWithCluster(const inBuff: TKDT40DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DS_BuildCall);
var
  TempStoreBuff: TKDT40DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DS_BuildMethod);
var
  TempStoreBuff: TKDT40DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DS_BuildProc);
var
  TempStoreBuff: TKDT40DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT40DS.Search(const Buff: TKDT40DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DS_Node;

var
  NearestNeighbour: PKDT40DS_Node;

  function FindParentNode(const BuffPtr: PKDT40DS_Vec; NodePtr: PKDT40DS_Node): PKDT40DS_Node;
  var
    Next       : PKDT40DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT40DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT40DS_Node; const BuffPtr: PKDT40DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT40DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT40DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT40DS_Vec; const p1, p2: PKDT40DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT40DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT40DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT40DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT40DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT40DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT40DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT40DS_Node(NearestNodes[0]);
    end;
end;

function TKDT40DS.Search(const Buff: TKDT40DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT40DS.Search(const Buff: TKDT40DS_Vec; var SearchedDistanceMin: Double): PKDT40DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT40DS.Search(const Buff: TKDT40DS_Vec): PKDT40DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT40DS.Search(const inBuff: TKDT40DS_DynamicVecBuffer; var OutBuff: TKDT40DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DS_DynamicVecBuffer;
  outBuffPtr : PKDT40DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DS.Search(const inBuff: TKDT40DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT40DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT40DS_Source));
end;

procedure TKDT40DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT40DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT40DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT40DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DS.PrintNodeTree(const NodePtr: PKDT40DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT40DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT40DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT40DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT40DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT40DS.KDT40DSVec(const s: string): TKDT40DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT40DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT40DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT40DS.KDT40DSVec(const v: TKDT40DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT40DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT40DS.KDT40DSPow(const v: TKDT40DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT40DS.KDT40DSDistance(const v1, v2: TKDT40DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT40DS_Axis - 1 do
      Result := Result + KDT40DSPow(v2[i] - v1[i]);
end;

procedure TKDT40DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT40DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT40DS.Test;
var
  TKDT40DS_Test    : TKDT40DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT40DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT40DS_Test := TKDT40DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT40DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT40DS_Test.TestBuff) - 1 do
    for j := 0 to KDT40DS_Axis - 1 do
        TKDT40DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT40DS_Test.TestBuff), length(TKDT40DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT40DS_Test.BuildKDTreeM(length(TKDT40DS_Test.TestBuff), nil, @TKDT40DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT40DS_Test.BuildKDTreeM(length(TKDT40DS_Test.TestBuff), nil, TKDT40DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT40DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT40DS_Test.TestBuff));
  TKDT40DS_Test.Search(TKDT40DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT40DSDistance(TKDT40DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT40DS_Test.Clear;
  { kMean test }
  TKDT40DS_Test.BuildKDTreeWithCluster(TKDT40DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT40DS_Test.Search(TKDT40DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT40DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT40DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT40DS_Test);
end;


function TKDT41DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT41DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT41DS_Node;
  function SortCompare(const p1, p2: PKDT41DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT41DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT41DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT41DS_SourceBuffer;
  dynBuff  : PKDT41DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT41DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT41DS.GetData(const index: NativeInt): PKDT41DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT41DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT41DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT41DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT41DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT41DS.StoreBuffPtr: PKDT41DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT41DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT41DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT41DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT41DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT41DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT41DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT41DS.BuildKDTreeWithCluster(const inBuff: TKDT41DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT41DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT41DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT41DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT41DS.BuildKDTreeWithCluster(const inBuff: TKDT41DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT41DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DS_BuildCall);
var
  TempStoreBuff: TKDT41DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT41DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DS_BuildMethod);
var
  TempStoreBuff: TKDT41DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT41DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DS_BuildProc);
var
  TempStoreBuff: TKDT41DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT41DS.Search(const Buff: TKDT41DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT41DS_Node;

var
  NearestNeighbour: PKDT41DS_Node;

  function FindParentNode(const BuffPtr: PKDT41DS_Vec; NodePtr: PKDT41DS_Node): PKDT41DS_Node;
  var
    Next       : PKDT41DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT41DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT41DS_Node; const BuffPtr: PKDT41DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT41DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT41DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT41DS_Vec; const p1, p2: PKDT41DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT41DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT41DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT41DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT41DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT41DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT41DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT41DS_Node(NearestNodes[0]);
    end;
end;

function TKDT41DS.Search(const Buff: TKDT41DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT41DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT41DS.Search(const Buff: TKDT41DS_Vec; var SearchedDistanceMin: Double): PKDT41DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT41DS.Search(const Buff: TKDT41DS_Vec): PKDT41DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT41DS.Search(const inBuff: TKDT41DS_DynamicVecBuffer; var OutBuff: TKDT41DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT41DS_DynamicVecBuffer;
  outBuffPtr : PKDT41DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT41DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT41DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT41DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT41DS.Search(const inBuff: TKDT41DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT41DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT41DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT41DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT41DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT41DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT41DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT41DS_Source));
end;

procedure TKDT41DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT41DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT41DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT41DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT41DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT41DS.PrintNodeTree(const NodePtr: PKDT41DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT41DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT41DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT41DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT41DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT41DS.KDT41DSVec(const s: string): TKDT41DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT41DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT41DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT41DS.KDT41DSVec(const v: TKDT41DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT41DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT41DS.KDT41DSPow(const v: TKDT41DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT41DS.KDT41DSDistance(const v1, v2: TKDT41DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT41DS_Axis - 1 do
      Result := Result + KDT41DSPow(v2[i] - v1[i]);
end;

procedure TKDT41DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT41DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT41DS.Test;
var
  TKDT41DS_Test    : TKDT41DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT41DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT41DS_Test := TKDT41DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT41DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT41DS_Test.TestBuff) - 1 do
    for j := 0 to KDT41DS_Axis - 1 do
        TKDT41DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT41DS_Test.TestBuff), length(TKDT41DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT41DS_Test.BuildKDTreeM(length(TKDT41DS_Test.TestBuff), nil, @TKDT41DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT41DS_Test.BuildKDTreeM(length(TKDT41DS_Test.TestBuff), nil, TKDT41DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT41DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT41DS_Test.TestBuff));
  TKDT41DS_Test.Search(TKDT41DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT41DSDistance(TKDT41DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT41DS_Test.Clear;
  { kMean test }
  TKDT41DS_Test.BuildKDTreeWithCluster(TKDT41DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT41DS_Test.Search(TKDT41DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT41DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT41DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT41DS_Test);
end;


function TKDT42DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT42DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT42DS_Node;
  function SortCompare(const p1, p2: PKDT42DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT42DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT42DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT42DS_SourceBuffer;
  dynBuff  : PKDT42DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT42DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT42DS.GetData(const index: NativeInt): PKDT42DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT42DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT42DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT42DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT42DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT42DS.StoreBuffPtr: PKDT42DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT42DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT42DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT42DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT42DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT42DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT42DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT42DS.BuildKDTreeWithCluster(const inBuff: TKDT42DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT42DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT42DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT42DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT42DS.BuildKDTreeWithCluster(const inBuff: TKDT42DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT42DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DS_BuildCall);
var
  TempStoreBuff: TKDT42DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT42DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DS_BuildMethod);
var
  TempStoreBuff: TKDT42DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT42DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DS_BuildProc);
var
  TempStoreBuff: TKDT42DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT42DS.Search(const Buff: TKDT42DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT42DS_Node;

var
  NearestNeighbour: PKDT42DS_Node;

  function FindParentNode(const BuffPtr: PKDT42DS_Vec; NodePtr: PKDT42DS_Node): PKDT42DS_Node;
  var
    Next       : PKDT42DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT42DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT42DS_Node; const BuffPtr: PKDT42DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT42DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT42DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT42DS_Vec; const p1, p2: PKDT42DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT42DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT42DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT42DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT42DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT42DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT42DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT42DS_Node(NearestNodes[0]);
    end;
end;

function TKDT42DS.Search(const Buff: TKDT42DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT42DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT42DS.Search(const Buff: TKDT42DS_Vec; var SearchedDistanceMin: Double): PKDT42DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT42DS.Search(const Buff: TKDT42DS_Vec): PKDT42DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT42DS.Search(const inBuff: TKDT42DS_DynamicVecBuffer; var OutBuff: TKDT42DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT42DS_DynamicVecBuffer;
  outBuffPtr : PKDT42DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT42DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT42DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT42DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT42DS.Search(const inBuff: TKDT42DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT42DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT42DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT42DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT42DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT42DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT42DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT42DS_Source));
end;

procedure TKDT42DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT42DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT42DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT42DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT42DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT42DS.PrintNodeTree(const NodePtr: PKDT42DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT42DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT42DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT42DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT42DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT42DS.KDT42DSVec(const s: string): TKDT42DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT42DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT42DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT42DS.KDT42DSVec(const v: TKDT42DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT42DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT42DS.KDT42DSPow(const v: TKDT42DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT42DS.KDT42DSDistance(const v1, v2: TKDT42DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT42DS_Axis - 1 do
      Result := Result + KDT42DSPow(v2[i] - v1[i]);
end;

procedure TKDT42DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT42DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT42DS.Test;
var
  TKDT42DS_Test    : TKDT42DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT42DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT42DS_Test := TKDT42DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT42DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT42DS_Test.TestBuff) - 1 do
    for j := 0 to KDT42DS_Axis - 1 do
        TKDT42DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT42DS_Test.TestBuff), length(TKDT42DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT42DS_Test.BuildKDTreeM(length(TKDT42DS_Test.TestBuff), nil, @TKDT42DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT42DS_Test.BuildKDTreeM(length(TKDT42DS_Test.TestBuff), nil, TKDT42DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT42DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT42DS_Test.TestBuff));
  TKDT42DS_Test.Search(TKDT42DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT42DSDistance(TKDT42DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT42DS_Test.Clear;
  { kMean test }
  TKDT42DS_Test.BuildKDTreeWithCluster(TKDT42DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT42DS_Test.Search(TKDT42DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT42DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT42DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT42DS_Test);
end;


function TKDT43DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT43DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT43DS_Node;
  function SortCompare(const p1, p2: PKDT43DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT43DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT43DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT43DS_SourceBuffer;
  dynBuff  : PKDT43DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT43DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT43DS.GetData(const index: NativeInt): PKDT43DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT43DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT43DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT43DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT43DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT43DS.StoreBuffPtr: PKDT43DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT43DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT43DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT43DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT43DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT43DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT43DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT43DS.BuildKDTreeWithCluster(const inBuff: TKDT43DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT43DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT43DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT43DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT43DS.BuildKDTreeWithCluster(const inBuff: TKDT43DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT43DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DS_BuildCall);
var
  TempStoreBuff: TKDT43DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT43DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DS_BuildMethod);
var
  TempStoreBuff: TKDT43DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT43DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DS_BuildProc);
var
  TempStoreBuff: TKDT43DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT43DS.Search(const Buff: TKDT43DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT43DS_Node;

var
  NearestNeighbour: PKDT43DS_Node;

  function FindParentNode(const BuffPtr: PKDT43DS_Vec; NodePtr: PKDT43DS_Node): PKDT43DS_Node;
  var
    Next       : PKDT43DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT43DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT43DS_Node; const BuffPtr: PKDT43DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT43DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT43DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT43DS_Vec; const p1, p2: PKDT43DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT43DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT43DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT43DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT43DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT43DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT43DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT43DS_Node(NearestNodes[0]);
    end;
end;

function TKDT43DS.Search(const Buff: TKDT43DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT43DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT43DS.Search(const Buff: TKDT43DS_Vec; var SearchedDistanceMin: Double): PKDT43DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT43DS.Search(const Buff: TKDT43DS_Vec): PKDT43DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT43DS.Search(const inBuff: TKDT43DS_DynamicVecBuffer; var OutBuff: TKDT43DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT43DS_DynamicVecBuffer;
  outBuffPtr : PKDT43DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT43DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT43DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT43DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT43DS.Search(const inBuff: TKDT43DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT43DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT43DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT43DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT43DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT43DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT43DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT43DS_Source));
end;

procedure TKDT43DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT43DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT43DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT43DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT43DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT43DS.PrintNodeTree(const NodePtr: PKDT43DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT43DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT43DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT43DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT43DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT43DS.KDT43DSVec(const s: string): TKDT43DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT43DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT43DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT43DS.KDT43DSVec(const v: TKDT43DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT43DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT43DS.KDT43DSPow(const v: TKDT43DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT43DS.KDT43DSDistance(const v1, v2: TKDT43DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT43DS_Axis - 1 do
      Result := Result + KDT43DSPow(v2[i] - v1[i]);
end;

procedure TKDT43DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT43DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT43DS.Test;
var
  TKDT43DS_Test    : TKDT43DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT43DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT43DS_Test := TKDT43DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT43DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT43DS_Test.TestBuff) - 1 do
    for j := 0 to KDT43DS_Axis - 1 do
        TKDT43DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT43DS_Test.TestBuff), length(TKDT43DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT43DS_Test.BuildKDTreeM(length(TKDT43DS_Test.TestBuff), nil, @TKDT43DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT43DS_Test.BuildKDTreeM(length(TKDT43DS_Test.TestBuff), nil, TKDT43DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT43DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT43DS_Test.TestBuff));
  TKDT43DS_Test.Search(TKDT43DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT43DSDistance(TKDT43DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT43DS_Test.Clear;
  { kMean test }
  TKDT43DS_Test.BuildKDTreeWithCluster(TKDT43DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT43DS_Test.Search(TKDT43DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT43DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT43DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT43DS_Test);
end;


function TKDT44DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DS_Node;
  function SortCompare(const p1, p2: PKDT44DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT44DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT44DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT44DS_SourceBuffer;
  dynBuff  : PKDT44DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT44DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT44DS.GetData(const index: NativeInt): PKDT44DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT44DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT44DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT44DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT44DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT44DS.StoreBuffPtr: PKDT44DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT44DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT44DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT44DS.BuildKDTreeWithCluster(const inBuff: TKDT44DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT44DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT44DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT44DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT44DS.BuildKDTreeWithCluster(const inBuff: TKDT44DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT44DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DS_BuildCall);
var
  TempStoreBuff: TKDT44DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DS_BuildMethod);
var
  TempStoreBuff: TKDT44DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DS_BuildProc);
var
  TempStoreBuff: TKDT44DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT44DS.Search(const Buff: TKDT44DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DS_Node;

var
  NearestNeighbour: PKDT44DS_Node;

  function FindParentNode(const BuffPtr: PKDT44DS_Vec; NodePtr: PKDT44DS_Node): PKDT44DS_Node;
  var
    Next       : PKDT44DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT44DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT44DS_Node; const BuffPtr: PKDT44DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT44DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT44DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT44DS_Vec; const p1, p2: PKDT44DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT44DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT44DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT44DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT44DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT44DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT44DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT44DS_Node(NearestNodes[0]);
    end;
end;

function TKDT44DS.Search(const Buff: TKDT44DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT44DS.Search(const Buff: TKDT44DS_Vec; var SearchedDistanceMin: Double): PKDT44DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT44DS.Search(const Buff: TKDT44DS_Vec): PKDT44DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT44DS.Search(const inBuff: TKDT44DS_DynamicVecBuffer; var OutBuff: TKDT44DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT44DS_DynamicVecBuffer;
  outBuffPtr : PKDT44DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT44DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT44DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT44DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT44DS.Search(const inBuff: TKDT44DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT44DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT44DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT44DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT44DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT44DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT44DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT44DS_Source));
end;

procedure TKDT44DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT44DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT44DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT44DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT44DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT44DS.PrintNodeTree(const NodePtr: PKDT44DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT44DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT44DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT44DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT44DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT44DS.KDT44DSVec(const s: string): TKDT44DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT44DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT44DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT44DS.KDT44DSVec(const v: TKDT44DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT44DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT44DS.KDT44DSPow(const v: TKDT44DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT44DS.KDT44DSDistance(const v1, v2: TKDT44DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT44DS_Axis - 1 do
      Result := Result + KDT44DSPow(v2[i] - v1[i]);
end;

procedure TKDT44DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT44DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT44DS.Test;
var
  TKDT44DS_Test    : TKDT44DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT44DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT44DS_Test := TKDT44DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT44DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT44DS_Test.TestBuff) - 1 do
    for j := 0 to KDT44DS_Axis - 1 do
        TKDT44DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT44DS_Test.TestBuff), length(TKDT44DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT44DS_Test.BuildKDTreeM(length(TKDT44DS_Test.TestBuff), nil, @TKDT44DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT44DS_Test.BuildKDTreeM(length(TKDT44DS_Test.TestBuff), nil, TKDT44DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT44DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT44DS_Test.TestBuff));
  TKDT44DS_Test.Search(TKDT44DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT44DSDistance(TKDT44DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT44DS_Test.Clear;
  { kMean test }
  TKDT44DS_Test.BuildKDTreeWithCluster(TKDT44DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT44DS_Test.Search(TKDT44DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT44DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT44DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT44DS_Test);
end;


function TKDT45DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT45DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT45DS_Node;
  function SortCompare(const p1, p2: PKDT45DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT45DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT45DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT45DS_SourceBuffer;
  dynBuff  : PKDT45DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT45DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT45DS.GetData(const index: NativeInt): PKDT45DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT45DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT45DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT45DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT45DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT45DS.StoreBuffPtr: PKDT45DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT45DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT45DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT45DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT45DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT45DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT45DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT45DS.BuildKDTreeWithCluster(const inBuff: TKDT45DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT45DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT45DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT45DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT45DS.BuildKDTreeWithCluster(const inBuff: TKDT45DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT45DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DS_BuildCall);
var
  TempStoreBuff: TKDT45DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT45DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DS_BuildMethod);
var
  TempStoreBuff: TKDT45DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT45DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DS_BuildProc);
var
  TempStoreBuff: TKDT45DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT45DS.Search(const Buff: TKDT45DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT45DS_Node;

var
  NearestNeighbour: PKDT45DS_Node;

  function FindParentNode(const BuffPtr: PKDT45DS_Vec; NodePtr: PKDT45DS_Node): PKDT45DS_Node;
  var
    Next       : PKDT45DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT45DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT45DS_Node; const BuffPtr: PKDT45DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT45DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT45DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT45DS_Vec; const p1, p2: PKDT45DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT45DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT45DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT45DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT45DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT45DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT45DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT45DS_Node(NearestNodes[0]);
    end;
end;

function TKDT45DS.Search(const Buff: TKDT45DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT45DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT45DS.Search(const Buff: TKDT45DS_Vec; var SearchedDistanceMin: Double): PKDT45DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT45DS.Search(const Buff: TKDT45DS_Vec): PKDT45DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT45DS.Search(const inBuff: TKDT45DS_DynamicVecBuffer; var OutBuff: TKDT45DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT45DS_DynamicVecBuffer;
  outBuffPtr : PKDT45DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT45DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT45DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT45DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT45DS.Search(const inBuff: TKDT45DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT45DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT45DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT45DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT45DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT45DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT45DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT45DS_Source));
end;

procedure TKDT45DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT45DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT45DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT45DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT45DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT45DS.PrintNodeTree(const NodePtr: PKDT45DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT45DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT45DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT45DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT45DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT45DS.KDT45DSVec(const s: string): TKDT45DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT45DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT45DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT45DS.KDT45DSVec(const v: TKDT45DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT45DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT45DS.KDT45DSPow(const v: TKDT45DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT45DS.KDT45DSDistance(const v1, v2: TKDT45DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT45DS_Axis - 1 do
      Result := Result + KDT45DSPow(v2[i] - v1[i]);
end;

procedure TKDT45DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT45DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT45DS.Test;
var
  TKDT45DS_Test    : TKDT45DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT45DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT45DS_Test := TKDT45DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT45DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT45DS_Test.TestBuff) - 1 do
    for j := 0 to KDT45DS_Axis - 1 do
        TKDT45DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT45DS_Test.TestBuff), length(TKDT45DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT45DS_Test.BuildKDTreeM(length(TKDT45DS_Test.TestBuff), nil, @TKDT45DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT45DS_Test.BuildKDTreeM(length(TKDT45DS_Test.TestBuff), nil, TKDT45DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT45DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT45DS_Test.TestBuff));
  TKDT45DS_Test.Search(TKDT45DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT45DSDistance(TKDT45DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT45DS_Test.Clear;
  { kMean test }
  TKDT45DS_Test.BuildKDTreeWithCluster(TKDT45DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT45DS_Test.Search(TKDT45DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT45DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT45DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT45DS_Test);
end;


function TKDT46DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT46DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT46DS_Node;
  function SortCompare(const p1, p2: PKDT46DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT46DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT46DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT46DS_SourceBuffer;
  dynBuff  : PKDT46DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT46DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT46DS.GetData(const index: NativeInt): PKDT46DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT46DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT46DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT46DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT46DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT46DS.StoreBuffPtr: PKDT46DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT46DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT46DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT46DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT46DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT46DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT46DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT46DS.BuildKDTreeWithCluster(const inBuff: TKDT46DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT46DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT46DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT46DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT46DS.BuildKDTreeWithCluster(const inBuff: TKDT46DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT46DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DS_BuildCall);
var
  TempStoreBuff: TKDT46DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT46DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DS_BuildMethod);
var
  TempStoreBuff: TKDT46DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT46DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DS_BuildProc);
var
  TempStoreBuff: TKDT46DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT46DS.Search(const Buff: TKDT46DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT46DS_Node;

var
  NearestNeighbour: PKDT46DS_Node;

  function FindParentNode(const BuffPtr: PKDT46DS_Vec; NodePtr: PKDT46DS_Node): PKDT46DS_Node;
  var
    Next       : PKDT46DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT46DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT46DS_Node; const BuffPtr: PKDT46DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT46DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT46DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT46DS_Vec; const p1, p2: PKDT46DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT46DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT46DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT46DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT46DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT46DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT46DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT46DS_Node(NearestNodes[0]);
    end;
end;

function TKDT46DS.Search(const Buff: TKDT46DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT46DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT46DS.Search(const Buff: TKDT46DS_Vec; var SearchedDistanceMin: Double): PKDT46DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT46DS.Search(const Buff: TKDT46DS_Vec): PKDT46DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT46DS.Search(const inBuff: TKDT46DS_DynamicVecBuffer; var OutBuff: TKDT46DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT46DS_DynamicVecBuffer;
  outBuffPtr : PKDT46DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT46DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT46DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT46DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT46DS.Search(const inBuff: TKDT46DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT46DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT46DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT46DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT46DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT46DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT46DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT46DS_Source));
end;

procedure TKDT46DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT46DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT46DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT46DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT46DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT46DS.PrintNodeTree(const NodePtr: PKDT46DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT46DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT46DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT46DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT46DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT46DS.KDT46DSVec(const s: string): TKDT46DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT46DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT46DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT46DS.KDT46DSVec(const v: TKDT46DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT46DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT46DS.KDT46DSPow(const v: TKDT46DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT46DS.KDT46DSDistance(const v1, v2: TKDT46DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT46DS_Axis - 1 do
      Result := Result + KDT46DSPow(v2[i] - v1[i]);
end;

procedure TKDT46DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT46DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT46DS.Test;
var
  TKDT46DS_Test    : TKDT46DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT46DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT46DS_Test := TKDT46DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT46DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT46DS_Test.TestBuff) - 1 do
    for j := 0 to KDT46DS_Axis - 1 do
        TKDT46DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT46DS_Test.TestBuff), length(TKDT46DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT46DS_Test.BuildKDTreeM(length(TKDT46DS_Test.TestBuff), nil, @TKDT46DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT46DS_Test.BuildKDTreeM(length(TKDT46DS_Test.TestBuff), nil, TKDT46DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT46DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT46DS_Test.TestBuff));
  TKDT46DS_Test.Search(TKDT46DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT46DSDistance(TKDT46DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT46DS_Test.Clear;
  { kMean test }
  TKDT46DS_Test.BuildKDTreeWithCluster(TKDT46DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT46DS_Test.Search(TKDT46DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT46DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT46DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT46DS_Test);
end;


function TKDT47DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT47DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT47DS_Node;
  function SortCompare(const p1, p2: PKDT47DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT47DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT47DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT47DS_SourceBuffer;
  dynBuff  : PKDT47DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT47DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT47DS.GetData(const index: NativeInt): PKDT47DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT47DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT47DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT47DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT47DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT47DS.StoreBuffPtr: PKDT47DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT47DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT47DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT47DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT47DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT47DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT47DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT47DS.BuildKDTreeWithCluster(const inBuff: TKDT47DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT47DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT47DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT47DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT47DS.BuildKDTreeWithCluster(const inBuff: TKDT47DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT47DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DS_BuildCall);
var
  TempStoreBuff: TKDT47DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT47DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DS_BuildMethod);
var
  TempStoreBuff: TKDT47DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT47DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DS_BuildProc);
var
  TempStoreBuff: TKDT47DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT47DS.Search(const Buff: TKDT47DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT47DS_Node;

var
  NearestNeighbour: PKDT47DS_Node;

  function FindParentNode(const BuffPtr: PKDT47DS_Vec; NodePtr: PKDT47DS_Node): PKDT47DS_Node;
  var
    Next       : PKDT47DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT47DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT47DS_Node; const BuffPtr: PKDT47DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT47DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT47DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT47DS_Vec; const p1, p2: PKDT47DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT47DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT47DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT47DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT47DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT47DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT47DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT47DS_Node(NearestNodes[0]);
    end;
end;

function TKDT47DS.Search(const Buff: TKDT47DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT47DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT47DS.Search(const Buff: TKDT47DS_Vec; var SearchedDistanceMin: Double): PKDT47DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT47DS.Search(const Buff: TKDT47DS_Vec): PKDT47DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT47DS.Search(const inBuff: TKDT47DS_DynamicVecBuffer; var OutBuff: TKDT47DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT47DS_DynamicVecBuffer;
  outBuffPtr : PKDT47DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT47DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT47DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT47DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT47DS.Search(const inBuff: TKDT47DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT47DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT47DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT47DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT47DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT47DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT47DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT47DS_Source));
end;

procedure TKDT47DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT47DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT47DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT47DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT47DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT47DS.PrintNodeTree(const NodePtr: PKDT47DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT47DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT47DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT47DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT47DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT47DS.KDT47DSVec(const s: string): TKDT47DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT47DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT47DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT47DS.KDT47DSVec(const v: TKDT47DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT47DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT47DS.KDT47DSPow(const v: TKDT47DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT47DS.KDT47DSDistance(const v1, v2: TKDT47DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT47DS_Axis - 1 do
      Result := Result + KDT47DSPow(v2[i] - v1[i]);
end;

procedure TKDT47DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT47DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT47DS.Test;
var
  TKDT47DS_Test    : TKDT47DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT47DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT47DS_Test := TKDT47DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT47DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT47DS_Test.TestBuff) - 1 do
    for j := 0 to KDT47DS_Axis - 1 do
        TKDT47DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT47DS_Test.TestBuff), length(TKDT47DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT47DS_Test.BuildKDTreeM(length(TKDT47DS_Test.TestBuff), nil, @TKDT47DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT47DS_Test.BuildKDTreeM(length(TKDT47DS_Test.TestBuff), nil, TKDT47DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT47DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT47DS_Test.TestBuff));
  TKDT47DS_Test.Search(TKDT47DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT47DSDistance(TKDT47DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT47DS_Test.Clear;
  { kMean test }
  TKDT47DS_Test.BuildKDTreeWithCluster(TKDT47DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT47DS_Test.Search(TKDT47DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT47DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT47DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT47DS_Test);
end;


function TKDT48DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DS_Node;
  function SortCompare(const p1, p2: PKDT48DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT48DS_SourceBuffer;
  dynBuff  : PKDT48DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT48DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DS.GetData(const index: NativeInt): PKDT48DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT48DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DS.StoreBuffPtr: PKDT48DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT48DS.BuildKDTreeWithCluster(const inBuff: TKDT48DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT48DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT48DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT48DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DS.BuildKDTreeWithCluster(const inBuff: TKDT48DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DS_BuildCall);
var
  TempStoreBuff: TKDT48DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DS_BuildMethod);
var
  TempStoreBuff: TKDT48DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DS_BuildProc);
var
  TempStoreBuff: TKDT48DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT48DS.Search(const Buff: TKDT48DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DS_Node;

var
  NearestNeighbour: PKDT48DS_Node;

  function FindParentNode(const BuffPtr: PKDT48DS_Vec; NodePtr: PKDT48DS_Node): PKDT48DS_Node;
  var
    Next       : PKDT48DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT48DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DS_Node; const BuffPtr: PKDT48DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT48DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT48DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT48DS_Vec; const p1, p2: PKDT48DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT48DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT48DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT48DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT48DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT48DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DS_Node(NearestNodes[0]);
    end;
end;

function TKDT48DS.Search(const Buff: TKDT48DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DS.Search(const Buff: TKDT48DS_Vec; var SearchedDistanceMin: Double): PKDT48DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DS.Search(const Buff: TKDT48DS_Vec): PKDT48DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT48DS.Search(const inBuff: TKDT48DS_DynamicVecBuffer; var OutBuff: TKDT48DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DS_DynamicVecBuffer;
  outBuffPtr : PKDT48DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DS.Search(const inBuff: TKDT48DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT48DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT48DS_Source));
end;

procedure TKDT48DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT48DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT48DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DS.PrintNodeTree(const NodePtr: PKDT48DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT48DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT48DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT48DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT48DS.KDT48DSVec(const s: string): TKDT48DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT48DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT48DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT48DS.KDT48DSVec(const v: TKDT48DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT48DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT48DS.KDT48DSPow(const v: TKDT48DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT48DS.KDT48DSDistance(const v1, v2: TKDT48DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT48DS_Axis - 1 do
      Result := Result + KDT48DSPow(v2[i] - v1[i]);
end;

procedure TKDT48DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT48DS.Test;
var
  TKDT48DS_Test    : TKDT48DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT48DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT48DS_Test := TKDT48DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT48DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT48DS_Test.TestBuff) - 1 do
    for j := 0 to KDT48DS_Axis - 1 do
        TKDT48DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT48DS_Test.TestBuff), length(TKDT48DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT48DS_Test.BuildKDTreeM(length(TKDT48DS_Test.TestBuff), nil, @TKDT48DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT48DS_Test.BuildKDTreeM(length(TKDT48DS_Test.TestBuff), nil, TKDT48DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT48DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT48DS_Test.TestBuff));
  TKDT48DS_Test.Search(TKDT48DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT48DSDistance(TKDT48DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT48DS_Test.Clear;
  { kMean test }
  TKDT48DS_Test.BuildKDTreeWithCluster(TKDT48DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT48DS_Test.Search(TKDT48DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT48DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT48DS_Test);
end;


function TKDT49DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT49DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT49DS_Node;
  function SortCompare(const p1, p2: PKDT49DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT49DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT49DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT49DS_SourceBuffer;
  dynBuff  : PKDT49DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT49DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT49DS.GetData(const index: NativeInt): PKDT49DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT49DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT49DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT49DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT49DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT49DS.StoreBuffPtr: PKDT49DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT49DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT49DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT49DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT49DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT49DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT49DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT49DS.BuildKDTreeWithCluster(const inBuff: TKDT49DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT49DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT49DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT49DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT49DS.BuildKDTreeWithCluster(const inBuff: TKDT49DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT49DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DS_BuildCall);
var
  TempStoreBuff: TKDT49DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT49DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DS_BuildMethod);
var
  TempStoreBuff: TKDT49DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT49DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DS_BuildProc);
var
  TempStoreBuff: TKDT49DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT49DS.Search(const Buff: TKDT49DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT49DS_Node;

var
  NearestNeighbour: PKDT49DS_Node;

  function FindParentNode(const BuffPtr: PKDT49DS_Vec; NodePtr: PKDT49DS_Node): PKDT49DS_Node;
  var
    Next       : PKDT49DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT49DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT49DS_Node; const BuffPtr: PKDT49DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT49DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT49DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT49DS_Vec; const p1, p2: PKDT49DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT49DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT49DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT49DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT49DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT49DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT49DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT49DS_Node(NearestNodes[0]);
    end;
end;

function TKDT49DS.Search(const Buff: TKDT49DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT49DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT49DS.Search(const Buff: TKDT49DS_Vec; var SearchedDistanceMin: Double): PKDT49DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT49DS.Search(const Buff: TKDT49DS_Vec): PKDT49DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT49DS.Search(const inBuff: TKDT49DS_DynamicVecBuffer; var OutBuff: TKDT49DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT49DS_DynamicVecBuffer;
  outBuffPtr : PKDT49DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT49DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT49DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT49DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT49DS.Search(const inBuff: TKDT49DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT49DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT49DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT49DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT49DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT49DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT49DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT49DS_Source));
end;

procedure TKDT49DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT49DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT49DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT49DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT49DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT49DS.PrintNodeTree(const NodePtr: PKDT49DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT49DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT49DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT49DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT49DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT49DS.KDT49DSVec(const s: string): TKDT49DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT49DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT49DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT49DS.KDT49DSVec(const v: TKDT49DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT49DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT49DS.KDT49DSPow(const v: TKDT49DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT49DS.KDT49DSDistance(const v1, v2: TKDT49DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT49DS_Axis - 1 do
      Result := Result + KDT49DSPow(v2[i] - v1[i]);
end;

procedure TKDT49DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT49DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT49DS.Test;
var
  TKDT49DS_Test    : TKDT49DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT49DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT49DS_Test := TKDT49DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT49DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT49DS_Test.TestBuff) - 1 do
    for j := 0 to KDT49DS_Axis - 1 do
        TKDT49DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT49DS_Test.TestBuff), length(TKDT49DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT49DS_Test.BuildKDTreeM(length(TKDT49DS_Test.TestBuff), nil, @TKDT49DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT49DS_Test.BuildKDTreeM(length(TKDT49DS_Test.TestBuff), nil, TKDT49DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT49DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT49DS_Test.TestBuff));
  TKDT49DS_Test.Search(TKDT49DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT49DSDistance(TKDT49DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT49DS_Test.Clear;
  { kMean test }
  TKDT49DS_Test.BuildKDTreeWithCluster(TKDT49DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT49DS_Test.Search(TKDT49DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT49DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT49DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT49DS_Test);
end;


function TKDT50DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DS_Node;
  function SortCompare(const p1, p2: PKDT50DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT50DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT50DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT50DS_SourceBuffer;
  dynBuff  : PKDT50DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT50DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT50DS.GetData(const index: NativeInt): PKDT50DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT50DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT50DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT50DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT50DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT50DS.StoreBuffPtr: PKDT50DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT50DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT50DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT50DS.BuildKDTreeWithCluster(const inBuff: TKDT50DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT50DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT50DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT50DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT50DS.BuildKDTreeWithCluster(const inBuff: TKDT50DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT50DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DS_BuildCall);
var
  TempStoreBuff: TKDT50DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DS_BuildMethod);
var
  TempStoreBuff: TKDT50DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DS_BuildProc);
var
  TempStoreBuff: TKDT50DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT50DS.Search(const Buff: TKDT50DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DS_Node;

var
  NearestNeighbour: PKDT50DS_Node;

  function FindParentNode(const BuffPtr: PKDT50DS_Vec; NodePtr: PKDT50DS_Node): PKDT50DS_Node;
  var
    Next       : PKDT50DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT50DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT50DS_Node; const BuffPtr: PKDT50DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT50DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT50DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT50DS_Vec; const p1, p2: PKDT50DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT50DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT50DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT50DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT50DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT50DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT50DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT50DS_Node(NearestNodes[0]);
    end;
end;

function TKDT50DS.Search(const Buff: TKDT50DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT50DS.Search(const Buff: TKDT50DS_Vec; var SearchedDistanceMin: Double): PKDT50DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT50DS.Search(const Buff: TKDT50DS_Vec): PKDT50DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT50DS.Search(const inBuff: TKDT50DS_DynamicVecBuffer; var OutBuff: TKDT50DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT50DS_DynamicVecBuffer;
  outBuffPtr : PKDT50DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT50DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT50DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT50DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT50DS.Search(const inBuff: TKDT50DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT50DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT50DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT50DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT50DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT50DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT50DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT50DS_Source));
end;

procedure TKDT50DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT50DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT50DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT50DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT50DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT50DS.PrintNodeTree(const NodePtr: PKDT50DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT50DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT50DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT50DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT50DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT50DS.KDT50DSVec(const s: string): TKDT50DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT50DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT50DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT50DS.KDT50DSVec(const v: TKDT50DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT50DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT50DS.KDT50DSPow(const v: TKDT50DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT50DS.KDT50DSDistance(const v1, v2: TKDT50DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT50DS_Axis - 1 do
      Result := Result + KDT50DSPow(v2[i] - v1[i]);
end;

procedure TKDT50DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT50DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT50DS.Test;
var
  TKDT50DS_Test    : TKDT50DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT50DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT50DS_Test := TKDT50DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT50DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT50DS_Test.TestBuff) - 1 do
    for j := 0 to KDT50DS_Axis - 1 do
        TKDT50DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT50DS_Test.TestBuff), length(TKDT50DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT50DS_Test.BuildKDTreeM(length(TKDT50DS_Test.TestBuff), nil, @TKDT50DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT50DS_Test.BuildKDTreeM(length(TKDT50DS_Test.TestBuff), nil, TKDT50DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT50DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT50DS_Test.TestBuff));
  TKDT50DS_Test.Search(TKDT50DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT50DSDistance(TKDT50DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT50DS_Test.Clear;
  { kMean test }
  TKDT50DS_Test.BuildKDTreeWithCluster(TKDT50DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT50DS_Test.Search(TKDT50DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT50DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT50DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT50DS_Test);
end;


function TKDT51DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT51DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT51DS_Node;
  function SortCompare(const p1, p2: PKDT51DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT51DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT51DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT51DS_SourceBuffer;
  dynBuff  : PKDT51DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT51DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT51DS.GetData(const index: NativeInt): PKDT51DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT51DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT51DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT51DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT51DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT51DS.StoreBuffPtr: PKDT51DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT51DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT51DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT51DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT51DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT51DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT51DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT51DS.BuildKDTreeWithCluster(const inBuff: TKDT51DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT51DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT51DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT51DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT51DS.BuildKDTreeWithCluster(const inBuff: TKDT51DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT51DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DS_BuildCall);
var
  TempStoreBuff: TKDT51DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT51DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DS_BuildMethod);
var
  TempStoreBuff: TKDT51DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT51DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DS_BuildProc);
var
  TempStoreBuff: TKDT51DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT51DS.Search(const Buff: TKDT51DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT51DS_Node;

var
  NearestNeighbour: PKDT51DS_Node;

  function FindParentNode(const BuffPtr: PKDT51DS_Vec; NodePtr: PKDT51DS_Node): PKDT51DS_Node;
  var
    Next       : PKDT51DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT51DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT51DS_Node; const BuffPtr: PKDT51DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT51DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT51DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT51DS_Vec; const p1, p2: PKDT51DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT51DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT51DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT51DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT51DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT51DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT51DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT51DS_Node(NearestNodes[0]);
    end;
end;

function TKDT51DS.Search(const Buff: TKDT51DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT51DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT51DS.Search(const Buff: TKDT51DS_Vec; var SearchedDistanceMin: Double): PKDT51DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT51DS.Search(const Buff: TKDT51DS_Vec): PKDT51DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT51DS.Search(const inBuff: TKDT51DS_DynamicVecBuffer; var OutBuff: TKDT51DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT51DS_DynamicVecBuffer;
  outBuffPtr : PKDT51DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT51DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT51DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT51DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT51DS.Search(const inBuff: TKDT51DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT51DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT51DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT51DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT51DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT51DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT51DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT51DS_Source));
end;

procedure TKDT51DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT51DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT51DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT51DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT51DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT51DS.PrintNodeTree(const NodePtr: PKDT51DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT51DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT51DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT51DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT51DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT51DS.KDT51DSVec(const s: string): TKDT51DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT51DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT51DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT51DS.KDT51DSVec(const v: TKDT51DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT51DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT51DS.KDT51DSPow(const v: TKDT51DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT51DS.KDT51DSDistance(const v1, v2: TKDT51DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT51DS_Axis - 1 do
      Result := Result + KDT51DSPow(v2[i] - v1[i]);
end;

procedure TKDT51DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT51DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT51DS.Test;
var
  TKDT51DS_Test    : TKDT51DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT51DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT51DS_Test := TKDT51DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT51DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT51DS_Test.TestBuff) - 1 do
    for j := 0 to KDT51DS_Axis - 1 do
        TKDT51DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT51DS_Test.TestBuff), length(TKDT51DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT51DS_Test.BuildKDTreeM(length(TKDT51DS_Test.TestBuff), nil, @TKDT51DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT51DS_Test.BuildKDTreeM(length(TKDT51DS_Test.TestBuff), nil, TKDT51DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT51DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT51DS_Test.TestBuff));
  TKDT51DS_Test.Search(TKDT51DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT51DSDistance(TKDT51DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT51DS_Test.Clear;
  { kMean test }
  TKDT51DS_Test.BuildKDTreeWithCluster(TKDT51DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT51DS_Test.Search(TKDT51DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT51DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT51DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT51DS_Test);
end;


function TKDT52DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DS_Node;
  function SortCompare(const p1, p2: PKDT52DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT52DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT52DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT52DS_SourceBuffer;
  dynBuff  : PKDT52DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT52DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT52DS.GetData(const index: NativeInt): PKDT52DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT52DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT52DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT52DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT52DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT52DS.StoreBuffPtr: PKDT52DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT52DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT52DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT52DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT52DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT52DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT52DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT52DS.BuildKDTreeWithCluster(const inBuff: TKDT52DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT52DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT52DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT52DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT52DS.BuildKDTreeWithCluster(const inBuff: TKDT52DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT52DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DS_BuildCall);
var
  TempStoreBuff: TKDT52DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT52DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DS_BuildMethod);
var
  TempStoreBuff: TKDT52DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT52DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DS_BuildProc);
var
  TempStoreBuff: TKDT52DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT52DS.Search(const Buff: TKDT52DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DS_Node;

var
  NearestNeighbour: PKDT52DS_Node;

  function FindParentNode(const BuffPtr: PKDT52DS_Vec; NodePtr: PKDT52DS_Node): PKDT52DS_Node;
  var
    Next       : PKDT52DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT52DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT52DS_Node; const BuffPtr: PKDT52DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT52DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT52DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT52DS_Vec; const p1, p2: PKDT52DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT52DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT52DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT52DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT52DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT52DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT52DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT52DS_Node(NearestNodes[0]);
    end;
end;

function TKDT52DS.Search(const Buff: TKDT52DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT52DS.Search(const Buff: TKDT52DS_Vec; var SearchedDistanceMin: Double): PKDT52DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT52DS.Search(const Buff: TKDT52DS_Vec): PKDT52DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT52DS.Search(const inBuff: TKDT52DS_DynamicVecBuffer; var OutBuff: TKDT52DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT52DS_DynamicVecBuffer;
  outBuffPtr : PKDT52DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT52DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT52DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DS.Search(const inBuff: TKDT52DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT52DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT52DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT52DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT52DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT52DS_Source));
end;

procedure TKDT52DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT52DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT52DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT52DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DS.PrintNodeTree(const NodePtr: PKDT52DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT52DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT52DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT52DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT52DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT52DS.KDT52DSVec(const s: string): TKDT52DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT52DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT52DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT52DS.KDT52DSVec(const v: TKDT52DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT52DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT52DS.KDT52DSPow(const v: TKDT52DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT52DS.KDT52DSDistance(const v1, v2: TKDT52DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT52DS_Axis - 1 do
      Result := Result + KDT52DSPow(v2[i] - v1[i]);
end;

procedure TKDT52DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT52DS.Test;
var
  TKDT52DS_Test    : TKDT52DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT52DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT52DS_Test := TKDT52DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT52DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT52DS_Test.TestBuff) - 1 do
    for j := 0 to KDT52DS_Axis - 1 do
        TKDT52DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT52DS_Test.TestBuff), length(TKDT52DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT52DS_Test.BuildKDTreeM(length(TKDT52DS_Test.TestBuff), nil, @TKDT52DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT52DS_Test.BuildKDTreeM(length(TKDT52DS_Test.TestBuff), nil, TKDT52DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT52DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT52DS_Test.TestBuff));
  TKDT52DS_Test.Search(TKDT52DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT52DSDistance(TKDT52DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT52DS_Test.Clear;
  { kMean test }
  TKDT52DS_Test.BuildKDTreeWithCluster(TKDT52DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT52DS_Test.Search(TKDT52DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT52DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT52DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT52DS_Test);
end;


function TKDT53DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT53DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT53DS_Node;
  function SortCompare(const p1, p2: PKDT53DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT53DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT53DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT53DS_SourceBuffer;
  dynBuff  : PKDT53DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT53DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT53DS.GetData(const index: NativeInt): PKDT53DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT53DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT53DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT53DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT53DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT53DS.StoreBuffPtr: PKDT53DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT53DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT53DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT53DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT53DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT53DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT53DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT53DS.BuildKDTreeWithCluster(const inBuff: TKDT53DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT53DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT53DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT53DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT53DS.BuildKDTreeWithCluster(const inBuff: TKDT53DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT53DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DS_BuildCall);
var
  TempStoreBuff: TKDT53DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT53DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DS_BuildMethod);
var
  TempStoreBuff: TKDT53DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT53DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DS_BuildProc);
var
  TempStoreBuff: TKDT53DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT53DS.Search(const Buff: TKDT53DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT53DS_Node;

var
  NearestNeighbour: PKDT53DS_Node;

  function FindParentNode(const BuffPtr: PKDT53DS_Vec; NodePtr: PKDT53DS_Node): PKDT53DS_Node;
  var
    Next       : PKDT53DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT53DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT53DS_Node; const BuffPtr: PKDT53DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT53DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT53DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT53DS_Vec; const p1, p2: PKDT53DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT53DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT53DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT53DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT53DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT53DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT53DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT53DS_Node(NearestNodes[0]);
    end;
end;

function TKDT53DS.Search(const Buff: TKDT53DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT53DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT53DS.Search(const Buff: TKDT53DS_Vec; var SearchedDistanceMin: Double): PKDT53DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT53DS.Search(const Buff: TKDT53DS_Vec): PKDT53DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT53DS.Search(const inBuff: TKDT53DS_DynamicVecBuffer; var OutBuff: TKDT53DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT53DS_DynamicVecBuffer;
  outBuffPtr : PKDT53DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT53DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT53DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT53DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT53DS.Search(const inBuff: TKDT53DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT53DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT53DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT53DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT53DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT53DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT53DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT53DS_Source));
end;

procedure TKDT53DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT53DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT53DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT53DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT53DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT53DS.PrintNodeTree(const NodePtr: PKDT53DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT53DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT53DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT53DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT53DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT53DS.KDT53DSVec(const s: string): TKDT53DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT53DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT53DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT53DS.KDT53DSVec(const v: TKDT53DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT53DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT53DS.KDT53DSPow(const v: TKDT53DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT53DS.KDT53DSDistance(const v1, v2: TKDT53DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT53DS_Axis - 1 do
      Result := Result + KDT53DSPow(v2[i] - v1[i]);
end;

procedure TKDT53DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT53DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT53DS.Test;
var
  TKDT53DS_Test    : TKDT53DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT53DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT53DS_Test := TKDT53DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT53DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT53DS_Test.TestBuff) - 1 do
    for j := 0 to KDT53DS_Axis - 1 do
        TKDT53DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT53DS_Test.TestBuff), length(TKDT53DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT53DS_Test.BuildKDTreeM(length(TKDT53DS_Test.TestBuff), nil, @TKDT53DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT53DS_Test.BuildKDTreeM(length(TKDT53DS_Test.TestBuff), nil, TKDT53DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT53DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT53DS_Test.TestBuff));
  TKDT53DS_Test.Search(TKDT53DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT53DSDistance(TKDT53DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT53DS_Test.Clear;
  { kMean test }
  TKDT53DS_Test.BuildKDTreeWithCluster(TKDT53DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT53DS_Test.Search(TKDT53DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT53DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT53DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT53DS_Test);
end;


function TKDT54DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT54DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT54DS_Node;
  function SortCompare(const p1, p2: PKDT54DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT54DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT54DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT54DS_SourceBuffer;
  dynBuff  : PKDT54DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT54DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT54DS.GetData(const index: NativeInt): PKDT54DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT54DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT54DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT54DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT54DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT54DS.StoreBuffPtr: PKDT54DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT54DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT54DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT54DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT54DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT54DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT54DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT54DS.BuildKDTreeWithCluster(const inBuff: TKDT54DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT54DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT54DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT54DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT54DS.BuildKDTreeWithCluster(const inBuff: TKDT54DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT54DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DS_BuildCall);
var
  TempStoreBuff: TKDT54DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT54DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DS_BuildMethod);
var
  TempStoreBuff: TKDT54DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT54DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DS_BuildProc);
var
  TempStoreBuff: TKDT54DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT54DS.Search(const Buff: TKDT54DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT54DS_Node;

var
  NearestNeighbour: PKDT54DS_Node;

  function FindParentNode(const BuffPtr: PKDT54DS_Vec; NodePtr: PKDT54DS_Node): PKDT54DS_Node;
  var
    Next       : PKDT54DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT54DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT54DS_Node; const BuffPtr: PKDT54DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT54DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT54DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT54DS_Vec; const p1, p2: PKDT54DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT54DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT54DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT54DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT54DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT54DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT54DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT54DS_Node(NearestNodes[0]);
    end;
end;

function TKDT54DS.Search(const Buff: TKDT54DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT54DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT54DS.Search(const Buff: TKDT54DS_Vec; var SearchedDistanceMin: Double): PKDT54DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT54DS.Search(const Buff: TKDT54DS_Vec): PKDT54DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT54DS.Search(const inBuff: TKDT54DS_DynamicVecBuffer; var OutBuff: TKDT54DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT54DS_DynamicVecBuffer;
  outBuffPtr : PKDT54DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT54DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT54DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT54DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT54DS.Search(const inBuff: TKDT54DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT54DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT54DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT54DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT54DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT54DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT54DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT54DS_Source));
end;

procedure TKDT54DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT54DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT54DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT54DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT54DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT54DS.PrintNodeTree(const NodePtr: PKDT54DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT54DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT54DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT54DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT54DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT54DS.KDT54DSVec(const s: string): TKDT54DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT54DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT54DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT54DS.KDT54DSVec(const v: TKDT54DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT54DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT54DS.KDT54DSPow(const v: TKDT54DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT54DS.KDT54DSDistance(const v1, v2: TKDT54DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT54DS_Axis - 1 do
      Result := Result + KDT54DSPow(v2[i] - v1[i]);
end;

procedure TKDT54DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT54DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT54DS.Test;
var
  TKDT54DS_Test    : TKDT54DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT54DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT54DS_Test := TKDT54DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT54DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT54DS_Test.TestBuff) - 1 do
    for j := 0 to KDT54DS_Axis - 1 do
        TKDT54DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT54DS_Test.TestBuff), length(TKDT54DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT54DS_Test.BuildKDTreeM(length(TKDT54DS_Test.TestBuff), nil, @TKDT54DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT54DS_Test.BuildKDTreeM(length(TKDT54DS_Test.TestBuff), nil, TKDT54DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT54DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT54DS_Test.TestBuff));
  TKDT54DS_Test.Search(TKDT54DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT54DSDistance(TKDT54DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT54DS_Test.Clear;
  { kMean test }
  TKDT54DS_Test.BuildKDTreeWithCluster(TKDT54DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT54DS_Test.Search(TKDT54DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT54DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT54DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT54DS_Test);
end;


function TKDT55DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT55DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT55DS_Node;
  function SortCompare(const p1, p2: PKDT55DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT55DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT55DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT55DS_SourceBuffer;
  dynBuff  : PKDT55DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT55DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT55DS.GetData(const index: NativeInt): PKDT55DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT55DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT55DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT55DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT55DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT55DS.StoreBuffPtr: PKDT55DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT55DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT55DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT55DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT55DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT55DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT55DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT55DS.BuildKDTreeWithCluster(const inBuff: TKDT55DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT55DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT55DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT55DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT55DS.BuildKDTreeWithCluster(const inBuff: TKDT55DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT55DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DS_BuildCall);
var
  TempStoreBuff: TKDT55DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT55DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DS_BuildMethod);
var
  TempStoreBuff: TKDT55DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT55DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DS_BuildProc);
var
  TempStoreBuff: TKDT55DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT55DS.Search(const Buff: TKDT55DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT55DS_Node;

var
  NearestNeighbour: PKDT55DS_Node;

  function FindParentNode(const BuffPtr: PKDT55DS_Vec; NodePtr: PKDT55DS_Node): PKDT55DS_Node;
  var
    Next       : PKDT55DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT55DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT55DS_Node; const BuffPtr: PKDT55DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT55DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT55DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT55DS_Vec; const p1, p2: PKDT55DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT55DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT55DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT55DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT55DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT55DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT55DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT55DS_Node(NearestNodes[0]);
    end;
end;

function TKDT55DS.Search(const Buff: TKDT55DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT55DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT55DS.Search(const Buff: TKDT55DS_Vec; var SearchedDistanceMin: Double): PKDT55DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT55DS.Search(const Buff: TKDT55DS_Vec): PKDT55DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT55DS.Search(const inBuff: TKDT55DS_DynamicVecBuffer; var OutBuff: TKDT55DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT55DS_DynamicVecBuffer;
  outBuffPtr : PKDT55DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT55DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT55DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT55DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT55DS.Search(const inBuff: TKDT55DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT55DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT55DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT55DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT55DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT55DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT55DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT55DS_Source));
end;

procedure TKDT55DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT55DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT55DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT55DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT55DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT55DS.PrintNodeTree(const NodePtr: PKDT55DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT55DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT55DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT55DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT55DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT55DS.KDT55DSVec(const s: string): TKDT55DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT55DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT55DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT55DS.KDT55DSVec(const v: TKDT55DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT55DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT55DS.KDT55DSPow(const v: TKDT55DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT55DS.KDT55DSDistance(const v1, v2: TKDT55DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT55DS_Axis - 1 do
      Result := Result + KDT55DSPow(v2[i] - v1[i]);
end;

procedure TKDT55DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT55DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT55DS.Test;
var
  TKDT55DS_Test    : TKDT55DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT55DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT55DS_Test := TKDT55DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT55DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT55DS_Test.TestBuff) - 1 do
    for j := 0 to KDT55DS_Axis - 1 do
        TKDT55DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT55DS_Test.TestBuff), length(TKDT55DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT55DS_Test.BuildKDTreeM(length(TKDT55DS_Test.TestBuff), nil, @TKDT55DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT55DS_Test.BuildKDTreeM(length(TKDT55DS_Test.TestBuff), nil, TKDT55DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT55DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT55DS_Test.TestBuff));
  TKDT55DS_Test.Search(TKDT55DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT55DSDistance(TKDT55DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT55DS_Test.Clear;
  { kMean test }
  TKDT55DS_Test.BuildKDTreeWithCluster(TKDT55DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT55DS_Test.Search(TKDT55DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT55DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT55DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT55DS_Test);
end;


function TKDT56DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DS_Node;
  function SortCompare(const p1, p2: PKDT56DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT56DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT56DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT56DS_SourceBuffer;
  dynBuff  : PKDT56DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT56DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT56DS.GetData(const index: NativeInt): PKDT56DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT56DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT56DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT56DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT56DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT56DS.StoreBuffPtr: PKDT56DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT56DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT56DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT56DS.BuildKDTreeWithCluster(const inBuff: TKDT56DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT56DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT56DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT56DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT56DS.BuildKDTreeWithCluster(const inBuff: TKDT56DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT56DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DS_BuildCall);
var
  TempStoreBuff: TKDT56DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DS_BuildMethod);
var
  TempStoreBuff: TKDT56DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DS_BuildProc);
var
  TempStoreBuff: TKDT56DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT56DS.Search(const Buff: TKDT56DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DS_Node;

var
  NearestNeighbour: PKDT56DS_Node;

  function FindParentNode(const BuffPtr: PKDT56DS_Vec; NodePtr: PKDT56DS_Node): PKDT56DS_Node;
  var
    Next       : PKDT56DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT56DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT56DS_Node; const BuffPtr: PKDT56DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT56DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT56DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT56DS_Vec; const p1, p2: PKDT56DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT56DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT56DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT56DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT56DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT56DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT56DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT56DS_Node(NearestNodes[0]);
    end;
end;

function TKDT56DS.Search(const Buff: TKDT56DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT56DS.Search(const Buff: TKDT56DS_Vec; var SearchedDistanceMin: Double): PKDT56DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT56DS.Search(const Buff: TKDT56DS_Vec): PKDT56DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT56DS.Search(const inBuff: TKDT56DS_DynamicVecBuffer; var OutBuff: TKDT56DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT56DS_DynamicVecBuffer;
  outBuffPtr : PKDT56DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT56DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT56DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT56DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT56DS.Search(const inBuff: TKDT56DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT56DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT56DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT56DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT56DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT56DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT56DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT56DS_Source));
end;

procedure TKDT56DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT56DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT56DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT56DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT56DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT56DS.PrintNodeTree(const NodePtr: PKDT56DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT56DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT56DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT56DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT56DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT56DS.KDT56DSVec(const s: string): TKDT56DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT56DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT56DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT56DS.KDT56DSVec(const v: TKDT56DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT56DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT56DS.KDT56DSPow(const v: TKDT56DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT56DS.KDT56DSDistance(const v1, v2: TKDT56DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT56DS_Axis - 1 do
      Result := Result + KDT56DSPow(v2[i] - v1[i]);
end;

procedure TKDT56DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT56DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT56DS.Test;
var
  TKDT56DS_Test    : TKDT56DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT56DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT56DS_Test := TKDT56DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT56DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT56DS_Test.TestBuff) - 1 do
    for j := 0 to KDT56DS_Axis - 1 do
        TKDT56DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT56DS_Test.TestBuff), length(TKDT56DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT56DS_Test.BuildKDTreeM(length(TKDT56DS_Test.TestBuff), nil, @TKDT56DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT56DS_Test.BuildKDTreeM(length(TKDT56DS_Test.TestBuff), nil, TKDT56DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT56DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT56DS_Test.TestBuff));
  TKDT56DS_Test.Search(TKDT56DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT56DSDistance(TKDT56DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT56DS_Test.Clear;
  { kMean test }
  TKDT56DS_Test.BuildKDTreeWithCluster(TKDT56DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT56DS_Test.Search(TKDT56DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT56DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT56DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT56DS_Test);
end;


function TKDT57DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT57DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT57DS_Node;
  function SortCompare(const p1, p2: PKDT57DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT57DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT57DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT57DS_SourceBuffer;
  dynBuff  : PKDT57DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT57DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT57DS.GetData(const index: NativeInt): PKDT57DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT57DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT57DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT57DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT57DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT57DS.StoreBuffPtr: PKDT57DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT57DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT57DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT57DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT57DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT57DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT57DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT57DS.BuildKDTreeWithCluster(const inBuff: TKDT57DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT57DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT57DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT57DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT57DS.BuildKDTreeWithCluster(const inBuff: TKDT57DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT57DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DS_BuildCall);
var
  TempStoreBuff: TKDT57DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT57DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DS_BuildMethod);
var
  TempStoreBuff: TKDT57DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT57DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DS_BuildProc);
var
  TempStoreBuff: TKDT57DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT57DS.Search(const Buff: TKDT57DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT57DS_Node;

var
  NearestNeighbour: PKDT57DS_Node;

  function FindParentNode(const BuffPtr: PKDT57DS_Vec; NodePtr: PKDT57DS_Node): PKDT57DS_Node;
  var
    Next       : PKDT57DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT57DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT57DS_Node; const BuffPtr: PKDT57DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT57DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT57DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT57DS_Vec; const p1, p2: PKDT57DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT57DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT57DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT57DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT57DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT57DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT57DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT57DS_Node(NearestNodes[0]);
    end;
end;

function TKDT57DS.Search(const Buff: TKDT57DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT57DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT57DS.Search(const Buff: TKDT57DS_Vec; var SearchedDistanceMin: Double): PKDT57DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT57DS.Search(const Buff: TKDT57DS_Vec): PKDT57DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT57DS.Search(const inBuff: TKDT57DS_DynamicVecBuffer; var OutBuff: TKDT57DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT57DS_DynamicVecBuffer;
  outBuffPtr : PKDT57DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT57DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT57DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT57DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT57DS.Search(const inBuff: TKDT57DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT57DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT57DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT57DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT57DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT57DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT57DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT57DS_Source));
end;

procedure TKDT57DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT57DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT57DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT57DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT57DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT57DS.PrintNodeTree(const NodePtr: PKDT57DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT57DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT57DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT57DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT57DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT57DS.KDT57DSVec(const s: string): TKDT57DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT57DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT57DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT57DS.KDT57DSVec(const v: TKDT57DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT57DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT57DS.KDT57DSPow(const v: TKDT57DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT57DS.KDT57DSDistance(const v1, v2: TKDT57DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT57DS_Axis - 1 do
      Result := Result + KDT57DSPow(v2[i] - v1[i]);
end;

procedure TKDT57DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT57DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT57DS.Test;
var
  TKDT57DS_Test    : TKDT57DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT57DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT57DS_Test := TKDT57DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT57DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT57DS_Test.TestBuff) - 1 do
    for j := 0 to KDT57DS_Axis - 1 do
        TKDT57DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT57DS_Test.TestBuff), length(TKDT57DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT57DS_Test.BuildKDTreeM(length(TKDT57DS_Test.TestBuff), nil, @TKDT57DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT57DS_Test.BuildKDTreeM(length(TKDT57DS_Test.TestBuff), nil, TKDT57DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT57DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT57DS_Test.TestBuff));
  TKDT57DS_Test.Search(TKDT57DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT57DSDistance(TKDT57DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT57DS_Test.Clear;
  { kMean test }
  TKDT57DS_Test.BuildKDTreeWithCluster(TKDT57DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT57DS_Test.Search(TKDT57DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT57DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT57DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT57DS_Test);
end;


function TKDT58DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT58DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT58DS_Node;
  function SortCompare(const p1, p2: PKDT58DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT58DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT58DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT58DS_SourceBuffer;
  dynBuff  : PKDT58DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT58DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT58DS.GetData(const index: NativeInt): PKDT58DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT58DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT58DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT58DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT58DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT58DS.StoreBuffPtr: PKDT58DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT58DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT58DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT58DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT58DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT58DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT58DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT58DS.BuildKDTreeWithCluster(const inBuff: TKDT58DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT58DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT58DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT58DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT58DS.BuildKDTreeWithCluster(const inBuff: TKDT58DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT58DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DS_BuildCall);
var
  TempStoreBuff: TKDT58DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT58DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DS_BuildMethod);
var
  TempStoreBuff: TKDT58DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT58DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DS_BuildProc);
var
  TempStoreBuff: TKDT58DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT58DS.Search(const Buff: TKDT58DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT58DS_Node;

var
  NearestNeighbour: PKDT58DS_Node;

  function FindParentNode(const BuffPtr: PKDT58DS_Vec; NodePtr: PKDT58DS_Node): PKDT58DS_Node;
  var
    Next       : PKDT58DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT58DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT58DS_Node; const BuffPtr: PKDT58DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT58DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT58DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT58DS_Vec; const p1, p2: PKDT58DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT58DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT58DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT58DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT58DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT58DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT58DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT58DS_Node(NearestNodes[0]);
    end;
end;

function TKDT58DS.Search(const Buff: TKDT58DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT58DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT58DS.Search(const Buff: TKDT58DS_Vec; var SearchedDistanceMin: Double): PKDT58DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT58DS.Search(const Buff: TKDT58DS_Vec): PKDT58DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT58DS.Search(const inBuff: TKDT58DS_DynamicVecBuffer; var OutBuff: TKDT58DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT58DS_DynamicVecBuffer;
  outBuffPtr : PKDT58DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT58DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT58DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT58DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT58DS.Search(const inBuff: TKDT58DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT58DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT58DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT58DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT58DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT58DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT58DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT58DS_Source));
end;

procedure TKDT58DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT58DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT58DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT58DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT58DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT58DS.PrintNodeTree(const NodePtr: PKDT58DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT58DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT58DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT58DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT58DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT58DS.KDT58DSVec(const s: string): TKDT58DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT58DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT58DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT58DS.KDT58DSVec(const v: TKDT58DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT58DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT58DS.KDT58DSPow(const v: TKDT58DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT58DS.KDT58DSDistance(const v1, v2: TKDT58DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT58DS_Axis - 1 do
      Result := Result + KDT58DSPow(v2[i] - v1[i]);
end;

procedure TKDT58DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT58DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT58DS.Test;
var
  TKDT58DS_Test    : TKDT58DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT58DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT58DS_Test := TKDT58DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT58DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT58DS_Test.TestBuff) - 1 do
    for j := 0 to KDT58DS_Axis - 1 do
        TKDT58DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT58DS_Test.TestBuff), length(TKDT58DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT58DS_Test.BuildKDTreeM(length(TKDT58DS_Test.TestBuff), nil, @TKDT58DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT58DS_Test.BuildKDTreeM(length(TKDT58DS_Test.TestBuff), nil, TKDT58DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT58DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT58DS_Test.TestBuff));
  TKDT58DS_Test.Search(TKDT58DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT58DSDistance(TKDT58DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT58DS_Test.Clear;
  { kMean test }
  TKDT58DS_Test.BuildKDTreeWithCluster(TKDT58DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT58DS_Test.Search(TKDT58DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT58DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT58DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT58DS_Test);
end;


function TKDT59DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT59DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT59DS_Node;
  function SortCompare(const p1, p2: PKDT59DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT59DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT59DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT59DS_SourceBuffer;
  dynBuff  : PKDT59DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT59DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT59DS.GetData(const index: NativeInt): PKDT59DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT59DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT59DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT59DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT59DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT59DS.StoreBuffPtr: PKDT59DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT59DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT59DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT59DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT59DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT59DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT59DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT59DS.BuildKDTreeWithCluster(const inBuff: TKDT59DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT59DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT59DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT59DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT59DS.BuildKDTreeWithCluster(const inBuff: TKDT59DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT59DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DS_BuildCall);
var
  TempStoreBuff: TKDT59DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT59DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DS_BuildMethod);
var
  TempStoreBuff: TKDT59DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT59DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DS_BuildProc);
var
  TempStoreBuff: TKDT59DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT59DS.Search(const Buff: TKDT59DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT59DS_Node;

var
  NearestNeighbour: PKDT59DS_Node;

  function FindParentNode(const BuffPtr: PKDT59DS_Vec; NodePtr: PKDT59DS_Node): PKDT59DS_Node;
  var
    Next       : PKDT59DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT59DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT59DS_Node; const BuffPtr: PKDT59DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT59DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT59DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT59DS_Vec; const p1, p2: PKDT59DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT59DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT59DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT59DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT59DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT59DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT59DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT59DS_Node(NearestNodes[0]);
    end;
end;

function TKDT59DS.Search(const Buff: TKDT59DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT59DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT59DS.Search(const Buff: TKDT59DS_Vec; var SearchedDistanceMin: Double): PKDT59DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT59DS.Search(const Buff: TKDT59DS_Vec): PKDT59DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT59DS.Search(const inBuff: TKDT59DS_DynamicVecBuffer; var OutBuff: TKDT59DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT59DS_DynamicVecBuffer;
  outBuffPtr : PKDT59DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT59DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT59DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT59DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT59DS.Search(const inBuff: TKDT59DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT59DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT59DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT59DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT59DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT59DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT59DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT59DS_Source));
end;

procedure TKDT59DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT59DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT59DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT59DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT59DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT59DS.PrintNodeTree(const NodePtr: PKDT59DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT59DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT59DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT59DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT59DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT59DS.KDT59DSVec(const s: string): TKDT59DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT59DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT59DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT59DS.KDT59DSVec(const v: TKDT59DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT59DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT59DS.KDT59DSPow(const v: TKDT59DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT59DS.KDT59DSDistance(const v1, v2: TKDT59DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT59DS_Axis - 1 do
      Result := Result + KDT59DSPow(v2[i] - v1[i]);
end;

procedure TKDT59DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT59DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT59DS.Test;
var
  TKDT59DS_Test    : TKDT59DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT59DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT59DS_Test := TKDT59DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT59DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT59DS_Test.TestBuff) - 1 do
    for j := 0 to KDT59DS_Axis - 1 do
        TKDT59DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT59DS_Test.TestBuff), length(TKDT59DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT59DS_Test.BuildKDTreeM(length(TKDT59DS_Test.TestBuff), nil, @TKDT59DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT59DS_Test.BuildKDTreeM(length(TKDT59DS_Test.TestBuff), nil, TKDT59DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT59DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT59DS_Test.TestBuff));
  TKDT59DS_Test.Search(TKDT59DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT59DSDistance(TKDT59DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT59DS_Test.Clear;
  { kMean test }
  TKDT59DS_Test.BuildKDTreeWithCluster(TKDT59DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT59DS_Test.Search(TKDT59DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT59DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT59DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT59DS_Test);
end;


function TKDT60DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DS_Node;
  function SortCompare(const p1, p2: PKDT60DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT60DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT60DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT60DS_SourceBuffer;
  dynBuff  : PKDT60DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT60DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT60DS.GetData(const index: NativeInt): PKDT60DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT60DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT60DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT60DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT60DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT60DS.StoreBuffPtr: PKDT60DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT60DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT60DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT60DS.BuildKDTreeWithCluster(const inBuff: TKDT60DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT60DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT60DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT60DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT60DS.BuildKDTreeWithCluster(const inBuff: TKDT60DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT60DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DS_BuildCall);
var
  TempStoreBuff: TKDT60DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DS_BuildMethod);
var
  TempStoreBuff: TKDT60DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DS_BuildProc);
var
  TempStoreBuff: TKDT60DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT60DS.Search(const Buff: TKDT60DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DS_Node;

var
  NearestNeighbour: PKDT60DS_Node;

  function FindParentNode(const BuffPtr: PKDT60DS_Vec; NodePtr: PKDT60DS_Node): PKDT60DS_Node;
  var
    Next       : PKDT60DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT60DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT60DS_Node; const BuffPtr: PKDT60DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT60DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT60DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT60DS_Vec; const p1, p2: PKDT60DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT60DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT60DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT60DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT60DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT60DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT60DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT60DS_Node(NearestNodes[0]);
    end;
end;

function TKDT60DS.Search(const Buff: TKDT60DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT60DS.Search(const Buff: TKDT60DS_Vec; var SearchedDistanceMin: Double): PKDT60DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT60DS.Search(const Buff: TKDT60DS_Vec): PKDT60DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT60DS.Search(const inBuff: TKDT60DS_DynamicVecBuffer; var OutBuff: TKDT60DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT60DS_DynamicVecBuffer;
  outBuffPtr : PKDT60DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT60DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT60DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT60DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT60DS.Search(const inBuff: TKDT60DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT60DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT60DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT60DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT60DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT60DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT60DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT60DS_Source));
end;

procedure TKDT60DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT60DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT60DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT60DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT60DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT60DS.PrintNodeTree(const NodePtr: PKDT60DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT60DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT60DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT60DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT60DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT60DS.KDT60DSVec(const s: string): TKDT60DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT60DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT60DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT60DS.KDT60DSVec(const v: TKDT60DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT60DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT60DS.KDT60DSPow(const v: TKDT60DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT60DS.KDT60DSDistance(const v1, v2: TKDT60DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT60DS_Axis - 1 do
      Result := Result + KDT60DSPow(v2[i] - v1[i]);
end;

procedure TKDT60DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT60DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT60DS.Test;
var
  TKDT60DS_Test    : TKDT60DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT60DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT60DS_Test := TKDT60DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT60DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT60DS_Test.TestBuff) - 1 do
    for j := 0 to KDT60DS_Axis - 1 do
        TKDT60DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT60DS_Test.TestBuff), length(TKDT60DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT60DS_Test.BuildKDTreeM(length(TKDT60DS_Test.TestBuff), nil, @TKDT60DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT60DS_Test.BuildKDTreeM(length(TKDT60DS_Test.TestBuff), nil, TKDT60DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT60DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT60DS_Test.TestBuff));
  TKDT60DS_Test.Search(TKDT60DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT60DSDistance(TKDT60DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT60DS_Test.Clear;
  { kMean test }
  TKDT60DS_Test.BuildKDTreeWithCluster(TKDT60DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT60DS_Test.Search(TKDT60DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT60DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT60DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT60DS_Test);
end;


function TKDT61DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT61DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT61DS_Node;
  function SortCompare(const p1, p2: PKDT61DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT61DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT61DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT61DS_SourceBuffer;
  dynBuff  : PKDT61DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT61DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT61DS.GetData(const index: NativeInt): PKDT61DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT61DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT61DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT61DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT61DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT61DS.StoreBuffPtr: PKDT61DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT61DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT61DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT61DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT61DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT61DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT61DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT61DS.BuildKDTreeWithCluster(const inBuff: TKDT61DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT61DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT61DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT61DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT61DS.BuildKDTreeWithCluster(const inBuff: TKDT61DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT61DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DS_BuildCall);
var
  TempStoreBuff: TKDT61DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT61DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DS_BuildMethod);
var
  TempStoreBuff: TKDT61DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT61DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DS_BuildProc);
var
  TempStoreBuff: TKDT61DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT61DS.Search(const Buff: TKDT61DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT61DS_Node;

var
  NearestNeighbour: PKDT61DS_Node;

  function FindParentNode(const BuffPtr: PKDT61DS_Vec; NodePtr: PKDT61DS_Node): PKDT61DS_Node;
  var
    Next       : PKDT61DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT61DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT61DS_Node; const BuffPtr: PKDT61DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT61DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT61DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT61DS_Vec; const p1, p2: PKDT61DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT61DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT61DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT61DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT61DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT61DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT61DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT61DS_Node(NearestNodes[0]);
    end;
end;

function TKDT61DS.Search(const Buff: TKDT61DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT61DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT61DS.Search(const Buff: TKDT61DS_Vec; var SearchedDistanceMin: Double): PKDT61DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT61DS.Search(const Buff: TKDT61DS_Vec): PKDT61DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT61DS.Search(const inBuff: TKDT61DS_DynamicVecBuffer; var OutBuff: TKDT61DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT61DS_DynamicVecBuffer;
  outBuffPtr : PKDT61DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT61DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT61DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT61DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT61DS.Search(const inBuff: TKDT61DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT61DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT61DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT61DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT61DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT61DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT61DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT61DS_Source));
end;

procedure TKDT61DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT61DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT61DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT61DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT61DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT61DS.PrintNodeTree(const NodePtr: PKDT61DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT61DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT61DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT61DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT61DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT61DS.KDT61DSVec(const s: string): TKDT61DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT61DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT61DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT61DS.KDT61DSVec(const v: TKDT61DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT61DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT61DS.KDT61DSPow(const v: TKDT61DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT61DS.KDT61DSDistance(const v1, v2: TKDT61DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT61DS_Axis - 1 do
      Result := Result + KDT61DSPow(v2[i] - v1[i]);
end;

procedure TKDT61DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT61DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT61DS.Test;
var
  TKDT61DS_Test    : TKDT61DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT61DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT61DS_Test := TKDT61DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT61DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT61DS_Test.TestBuff) - 1 do
    for j := 0 to KDT61DS_Axis - 1 do
        TKDT61DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT61DS_Test.TestBuff), length(TKDT61DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT61DS_Test.BuildKDTreeM(length(TKDT61DS_Test.TestBuff), nil, @TKDT61DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT61DS_Test.BuildKDTreeM(length(TKDT61DS_Test.TestBuff), nil, TKDT61DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT61DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT61DS_Test.TestBuff));
  TKDT61DS_Test.Search(TKDT61DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT61DSDistance(TKDT61DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT61DS_Test.Clear;
  { kMean test }
  TKDT61DS_Test.BuildKDTreeWithCluster(TKDT61DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT61DS_Test.Search(TKDT61DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT61DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT61DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT61DS_Test);
end;


function TKDT62DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT62DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT62DS_Node;
  function SortCompare(const p1, p2: PKDT62DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT62DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT62DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT62DS_SourceBuffer;
  dynBuff  : PKDT62DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT62DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT62DS.GetData(const index: NativeInt): PKDT62DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT62DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT62DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT62DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT62DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT62DS.StoreBuffPtr: PKDT62DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT62DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT62DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT62DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT62DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT62DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT62DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT62DS.BuildKDTreeWithCluster(const inBuff: TKDT62DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT62DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT62DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT62DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT62DS.BuildKDTreeWithCluster(const inBuff: TKDT62DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT62DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DS_BuildCall);
var
  TempStoreBuff: TKDT62DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT62DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DS_BuildMethod);
var
  TempStoreBuff: TKDT62DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT62DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DS_BuildProc);
var
  TempStoreBuff: TKDT62DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT62DS.Search(const Buff: TKDT62DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT62DS_Node;

var
  NearestNeighbour: PKDT62DS_Node;

  function FindParentNode(const BuffPtr: PKDT62DS_Vec; NodePtr: PKDT62DS_Node): PKDT62DS_Node;
  var
    Next       : PKDT62DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT62DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT62DS_Node; const BuffPtr: PKDT62DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT62DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT62DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT62DS_Vec; const p1, p2: PKDT62DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT62DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT62DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT62DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT62DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT62DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT62DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT62DS_Node(NearestNodes[0]);
    end;
end;

function TKDT62DS.Search(const Buff: TKDT62DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT62DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT62DS.Search(const Buff: TKDT62DS_Vec; var SearchedDistanceMin: Double): PKDT62DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT62DS.Search(const Buff: TKDT62DS_Vec): PKDT62DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT62DS.Search(const inBuff: TKDT62DS_DynamicVecBuffer; var OutBuff: TKDT62DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT62DS_DynamicVecBuffer;
  outBuffPtr : PKDT62DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT62DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT62DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT62DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT62DS.Search(const inBuff: TKDT62DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT62DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT62DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT62DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT62DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT62DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT62DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT62DS_Source));
end;

procedure TKDT62DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT62DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT62DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT62DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT62DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT62DS.PrintNodeTree(const NodePtr: PKDT62DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT62DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT62DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT62DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT62DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT62DS.KDT62DSVec(const s: string): TKDT62DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT62DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT62DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT62DS.KDT62DSVec(const v: TKDT62DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT62DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT62DS.KDT62DSPow(const v: TKDT62DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT62DS.KDT62DSDistance(const v1, v2: TKDT62DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT62DS_Axis - 1 do
      Result := Result + KDT62DSPow(v2[i] - v1[i]);
end;

procedure TKDT62DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT62DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT62DS.Test;
var
  TKDT62DS_Test    : TKDT62DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT62DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT62DS_Test := TKDT62DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT62DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT62DS_Test.TestBuff) - 1 do
    for j := 0 to KDT62DS_Axis - 1 do
        TKDT62DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT62DS_Test.TestBuff), length(TKDT62DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT62DS_Test.BuildKDTreeM(length(TKDT62DS_Test.TestBuff), nil, @TKDT62DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT62DS_Test.BuildKDTreeM(length(TKDT62DS_Test.TestBuff), nil, TKDT62DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT62DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT62DS_Test.TestBuff));
  TKDT62DS_Test.Search(TKDT62DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT62DSDistance(TKDT62DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT62DS_Test.Clear;
  { kMean test }
  TKDT62DS_Test.BuildKDTreeWithCluster(TKDT62DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT62DS_Test.Search(TKDT62DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT62DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT62DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT62DS_Test);
end;


function TKDT63DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT63DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT63DS_Node;
  function SortCompare(const p1, p2: PKDT63DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT63DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT63DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT63DS_SourceBuffer;
  dynBuff  : PKDT63DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT63DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT63DS.GetData(const index: NativeInt): PKDT63DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT63DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT63DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT63DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT63DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT63DS.StoreBuffPtr: PKDT63DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT63DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT63DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT63DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT63DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT63DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT63DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT63DS.BuildKDTreeWithCluster(const inBuff: TKDT63DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT63DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT63DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT63DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT63DS.BuildKDTreeWithCluster(const inBuff: TKDT63DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT63DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DS_BuildCall);
var
  TempStoreBuff: TKDT63DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT63DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DS_BuildMethod);
var
  TempStoreBuff: TKDT63DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT63DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DS_BuildProc);
var
  TempStoreBuff: TKDT63DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT63DS.Search(const Buff: TKDT63DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT63DS_Node;

var
  NearestNeighbour: PKDT63DS_Node;

  function FindParentNode(const BuffPtr: PKDT63DS_Vec; NodePtr: PKDT63DS_Node): PKDT63DS_Node;
  var
    Next       : PKDT63DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT63DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT63DS_Node; const BuffPtr: PKDT63DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT63DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT63DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT63DS_Vec; const p1, p2: PKDT63DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT63DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT63DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT63DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT63DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT63DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT63DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT63DS_Node(NearestNodes[0]);
    end;
end;

function TKDT63DS.Search(const Buff: TKDT63DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT63DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT63DS.Search(const Buff: TKDT63DS_Vec; var SearchedDistanceMin: Double): PKDT63DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT63DS.Search(const Buff: TKDT63DS_Vec): PKDT63DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT63DS.Search(const inBuff: TKDT63DS_DynamicVecBuffer; var OutBuff: TKDT63DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT63DS_DynamicVecBuffer;
  outBuffPtr : PKDT63DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT63DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT63DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT63DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT63DS.Search(const inBuff: TKDT63DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT63DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT63DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT63DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT63DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT63DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT63DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT63DS_Source));
end;

procedure TKDT63DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT63DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT63DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT63DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT63DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT63DS.PrintNodeTree(const NodePtr: PKDT63DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT63DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT63DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT63DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT63DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT63DS.KDT63DSVec(const s: string): TKDT63DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT63DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT63DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT63DS.KDT63DSVec(const v: TKDT63DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT63DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT63DS.KDT63DSPow(const v: TKDT63DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT63DS.KDT63DSDistance(const v1, v2: TKDT63DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT63DS_Axis - 1 do
      Result := Result + KDT63DSPow(v2[i] - v1[i]);
end;

procedure TKDT63DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT63DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT63DS.Test;
var
  TKDT63DS_Test    : TKDT63DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT63DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT63DS_Test := TKDT63DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT63DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT63DS_Test.TestBuff) - 1 do
    for j := 0 to KDT63DS_Axis - 1 do
        TKDT63DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT63DS_Test.TestBuff), length(TKDT63DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT63DS_Test.BuildKDTreeM(length(TKDT63DS_Test.TestBuff), nil, @TKDT63DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT63DS_Test.BuildKDTreeM(length(TKDT63DS_Test.TestBuff), nil, TKDT63DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT63DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT63DS_Test.TestBuff));
  TKDT63DS_Test.Search(TKDT63DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT63DSDistance(TKDT63DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT63DS_Test.Clear;
  { kMean test }
  TKDT63DS_Test.BuildKDTreeWithCluster(TKDT63DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT63DS_Test.Search(TKDT63DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT63DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT63DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT63DS_Test);
end;


function TKDT64DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DS_Node;
  function SortCompare(const p1, p2: PKDT64DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT64DS_SourceBuffer;
  dynBuff  : PKDT64DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT64DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DS.GetData(const index: NativeInt): PKDT64DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT64DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DS.StoreBuffPtr: PKDT64DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT64DS.BuildKDTreeWithCluster(const inBuff: TKDT64DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT64DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT64DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT64DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DS.BuildKDTreeWithCluster(const inBuff: TKDT64DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DS_BuildCall);
var
  TempStoreBuff: TKDT64DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DS_BuildMethod);
var
  TempStoreBuff: TKDT64DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DS_BuildProc);
var
  TempStoreBuff: TKDT64DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT64DS.Search(const Buff: TKDT64DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DS_Node;

var
  NearestNeighbour: PKDT64DS_Node;

  function FindParentNode(const BuffPtr: PKDT64DS_Vec; NodePtr: PKDT64DS_Node): PKDT64DS_Node;
  var
    Next       : PKDT64DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT64DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DS_Node; const BuffPtr: PKDT64DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT64DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT64DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT64DS_Vec; const p1, p2: PKDT64DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT64DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT64DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT64DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT64DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT64DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DS_Node(NearestNodes[0]);
    end;
end;

function TKDT64DS.Search(const Buff: TKDT64DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DS.Search(const Buff: TKDT64DS_Vec; var SearchedDistanceMin: Double): PKDT64DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DS.Search(const Buff: TKDT64DS_Vec): PKDT64DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT64DS.Search(const inBuff: TKDT64DS_DynamicVecBuffer; var OutBuff: TKDT64DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DS_DynamicVecBuffer;
  outBuffPtr : PKDT64DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DS.Search(const inBuff: TKDT64DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT64DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT64DS_Source));
end;

procedure TKDT64DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT64DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT64DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DS.PrintNodeTree(const NodePtr: PKDT64DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT64DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT64DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT64DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT64DS.KDT64DSVec(const s: string): TKDT64DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT64DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT64DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT64DS.KDT64DSVec(const v: TKDT64DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT64DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT64DS.KDT64DSPow(const v: TKDT64DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT64DS.KDT64DSDistance(const v1, v2: TKDT64DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT64DS_Axis - 1 do
      Result := Result + KDT64DSPow(v2[i] - v1[i]);
end;

procedure TKDT64DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT64DS.Test;
var
  TKDT64DS_Test    : TKDT64DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT64DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT64DS_Test := TKDT64DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT64DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT64DS_Test.TestBuff) - 1 do
    for j := 0 to KDT64DS_Axis - 1 do
        TKDT64DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT64DS_Test.TestBuff), length(TKDT64DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT64DS_Test.BuildKDTreeM(length(TKDT64DS_Test.TestBuff), nil, @TKDT64DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT64DS_Test.BuildKDTreeM(length(TKDT64DS_Test.TestBuff), nil, TKDT64DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT64DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT64DS_Test.TestBuff));
  TKDT64DS_Test.Search(TKDT64DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT64DSDistance(TKDT64DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT64DS_Test.Clear;
  { kMean test }
  TKDT64DS_Test.BuildKDTreeWithCluster(TKDT64DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT64DS_Test.Search(TKDT64DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT64DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT64DS_Test);
end;


function TKDT65DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT65DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT65DS_Node;
  function SortCompare(const p1, p2: PKDT65DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT65DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT65DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT65DS_SourceBuffer;
  dynBuff  : PKDT65DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT65DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT65DS.GetData(const index: NativeInt): PKDT65DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT65DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT65DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT65DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT65DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT65DS.StoreBuffPtr: PKDT65DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT65DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT65DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT65DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT65DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT65DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT65DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT65DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT65DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT65DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT65DS.BuildKDTreeWithCluster(const inBuff: TKDT65DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT65DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT65DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT65DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT65DS.BuildKDTreeWithCluster(const inBuff: TKDT65DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT65DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DS_BuildCall);
var
  TempStoreBuff: TKDT65DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT65DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT65DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT65DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT65DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT65DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DS_BuildMethod);
var
  TempStoreBuff: TKDT65DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT65DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT65DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT65DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT65DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT65DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DS_BuildProc);
var
  TempStoreBuff: TKDT65DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT65DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT65DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT65DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT65DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT65DS.Search(const Buff: TKDT65DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT65DS_Node;

var
  NearestNeighbour: PKDT65DS_Node;

  function FindParentNode(const BuffPtr: PKDT65DS_Vec; NodePtr: PKDT65DS_Node): PKDT65DS_Node;
  var
    Next       : PKDT65DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT65DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT65DS_Node; const BuffPtr: PKDT65DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT65DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT65DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT65DS_Vec; const p1, p2: PKDT65DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT65DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT65DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT65DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT65DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT65DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT65DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT65DS_Node(NearestNodes[0]);
    end;
end;

function TKDT65DS.Search(const Buff: TKDT65DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT65DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT65DS.Search(const Buff: TKDT65DS_Vec; var SearchedDistanceMin: Double): PKDT65DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT65DS.Search(const Buff: TKDT65DS_Vec): PKDT65DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT65DS.Search(const inBuff: TKDT65DS_DynamicVecBuffer; var OutBuff: TKDT65DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT65DS_DynamicVecBuffer;
  outBuffPtr : PKDT65DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT65DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT65DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT65DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT65DS.Search(const inBuff: TKDT65DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT65DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT65DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT65DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT65DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT65DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT65DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT65DS_Source));
end;

procedure TKDT65DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT65DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT65DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT65DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT65DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT65DS.PrintNodeTree(const NodePtr: PKDT65DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT65DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT65DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT65DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT65DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT65DS.KDT65DSVec(const s: string): TKDT65DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT65DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT65DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT65DS.KDT65DSVec(const v: TKDT65DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT65DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT65DS.KDT65DSPow(const v: TKDT65DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT65DS.KDT65DSDistance(const v1, v2: TKDT65DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT65DS_Axis - 1 do
      Result := Result + KDT65DSPow(v2[i] - v1[i]);
end;

procedure TKDT65DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT65DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT65DS.Test;
var
  TKDT65DS_Test    : TKDT65DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT65DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT65DS_Test := TKDT65DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT65DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT65DS_Test.TestBuff) - 1 do
    for j := 0 to KDT65DS_Axis - 1 do
        TKDT65DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT65DS_Test.TestBuff), length(TKDT65DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT65DS_Test.BuildKDTreeM(length(TKDT65DS_Test.TestBuff), nil, @TKDT65DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT65DS_Test.BuildKDTreeM(length(TKDT65DS_Test.TestBuff), nil, TKDT65DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT65DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT65DS_Test.TestBuff));
  TKDT65DS_Test.Search(TKDT65DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT65DSDistance(TKDT65DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT65DS_Test.Clear;
  { kMean test }
  TKDT65DS_Test.BuildKDTreeWithCluster(TKDT65DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT65DS_Test.Search(TKDT65DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT65DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT65DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT65DS_Test);
end;


function TKDT66DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT66DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT66DS_Node;
  function SortCompare(const p1, p2: PKDT66DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT66DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT66DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT66DS_SourceBuffer;
  dynBuff  : PKDT66DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT66DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT66DS.GetData(const index: NativeInt): PKDT66DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT66DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT66DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT66DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT66DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT66DS.StoreBuffPtr: PKDT66DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT66DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT66DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT66DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT66DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT66DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT66DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT66DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT66DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT66DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT66DS.BuildKDTreeWithCluster(const inBuff: TKDT66DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT66DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT66DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT66DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT66DS.BuildKDTreeWithCluster(const inBuff: TKDT66DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT66DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DS_BuildCall);
var
  TempStoreBuff: TKDT66DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT66DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT66DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT66DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT66DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT66DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DS_BuildMethod);
var
  TempStoreBuff: TKDT66DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT66DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT66DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT66DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT66DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT66DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DS_BuildProc);
var
  TempStoreBuff: TKDT66DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT66DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT66DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT66DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT66DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT66DS.Search(const Buff: TKDT66DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT66DS_Node;

var
  NearestNeighbour: PKDT66DS_Node;

  function FindParentNode(const BuffPtr: PKDT66DS_Vec; NodePtr: PKDT66DS_Node): PKDT66DS_Node;
  var
    Next       : PKDT66DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT66DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT66DS_Node; const BuffPtr: PKDT66DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT66DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT66DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT66DS_Vec; const p1, p2: PKDT66DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT66DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT66DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT66DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT66DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT66DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT66DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT66DS_Node(NearestNodes[0]);
    end;
end;

function TKDT66DS.Search(const Buff: TKDT66DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT66DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT66DS.Search(const Buff: TKDT66DS_Vec; var SearchedDistanceMin: Double): PKDT66DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT66DS.Search(const Buff: TKDT66DS_Vec): PKDT66DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT66DS.Search(const inBuff: TKDT66DS_DynamicVecBuffer; var OutBuff: TKDT66DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT66DS_DynamicVecBuffer;
  outBuffPtr : PKDT66DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT66DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT66DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT66DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT66DS.Search(const inBuff: TKDT66DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT66DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT66DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT66DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT66DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT66DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT66DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT66DS_Source));
end;

procedure TKDT66DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT66DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT66DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT66DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT66DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT66DS.PrintNodeTree(const NodePtr: PKDT66DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT66DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT66DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT66DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT66DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT66DS.KDT66DSVec(const s: string): TKDT66DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT66DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT66DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT66DS.KDT66DSVec(const v: TKDT66DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT66DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT66DS.KDT66DSPow(const v: TKDT66DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT66DS.KDT66DSDistance(const v1, v2: TKDT66DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT66DS_Axis - 1 do
      Result := Result + KDT66DSPow(v2[i] - v1[i]);
end;

procedure TKDT66DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT66DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT66DS.Test;
var
  TKDT66DS_Test    : TKDT66DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT66DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT66DS_Test := TKDT66DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT66DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT66DS_Test.TestBuff) - 1 do
    for j := 0 to KDT66DS_Axis - 1 do
        TKDT66DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT66DS_Test.TestBuff), length(TKDT66DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT66DS_Test.BuildKDTreeM(length(TKDT66DS_Test.TestBuff), nil, @TKDT66DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT66DS_Test.BuildKDTreeM(length(TKDT66DS_Test.TestBuff), nil, TKDT66DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT66DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT66DS_Test.TestBuff));
  TKDT66DS_Test.Search(TKDT66DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT66DSDistance(TKDT66DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT66DS_Test.Clear;
  { kMean test }
  TKDT66DS_Test.BuildKDTreeWithCluster(TKDT66DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT66DS_Test.Search(TKDT66DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT66DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT66DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT66DS_Test);
end;


function TKDT67DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT67DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT67DS_Node;
  function SortCompare(const p1, p2: PKDT67DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT67DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT67DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT67DS_SourceBuffer;
  dynBuff  : PKDT67DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT67DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT67DS.GetData(const index: NativeInt): PKDT67DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT67DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT67DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT67DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT67DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT67DS.StoreBuffPtr: PKDT67DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT67DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT67DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT67DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT67DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT67DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT67DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT67DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT67DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT67DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT67DS.BuildKDTreeWithCluster(const inBuff: TKDT67DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT67DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT67DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT67DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT67DS.BuildKDTreeWithCluster(const inBuff: TKDT67DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT67DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DS_BuildCall);
var
  TempStoreBuff: TKDT67DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT67DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT67DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT67DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT67DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT67DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DS_BuildMethod);
var
  TempStoreBuff: TKDT67DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT67DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT67DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT67DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT67DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT67DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DS_BuildProc);
var
  TempStoreBuff: TKDT67DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT67DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT67DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT67DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT67DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT67DS.Search(const Buff: TKDT67DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT67DS_Node;

var
  NearestNeighbour: PKDT67DS_Node;

  function FindParentNode(const BuffPtr: PKDT67DS_Vec; NodePtr: PKDT67DS_Node): PKDT67DS_Node;
  var
    Next       : PKDT67DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT67DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT67DS_Node; const BuffPtr: PKDT67DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT67DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT67DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT67DS_Vec; const p1, p2: PKDT67DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT67DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT67DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT67DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT67DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT67DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT67DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT67DS_Node(NearestNodes[0]);
    end;
end;

function TKDT67DS.Search(const Buff: TKDT67DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT67DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT67DS.Search(const Buff: TKDT67DS_Vec; var SearchedDistanceMin: Double): PKDT67DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT67DS.Search(const Buff: TKDT67DS_Vec): PKDT67DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT67DS.Search(const inBuff: TKDT67DS_DynamicVecBuffer; var OutBuff: TKDT67DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT67DS_DynamicVecBuffer;
  outBuffPtr : PKDT67DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT67DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT67DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT67DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT67DS.Search(const inBuff: TKDT67DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT67DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT67DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT67DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT67DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT67DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT67DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT67DS_Source));
end;

procedure TKDT67DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT67DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT67DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT67DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT67DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT67DS.PrintNodeTree(const NodePtr: PKDT67DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT67DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT67DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT67DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT67DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT67DS.KDT67DSVec(const s: string): TKDT67DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT67DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT67DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT67DS.KDT67DSVec(const v: TKDT67DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT67DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT67DS.KDT67DSPow(const v: TKDT67DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT67DS.KDT67DSDistance(const v1, v2: TKDT67DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT67DS_Axis - 1 do
      Result := Result + KDT67DSPow(v2[i] - v1[i]);
end;

procedure TKDT67DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT67DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT67DS.Test;
var
  TKDT67DS_Test    : TKDT67DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT67DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT67DS_Test := TKDT67DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT67DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT67DS_Test.TestBuff) - 1 do
    for j := 0 to KDT67DS_Axis - 1 do
        TKDT67DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT67DS_Test.TestBuff), length(TKDT67DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT67DS_Test.BuildKDTreeM(length(TKDT67DS_Test.TestBuff), nil, @TKDT67DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT67DS_Test.BuildKDTreeM(length(TKDT67DS_Test.TestBuff), nil, TKDT67DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT67DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT67DS_Test.TestBuff));
  TKDT67DS_Test.Search(TKDT67DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT67DSDistance(TKDT67DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT67DS_Test.Clear;
  { kMean test }
  TKDT67DS_Test.BuildKDTreeWithCluster(TKDT67DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT67DS_Test.Search(TKDT67DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT67DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT67DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT67DS_Test);
end;


function TKDT68DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT68DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT68DS_Node;
  function SortCompare(const p1, p2: PKDT68DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT68DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT68DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT68DS_SourceBuffer;
  dynBuff  : PKDT68DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT68DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT68DS.GetData(const index: NativeInt): PKDT68DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT68DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT68DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT68DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT68DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT68DS.StoreBuffPtr: PKDT68DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT68DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT68DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT68DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT68DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT68DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT68DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT68DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT68DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT68DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT68DS.BuildKDTreeWithCluster(const inBuff: TKDT68DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT68DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT68DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT68DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT68DS.BuildKDTreeWithCluster(const inBuff: TKDT68DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT68DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DS_BuildCall);
var
  TempStoreBuff: TKDT68DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT68DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT68DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT68DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT68DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT68DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DS_BuildMethod);
var
  TempStoreBuff: TKDT68DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT68DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT68DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT68DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT68DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT68DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DS_BuildProc);
var
  TempStoreBuff: TKDT68DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT68DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT68DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT68DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT68DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT68DS.Search(const Buff: TKDT68DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT68DS_Node;

var
  NearestNeighbour: PKDT68DS_Node;

  function FindParentNode(const BuffPtr: PKDT68DS_Vec; NodePtr: PKDT68DS_Node): PKDT68DS_Node;
  var
    Next       : PKDT68DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT68DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT68DS_Node; const BuffPtr: PKDT68DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT68DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT68DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT68DS_Vec; const p1, p2: PKDT68DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT68DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT68DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT68DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT68DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT68DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT68DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT68DS_Node(NearestNodes[0]);
    end;
end;

function TKDT68DS.Search(const Buff: TKDT68DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT68DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT68DS.Search(const Buff: TKDT68DS_Vec; var SearchedDistanceMin: Double): PKDT68DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT68DS.Search(const Buff: TKDT68DS_Vec): PKDT68DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT68DS.Search(const inBuff: TKDT68DS_DynamicVecBuffer; var OutBuff: TKDT68DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT68DS_DynamicVecBuffer;
  outBuffPtr : PKDT68DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT68DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT68DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT68DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT68DS.Search(const inBuff: TKDT68DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT68DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT68DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT68DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT68DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT68DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT68DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT68DS_Source));
end;

procedure TKDT68DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT68DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT68DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT68DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT68DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT68DS.PrintNodeTree(const NodePtr: PKDT68DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT68DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT68DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT68DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT68DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT68DS.KDT68DSVec(const s: string): TKDT68DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT68DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT68DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT68DS.KDT68DSVec(const v: TKDT68DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT68DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT68DS.KDT68DSPow(const v: TKDT68DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT68DS.KDT68DSDistance(const v1, v2: TKDT68DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT68DS_Axis - 1 do
      Result := Result + KDT68DSPow(v2[i] - v1[i]);
end;

procedure TKDT68DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT68DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT68DS.Test;
var
  TKDT68DS_Test    : TKDT68DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT68DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT68DS_Test := TKDT68DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT68DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT68DS_Test.TestBuff) - 1 do
    for j := 0 to KDT68DS_Axis - 1 do
        TKDT68DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT68DS_Test.TestBuff), length(TKDT68DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT68DS_Test.BuildKDTreeM(length(TKDT68DS_Test.TestBuff), nil, @TKDT68DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT68DS_Test.BuildKDTreeM(length(TKDT68DS_Test.TestBuff), nil, TKDT68DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT68DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT68DS_Test.TestBuff));
  TKDT68DS_Test.Search(TKDT68DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT68DSDistance(TKDT68DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT68DS_Test.Clear;
  { kMean test }
  TKDT68DS_Test.BuildKDTreeWithCluster(TKDT68DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT68DS_Test.Search(TKDT68DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT68DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT68DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT68DS_Test);
end;


function TKDT69DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT69DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT69DS_Node;
  function SortCompare(const p1, p2: PKDT69DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT69DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT69DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT69DS_SourceBuffer;
  dynBuff  : PKDT69DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT69DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT69DS.GetData(const index: NativeInt): PKDT69DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT69DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT69DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT69DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT69DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT69DS.StoreBuffPtr: PKDT69DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT69DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT69DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT69DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT69DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT69DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT69DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT69DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT69DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT69DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT69DS.BuildKDTreeWithCluster(const inBuff: TKDT69DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT69DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT69DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT69DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT69DS.BuildKDTreeWithCluster(const inBuff: TKDT69DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT69DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DS_BuildCall);
var
  TempStoreBuff: TKDT69DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT69DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT69DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT69DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT69DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT69DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DS_BuildMethod);
var
  TempStoreBuff: TKDT69DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT69DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT69DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT69DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT69DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT69DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DS_BuildProc);
var
  TempStoreBuff: TKDT69DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT69DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT69DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT69DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT69DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT69DS.Search(const Buff: TKDT69DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT69DS_Node;

var
  NearestNeighbour: PKDT69DS_Node;

  function FindParentNode(const BuffPtr: PKDT69DS_Vec; NodePtr: PKDT69DS_Node): PKDT69DS_Node;
  var
    Next       : PKDT69DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT69DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT69DS_Node; const BuffPtr: PKDT69DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT69DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT69DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT69DS_Vec; const p1, p2: PKDT69DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT69DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT69DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT69DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT69DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT69DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT69DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT69DS_Node(NearestNodes[0]);
    end;
end;

function TKDT69DS.Search(const Buff: TKDT69DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT69DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT69DS.Search(const Buff: TKDT69DS_Vec; var SearchedDistanceMin: Double): PKDT69DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT69DS.Search(const Buff: TKDT69DS_Vec): PKDT69DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT69DS.Search(const inBuff: TKDT69DS_DynamicVecBuffer; var OutBuff: TKDT69DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT69DS_DynamicVecBuffer;
  outBuffPtr : PKDT69DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT69DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT69DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT69DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT69DS.Search(const inBuff: TKDT69DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT69DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT69DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT69DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT69DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT69DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT69DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT69DS_Source));
end;

procedure TKDT69DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT69DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT69DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT69DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT69DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT69DS.PrintNodeTree(const NodePtr: PKDT69DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT69DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT69DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT69DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT69DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT69DS.KDT69DSVec(const s: string): TKDT69DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT69DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT69DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT69DS.KDT69DSVec(const v: TKDT69DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT69DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT69DS.KDT69DSPow(const v: TKDT69DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT69DS.KDT69DSDistance(const v1, v2: TKDT69DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT69DS_Axis - 1 do
      Result := Result + KDT69DSPow(v2[i] - v1[i]);
end;

procedure TKDT69DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT69DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT69DS.Test;
var
  TKDT69DS_Test    : TKDT69DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT69DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT69DS_Test := TKDT69DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT69DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT69DS_Test.TestBuff) - 1 do
    for j := 0 to KDT69DS_Axis - 1 do
        TKDT69DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT69DS_Test.TestBuff), length(TKDT69DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT69DS_Test.BuildKDTreeM(length(TKDT69DS_Test.TestBuff), nil, @TKDT69DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT69DS_Test.BuildKDTreeM(length(TKDT69DS_Test.TestBuff), nil, TKDT69DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT69DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT69DS_Test.TestBuff));
  TKDT69DS_Test.Search(TKDT69DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT69DSDistance(TKDT69DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT69DS_Test.Clear;
  { kMean test }
  TKDT69DS_Test.BuildKDTreeWithCluster(TKDT69DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT69DS_Test.Search(TKDT69DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT69DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT69DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT69DS_Test);
end;


function TKDT70DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT70DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT70DS_Node;
  function SortCompare(const p1, p2: PKDT70DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT70DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT70DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT70DS_SourceBuffer;
  dynBuff  : PKDT70DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT70DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT70DS.GetData(const index: NativeInt): PKDT70DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT70DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT70DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT70DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT70DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT70DS.StoreBuffPtr: PKDT70DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT70DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT70DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT70DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT70DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT70DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT70DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT70DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT70DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT70DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT70DS.BuildKDTreeWithCluster(const inBuff: TKDT70DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT70DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT70DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT70DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT70DS.BuildKDTreeWithCluster(const inBuff: TKDT70DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT70DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DS_BuildCall);
var
  TempStoreBuff: TKDT70DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT70DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT70DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT70DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT70DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT70DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DS_BuildMethod);
var
  TempStoreBuff: TKDT70DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT70DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT70DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT70DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT70DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT70DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DS_BuildProc);
var
  TempStoreBuff: TKDT70DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT70DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT70DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT70DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT70DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT70DS.Search(const Buff: TKDT70DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT70DS_Node;

var
  NearestNeighbour: PKDT70DS_Node;

  function FindParentNode(const BuffPtr: PKDT70DS_Vec; NodePtr: PKDT70DS_Node): PKDT70DS_Node;
  var
    Next       : PKDT70DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT70DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT70DS_Node; const BuffPtr: PKDT70DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT70DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT70DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT70DS_Vec; const p1, p2: PKDT70DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT70DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT70DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT70DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT70DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT70DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT70DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT70DS_Node(NearestNodes[0]);
    end;
end;

function TKDT70DS.Search(const Buff: TKDT70DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT70DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT70DS.Search(const Buff: TKDT70DS_Vec; var SearchedDistanceMin: Double): PKDT70DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT70DS.Search(const Buff: TKDT70DS_Vec): PKDT70DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT70DS.Search(const inBuff: TKDT70DS_DynamicVecBuffer; var OutBuff: TKDT70DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT70DS_DynamicVecBuffer;
  outBuffPtr : PKDT70DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT70DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT70DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT70DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT70DS.Search(const inBuff: TKDT70DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT70DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT70DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT70DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT70DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT70DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT70DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT70DS_Source));
end;

procedure TKDT70DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT70DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT70DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT70DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT70DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT70DS.PrintNodeTree(const NodePtr: PKDT70DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT70DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT70DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT70DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT70DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT70DS.KDT70DSVec(const s: string): TKDT70DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT70DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT70DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT70DS.KDT70DSVec(const v: TKDT70DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT70DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT70DS.KDT70DSPow(const v: TKDT70DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT70DS.KDT70DSDistance(const v1, v2: TKDT70DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT70DS_Axis - 1 do
      Result := Result + KDT70DSPow(v2[i] - v1[i]);
end;

procedure TKDT70DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT70DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT70DS.Test;
var
  TKDT70DS_Test    : TKDT70DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT70DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT70DS_Test := TKDT70DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT70DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT70DS_Test.TestBuff) - 1 do
    for j := 0 to KDT70DS_Axis - 1 do
        TKDT70DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT70DS_Test.TestBuff), length(TKDT70DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT70DS_Test.BuildKDTreeM(length(TKDT70DS_Test.TestBuff), nil, @TKDT70DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT70DS_Test.BuildKDTreeM(length(TKDT70DS_Test.TestBuff), nil, TKDT70DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT70DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT70DS_Test.TestBuff));
  TKDT70DS_Test.Search(TKDT70DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT70DSDistance(TKDT70DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT70DS_Test.Clear;
  { kMean test }
  TKDT70DS_Test.BuildKDTreeWithCluster(TKDT70DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT70DS_Test.Search(TKDT70DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT70DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT70DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT70DS_Test);
end;


function TKDT71DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT71DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT71DS_Node;
  function SortCompare(const p1, p2: PKDT71DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT71DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT71DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT71DS_SourceBuffer;
  dynBuff  : PKDT71DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT71DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT71DS.GetData(const index: NativeInt): PKDT71DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT71DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT71DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT71DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT71DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT71DS.StoreBuffPtr: PKDT71DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT71DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT71DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT71DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT71DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT71DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT71DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT71DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT71DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT71DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT71DS.BuildKDTreeWithCluster(const inBuff: TKDT71DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT71DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT71DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT71DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT71DS.BuildKDTreeWithCluster(const inBuff: TKDT71DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT71DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DS_BuildCall);
var
  TempStoreBuff: TKDT71DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT71DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT71DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT71DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT71DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT71DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DS_BuildMethod);
var
  TempStoreBuff: TKDT71DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT71DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT71DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT71DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT71DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT71DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DS_BuildProc);
var
  TempStoreBuff: TKDT71DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT71DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT71DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT71DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT71DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT71DS.Search(const Buff: TKDT71DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT71DS_Node;

var
  NearestNeighbour: PKDT71DS_Node;

  function FindParentNode(const BuffPtr: PKDT71DS_Vec; NodePtr: PKDT71DS_Node): PKDT71DS_Node;
  var
    Next       : PKDT71DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT71DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT71DS_Node; const BuffPtr: PKDT71DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT71DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT71DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT71DS_Vec; const p1, p2: PKDT71DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT71DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT71DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT71DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT71DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT71DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT71DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT71DS_Node(NearestNodes[0]);
    end;
end;

function TKDT71DS.Search(const Buff: TKDT71DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT71DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT71DS.Search(const Buff: TKDT71DS_Vec; var SearchedDistanceMin: Double): PKDT71DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT71DS.Search(const Buff: TKDT71DS_Vec): PKDT71DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT71DS.Search(const inBuff: TKDT71DS_DynamicVecBuffer; var OutBuff: TKDT71DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT71DS_DynamicVecBuffer;
  outBuffPtr : PKDT71DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT71DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT71DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT71DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT71DS.Search(const inBuff: TKDT71DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT71DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT71DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT71DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT71DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT71DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT71DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT71DS_Source));
end;

procedure TKDT71DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT71DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT71DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT71DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT71DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT71DS.PrintNodeTree(const NodePtr: PKDT71DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT71DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT71DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT71DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT71DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT71DS.KDT71DSVec(const s: string): TKDT71DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT71DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT71DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT71DS.KDT71DSVec(const v: TKDT71DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT71DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT71DS.KDT71DSPow(const v: TKDT71DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT71DS.KDT71DSDistance(const v1, v2: TKDT71DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT71DS_Axis - 1 do
      Result := Result + KDT71DSPow(v2[i] - v1[i]);
end;

procedure TKDT71DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT71DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT71DS.Test;
var
  TKDT71DS_Test    : TKDT71DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT71DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT71DS_Test := TKDT71DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT71DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT71DS_Test.TestBuff) - 1 do
    for j := 0 to KDT71DS_Axis - 1 do
        TKDT71DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT71DS_Test.TestBuff), length(TKDT71DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT71DS_Test.BuildKDTreeM(length(TKDT71DS_Test.TestBuff), nil, @TKDT71DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT71DS_Test.BuildKDTreeM(length(TKDT71DS_Test.TestBuff), nil, TKDT71DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT71DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT71DS_Test.TestBuff));
  TKDT71DS_Test.Search(TKDT71DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT71DSDistance(TKDT71DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT71DS_Test.Clear;
  { kMean test }
  TKDT71DS_Test.BuildKDTreeWithCluster(TKDT71DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT71DS_Test.Search(TKDT71DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT71DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT71DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT71DS_Test);
end;


function TKDT72DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DS_Node;
  function SortCompare(const p1, p2: PKDT72DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT72DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT72DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT72DS_SourceBuffer;
  dynBuff  : PKDT72DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT72DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT72DS.GetData(const index: NativeInt): PKDT72DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT72DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT72DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT72DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT72DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT72DS.StoreBuffPtr: PKDT72DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT72DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT72DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT72DS.BuildKDTreeWithCluster(const inBuff: TKDT72DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT72DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT72DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT72DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT72DS.BuildKDTreeWithCluster(const inBuff: TKDT72DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT72DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DS_BuildCall);
var
  TempStoreBuff: TKDT72DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DS_BuildMethod);
var
  TempStoreBuff: TKDT72DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DS_BuildProc);
var
  TempStoreBuff: TKDT72DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT72DS.Search(const Buff: TKDT72DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DS_Node;

var
  NearestNeighbour: PKDT72DS_Node;

  function FindParentNode(const BuffPtr: PKDT72DS_Vec; NodePtr: PKDT72DS_Node): PKDT72DS_Node;
  var
    Next       : PKDT72DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT72DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT72DS_Node; const BuffPtr: PKDT72DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT72DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT72DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT72DS_Vec; const p1, p2: PKDT72DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT72DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT72DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT72DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT72DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT72DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT72DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT72DS_Node(NearestNodes[0]);
    end;
end;

function TKDT72DS.Search(const Buff: TKDT72DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT72DS.Search(const Buff: TKDT72DS_Vec; var SearchedDistanceMin: Double): PKDT72DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT72DS.Search(const Buff: TKDT72DS_Vec): PKDT72DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT72DS.Search(const inBuff: TKDT72DS_DynamicVecBuffer; var OutBuff: TKDT72DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT72DS_DynamicVecBuffer;
  outBuffPtr : PKDT72DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT72DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT72DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT72DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT72DS.Search(const inBuff: TKDT72DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT72DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT72DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT72DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT72DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT72DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT72DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT72DS_Source));
end;

procedure TKDT72DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT72DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT72DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT72DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT72DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT72DS.PrintNodeTree(const NodePtr: PKDT72DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT72DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT72DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT72DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT72DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT72DS.KDT72DSVec(const s: string): TKDT72DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT72DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT72DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT72DS.KDT72DSVec(const v: TKDT72DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT72DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT72DS.KDT72DSPow(const v: TKDT72DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT72DS.KDT72DSDistance(const v1, v2: TKDT72DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT72DS_Axis - 1 do
      Result := Result + KDT72DSPow(v2[i] - v1[i]);
end;

procedure TKDT72DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT72DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT72DS.Test;
var
  TKDT72DS_Test    : TKDT72DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT72DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT72DS_Test := TKDT72DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT72DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT72DS_Test.TestBuff) - 1 do
    for j := 0 to KDT72DS_Axis - 1 do
        TKDT72DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT72DS_Test.TestBuff), length(TKDT72DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT72DS_Test.BuildKDTreeM(length(TKDT72DS_Test.TestBuff), nil, @TKDT72DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT72DS_Test.BuildKDTreeM(length(TKDT72DS_Test.TestBuff), nil, TKDT72DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT72DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT72DS_Test.TestBuff));
  TKDT72DS_Test.Search(TKDT72DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT72DSDistance(TKDT72DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT72DS_Test.Clear;
  { kMean test }
  TKDT72DS_Test.BuildKDTreeWithCluster(TKDT72DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT72DS_Test.Search(TKDT72DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT72DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT72DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT72DS_Test);
end;


function TKDT84DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DS_Node;
  function SortCompare(const p1, p2: PKDT84DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT84DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT84DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT84DS_SourceBuffer;
  dynBuff  : PKDT84DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT84DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT84DS.GetData(const index: NativeInt): PKDT84DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT84DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT84DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT84DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT84DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT84DS.StoreBuffPtr: PKDT84DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT84DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT84DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT84DS.BuildKDTreeWithCluster(const inBuff: TKDT84DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT84DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT84DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT84DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT84DS.BuildKDTreeWithCluster(const inBuff: TKDT84DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT84DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DS_BuildCall);
var
  TempStoreBuff: TKDT84DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DS_BuildMethod);
var
  TempStoreBuff: TKDT84DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DS_BuildProc);
var
  TempStoreBuff: TKDT84DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT84DS.Search(const Buff: TKDT84DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DS_Node;

var
  NearestNeighbour: PKDT84DS_Node;

  function FindParentNode(const BuffPtr: PKDT84DS_Vec; NodePtr: PKDT84DS_Node): PKDT84DS_Node;
  var
    Next       : PKDT84DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT84DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT84DS_Node; const BuffPtr: PKDT84DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT84DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT84DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT84DS_Vec; const p1, p2: PKDT84DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT84DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT84DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT84DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT84DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT84DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT84DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT84DS_Node(NearestNodes[0]);
    end;
end;

function TKDT84DS.Search(const Buff: TKDT84DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT84DS.Search(const Buff: TKDT84DS_Vec; var SearchedDistanceMin: Double): PKDT84DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT84DS.Search(const Buff: TKDT84DS_Vec): PKDT84DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT84DS.Search(const inBuff: TKDT84DS_DynamicVecBuffer; var OutBuff: TKDT84DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT84DS_DynamicVecBuffer;
  outBuffPtr : PKDT84DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT84DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT84DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT84DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT84DS.Search(const inBuff: TKDT84DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT84DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT84DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT84DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT84DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT84DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT84DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT84DS_Source));
end;

procedure TKDT84DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT84DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT84DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT84DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT84DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT84DS.PrintNodeTree(const NodePtr: PKDT84DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT84DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT84DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT84DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT84DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT84DS.KDT84DSVec(const s: string): TKDT84DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT84DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT84DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT84DS.KDT84DSVec(const v: TKDT84DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT84DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT84DS.KDT84DSPow(const v: TKDT84DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT84DS.KDT84DSDistance(const v1, v2: TKDT84DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT84DS_Axis - 1 do
      Result := Result + KDT84DSPow(v2[i] - v1[i]);
end;

procedure TKDT84DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT84DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT84DS.Test;
var
  TKDT84DS_Test    : TKDT84DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT84DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT84DS_Test := TKDT84DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT84DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT84DS_Test.TestBuff) - 1 do
    for j := 0 to KDT84DS_Axis - 1 do
        TKDT84DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT84DS_Test.TestBuff), length(TKDT84DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT84DS_Test.BuildKDTreeM(length(TKDT84DS_Test.TestBuff), nil, @TKDT84DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT84DS_Test.BuildKDTreeM(length(TKDT84DS_Test.TestBuff), nil, TKDT84DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT84DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT84DS_Test.TestBuff));
  TKDT84DS_Test.Search(TKDT84DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT84DSDistance(TKDT84DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT84DS_Test.Clear;
  { kMean test }
  TKDT84DS_Test.BuildKDTreeWithCluster(TKDT84DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT84DS_Test.Search(TKDT84DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT84DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT84DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT84DS_Test);
end;


function TKDT96DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DS_Node;
  function SortCompare(const p1, p2: PKDT96DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT96DS_SourceBuffer;
  dynBuff  : PKDT96DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT96DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DS.GetData(const index: NativeInt): PKDT96DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT96DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DS.StoreBuffPtr: PKDT96DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT96DS.BuildKDTreeWithCluster(const inBuff: TKDT96DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT96DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT96DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT96DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DS.BuildKDTreeWithCluster(const inBuff: TKDT96DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DS_BuildCall);
var
  TempStoreBuff: TKDT96DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DS_BuildMethod);
var
  TempStoreBuff: TKDT96DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DS_BuildProc);
var
  TempStoreBuff: TKDT96DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT96DS.Search(const Buff: TKDT96DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DS_Node;

var
  NearestNeighbour: PKDT96DS_Node;

  function FindParentNode(const BuffPtr: PKDT96DS_Vec; NodePtr: PKDT96DS_Node): PKDT96DS_Node;
  var
    Next       : PKDT96DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT96DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DS_Node; const BuffPtr: PKDT96DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT96DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT96DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT96DS_Vec; const p1, p2: PKDT96DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT96DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT96DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT96DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT96DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT96DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DS_Node(NearestNodes[0]);
    end;
end;

function TKDT96DS.Search(const Buff: TKDT96DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DS.Search(const Buff: TKDT96DS_Vec; var SearchedDistanceMin: Double): PKDT96DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DS.Search(const Buff: TKDT96DS_Vec): PKDT96DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT96DS.Search(const inBuff: TKDT96DS_DynamicVecBuffer; var OutBuff: TKDT96DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DS_DynamicVecBuffer;
  outBuffPtr : PKDT96DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DS.Search(const inBuff: TKDT96DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT96DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT96DS_Source));
end;

procedure TKDT96DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT96DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT96DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DS.PrintNodeTree(const NodePtr: PKDT96DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT96DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT96DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT96DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT96DS.KDT96DSVec(const s: string): TKDT96DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT96DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT96DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT96DS.KDT96DSVec(const v: TKDT96DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT96DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT96DS.KDT96DSPow(const v: TKDT96DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT96DS.KDT96DSDistance(const v1, v2: TKDT96DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT96DS_Axis - 1 do
      Result := Result + KDT96DSPow(v2[i] - v1[i]);
end;

procedure TKDT96DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT96DS.Test;
var
  TKDT96DS_Test    : TKDT96DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT96DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT96DS_Test := TKDT96DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT96DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT96DS_Test.TestBuff) - 1 do
    for j := 0 to KDT96DS_Axis - 1 do
        TKDT96DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT96DS_Test.TestBuff), length(TKDT96DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT96DS_Test.BuildKDTreeM(length(TKDT96DS_Test.TestBuff), nil, @TKDT96DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT96DS_Test.BuildKDTreeM(length(TKDT96DS_Test.TestBuff), nil, TKDT96DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT96DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT96DS_Test.TestBuff));
  TKDT96DS_Test.Search(TKDT96DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT96DSDistance(TKDT96DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT96DS_Test.Clear;
  { kMean test }
  TKDT96DS_Test.BuildKDTreeWithCluster(TKDT96DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT96DS_Test.Search(TKDT96DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT96DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT96DS_Test);
end;


function TKDT128DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DS_Node;
  function SortCompare(const p1, p2: PKDT128DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT128DS_SourceBuffer;
  dynBuff  : PKDT128DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT128DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DS.GetData(const index: NativeInt): PKDT128DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT128DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DS.StoreBuffPtr: PKDT128DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT128DS.BuildKDTreeWithCluster(const inBuff: TKDT128DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT128DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT128DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT128DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DS.BuildKDTreeWithCluster(const inBuff: TKDT128DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DS_BuildCall);
var
  TempStoreBuff: TKDT128DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DS_BuildMethod);
var
  TempStoreBuff: TKDT128DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DS_BuildProc);
var
  TempStoreBuff: TKDT128DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT128DS.Search(const Buff: TKDT128DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DS_Node;

var
  NearestNeighbour: PKDT128DS_Node;

  function FindParentNode(const BuffPtr: PKDT128DS_Vec; NodePtr: PKDT128DS_Node): PKDT128DS_Node;
  var
    Next       : PKDT128DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT128DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DS_Node; const BuffPtr: PKDT128DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT128DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT128DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT128DS_Vec; const p1, p2: PKDT128DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT128DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT128DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT128DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT128DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT128DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DS_Node(NearestNodes[0]);
    end;
end;

function TKDT128DS.Search(const Buff: TKDT128DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DS.Search(const Buff: TKDT128DS_Vec; var SearchedDistanceMin: Double): PKDT128DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DS.Search(const Buff: TKDT128DS_Vec): PKDT128DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT128DS.Search(const inBuff: TKDT128DS_DynamicVecBuffer; var OutBuff: TKDT128DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DS_DynamicVecBuffer;
  outBuffPtr : PKDT128DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DS.Search(const inBuff: TKDT128DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT128DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT128DS_Source));
end;

procedure TKDT128DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT128DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT128DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DS.PrintNodeTree(const NodePtr: PKDT128DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT128DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT128DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT128DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT128DS.KDT128DSVec(const s: string): TKDT128DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT128DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT128DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT128DS.KDT128DSVec(const v: TKDT128DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT128DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT128DS.KDT128DSPow(const v: TKDT128DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT128DS.KDT128DSDistance(const v1, v2: TKDT128DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT128DS_Axis - 1 do
      Result := Result + KDT128DSPow(v2[i] - v1[i]);
end;

procedure TKDT128DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT128DS.Test;
var
  TKDT128DS_Test    : TKDT128DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT128DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT128DS_Test := TKDT128DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT128DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT128DS_Test.TestBuff) - 1 do
    for j := 0 to KDT128DS_Axis - 1 do
        TKDT128DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT128DS_Test.TestBuff), length(TKDT128DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT128DS_Test.BuildKDTreeM(length(TKDT128DS_Test.TestBuff), nil, @TKDT128DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT128DS_Test.BuildKDTreeM(length(TKDT128DS_Test.TestBuff), nil, TKDT128DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT128DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT128DS_Test.TestBuff));
  TKDT128DS_Test.Search(TKDT128DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT128DSDistance(TKDT128DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT128DS_Test.Clear;
  { kMean test }
  TKDT128DS_Test.BuildKDTreeWithCluster(TKDT128DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT128DS_Test.Search(TKDT128DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT128DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT128DS_Test);
end;


function TKDT140DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DS_Node;
  function SortCompare(const p1, p2: PKDT140DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT140DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT140DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT140DS_SourceBuffer;
  dynBuff  : PKDT140DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT140DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT140DS.GetData(const index: NativeInt): PKDT140DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT140DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT140DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT140DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT140DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT140DS.StoreBuffPtr: PKDT140DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT140DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT140DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT140DS.BuildKDTreeWithCluster(const inBuff: TKDT140DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT140DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT140DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT140DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT140DS.BuildKDTreeWithCluster(const inBuff: TKDT140DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT140DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DS_BuildCall);
var
  TempStoreBuff: TKDT140DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DS_BuildMethod);
var
  TempStoreBuff: TKDT140DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DS_BuildProc);
var
  TempStoreBuff: TKDT140DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT140DS.Search(const Buff: TKDT140DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DS_Node;

var
  NearestNeighbour: PKDT140DS_Node;

  function FindParentNode(const BuffPtr: PKDT140DS_Vec; NodePtr: PKDT140DS_Node): PKDT140DS_Node;
  var
    Next       : PKDT140DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT140DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT140DS_Node; const BuffPtr: PKDT140DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT140DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT140DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT140DS_Vec; const p1, p2: PKDT140DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT140DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT140DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT140DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT140DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT140DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT140DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT140DS_Node(NearestNodes[0]);
    end;
end;

function TKDT140DS.Search(const Buff: TKDT140DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT140DS.Search(const Buff: TKDT140DS_Vec; var SearchedDistanceMin: Double): PKDT140DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT140DS.Search(const Buff: TKDT140DS_Vec): PKDT140DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT140DS.Search(const inBuff: TKDT140DS_DynamicVecBuffer; var OutBuff: TKDT140DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT140DS_DynamicVecBuffer;
  outBuffPtr : PKDT140DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT140DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT140DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT140DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT140DS.Search(const inBuff: TKDT140DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT140DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT140DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT140DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT140DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT140DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT140DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT140DS_Source));
end;

procedure TKDT140DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT140DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT140DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT140DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT140DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT140DS.PrintNodeTree(const NodePtr: PKDT140DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT140DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT140DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT140DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT140DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT140DS.KDT140DSVec(const s: string): TKDT140DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT140DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT140DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT140DS.KDT140DSVec(const v: TKDT140DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT140DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT140DS.KDT140DSPow(const v: TKDT140DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT140DS.KDT140DSDistance(const v1, v2: TKDT140DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT140DS_Axis - 1 do
      Result := Result + KDT140DSPow(v2[i] - v1[i]);
end;

procedure TKDT140DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT140DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT140DS.Test;
var
  TKDT140DS_Test    : TKDT140DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT140DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT140DS_Test := TKDT140DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT140DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT140DS_Test.TestBuff) - 1 do
    for j := 0 to KDT140DS_Axis - 1 do
        TKDT140DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT140DS_Test.TestBuff), length(TKDT140DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT140DS_Test.BuildKDTreeM(length(TKDT140DS_Test.TestBuff), nil, @TKDT140DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT140DS_Test.BuildKDTreeM(length(TKDT140DS_Test.TestBuff), nil, TKDT140DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT140DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT140DS_Test.TestBuff));
  TKDT140DS_Test.Search(TKDT140DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT140DSDistance(TKDT140DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT140DS_Test.Clear;
  { kMean test }
  TKDT140DS_Test.BuildKDTreeWithCluster(TKDT140DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT140DS_Test.Search(TKDT140DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT140DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT140DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT140DS_Test);
end;


function TKDT160DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DS_Node;
  function SortCompare(const p1, p2: PKDT160DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT160DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT160DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT160DS_SourceBuffer;
  dynBuff  : PKDT160DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT160DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT160DS.GetData(const index: NativeInt): PKDT160DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT160DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT160DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT160DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT160DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT160DS.StoreBuffPtr: PKDT160DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT160DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT160DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT160DS.BuildKDTreeWithCluster(const inBuff: TKDT160DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT160DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT160DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT160DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT160DS.BuildKDTreeWithCluster(const inBuff: TKDT160DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT160DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DS_BuildCall);
var
  TempStoreBuff: TKDT160DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DS_BuildMethod);
var
  TempStoreBuff: TKDT160DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DS_BuildProc);
var
  TempStoreBuff: TKDT160DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT160DS.Search(const Buff: TKDT160DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DS_Node;

var
  NearestNeighbour: PKDT160DS_Node;

  function FindParentNode(const BuffPtr: PKDT160DS_Vec; NodePtr: PKDT160DS_Node): PKDT160DS_Node;
  var
    Next       : PKDT160DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT160DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT160DS_Node; const BuffPtr: PKDT160DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT160DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT160DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT160DS_Vec; const p1, p2: PKDT160DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT160DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT160DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT160DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT160DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT160DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT160DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT160DS_Node(NearestNodes[0]);
    end;
end;

function TKDT160DS.Search(const Buff: TKDT160DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT160DS.Search(const Buff: TKDT160DS_Vec; var SearchedDistanceMin: Double): PKDT160DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT160DS.Search(const Buff: TKDT160DS_Vec): PKDT160DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT160DS.Search(const inBuff: TKDT160DS_DynamicVecBuffer; var OutBuff: TKDT160DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT160DS_DynamicVecBuffer;
  outBuffPtr : PKDT160DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT160DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT160DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT160DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT160DS.Search(const inBuff: TKDT160DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT160DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT160DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT160DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT160DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT160DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT160DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT160DS_Source));
end;

procedure TKDT160DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT160DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT160DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT160DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT160DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT160DS.PrintNodeTree(const NodePtr: PKDT160DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT160DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT160DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT160DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT160DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT160DS.KDT160DSVec(const s: string): TKDT160DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT160DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT160DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT160DS.KDT160DSVec(const v: TKDT160DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT160DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT160DS.KDT160DSPow(const v: TKDT160DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT160DS.KDT160DSDistance(const v1, v2: TKDT160DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT160DS_Axis - 1 do
      Result := Result + KDT160DSPow(v2[i] - v1[i]);
end;

procedure TKDT160DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT160DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT160DS.Test;
var
  TKDT160DS_Test    : TKDT160DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT160DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT160DS_Test := TKDT160DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT160DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT160DS_Test.TestBuff) - 1 do
    for j := 0 to KDT160DS_Axis - 1 do
        TKDT160DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT160DS_Test.TestBuff), length(TKDT160DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT160DS_Test.BuildKDTreeM(length(TKDT160DS_Test.TestBuff), nil, @TKDT160DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT160DS_Test.BuildKDTreeM(length(TKDT160DS_Test.TestBuff), nil, TKDT160DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT160DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT160DS_Test.TestBuff));
  TKDT160DS_Test.Search(TKDT160DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT160DSDistance(TKDT160DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT160DS_Test.Clear;
  { kMean test }
  TKDT160DS_Test.BuildKDTreeWithCluster(TKDT160DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT160DS_Test.Search(TKDT160DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT160DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT160DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT160DS_Test);
end;


function TKDT196DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DS_Node;
  function SortCompare(const p1, p2: PKDT196DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT196DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT196DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT196DS_SourceBuffer;
  dynBuff  : PKDT196DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT196DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT196DS.GetData(const index: NativeInt): PKDT196DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT196DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT196DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT196DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT196DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT196DS.StoreBuffPtr: PKDT196DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT196DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT196DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT196DS.BuildKDTreeWithCluster(const inBuff: TKDT196DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT196DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT196DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT196DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT196DS.BuildKDTreeWithCluster(const inBuff: TKDT196DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT196DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DS_BuildCall);
var
  TempStoreBuff: TKDT196DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DS_BuildMethod);
var
  TempStoreBuff: TKDT196DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DS_BuildProc);
var
  TempStoreBuff: TKDT196DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT196DS.Search(const Buff: TKDT196DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DS_Node;

var
  NearestNeighbour: PKDT196DS_Node;

  function FindParentNode(const BuffPtr: PKDT196DS_Vec; NodePtr: PKDT196DS_Node): PKDT196DS_Node;
  var
    Next       : PKDT196DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT196DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT196DS_Node; const BuffPtr: PKDT196DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT196DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT196DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT196DS_Vec; const p1, p2: PKDT196DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT196DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT196DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT196DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT196DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT196DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT196DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT196DS_Node(NearestNodes[0]);
    end;
end;

function TKDT196DS.Search(const Buff: TKDT196DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT196DS.Search(const Buff: TKDT196DS_Vec; var SearchedDistanceMin: Double): PKDT196DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT196DS.Search(const Buff: TKDT196DS_Vec): PKDT196DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT196DS.Search(const inBuff: TKDT196DS_DynamicVecBuffer; var OutBuff: TKDT196DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT196DS_DynamicVecBuffer;
  outBuffPtr : PKDT196DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT196DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT196DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT196DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT196DS.Search(const inBuff: TKDT196DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT196DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT196DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT196DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT196DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT196DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT196DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT196DS_Source));
end;

procedure TKDT196DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT196DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT196DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT196DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT196DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT196DS.PrintNodeTree(const NodePtr: PKDT196DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT196DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT196DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT196DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT196DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT196DS.KDT196DSVec(const s: string): TKDT196DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT196DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT196DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT196DS.KDT196DSVec(const v: TKDT196DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT196DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT196DS.KDT196DSPow(const v: TKDT196DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT196DS.KDT196DSDistance(const v1, v2: TKDT196DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT196DS_Axis - 1 do
      Result := Result + KDT196DSPow(v2[i] - v1[i]);
end;

procedure TKDT196DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT196DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT196DS.Test;
var
  TKDT196DS_Test    : TKDT196DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT196DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT196DS_Test := TKDT196DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT196DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT196DS_Test.TestBuff) - 1 do
    for j := 0 to KDT196DS_Axis - 1 do
        TKDT196DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT196DS_Test.TestBuff), length(TKDT196DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT196DS_Test.BuildKDTreeM(length(TKDT196DS_Test.TestBuff), nil, @TKDT196DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT196DS_Test.BuildKDTreeM(length(TKDT196DS_Test.TestBuff), nil, TKDT196DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT196DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT196DS_Test.TestBuff));
  TKDT196DS_Test.Search(TKDT196DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT196DSDistance(TKDT196DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT196DS_Test.Clear;
  { kMean test }
  TKDT196DS_Test.BuildKDTreeWithCluster(TKDT196DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT196DS_Test.Search(TKDT196DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT196DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT196DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT196DS_Test);
end;


function TKDT256DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DS_Node;
  function SortCompare(const p1, p2: PKDT256DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT256DS_SourceBuffer;
  dynBuff  : PKDT256DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT256DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DS.GetData(const index: NativeInt): PKDT256DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT256DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DS.StoreBuffPtr: PKDT256DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT256DS.BuildKDTreeWithCluster(const inBuff: TKDT256DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT256DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT256DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT256DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DS.BuildKDTreeWithCluster(const inBuff: TKDT256DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DS_BuildCall);
var
  TempStoreBuff: TKDT256DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DS_BuildMethod);
var
  TempStoreBuff: TKDT256DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DS_BuildProc);
var
  TempStoreBuff: TKDT256DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT256DS.Search(const Buff: TKDT256DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DS_Node;

var
  NearestNeighbour: PKDT256DS_Node;

  function FindParentNode(const BuffPtr: PKDT256DS_Vec; NodePtr: PKDT256DS_Node): PKDT256DS_Node;
  var
    Next       : PKDT256DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT256DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DS_Node; const BuffPtr: PKDT256DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT256DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT256DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT256DS_Vec; const p1, p2: PKDT256DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT256DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT256DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT256DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT256DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT256DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DS_Node(NearestNodes[0]);
    end;
end;

function TKDT256DS.Search(const Buff: TKDT256DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DS.Search(const Buff: TKDT256DS_Vec; var SearchedDistanceMin: Double): PKDT256DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DS.Search(const Buff: TKDT256DS_Vec): PKDT256DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT256DS.Search(const inBuff: TKDT256DS_DynamicVecBuffer; var OutBuff: TKDT256DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DS_DynamicVecBuffer;
  outBuffPtr : PKDT256DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DS.Search(const inBuff: TKDT256DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT256DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT256DS_Source));
end;

procedure TKDT256DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT256DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT256DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DS.PrintNodeTree(const NodePtr: PKDT256DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT256DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT256DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT256DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT256DS.KDT256DSVec(const s: string): TKDT256DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT256DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT256DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT256DS.KDT256DSVec(const v: TKDT256DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT256DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT256DS.KDT256DSPow(const v: TKDT256DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT256DS.KDT256DSDistance(const v1, v2: TKDT256DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT256DS_Axis - 1 do
      Result := Result + KDT256DSPow(v2[i] - v1[i]);
end;

procedure TKDT256DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT256DS.Test;
var
  TKDT256DS_Test    : TKDT256DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT256DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT256DS_Test := TKDT256DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT256DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT256DS_Test.TestBuff) - 1 do
    for j := 0 to KDT256DS_Axis - 1 do
        TKDT256DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT256DS_Test.TestBuff), length(TKDT256DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT256DS_Test.BuildKDTreeM(length(TKDT256DS_Test.TestBuff), nil, @TKDT256DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT256DS_Test.BuildKDTreeM(length(TKDT256DS_Test.TestBuff), nil, TKDT256DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT256DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT256DS_Test.TestBuff));
  TKDT256DS_Test.Search(TKDT256DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT256DSDistance(TKDT256DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT256DS_Test.Clear;
  { kMean test }
  TKDT256DS_Test.BuildKDTreeWithCluster(TKDT256DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT256DS_Test.Search(TKDT256DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT256DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT256DS_Test);
end;


function TKDT272DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DS_Node;
  function SortCompare(const p1, p2: PKDT272DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT272DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT272DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT272DS_SourceBuffer;
  dynBuff  : PKDT272DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT272DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT272DS.GetData(const index: NativeInt): PKDT272DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT272DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT272DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT272DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT272DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT272DS.StoreBuffPtr: PKDT272DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT272DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT272DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT272DS.BuildKDTreeWithCluster(const inBuff: TKDT272DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT272DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT272DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT272DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT272DS.BuildKDTreeWithCluster(const inBuff: TKDT272DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT272DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DS_BuildCall);
var
  TempStoreBuff: TKDT272DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DS_BuildMethod);
var
  TempStoreBuff: TKDT272DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DS_BuildProc);
var
  TempStoreBuff: TKDT272DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT272DS.Search(const Buff: TKDT272DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DS_Node;

var
  NearestNeighbour: PKDT272DS_Node;

  function FindParentNode(const BuffPtr: PKDT272DS_Vec; NodePtr: PKDT272DS_Node): PKDT272DS_Node;
  var
    Next       : PKDT272DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT272DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT272DS_Node; const BuffPtr: PKDT272DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT272DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT272DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT272DS_Vec; const p1, p2: PKDT272DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT272DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT272DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT272DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT272DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT272DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT272DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT272DS_Node(NearestNodes[0]);
    end;
end;

function TKDT272DS.Search(const Buff: TKDT272DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT272DS.Search(const Buff: TKDT272DS_Vec; var SearchedDistanceMin: Double): PKDT272DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT272DS.Search(const Buff: TKDT272DS_Vec): PKDT272DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT272DS.Search(const inBuff: TKDT272DS_DynamicVecBuffer; var OutBuff: TKDT272DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT272DS_DynamicVecBuffer;
  outBuffPtr : PKDT272DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT272DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT272DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT272DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT272DS.Search(const inBuff: TKDT272DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT272DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT272DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT272DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT272DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT272DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT272DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT272DS_Source));
end;

procedure TKDT272DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT272DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT272DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT272DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT272DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT272DS.PrintNodeTree(const NodePtr: PKDT272DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT272DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT272DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT272DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT272DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT272DS.KDT272DSVec(const s: string): TKDT272DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT272DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT272DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT272DS.KDT272DSVec(const v: TKDT272DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT272DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT272DS.KDT272DSPow(const v: TKDT272DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT272DS.KDT272DSDistance(const v1, v2: TKDT272DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT272DS_Axis - 1 do
      Result := Result + KDT272DSPow(v2[i] - v1[i]);
end;

procedure TKDT272DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT272DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT272DS.Test;
var
  TKDT272DS_Test    : TKDT272DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT272DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT272DS_Test := TKDT272DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT272DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT272DS_Test.TestBuff) - 1 do
    for j := 0 to KDT272DS_Axis - 1 do
        TKDT272DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT272DS_Test.TestBuff), length(TKDT272DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT272DS_Test.BuildKDTreeM(length(TKDT272DS_Test.TestBuff), nil, @TKDT272DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT272DS_Test.BuildKDTreeM(length(TKDT272DS_Test.TestBuff), nil, TKDT272DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT272DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT272DS_Test.TestBuff));
  TKDT272DS_Test.Search(TKDT272DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT272DSDistance(TKDT272DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT272DS_Test.Clear;
  { kMean test }
  TKDT272DS_Test.BuildKDTreeWithCluster(TKDT272DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT272DS_Test.Search(TKDT272DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT272DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT272DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT272DS_Test);
end;


function TKDT288DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DS_Node;
  function SortCompare(const p1, p2: PKDT288DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT288DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT288DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT288DS_SourceBuffer;
  dynBuff  : PKDT288DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT288DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT288DS.GetData(const index: NativeInt): PKDT288DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT288DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT288DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT288DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT288DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT288DS.StoreBuffPtr: PKDT288DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT288DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT288DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT288DS.BuildKDTreeWithCluster(const inBuff: TKDT288DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT288DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT288DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT288DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT288DS.BuildKDTreeWithCluster(const inBuff: TKDT288DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT288DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DS_BuildCall);
var
  TempStoreBuff: TKDT288DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DS_BuildMethod);
var
  TempStoreBuff: TKDT288DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DS_BuildProc);
var
  TempStoreBuff: TKDT288DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT288DS.Search(const Buff: TKDT288DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DS_Node;

var
  NearestNeighbour: PKDT288DS_Node;

  function FindParentNode(const BuffPtr: PKDT288DS_Vec; NodePtr: PKDT288DS_Node): PKDT288DS_Node;
  var
    Next       : PKDT288DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT288DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT288DS_Node; const BuffPtr: PKDT288DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT288DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT288DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT288DS_Vec; const p1, p2: PKDT288DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT288DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT288DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT288DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT288DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT288DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT288DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT288DS_Node(NearestNodes[0]);
    end;
end;

function TKDT288DS.Search(const Buff: TKDT288DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT288DS.Search(const Buff: TKDT288DS_Vec; var SearchedDistanceMin: Double): PKDT288DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT288DS.Search(const Buff: TKDT288DS_Vec): PKDT288DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT288DS.Search(const inBuff: TKDT288DS_DynamicVecBuffer; var OutBuff: TKDT288DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT288DS_DynamicVecBuffer;
  outBuffPtr : PKDT288DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT288DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT288DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT288DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT288DS.Search(const inBuff: TKDT288DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT288DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT288DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT288DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT288DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT288DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT288DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT288DS_Source));
end;

procedure TKDT288DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT288DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT288DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT288DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT288DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT288DS.PrintNodeTree(const NodePtr: PKDT288DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT288DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT288DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT288DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT288DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT288DS.KDT288DSVec(const s: string): TKDT288DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT288DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT288DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT288DS.KDT288DSVec(const v: TKDT288DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT288DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT288DS.KDT288DSPow(const v: TKDT288DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT288DS.KDT288DSDistance(const v1, v2: TKDT288DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT288DS_Axis - 1 do
      Result := Result + KDT288DSPow(v2[i] - v1[i]);
end;

procedure TKDT288DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT288DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT288DS.Test;
var
  TKDT288DS_Test    : TKDT288DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT288DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT288DS_Test := TKDT288DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT288DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT288DS_Test.TestBuff) - 1 do
    for j := 0 to KDT288DS_Axis - 1 do
        TKDT288DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT288DS_Test.TestBuff), length(TKDT288DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT288DS_Test.BuildKDTreeM(length(TKDT288DS_Test.TestBuff), nil, @TKDT288DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT288DS_Test.BuildKDTreeM(length(TKDT288DS_Test.TestBuff), nil, TKDT288DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT288DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT288DS_Test.TestBuff));
  TKDT288DS_Test.Search(TKDT288DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT288DSDistance(TKDT288DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT288DS_Test.Clear;
  { kMean test }
  TKDT288DS_Test.BuildKDTreeWithCluster(TKDT288DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT288DS_Test.Search(TKDT288DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT288DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT288DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT288DS_Test);
end;


function TKDT372DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DS_Node;
  function SortCompare(const p1, p2: PKDT372DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT372DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT372DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT372DS_SourceBuffer;
  dynBuff  : PKDT372DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT372DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT372DS.GetData(const index: NativeInt): PKDT372DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT372DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT372DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT372DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT372DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT372DS.StoreBuffPtr: PKDT372DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT372DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT372DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT372DS.BuildKDTreeWithCluster(const inBuff: TKDT372DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT372DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT372DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT372DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT372DS.BuildKDTreeWithCluster(const inBuff: TKDT372DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DS_BuildCall);
var
  TempStoreBuff: TKDT372DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DS_BuildMethod);
var
  TempStoreBuff: TKDT372DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DS_BuildProc);
var
  TempStoreBuff: TKDT372DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT372DS.Search(const Buff: TKDT372DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DS_Node;

var
  NearestNeighbour: PKDT372DS_Node;

  function FindParentNode(const BuffPtr: PKDT372DS_Vec; NodePtr: PKDT372DS_Node): PKDT372DS_Node;
  var
    Next       : PKDT372DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT372DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT372DS_Node; const BuffPtr: PKDT372DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT372DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT372DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT372DS_Vec; const p1, p2: PKDT372DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT372DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT372DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT372DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT372DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT372DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT372DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT372DS_Node(NearestNodes[0]);
    end;
end;

function TKDT372DS.Search(const Buff: TKDT372DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT372DS.Search(const Buff: TKDT372DS_Vec; var SearchedDistanceMin: Double): PKDT372DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT372DS.Search(const Buff: TKDT372DS_Vec): PKDT372DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT372DS.Search(const inBuff: TKDT372DS_DynamicVecBuffer; var OutBuff: TKDT372DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DS_DynamicVecBuffer;
  outBuffPtr : PKDT372DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DS.Search(const inBuff: TKDT372DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT372DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT372DS_Source));
end;

procedure TKDT372DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT372DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT372DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT372DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DS.PrintNodeTree(const NodePtr: PKDT372DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT372DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT372DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT372DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT372DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT372DS.KDT372DSVec(const s: string): TKDT372DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT372DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT372DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT372DS.KDT372DSVec(const v: TKDT372DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT372DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT372DS.KDT372DSPow(const v: TKDT372DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT372DS.KDT372DSDistance(const v1, v2: TKDT372DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT372DS_Axis - 1 do
      Result := Result + KDT372DSPow(v2[i] - v1[i]);
end;

procedure TKDT372DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT372DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT372DS.Test;
var
  TKDT372DS_Test    : TKDT372DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT372DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT372DS_Test := TKDT372DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT372DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT372DS_Test.TestBuff) - 1 do
    for j := 0 to KDT372DS_Axis - 1 do
        TKDT372DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT372DS_Test.TestBuff), length(TKDT372DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT372DS_Test.BuildKDTreeM(length(TKDT372DS_Test.TestBuff), nil, @TKDT372DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT372DS_Test.BuildKDTreeM(length(TKDT372DS_Test.TestBuff), nil, TKDT372DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT372DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT372DS_Test.TestBuff));
  TKDT372DS_Test.Search(TKDT372DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT372DSDistance(TKDT372DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT372DS_Test.Clear;
  { kMean test }
  TKDT372DS_Test.BuildKDTreeWithCluster(TKDT372DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT372DS_Test.Search(TKDT372DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT372DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT372DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT372DS_Test);
end;


function TKDT512DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DS_Node;
  function SortCompare(const p1, p2: PKDT512DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT512DS_SourceBuffer;
  dynBuff  : PKDT512DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT512DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DS.GetData(const index: NativeInt): PKDT512DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT512DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DS.StoreBuffPtr: PKDT512DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT512DS.BuildKDTreeWithCluster(const inBuff: TKDT512DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT512DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT512DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT512DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DS.BuildKDTreeWithCluster(const inBuff: TKDT512DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DS_BuildCall);
var
  TempStoreBuff: TKDT512DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DS_BuildMethod);
var
  TempStoreBuff: TKDT512DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DS_BuildProc);
var
  TempStoreBuff: TKDT512DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT512DS.Search(const Buff: TKDT512DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DS_Node;

var
  NearestNeighbour: PKDT512DS_Node;

  function FindParentNode(const BuffPtr: PKDT512DS_Vec; NodePtr: PKDT512DS_Node): PKDT512DS_Node;
  var
    Next       : PKDT512DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT512DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DS_Node; const BuffPtr: PKDT512DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT512DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT512DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT512DS_Vec; const p1, p2: PKDT512DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT512DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT512DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT512DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT512DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT512DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DS_Node(NearestNodes[0]);
    end;
end;

function TKDT512DS.Search(const Buff: TKDT512DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DS.Search(const Buff: TKDT512DS_Vec; var SearchedDistanceMin: Double): PKDT512DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DS.Search(const Buff: TKDT512DS_Vec): PKDT512DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT512DS.Search(const inBuff: TKDT512DS_DynamicVecBuffer; var OutBuff: TKDT512DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DS_DynamicVecBuffer;
  outBuffPtr : PKDT512DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DS.Search(const inBuff: TKDT512DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT512DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT512DS_Source));
end;

procedure TKDT512DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT512DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT512DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DS.PrintNodeTree(const NodePtr: PKDT512DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT512DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT512DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT512DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT512DS.KDT512DSVec(const s: string): TKDT512DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT512DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT512DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT512DS.KDT512DSVec(const v: TKDT512DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT512DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT512DS.KDT512DSPow(const v: TKDT512DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT512DS.KDT512DSDistance(const v1, v2: TKDT512DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT512DS_Axis - 1 do
      Result := Result + KDT512DSPow(v2[i] - v1[i]);
end;

procedure TKDT512DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT512DS.Test;
var
  TKDT512DS_Test    : TKDT512DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT512DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT512DS_Test := TKDT512DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT512DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT512DS_Test.TestBuff) - 1 do
    for j := 0 to KDT512DS_Axis - 1 do
        TKDT512DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT512DS_Test.TestBuff), length(TKDT512DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT512DS_Test.BuildKDTreeM(length(TKDT512DS_Test.TestBuff), nil, @TKDT512DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT512DS_Test.BuildKDTreeM(length(TKDT512DS_Test.TestBuff), nil, TKDT512DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT512DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT512DS_Test.TestBuff));
  TKDT512DS_Test.Search(TKDT512DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT512DSDistance(TKDT512DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT512DS_Test.Clear;
  { kMean test }
  TKDT512DS_Test.BuildKDTreeWithCluster(TKDT512DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT512DS_Test.Search(TKDT512DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT512DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT512DS_Test);
end;


function TKDT576DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DS_Node;
  function SortCompare(const p1, p2: PKDT576DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT576DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT576DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT576DS_SourceBuffer;
  dynBuff  : PKDT576DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT576DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT576DS.GetData(const index: NativeInt): PKDT576DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT576DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT576DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT576DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT576DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT576DS.StoreBuffPtr: PKDT576DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT576DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT576DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT576DS.BuildKDTreeWithCluster(const inBuff: TKDT576DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT576DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT576DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT576DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT576DS.BuildKDTreeWithCluster(const inBuff: TKDT576DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT576DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DS_BuildCall);
var
  TempStoreBuff: TKDT576DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DS_BuildMethod);
var
  TempStoreBuff: TKDT576DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DS_BuildProc);
var
  TempStoreBuff: TKDT576DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT576DS.Search(const Buff: TKDT576DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DS_Node;

var
  NearestNeighbour: PKDT576DS_Node;

  function FindParentNode(const BuffPtr: PKDT576DS_Vec; NodePtr: PKDT576DS_Node): PKDT576DS_Node;
  var
    Next       : PKDT576DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT576DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT576DS_Node; const BuffPtr: PKDT576DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT576DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT576DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT576DS_Vec; const p1, p2: PKDT576DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT576DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT576DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT576DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT576DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT576DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT576DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT576DS_Node(NearestNodes[0]);
    end;
end;

function TKDT576DS.Search(const Buff: TKDT576DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT576DS.Search(const Buff: TKDT576DS_Vec; var SearchedDistanceMin: Double): PKDT576DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT576DS.Search(const Buff: TKDT576DS_Vec): PKDT576DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT576DS.Search(const inBuff: TKDT576DS_DynamicVecBuffer; var OutBuff: TKDT576DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT576DS_DynamicVecBuffer;
  outBuffPtr : PKDT576DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT576DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT576DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT576DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT576DS.Search(const inBuff: TKDT576DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT576DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT576DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT576DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT576DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT576DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT576DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT576DS_Source));
end;

procedure TKDT576DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT576DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT576DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT576DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT576DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT576DS.PrintNodeTree(const NodePtr: PKDT576DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT576DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT576DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT576DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT576DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT576DS.KDT576DSVec(const s: string): TKDT576DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT576DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT576DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT576DS.KDT576DSVec(const v: TKDT576DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT576DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT576DS.KDT576DSPow(const v: TKDT576DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT576DS.KDT576DSDistance(const v1, v2: TKDT576DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT576DS_Axis - 1 do
      Result := Result + KDT576DSPow(v2[i] - v1[i]);
end;

procedure TKDT576DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT576DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT576DS.Test;
var
  TKDT576DS_Test    : TKDT576DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT576DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT576DS_Test := TKDT576DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT576DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT576DS_Test.TestBuff) - 1 do
    for j := 0 to KDT576DS_Axis - 1 do
        TKDT576DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT576DS_Test.TestBuff), length(TKDT576DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT576DS_Test.BuildKDTreeM(length(TKDT576DS_Test.TestBuff), nil, @TKDT576DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT576DS_Test.BuildKDTreeM(length(TKDT576DS_Test.TestBuff), nil, TKDT576DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT576DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT576DS_Test.TestBuff));
  TKDT576DS_Test.Search(TKDT576DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT576DSDistance(TKDT576DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT576DS_Test.Clear;
  { kMean test }
  TKDT576DS_Test.BuildKDTreeWithCluster(TKDT576DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT576DS_Test.Search(TKDT576DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT576DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT576DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT576DS_Test);
end;


function TKDT768DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DS_Node;
  function SortCompare(const p1, p2: PKDT768DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT768DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT768DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT768DS_SourceBuffer;
  dynBuff  : PKDT768DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT768DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT768DS.GetData(const index: NativeInt): PKDT768DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT768DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT768DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT768DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT768DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT768DS.StoreBuffPtr: PKDT768DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT768DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT768DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT768DS.BuildKDTreeWithCluster(const inBuff: TKDT768DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT768DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT768DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT768DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT768DS.BuildKDTreeWithCluster(const inBuff: TKDT768DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DS_BuildCall);
var
  TempStoreBuff: TKDT768DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DS_BuildMethod);
var
  TempStoreBuff: TKDT768DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DS_BuildProc);
var
  TempStoreBuff: TKDT768DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT768DS.Search(const Buff: TKDT768DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DS_Node;

var
  NearestNeighbour: PKDT768DS_Node;

  function FindParentNode(const BuffPtr: PKDT768DS_Vec; NodePtr: PKDT768DS_Node): PKDT768DS_Node;
  var
    Next       : PKDT768DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT768DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT768DS_Node; const BuffPtr: PKDT768DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT768DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT768DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT768DS_Vec; const p1, p2: PKDT768DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT768DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT768DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT768DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT768DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT768DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT768DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT768DS_Node(NearestNodes[0]);
    end;
end;

function TKDT768DS.Search(const Buff: TKDT768DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT768DS.Search(const Buff: TKDT768DS_Vec; var SearchedDistanceMin: Double): PKDT768DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT768DS.Search(const Buff: TKDT768DS_Vec): PKDT768DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT768DS.Search(const inBuff: TKDT768DS_DynamicVecBuffer; var OutBuff: TKDT768DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DS_DynamicVecBuffer;
  outBuffPtr : PKDT768DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DS.Search(const inBuff: TKDT768DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT768DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT768DS_Source));
end;

procedure TKDT768DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT768DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT768DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT768DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DS.PrintNodeTree(const NodePtr: PKDT768DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT768DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT768DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT768DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT768DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT768DS.KDT768DSVec(const s: string): TKDT768DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT768DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT768DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT768DS.KDT768DSVec(const v: TKDT768DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT768DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT768DS.KDT768DSPow(const v: TKDT768DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT768DS.KDT768DSDistance(const v1, v2: TKDT768DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT768DS_Axis - 1 do
      Result := Result + KDT768DSPow(v2[i] - v1[i]);
end;

procedure TKDT768DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT768DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT768DS.Test;
var
  TKDT768DS_Test    : TKDT768DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT768DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT768DS_Test := TKDT768DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT768DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT768DS_Test.TestBuff) - 1 do
    for j := 0 to KDT768DS_Axis - 1 do
        TKDT768DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT768DS_Test.TestBuff), length(TKDT768DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT768DS_Test.BuildKDTreeM(length(TKDT768DS_Test.TestBuff), nil, @TKDT768DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT768DS_Test.BuildKDTreeM(length(TKDT768DS_Test.TestBuff), nil, TKDT768DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT768DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT768DS_Test.TestBuff));
  TKDT768DS_Test.Search(TKDT768DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT768DSDistance(TKDT768DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT768DS_Test.Clear;
  { kMean test }
  TKDT768DS_Test.BuildKDTreeWithCluster(TKDT768DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT768DS_Test.Search(TKDT768DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT768DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT768DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT768DS_Test);
end;


function TKDT1024DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DS_Node;
  function SortCompare(const p1, p2: PKDT1024DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1024DS_SourceBuffer;
  dynBuff  : PKDT1024DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1024DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DS.GetData(const index: NativeInt): PKDT1024DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1024DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DS.StoreBuffPtr: PKDT1024DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1024DS.BuildKDTreeWithCluster(const inBuff: TKDT1024DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1024DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1024DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1024DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DS.BuildKDTreeWithCluster(const inBuff: TKDT1024DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildCall);
var
  TempStoreBuff: TKDT1024DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildMethod);
var
  TempStoreBuff: TKDT1024DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DS_BuildProc);
var
  TempStoreBuff: TKDT1024DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1024DS.Search(const Buff: TKDT1024DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DS_Node;

var
  NearestNeighbour: PKDT1024DS_Node;

  function FindParentNode(const BuffPtr: PKDT1024DS_Vec; NodePtr: PKDT1024DS_Node): PKDT1024DS_Node;
  var
    Next       : PKDT1024DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1024DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DS_Node; const BuffPtr: PKDT1024DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1024DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1024DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1024DS_Vec; const p1, p2: PKDT1024DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1024DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1024DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1024DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1024DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1024DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DS_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DS.Search(const Buff: TKDT1024DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DS.Search(const Buff: TKDT1024DS_Vec; var SearchedDistanceMin: Double): PKDT1024DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DS.Search(const Buff: TKDT1024DS_Vec): PKDT1024DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1024DS.Search(const inBuff: TKDT1024DS_DynamicVecBuffer; var OutBuff: TKDT1024DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DS_DynamicVecBuffer;
  outBuffPtr : PKDT1024DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DS.Search(const inBuff: TKDT1024DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1024DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1024DS_Source));
end;

procedure TKDT1024DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1024DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1024DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DS.PrintNodeTree(const NodePtr: PKDT1024DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1024DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1024DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1024DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1024DS.KDT1024DSVec(const s: string): TKDT1024DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1024DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1024DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1024DS.KDT1024DSVec(const v: TKDT1024DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1024DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1024DS.KDT1024DSPow(const v: TKDT1024DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1024DS.KDT1024DSDistance(const v1, v2: TKDT1024DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1024DS_Axis - 1 do
      Result := Result + KDT1024DSPow(v2[i] - v1[i]);
end;

procedure TKDT1024DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1024DS.Test;
var
  TKDT1024DS_Test    : TKDT1024DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1024DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1024DS_Test := TKDT1024DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1024DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT1024DS_Test.TestBuff) - 1 do
    for j := 0 to KDT1024DS_Axis - 1 do
        TKDT1024DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1024DS_Test.TestBuff), length(TKDT1024DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1024DS_Test.BuildKDTreeM(length(TKDT1024DS_Test.TestBuff), nil, @TKDT1024DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1024DS_Test.BuildKDTreeM(length(TKDT1024DS_Test.TestBuff), nil, TKDT1024DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1024DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1024DS_Test.TestBuff));
  TKDT1024DS_Test.Search(TKDT1024DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1024DSDistance(TKDT1024DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1024DS_Test.Clear;
  { kMean test }
  TKDT1024DS_Test.BuildKDTreeWithCluster(TKDT1024DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1024DS_Test.Search(TKDT1024DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1024DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1024DS_Test);
end;


function TKDT1040DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DS_Node;
  function SortCompare(const p1, p2: PKDT1040DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1040DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1040DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1040DS_SourceBuffer;
  dynBuff  : PKDT1040DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1040DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1040DS.GetData(const index: NativeInt): PKDT1040DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1040DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1040DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1040DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1040DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1040DS.StoreBuffPtr: PKDT1040DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1040DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1040DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1040DS.BuildKDTreeWithCluster(const inBuff: TKDT1040DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1040DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1040DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1040DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1040DS.BuildKDTreeWithCluster(const inBuff: TKDT1040DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1040DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildCall);
var
  TempStoreBuff: TKDT1040DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildMethod);
var
  TempStoreBuff: TKDT1040DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DS_BuildProc);
var
  TempStoreBuff: TKDT1040DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1040DS.Search(const Buff: TKDT1040DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DS_Node;

var
  NearestNeighbour: PKDT1040DS_Node;

  function FindParentNode(const BuffPtr: PKDT1040DS_Vec; NodePtr: PKDT1040DS_Node): PKDT1040DS_Node;
  var
    Next       : PKDT1040DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1040DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1040DS_Node; const BuffPtr: PKDT1040DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1040DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1040DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1040DS_Vec; const p1, p2: PKDT1040DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1040DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1040DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1040DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1040DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1040DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1040DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1040DS_Node(NearestNodes[0]);
    end;
end;

function TKDT1040DS.Search(const Buff: TKDT1040DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1040DS.Search(const Buff: TKDT1040DS_Vec; var SearchedDistanceMin: Double): PKDT1040DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1040DS.Search(const Buff: TKDT1040DS_Vec): PKDT1040DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1040DS.Search(const inBuff: TKDT1040DS_DynamicVecBuffer; var OutBuff: TKDT1040DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1040DS_DynamicVecBuffer;
  outBuffPtr : PKDT1040DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1040DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1040DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1040DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1040DS.Search(const inBuff: TKDT1040DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1040DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1040DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1040DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1040DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1040DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1040DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1040DS_Source));
end;

procedure TKDT1040DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1040DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1040DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1040DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1040DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1040DS.PrintNodeTree(const NodePtr: PKDT1040DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1040DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1040DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1040DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1040DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1040DS.KDT1040DSVec(const s: string): TKDT1040DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1040DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1040DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1040DS.KDT1040DSVec(const v: TKDT1040DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1040DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1040DS.KDT1040DSPow(const v: TKDT1040DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1040DS.KDT1040DSDistance(const v1, v2: TKDT1040DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1040DS_Axis - 1 do
      Result := Result + KDT1040DSPow(v2[i] - v1[i]);
end;

procedure TKDT1040DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1040DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1040DS.Test;
var
  TKDT1040DS_Test    : TKDT1040DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1040DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1040DS_Test := TKDT1040DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1040DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT1040DS_Test.TestBuff) - 1 do
    for j := 0 to KDT1040DS_Axis - 1 do
        TKDT1040DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1040DS_Test.TestBuff), length(TKDT1040DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1040DS_Test.BuildKDTreeM(length(TKDT1040DS_Test.TestBuff), nil, @TKDT1040DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1040DS_Test.BuildKDTreeM(length(TKDT1040DS_Test.TestBuff), nil, TKDT1040DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1040DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1040DS_Test.TestBuff));
  TKDT1040DS_Test.Search(TKDT1040DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1040DSDistance(TKDT1040DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1040DS_Test.Clear;
  { kMean test }
  TKDT1040DS_Test.BuildKDTreeWithCluster(TKDT1040DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1040DS_Test.Search(TKDT1040DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1040DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1040DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1040DS_Test);
end;


function TKDT1056DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DS_Node;
  function SortCompare(const p1, p2: PKDT1056DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1056DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1056DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1056DS_SourceBuffer;
  dynBuff  : PKDT1056DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1056DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1056DS.GetData(const index: NativeInt): PKDT1056DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1056DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1056DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1056DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1056DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1056DS.StoreBuffPtr: PKDT1056DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1056DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1056DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1056DS.BuildKDTreeWithCluster(const inBuff: TKDT1056DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1056DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1056DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1056DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1056DS.BuildKDTreeWithCluster(const inBuff: TKDT1056DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1056DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildCall);
var
  TempStoreBuff: TKDT1056DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildMethod);
var
  TempStoreBuff: TKDT1056DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DS_BuildProc);
var
  TempStoreBuff: TKDT1056DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1056DS.Search(const Buff: TKDT1056DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DS_Node;

var
  NearestNeighbour: PKDT1056DS_Node;

  function FindParentNode(const BuffPtr: PKDT1056DS_Vec; NodePtr: PKDT1056DS_Node): PKDT1056DS_Node;
  var
    Next       : PKDT1056DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1056DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1056DS_Node; const BuffPtr: PKDT1056DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1056DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1056DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1056DS_Vec; const p1, p2: PKDT1056DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1056DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1056DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1056DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1056DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1056DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1056DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1056DS_Node(NearestNodes[0]);
    end;
end;

function TKDT1056DS.Search(const Buff: TKDT1056DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1056DS.Search(const Buff: TKDT1056DS_Vec; var SearchedDistanceMin: Double): PKDT1056DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1056DS.Search(const Buff: TKDT1056DS_Vec): PKDT1056DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1056DS.Search(const inBuff: TKDT1056DS_DynamicVecBuffer; var OutBuff: TKDT1056DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1056DS_DynamicVecBuffer;
  outBuffPtr : PKDT1056DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1056DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1056DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1056DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1056DS.Search(const inBuff: TKDT1056DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1056DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1056DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1056DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1056DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1056DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1056DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1056DS_Source));
end;

procedure TKDT1056DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1056DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1056DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1056DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1056DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1056DS.PrintNodeTree(const NodePtr: PKDT1056DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1056DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1056DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1056DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1056DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1056DS.KDT1056DSVec(const s: string): TKDT1056DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1056DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1056DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1056DS.KDT1056DSVec(const v: TKDT1056DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1056DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1056DS.KDT1056DSPow(const v: TKDT1056DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1056DS.KDT1056DSDistance(const v1, v2: TKDT1056DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1056DS_Axis - 1 do
      Result := Result + KDT1056DSPow(v2[i] - v1[i]);
end;

procedure TKDT1056DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1056DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1056DS.Test;
var
  TKDT1056DS_Test    : TKDT1056DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1056DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1056DS_Test := TKDT1056DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1056DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT1056DS_Test.TestBuff) - 1 do
    for j := 0 to KDT1056DS_Axis - 1 do
        TKDT1056DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1056DS_Test.TestBuff), length(TKDT1056DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1056DS_Test.BuildKDTreeM(length(TKDT1056DS_Test.TestBuff), nil, @TKDT1056DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1056DS_Test.BuildKDTreeM(length(TKDT1056DS_Test.TestBuff), nil, TKDT1056DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1056DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1056DS_Test.TestBuff));
  TKDT1056DS_Test.Search(TKDT1056DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1056DSDistance(TKDT1056DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1056DS_Test.Clear;
  { kMean test }
  TKDT1056DS_Test.BuildKDTreeWithCluster(TKDT1056DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1056DS_Test.Search(TKDT1056DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1056DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1056DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1056DS_Test);
end;


function TKDT1536DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DS_Node;
  function SortCompare(const p1, p2: PKDT1536DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1536DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1536DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1536DS_SourceBuffer;
  dynBuff  : PKDT1536DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1536DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1536DS.GetData(const index: NativeInt): PKDT1536DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1536DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1536DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1536DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1536DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1536DS.StoreBuffPtr: PKDT1536DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1536DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1536DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1536DS.BuildKDTreeWithCluster(const inBuff: TKDT1536DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1536DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1536DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1536DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1536DS.BuildKDTreeWithCluster(const inBuff: TKDT1536DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildCall);
var
  TempStoreBuff: TKDT1536DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildMethod);
var
  TempStoreBuff: TKDT1536DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DS_BuildProc);
var
  TempStoreBuff: TKDT1536DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1536DS.Search(const Buff: TKDT1536DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DS_Node;

var
  NearestNeighbour: PKDT1536DS_Node;

  function FindParentNode(const BuffPtr: PKDT1536DS_Vec; NodePtr: PKDT1536DS_Node): PKDT1536DS_Node;
  var
    Next       : PKDT1536DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1536DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1536DS_Node; const BuffPtr: PKDT1536DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1536DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1536DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1536DS_Vec; const p1, p2: PKDT1536DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1536DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1536DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1536DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1536DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1536DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1536DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1536DS_Node(NearestNodes[0]);
    end;
end;

function TKDT1536DS.Search(const Buff: TKDT1536DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1536DS.Search(const Buff: TKDT1536DS_Vec; var SearchedDistanceMin: Double): PKDT1536DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1536DS.Search(const Buff: TKDT1536DS_Vec): PKDT1536DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1536DS.Search(const inBuff: TKDT1536DS_DynamicVecBuffer; var OutBuff: TKDT1536DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DS_DynamicVecBuffer;
  outBuffPtr : PKDT1536DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DS.Search(const inBuff: TKDT1536DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1536DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1536DS_Source));
end;

procedure TKDT1536DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1536DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1536DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1536DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DS.PrintNodeTree(const NodePtr: PKDT1536DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1536DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1536DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1536DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1536DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1536DS.KDT1536DSVec(const s: string): TKDT1536DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1536DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1536DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1536DS.KDT1536DSVec(const v: TKDT1536DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1536DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1536DS.KDT1536DSPow(const v: TKDT1536DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1536DS.KDT1536DSDistance(const v1, v2: TKDT1536DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1536DS_Axis - 1 do
      Result := Result + KDT1536DSPow(v2[i] - v1[i]);
end;

procedure TKDT1536DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1536DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1536DS.Test;
var
  TKDT1536DS_Test    : TKDT1536DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1536DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1536DS_Test := TKDT1536DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1536DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT1536DS_Test.TestBuff) - 1 do
    for j := 0 to KDT1536DS_Axis - 1 do
        TKDT1536DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1536DS_Test.TestBuff), length(TKDT1536DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1536DS_Test.BuildKDTreeM(length(TKDT1536DS_Test.TestBuff), nil, @TKDT1536DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1536DS_Test.BuildKDTreeM(length(TKDT1536DS_Test.TestBuff), nil, TKDT1536DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1536DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1536DS_Test.TestBuff));
  TKDT1536DS_Test.Search(TKDT1536DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1536DSDistance(TKDT1536DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1536DS_Test.Clear;
  { kMean test }
  TKDT1536DS_Test.BuildKDTreeWithCluster(TKDT1536DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1536DS_Test.Search(TKDT1536DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1536DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1536DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1536DS_Test);
end;


function TKDT1920DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DS_Node;
  function SortCompare(const p1, p2: PKDT1920DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1920DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1920DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1920DS_SourceBuffer;
  dynBuff  : PKDT1920DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1920DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1920DS.GetData(const index: NativeInt): PKDT1920DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1920DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1920DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1920DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1920DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1920DS.StoreBuffPtr: PKDT1920DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1920DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1920DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1920DS.BuildKDTreeWithCluster(const inBuff: TKDT1920DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1920DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1920DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1920DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1920DS.BuildKDTreeWithCluster(const inBuff: TKDT1920DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildCall);
var
  TempStoreBuff: TKDT1920DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildMethod);
var
  TempStoreBuff: TKDT1920DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DS_BuildProc);
var
  TempStoreBuff: TKDT1920DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1920DS.Search(const Buff: TKDT1920DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DS_Node;

var
  NearestNeighbour: PKDT1920DS_Node;

  function FindParentNode(const BuffPtr: PKDT1920DS_Vec; NodePtr: PKDT1920DS_Node): PKDT1920DS_Node;
  var
    Next       : PKDT1920DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1920DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1920DS_Node; const BuffPtr: PKDT1920DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1920DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1920DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1920DS_Vec; const p1, p2: PKDT1920DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1920DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1920DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1920DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1920DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1920DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1920DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1920DS_Node(NearestNodes[0]);
    end;
end;

function TKDT1920DS.Search(const Buff: TKDT1920DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1920DS.Search(const Buff: TKDT1920DS_Vec; var SearchedDistanceMin: Double): PKDT1920DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1920DS.Search(const Buff: TKDT1920DS_Vec): PKDT1920DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1920DS.Search(const inBuff: TKDT1920DS_DynamicVecBuffer; var OutBuff: TKDT1920DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DS_DynamicVecBuffer;
  outBuffPtr : PKDT1920DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DS.Search(const inBuff: TKDT1920DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1920DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1920DS_Source));
end;

procedure TKDT1920DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1920DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1920DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1920DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DS.PrintNodeTree(const NodePtr: PKDT1920DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1920DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1920DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1920DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1920DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1920DS.KDT1920DSVec(const s: string): TKDT1920DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1920DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1920DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1920DS.KDT1920DSVec(const v: TKDT1920DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1920DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1920DS.KDT1920DSPow(const v: TKDT1920DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1920DS.KDT1920DSDistance(const v1, v2: TKDT1920DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1920DS_Axis - 1 do
      Result := Result + KDT1920DSPow(v2[i] - v1[i]);
end;

procedure TKDT1920DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1920DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1920DS.Test;
var
  TKDT1920DS_Test    : TKDT1920DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1920DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1920DS_Test := TKDT1920DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1920DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT1920DS_Test.TestBuff) - 1 do
    for j := 0 to KDT1920DS_Axis - 1 do
        TKDT1920DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1920DS_Test.TestBuff), length(TKDT1920DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1920DS_Test.BuildKDTreeM(length(TKDT1920DS_Test.TestBuff), nil, @TKDT1920DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1920DS_Test.BuildKDTreeM(length(TKDT1920DS_Test.TestBuff), nil, TKDT1920DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1920DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1920DS_Test.TestBuff));
  TKDT1920DS_Test.Search(TKDT1920DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1920DSDistance(TKDT1920DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1920DS_Test.Clear;
  { kMean test }
  TKDT1920DS_Test.BuildKDTreeWithCluster(TKDT1920DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1920DS_Test.Search(TKDT1920DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1920DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1920DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1920DS_Test);
end;


function TKDT1980DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DS_Node;
  function SortCompare(const p1, p2: PKDT1980DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1980DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1980DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1980DS_SourceBuffer;
  dynBuff  : PKDT1980DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1980DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1980DS.GetData(const index: NativeInt): PKDT1980DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1980DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1980DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1980DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1980DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1980DS.StoreBuffPtr: PKDT1980DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1980DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1980DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1980DS.BuildKDTreeWithCluster(const inBuff: TKDT1980DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1980DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1980DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1980DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1980DS.BuildKDTreeWithCluster(const inBuff: TKDT1980DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1980DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildCall);
var
  TempStoreBuff: TKDT1980DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildMethod);
var
  TempStoreBuff: TKDT1980DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DS_BuildProc);
var
  TempStoreBuff: TKDT1980DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1980DS.Search(const Buff: TKDT1980DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DS_Node;

var
  NearestNeighbour: PKDT1980DS_Node;

  function FindParentNode(const BuffPtr: PKDT1980DS_Vec; NodePtr: PKDT1980DS_Node): PKDT1980DS_Node;
  var
    Next       : PKDT1980DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1980DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1980DS_Node; const BuffPtr: PKDT1980DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1980DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1980DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1980DS_Vec; const p1, p2: PKDT1980DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1980DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1980DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1980DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1980DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1980DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1980DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1980DS_Node(NearestNodes[0]);
    end;
end;

function TKDT1980DS.Search(const Buff: TKDT1980DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1980DS.Search(const Buff: TKDT1980DS_Vec; var SearchedDistanceMin: Double): PKDT1980DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1980DS.Search(const Buff: TKDT1980DS_Vec): PKDT1980DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1980DS.Search(const inBuff: TKDT1980DS_DynamicVecBuffer; var OutBuff: TKDT1980DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1980DS_DynamicVecBuffer;
  outBuffPtr : PKDT1980DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1980DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1980DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1980DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1980DS.Search(const inBuff: TKDT1980DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1980DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1980DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1980DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1980DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1980DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1980DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1980DS_Source));
end;

procedure TKDT1980DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1980DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1980DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1980DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1980DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1980DS.PrintNodeTree(const NodePtr: PKDT1980DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1980DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1980DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1980DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1980DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1980DS.KDT1980DSVec(const s: string): TKDT1980DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1980DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1980DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1980DS.KDT1980DSVec(const v: TKDT1980DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1980DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1980DS.KDT1980DSPow(const v: TKDT1980DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1980DS.KDT1980DSDistance(const v1, v2: TKDT1980DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1980DS_Axis - 1 do
      Result := Result + KDT1980DSPow(v2[i] - v1[i]);
end;

procedure TKDT1980DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1980DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1980DS.Test;
var
  TKDT1980DS_Test    : TKDT1980DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1980DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1980DS_Test := TKDT1980DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1980DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT1980DS_Test.TestBuff) - 1 do
    for j := 0 to KDT1980DS_Axis - 1 do
        TKDT1980DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1980DS_Test.TestBuff), length(TKDT1980DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1980DS_Test.BuildKDTreeM(length(TKDT1980DS_Test.TestBuff), nil, @TKDT1980DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1980DS_Test.BuildKDTreeM(length(TKDT1980DS_Test.TestBuff), nil, TKDT1980DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1980DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1980DS_Test.TestBuff));
  TKDT1980DS_Test.Search(TKDT1980DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1980DSDistance(TKDT1980DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1980DS_Test.Clear;
  { kMean test }
  TKDT1980DS_Test.BuildKDTreeWithCluster(TKDT1980DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1980DS_Test.Search(TKDT1980DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1980DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1980DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1980DS_Test);
end;


function TKDT2048DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DS_Node;
  function SortCompare(const p1, p2: PKDT2048DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2048DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2048DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2048DS_SourceBuffer;
  dynBuff  : PKDT2048DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT2048DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2048DS.GetData(const index: NativeInt): PKDT2048DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2048DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2048DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2048DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2048DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2048DS.StoreBuffPtr: PKDT2048DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2048DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2048DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2048DS.BuildKDTreeWithCluster(const inBuff: TKDT2048DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT2048DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT2048DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT2048DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2048DS.BuildKDTreeWithCluster(const inBuff: TKDT2048DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildCall);
var
  TempStoreBuff: TKDT2048DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildMethod);
var
  TempStoreBuff: TKDT2048DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DS_BuildProc);
var
  TempStoreBuff: TKDT2048DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT2048DS.Search(const Buff: TKDT2048DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DS_Node;

var
  NearestNeighbour: PKDT2048DS_Node;

  function FindParentNode(const BuffPtr: PKDT2048DS_Vec; NodePtr: PKDT2048DS_Node): PKDT2048DS_Node;
  var
    Next       : PKDT2048DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT2048DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2048DS_Node; const BuffPtr: PKDT2048DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2048DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT2048DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2048DS_Vec; const p1, p2: PKDT2048DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2048DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2048DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2048DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2048DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2048DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2048DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2048DS_Node(NearestNodes[0]);
    end;
end;

function TKDT2048DS.Search(const Buff: TKDT2048DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2048DS.Search(const Buff: TKDT2048DS_Vec; var SearchedDistanceMin: Double): PKDT2048DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2048DS.Search(const Buff: TKDT2048DS_Vec): PKDT2048DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2048DS.Search(const inBuff: TKDT2048DS_DynamicVecBuffer; var OutBuff: TKDT2048DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DS_DynamicVecBuffer;
  outBuffPtr : PKDT2048DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DS.Search(const inBuff: TKDT2048DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT2048DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2048DS_Source));
end;

procedure TKDT2048DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT2048DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2048DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2048DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DS.PrintNodeTree(const NodePtr: PKDT2048DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2048DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2048DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2048DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2048DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT2048DS.KDT2048DSVec(const s: string): TKDT2048DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT2048DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT2048DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT2048DS.KDT2048DSVec(const v: TKDT2048DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT2048DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT2048DS.KDT2048DSPow(const v: TKDT2048DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT2048DS.KDT2048DSDistance(const v1, v2: TKDT2048DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT2048DS_Axis - 1 do
      Result := Result + KDT2048DSPow(v2[i] - v1[i]);
end;

procedure TKDT2048DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2048DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2048DS.Test;
var
  TKDT2048DS_Test    : TKDT2048DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2048DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2048DS_Test := TKDT2048DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2048DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT2048DS_Test.TestBuff) - 1 do
    for j := 0 to KDT2048DS_Axis - 1 do
        TKDT2048DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2048DS_Test.TestBuff), length(TKDT2048DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2048DS_Test.BuildKDTreeM(length(TKDT2048DS_Test.TestBuff), nil, @TKDT2048DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2048DS_Test.BuildKDTreeM(length(TKDT2048DS_Test.TestBuff), nil, TKDT2048DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2048DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2048DS_Test.TestBuff));
  TKDT2048DS_Test.Search(TKDT2048DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2048DSDistance(TKDT2048DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2048DS_Test.Clear;
  { kMean test }
  TKDT2048DS_Test.BuildKDTreeWithCluster(TKDT2048DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2048DS_Test.Search(TKDT2048DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2048DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2048DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2048DS_Test);
end;


function TKDT3072DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DS_Node;
  function SortCompare(const p1, p2: PKDT3072DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3072DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3072DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3072DS_SourceBuffer;
  dynBuff  : PKDT3072DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3072DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3072DS.GetData(const index: NativeInt): PKDT3072DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3072DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3072DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3072DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3072DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3072DS.StoreBuffPtr: PKDT3072DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3072DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3072DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3072DS.BuildKDTreeWithCluster(const inBuff: TKDT3072DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3072DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3072DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3072DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3072DS.BuildKDTreeWithCluster(const inBuff: TKDT3072DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildCall);
var
  TempStoreBuff: TKDT3072DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildMethod);
var
  TempStoreBuff: TKDT3072DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DS_BuildProc);
var
  TempStoreBuff: TKDT3072DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3072DS.Search(const Buff: TKDT3072DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DS_Node;

var
  NearestNeighbour: PKDT3072DS_Node;

  function FindParentNode(const BuffPtr: PKDT3072DS_Vec; NodePtr: PKDT3072DS_Node): PKDT3072DS_Node;
  var
    Next       : PKDT3072DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3072DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3072DS_Node; const BuffPtr: PKDT3072DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3072DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3072DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3072DS_Vec; const p1, p2: PKDT3072DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3072DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3072DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3072DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3072DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3072DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3072DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3072DS_Node(NearestNodes[0]);
    end;
end;

function TKDT3072DS.Search(const Buff: TKDT3072DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3072DS.Search(const Buff: TKDT3072DS_Vec; var SearchedDistanceMin: Double): PKDT3072DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3072DS.Search(const Buff: TKDT3072DS_Vec): PKDT3072DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3072DS.Search(const inBuff: TKDT3072DS_DynamicVecBuffer; var OutBuff: TKDT3072DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DS_DynamicVecBuffer;
  outBuffPtr : PKDT3072DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DS.Search(const inBuff: TKDT3072DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3072DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3072DS_Source));
end;

procedure TKDT3072DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3072DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3072DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3072DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DS.PrintNodeTree(const NodePtr: PKDT3072DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3072DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3072DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3072DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3072DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3072DS.KDT3072DSVec(const s: string): TKDT3072DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3072DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3072DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3072DS.KDT3072DSVec(const v: TKDT3072DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3072DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3072DS.KDT3072DSPow(const v: TKDT3072DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3072DS.KDT3072DSDistance(const v1, v2: TKDT3072DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3072DS_Axis - 1 do
      Result := Result + KDT3072DSPow(v2[i] - v1[i]);
end;

procedure TKDT3072DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3072DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3072DS.Test;
var
  TKDT3072DS_Test    : TKDT3072DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3072DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3072DS_Test := TKDT3072DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3072DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT3072DS_Test.TestBuff) - 1 do
    for j := 0 to KDT3072DS_Axis - 1 do
        TKDT3072DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3072DS_Test.TestBuff), length(TKDT3072DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3072DS_Test.BuildKDTreeM(length(TKDT3072DS_Test.TestBuff), nil, @TKDT3072DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3072DS_Test.BuildKDTreeM(length(TKDT3072DS_Test.TestBuff), nil, TKDT3072DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3072DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3072DS_Test.TestBuff));
  TKDT3072DS_Test.Search(TKDT3072DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3072DSDistance(TKDT3072DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3072DS_Test.Clear;
  { kMean test }
  TKDT3072DS_Test.BuildKDTreeWithCluster(TKDT3072DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3072DS_Test.Search(TKDT3072DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3072DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3072DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3072DS_Test);
end;


function TKDT3088DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DS_Node;
  function SortCompare(const p1, p2: PKDT3088DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3088DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3088DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3088DS_SourceBuffer;
  dynBuff  : PKDT3088DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3088DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3088DS.GetData(const index: NativeInt): PKDT3088DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3088DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3088DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3088DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3088DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3088DS.StoreBuffPtr: PKDT3088DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3088DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3088DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3088DS.BuildKDTreeWithCluster(const inBuff: TKDT3088DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3088DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3088DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3088DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3088DS.BuildKDTreeWithCluster(const inBuff: TKDT3088DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3088DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildCall);
var
  TempStoreBuff: TKDT3088DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildMethod);
var
  TempStoreBuff: TKDT3088DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DS_BuildProc);
var
  TempStoreBuff: TKDT3088DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3088DS.Search(const Buff: TKDT3088DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DS_Node;

var
  NearestNeighbour: PKDT3088DS_Node;

  function FindParentNode(const BuffPtr: PKDT3088DS_Vec; NodePtr: PKDT3088DS_Node): PKDT3088DS_Node;
  var
    Next       : PKDT3088DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3088DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3088DS_Node; const BuffPtr: PKDT3088DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3088DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3088DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3088DS_Vec; const p1, p2: PKDT3088DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3088DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3088DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3088DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3088DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3088DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3088DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3088DS_Node(NearestNodes[0]);
    end;
end;

function TKDT3088DS.Search(const Buff: TKDT3088DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3088DS.Search(const Buff: TKDT3088DS_Vec; var SearchedDistanceMin: Double): PKDT3088DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3088DS.Search(const Buff: TKDT3088DS_Vec): PKDT3088DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3088DS.Search(const inBuff: TKDT3088DS_DynamicVecBuffer; var OutBuff: TKDT3088DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3088DS_DynamicVecBuffer;
  outBuffPtr : PKDT3088DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3088DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3088DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3088DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3088DS.Search(const inBuff: TKDT3088DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3088DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3088DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3088DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3088DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3088DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3088DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3088DS_Source));
end;

procedure TKDT3088DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3088DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3088DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3088DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3088DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3088DS.PrintNodeTree(const NodePtr: PKDT3088DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3088DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3088DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3088DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3088DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3088DS.KDT3088DSVec(const s: string): TKDT3088DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3088DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3088DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3088DS.KDT3088DSVec(const v: TKDT3088DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3088DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3088DS.KDT3088DSPow(const v: TKDT3088DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3088DS.KDT3088DSDistance(const v1, v2: TKDT3088DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3088DS_Axis - 1 do
      Result := Result + KDT3088DSPow(v2[i] - v1[i]);
end;

procedure TKDT3088DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3088DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3088DS.Test;
var
  TKDT3088DS_Test    : TKDT3088DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3088DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3088DS_Test := TKDT3088DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3088DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT3088DS_Test.TestBuff) - 1 do
    for j := 0 to KDT3088DS_Axis - 1 do
        TKDT3088DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3088DS_Test.TestBuff), length(TKDT3088DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3088DS_Test.BuildKDTreeM(length(TKDT3088DS_Test.TestBuff), nil, @TKDT3088DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3088DS_Test.BuildKDTreeM(length(TKDT3088DS_Test.TestBuff), nil, TKDT3088DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3088DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3088DS_Test.TestBuff));
  TKDT3088DS_Test.Search(TKDT3088DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3088DSDistance(TKDT3088DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3088DS_Test.Clear;
  { kMean test }
  TKDT3088DS_Test.BuildKDTreeWithCluster(TKDT3088DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3088DS_Test.Search(TKDT3088DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3088DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3088DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3088DS_Test);
end;


function TKDT3104DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DS_Node;
  function SortCompare(const p1, p2: PKDT3104DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3104DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3104DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3104DS_SourceBuffer;
  dynBuff  : PKDT3104DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3104DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3104DS.GetData(const index: NativeInt): PKDT3104DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3104DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3104DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3104DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3104DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3104DS.StoreBuffPtr: PKDT3104DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3104DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3104DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3104DS.BuildKDTreeWithCluster(const inBuff: TKDT3104DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3104DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3104DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3104DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3104DS.BuildKDTreeWithCluster(const inBuff: TKDT3104DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3104DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildCall);
var
  TempStoreBuff: TKDT3104DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildMethod);
var
  TempStoreBuff: TKDT3104DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DS_BuildProc);
var
  TempStoreBuff: TKDT3104DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3104DS.Search(const Buff: TKDT3104DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DS_Node;

var
  NearestNeighbour: PKDT3104DS_Node;

  function FindParentNode(const BuffPtr: PKDT3104DS_Vec; NodePtr: PKDT3104DS_Node): PKDT3104DS_Node;
  var
    Next       : PKDT3104DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3104DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3104DS_Node; const BuffPtr: PKDT3104DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3104DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3104DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3104DS_Vec; const p1, p2: PKDT3104DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3104DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3104DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3104DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3104DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3104DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3104DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3104DS_Node(NearestNodes[0]);
    end;
end;

function TKDT3104DS.Search(const Buff: TKDT3104DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3104DS.Search(const Buff: TKDT3104DS_Vec; var SearchedDistanceMin: Double): PKDT3104DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3104DS.Search(const Buff: TKDT3104DS_Vec): PKDT3104DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3104DS.Search(const inBuff: TKDT3104DS_DynamicVecBuffer; var OutBuff: TKDT3104DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3104DS_DynamicVecBuffer;
  outBuffPtr : PKDT3104DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3104DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3104DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3104DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3104DS.Search(const inBuff: TKDT3104DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3104DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3104DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3104DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3104DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3104DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3104DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3104DS_Source));
end;

procedure TKDT3104DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3104DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3104DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3104DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3104DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3104DS.PrintNodeTree(const NodePtr: PKDT3104DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3104DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3104DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3104DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3104DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3104DS.KDT3104DSVec(const s: string): TKDT3104DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3104DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3104DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3104DS.KDT3104DSVec(const v: TKDT3104DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3104DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3104DS.KDT3104DSPow(const v: TKDT3104DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3104DS.KDT3104DSDistance(const v1, v2: TKDT3104DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3104DS_Axis - 1 do
      Result := Result + KDT3104DSPow(v2[i] - v1[i]);
end;

procedure TKDT3104DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3104DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3104DS.Test;
var
  TKDT3104DS_Test    : TKDT3104DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3104DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3104DS_Test := TKDT3104DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3104DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT3104DS_Test.TestBuff) - 1 do
    for j := 0 to KDT3104DS_Axis - 1 do
        TKDT3104DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3104DS_Test.TestBuff), length(TKDT3104DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3104DS_Test.BuildKDTreeM(length(TKDT3104DS_Test.TestBuff), nil, @TKDT3104DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3104DS_Test.BuildKDTreeM(length(TKDT3104DS_Test.TestBuff), nil, TKDT3104DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3104DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3104DS_Test.TestBuff));
  TKDT3104DS_Test.Search(TKDT3104DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3104DSDistance(TKDT3104DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3104DS_Test.Clear;
  { kMean test }
  TKDT3104DS_Test.BuildKDTreeWithCluster(TKDT3104DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3104DS_Test.Search(TKDT3104DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3104DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3104DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3104DS_Test);
end;


function TKDT4096DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DS_Node;
  function SortCompare(const p1, p2: PKDT4096DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4096DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4096DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4096DS_SourceBuffer;
  dynBuff  : PKDT4096DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT4096DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4096DS.GetData(const index: NativeInt): PKDT4096DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4096DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4096DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4096DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4096DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4096DS.StoreBuffPtr: PKDT4096DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4096DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4096DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4096DS.BuildKDTreeWithCluster(const inBuff: TKDT4096DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT4096DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT4096DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT4096DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4096DS.BuildKDTreeWithCluster(const inBuff: TKDT4096DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4096DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildCall);
var
  TempStoreBuff: TKDT4096DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildMethod);
var
  TempStoreBuff: TKDT4096DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DS_BuildProc);
var
  TempStoreBuff: TKDT4096DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT4096DS.Search(const Buff: TKDT4096DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DS_Node;

var
  NearestNeighbour: PKDT4096DS_Node;

  function FindParentNode(const BuffPtr: PKDT4096DS_Vec; NodePtr: PKDT4096DS_Node): PKDT4096DS_Node;
  var
    Next       : PKDT4096DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT4096DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4096DS_Node; const BuffPtr: PKDT4096DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4096DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT4096DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4096DS_Vec; const p1, p2: PKDT4096DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4096DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4096DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4096DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4096DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4096DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4096DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4096DS_Node(NearestNodes[0]);
    end;
end;

function TKDT4096DS.Search(const Buff: TKDT4096DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4096DS.Search(const Buff: TKDT4096DS_Vec; var SearchedDistanceMin: Double): PKDT4096DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4096DS.Search(const Buff: TKDT4096DS_Vec): PKDT4096DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4096DS.Search(const inBuff: TKDT4096DS_DynamicVecBuffer; var OutBuff: TKDT4096DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4096DS_DynamicVecBuffer;
  outBuffPtr : PKDT4096DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4096DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4096DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4096DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4096DS.Search(const inBuff: TKDT4096DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4096DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4096DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4096DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4096DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4096DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT4096DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4096DS_Source));
end;

procedure TKDT4096DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT4096DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4096DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4096DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4096DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4096DS.PrintNodeTree(const NodePtr: PKDT4096DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4096DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4096DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4096DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4096DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT4096DS.KDT4096DSVec(const s: string): TKDT4096DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT4096DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT4096DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT4096DS.KDT4096DSVec(const v: TKDT4096DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT4096DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT4096DS.KDT4096DSPow(const v: TKDT4096DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT4096DS.KDT4096DSDistance(const v1, v2: TKDT4096DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT4096DS_Axis - 1 do
      Result := Result + KDT4096DSPow(v2[i] - v1[i]);
end;

procedure TKDT4096DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4096DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4096DS.Test;
var
  TKDT4096DS_Test    : TKDT4096DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4096DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4096DS_Test := TKDT4096DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4096DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT4096DS_Test.TestBuff) - 1 do
    for j := 0 to KDT4096DS_Axis - 1 do
        TKDT4096DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT4096DS_Test.TestBuff), length(TKDT4096DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4096DS_Test.BuildKDTreeM(length(TKDT4096DS_Test.TestBuff), nil, @TKDT4096DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4096DS_Test.BuildKDTreeM(length(TKDT4096DS_Test.TestBuff), nil, TKDT4096DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4096DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4096DS_Test.TestBuff));
  TKDT4096DS_Test.Search(TKDT4096DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4096DSDistance(TKDT4096DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4096DS_Test.Clear;
  { kMean test }
  TKDT4096DS_Test.BuildKDTreeWithCluster(TKDT4096DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4096DS_Test.Search(TKDT4096DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4096DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4096DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4096DS_Test);
end;


function TKDT8192DS.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DS_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DS_Node;
  function SortCompare(const p1, p2: PKDT8192DS_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8192DS_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8192DS_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8192DS_SourceBuffer;
  dynBuff  : PKDT8192DSyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT8192DS_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8192DS.GetData(const index: NativeInt): PKDT8192DS_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8192DS.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8192DS.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8192DS.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8192DS_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8192DS.StoreBuffPtr: PKDT8192DSyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8192DS.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8192DS.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DS.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DSyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DS_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8192DS.BuildKDTreeWithCluster(const inBuff: TKDT8192DS_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT8192DS_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT8192DS_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT8192DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8192DS.BuildKDTreeWithCluster(const inBuff: TKDT8192DS_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8192DS.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildCall);
var
  TempStoreBuff: TKDT8192DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DS.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildMethod);
var
  TempStoreBuff: TKDT8192DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DS.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DS_BuildProc);
var
  TempStoreBuff: TKDT8192DSyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DS_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DS_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DS_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DS_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DS_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT8192DS.Search(const Buff: TKDT8192DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DS_Node;

var
  NearestNeighbour: PKDT8192DS_Node;

  function FindParentNode(const BuffPtr: PKDT8192DS_Vec; NodePtr: PKDT8192DS_Node): PKDT8192DS_Node;
  var
    Next       : PKDT8192DS_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT8192DS_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8192DS_Node; const BuffPtr: PKDT8192DS_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8192DSDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT8192DS_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8192DS_Vec; const p1, p2: PKDT8192DS_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8192DSDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8192DSDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8192DS_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8192DS_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8192DS_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8192DSDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8192DS_Node(NearestNodes[0]);
    end;
end;

function TKDT8192DS.Search(const Buff: TKDT8192DS_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DS_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8192DS.Search(const Buff: TKDT8192DS_Vec; var SearchedDistanceMin: Double): PKDT8192DS_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8192DS.Search(const Buff: TKDT8192DS_Vec): PKDT8192DS_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8192DS.Search(const inBuff: TKDT8192DS_DynamicVecBuffer; var OutBuff: TKDT8192DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8192DS_DynamicVecBuffer;
  outBuffPtr : PKDT8192DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8192DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8192DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8192DS_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8192DS.Search(const inBuff: TKDT8192DS_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8192DS_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8192DS_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8192DS_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8192DS_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8192DS.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT8192DS_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8192DS_Source));
end;

procedure TKDT8192DS.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT8192DS_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8192DS_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8192DS.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8192DS.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8192DS.PrintNodeTree(const NodePtr: PKDT8192DS_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8192DS_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8192DSVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8192DS.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8192DSVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT8192DS.KDT8192DSVec(const s: string): TKDT8192DS_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT8192DS_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT8192DS_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT8192DS.KDT8192DSVec(const v: TKDT8192DS_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT8192DS_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT8192DS.KDT8192DSPow(const v: TKDT8192DS_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT8192DS.KDT8192DSDistance(const v1, v2: TKDT8192DS_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT8192DS_Axis - 1 do
      Result := Result + KDT8192DSPow(v2[i] - v1[i]);
end;

procedure TKDT8192DS.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8192DS_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8192DS.Test;
var
  TKDT8192DS_Test    : TKDT8192DS;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8192DS_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8192DS_Test := TKDT8192DS.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8192DS_Test.TestBuff, 100);
  for i := 0 to length(TKDT8192DS_Test.TestBuff) - 1 do
    for j := 0 to KDT8192DS_Axis - 1 do
        TKDT8192DS_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT8192DS_Test.TestBuff), length(TKDT8192DS_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8192DS_Test.BuildKDTreeM(length(TKDT8192DS_Test.TestBuff), nil, @TKDT8192DS_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8192DS_Test.BuildKDTreeM(length(TKDT8192DS_Test.TestBuff), nil, TKDT8192DS_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8192DS_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8192DS_Test.TestBuff));
  TKDT8192DS_Test.Search(TKDT8192DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8192DSDistance(TKDT8192DS_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8192DS_Test.Clear;
  { kMean test }
  TKDT8192DS_Test.BuildKDTreeWithCluster(TKDT8192DS_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8192DS_Test.Search(TKDT8192DS_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8192DS_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8192DS_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8192DS_Test);
end;


procedure Test_All;
begin
  TKDT1DS.Test();
  TKDT2DS.Test();
  TKDT3DS.Test();
  TKDT4DS.Test();
  TKDT5DS.Test();
  TKDT6DS.Test();
  TKDT7DS.Test();
  TKDT8DS.Test();
  TKDT9DS.Test();
  TKDT10DS.Test();
  TKDT11DS.Test();
  TKDT12DS.Test();
  TKDT13DS.Test();
  TKDT14DS.Test();
  TKDT15DS.Test();
  TKDT16DS.Test();
  TKDT17DS.Test();
  TKDT18DS.Test();
  TKDT19DS.Test();
  TKDT20DS.Test();
  TKDT21DS.Test();
  TKDT22DS.Test();
  TKDT23DS.Test();
  TKDT24DS.Test();
  TKDT25DS.Test();
  TKDT26DS.Test();
  TKDT27DS.Test();
  TKDT28DS.Test();
  TKDT29DS.Test();
  TKDT30DS.Test();
  TKDT31DS.Test();
  TKDT32DS.Test();
  TKDT33DS.Test();
  TKDT34DS.Test();
  TKDT35DS.Test();
  TKDT36DS.Test();
  TKDT37DS.Test();
  TKDT38DS.Test();
  TKDT39DS.Test();
  TKDT40DS.Test();
  TKDT41DS.Test();
  TKDT42DS.Test();
  TKDT43DS.Test();
  TKDT44DS.Test();
  TKDT45DS.Test();
  TKDT46DS.Test();
  TKDT47DS.Test();
  TKDT48DS.Test();
  TKDT49DS.Test();
  TKDT50DS.Test();
  TKDT51DS.Test();
  TKDT52DS.Test();
  TKDT53DS.Test();
  TKDT54DS.Test();
  TKDT55DS.Test();
  TKDT56DS.Test();
  TKDT57DS.Test();
  TKDT58DS.Test();
  TKDT59DS.Test();
  TKDT60DS.Test();
  TKDT61DS.Test();
  TKDT62DS.Test();
  TKDT63DS.Test();
  TKDT64DS.Test();
  TKDT65DS.Test();
  TKDT66DS.Test();
  TKDT67DS.Test();
  TKDT68DS.Test();
  TKDT69DS.Test();
  TKDT70DS.Test();
  TKDT71DS.Test();
  TKDT72DS.Test();
  TKDT84DS.Test();
  TKDT96DS.Test();
  TKDT128DS.Test();
  TKDT140DS.Test();
  TKDT160DS.Test();
  TKDT196DS.Test();
  TKDT256DS.Test();
  TKDT272DS.Test();
  TKDT288DS.Test();
  TKDT372DS.Test();
  TKDT512DS.Test();
  TKDT576DS.Test();
  TKDT768DS.Test();
  TKDT1024DS.Test();
  TKDT1040DS.Test();
  TKDT1056DS.Test();
  TKDT1536DS.Test();
  TKDT1920DS.Test();
  TKDT1980DS.Test();
  TKDT2048DS.Test();
  TKDT3072DS.Test();
  TKDT3088DS.Test();
  TKDT3104DS.Test();
  TKDT4096DS.Test();
  TKDT8192DS.Test();
  DoStatus('All Test Finished');
end;





initialization

finalization

end.

