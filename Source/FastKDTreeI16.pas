{ Fast KDTree SmallInt type support                                              }
{ ****************************************************************************** }
{ * fast KDTree Support,writen by QQ 600585@qq.com                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ ****************************************************************************** }

unit FastKDTreeI16;

interface

uses CoreClasses, KM;

{$I zDefine.inc}

{$IFDEF FPC}
{$DEFINE DEBUG}
{$ENDIF FPC}

const

  // SmallInt KDTree
  TKDT1DI16_AxisCount = 1;
  TKDT2DI16_AxisCount = 2;
  TKDT3DI16_AxisCount = 3;
  TKDT4DI16_AxisCount = 4;
  TKDT6DI16_AxisCount = 6;
  TKDT8DI16_AxisCount = 8;
  TKDT10DI16_AxisCount = 10;
  TKDT12DI16_AxisCount = 12;
  TKDT14DI16_AxisCount = 14;
  TKDT16DI16_AxisCount = 16;
  TKDT18DI16_AxisCount = 18;
  TKDT20DI16_AxisCount = 20;
  TKDT22DI16_AxisCount = 22;
  TKDT24DI16_AxisCount = 24;
  TKDT28DI16_AxisCount = 28;
  TKDT30DI16_AxisCount = 30;
  TKDT32DI16_AxisCount = 32;
  TKDT34DI16_AxisCount = 34;
  TKDT36DI16_AxisCount = 36;
  TKDT40DI16_AxisCount = 40;
  TKDT48DI16_AxisCount = 48;
  TKDT64DI16_AxisCount = 64;
  TKDT96DI16_AxisCount = 96;
  TKDT128DI16_AxisCount = 128;
  TKDT256DI16_AxisCount = 256;
  TKDT372DI16_AxisCount = 372;
  TKDT512DI16_AxisCount = 512;
  TKDT640DI16_AxisCount = 640;
  TKDT768DI16_AxisCount = 768;
  TKDT1024DI16_AxisCount = 1024;
  TKDT1080DI16_AxisCount = 1080;
  TKDT1536DI16_AxisCount = 1536;
  TKDT1920DI16_AxisCount = 1920;
  TKDT2048DI16_AxisCount = 2048;
  TKDT3072DI16_AxisCount = 3072;

type

  // SmallInt: KDTree
  TKDT1DI16 = class;  TKDT1DI16_VecType = Single; // 1D
  TKDT2DI16 = class;  TKDT2DI16_VecType = Single; // 2D
  TKDT3DI16 = class;  TKDT3DI16_VecType = Single; // 3D
  TKDT4DI16 = class;  TKDT4DI16_VecType = Single; // 4D
  TKDT6DI16 = class;  TKDT6DI16_VecType = Single; // 6D
  TKDT8DI16 = class;  TKDT8DI16_VecType = Single; // 8D
  TKDT10DI16 = class;  TKDT10DI16_VecType = Single; // 10D
  TKDT12DI16 = class;  TKDT12DI16_VecType = Single; // 12D
  TKDT14DI16 = class;  TKDT14DI16_VecType = Single; // 14D
  TKDT16DI16 = class;  TKDT16DI16_VecType = Single; // 16D
  TKDT18DI16 = class;  TKDT18DI16_VecType = Single; // 18D
  TKDT20DI16 = class;  TKDT20DI16_VecType = Single; // 20D
  TKDT22DI16 = class;  TKDT22DI16_VecType = Single; // 22D
  TKDT24DI16 = class;  TKDT24DI16_VecType = Single; // 24D
  TKDT28DI16 = class;  TKDT28DI16_VecType = Single; // 28D
  TKDT30DI16 = class;  TKDT30DI16_VecType = Single; // 30D
  TKDT32DI16 = class;  TKDT32DI16_VecType = Single; // 32D
  TKDT34DI16 = class;  TKDT34DI16_VecType = Single; // 34D
  TKDT36DI16 = class;  TKDT36DI16_VecType = Single; // 36D
  TKDT40DI16 = class;  TKDT40DI16_VecType = Single; // 40D
  TKDT48DI16 = class;  TKDT48DI16_VecType = Single; // 48D
  TKDT64DI16 = class;  TKDT64DI16_VecType = Single; // 64D
  TKDT96DI16 = class;  TKDT96DI16_VecType = Single; // 96D
  TKDT128DI16 = class;  TKDT128DI16_VecType = Single; // 128D
  TKDT256DI16 = class;  TKDT256DI16_VecType = Single; // 256D
  TKDT372DI16 = class;  TKDT372DI16_VecType = Single; // 372D
  TKDT512DI16 = class;  TKDT512DI16_VecType = Single; // 512D
  TKDT640DI16 = class;  TKDT640DI16_VecType = Single; // 640D
  TKDT768DI16 = class;  TKDT768DI16_VecType = Single; // 768D
  TKDT1024DI16 = class;  TKDT1024DI16_VecType = Single; // 1024D
  TKDT1080DI16 = class;  TKDT1080DI16_VecType = Single; // 1080D
  TKDT1536DI16 = class;  TKDT1536DI16_VecType = Single; // 1536D
  TKDT1920DI16 = class;  TKDT1920DI16_VecType = Single; // 1920D
  TKDT2048DI16 = class;  TKDT2048DI16_VecType = Single; // 2048D
  TKDT3072DI16 = class;  TKDT3072DI16_VecType = Single; // 3072D










  // SmallInt KDTree


  TKDT1DI16_Vec = array [0 .. TKDT1DI16_AxisCount - 1] of TKDT1DI16_VecType;
  PKDT1DI16_Vec = ^TKDT1DI16_Vec;

  TKDT1DI16_DynamicVecBuffer = array of TKDT1DI16_Vec;
  PKDT1DI16_DynamicVecBuffer = ^TKDT1DI16_DynamicVecBuffer;

  TKDT1DI16_Source = packed record
    Buff: TKDT1DI16_Vec;
    index: Int64;
  end;

  PKDT1DI16_Source       = ^TKDT1DI16_Source;
  TKDT1DI16_SourceBuffer = array [0 .. 0] of PKDT1DI16_Source;
  PKDT1DI16_SourceBuffer = ^TKDT1DI16_SourceBuffer;

  TKDT1DI16yanmicSourceBuffer = array of PKDT1DI16_Source;
  PKDT1DI16yanmicSourceBuffer = ^TKDT1DI16yanmicSourceBuffer;

  TKDT1DI16yanmicStoreBuffer = array of TKDT1DI16_Source;
  PKDT1DI16yanmicStoreBuffer = ^TKDT1DI16yanmicStoreBuffer;

  PKDT1DI16_Node = ^TKDT1DI16_Node;

  TKDT1DI16_Node = packed record
    Parent, Right, Left: PKDT1DI16_Node;
    vec: PKDT1DI16_Source;
  end;

  TKDT1DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1DI16_Source);
  TKDT1DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT1DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1DI16_Source);
  {$ENDIF}

  TKDT1DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1DI16yanmicStoreBuffer;
    KDBuff     : TKDT1DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1DI16yanmicStoreBuffer; const Buff: TKDT1DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DI16_Node; overload;
    function Search(const Buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DI16_Node; overload;
    function Search(const Buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double): PKDT1DI16_Node; overload;
    function Search(const Buff: TKDT1DI16_Vec): PKDT1DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1DI16_DynamicVecBuffer; var OutBuff: TKDT1DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT2DI16_Vec = array [0 .. TKDT2DI16_AxisCount - 1] of TKDT2DI16_VecType;
  PKDT2DI16_Vec = ^TKDT2DI16_Vec;

  TKDT2DI16_DynamicVecBuffer = array of TKDT2DI16_Vec;
  PKDT2DI16_DynamicVecBuffer = ^TKDT2DI16_DynamicVecBuffer;

  TKDT2DI16_Source = packed record
    Buff: TKDT2DI16_Vec;
    index: Int64;
  end;

  PKDT2DI16_Source       = ^TKDT2DI16_Source;
  TKDT2DI16_SourceBuffer = array [0 .. 0] of PKDT2DI16_Source;
  PKDT2DI16_SourceBuffer = ^TKDT2DI16_SourceBuffer;

  TKDT2DI16yanmicSourceBuffer = array of PKDT2DI16_Source;
  PKDT2DI16yanmicSourceBuffer = ^TKDT2DI16yanmicSourceBuffer;

  TKDT2DI16yanmicStoreBuffer = array of TKDT2DI16_Source;
  PKDT2DI16yanmicStoreBuffer = ^TKDT2DI16yanmicStoreBuffer;

  PKDT2DI16_Node = ^TKDT2DI16_Node;

  TKDT2DI16_Node = packed record
    Parent, Right, Left: PKDT2DI16_Node;
    vec: PKDT2DI16_Source;
  end;

  TKDT2DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT2DI16_Source);
  TKDT2DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT2DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT2DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT2DI16_Source);
  {$ENDIF}

  TKDT2DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2DI16yanmicStoreBuffer;
    KDBuff     : TKDT2DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT2DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT2DI16yanmicStoreBuffer; const Buff: TKDT2DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT2DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DI16_Node; overload;
    function Search(const Buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DI16_Node; overload;
    function Search(const Buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double): PKDT2DI16_Node; overload;
    function Search(const Buff: TKDT2DI16_Vec): PKDT2DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2DI16_DynamicVecBuffer; var OutBuff: TKDT2DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT2DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT2DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3DI16_Vec = array [0 .. TKDT3DI16_AxisCount - 1] of TKDT3DI16_VecType;
  PKDT3DI16_Vec = ^TKDT3DI16_Vec;

  TKDT3DI16_DynamicVecBuffer = array of TKDT3DI16_Vec;
  PKDT3DI16_DynamicVecBuffer = ^TKDT3DI16_DynamicVecBuffer;

  TKDT3DI16_Source = packed record
    Buff: TKDT3DI16_Vec;
    index: Int64;
  end;

  PKDT3DI16_Source       = ^TKDT3DI16_Source;
  TKDT3DI16_SourceBuffer = array [0 .. 0] of PKDT3DI16_Source;
  PKDT3DI16_SourceBuffer = ^TKDT3DI16_SourceBuffer;

  TKDT3DI16yanmicSourceBuffer = array of PKDT3DI16_Source;
  PKDT3DI16yanmicSourceBuffer = ^TKDT3DI16yanmicSourceBuffer;

  TKDT3DI16yanmicStoreBuffer = array of TKDT3DI16_Source;
  PKDT3DI16yanmicStoreBuffer = ^TKDT3DI16yanmicStoreBuffer;

  PKDT3DI16_Node = ^TKDT3DI16_Node;

  TKDT3DI16_Node = packed record
    Parent, Right, Left: PKDT3DI16_Node;
    vec: PKDT3DI16_Source;
  end;

  TKDT3DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3DI16_Source);
  TKDT3DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT3DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3DI16_Source);
  {$ENDIF}

  TKDT3DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3DI16yanmicStoreBuffer;
    KDBuff     : TKDT3DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3DI16yanmicStoreBuffer; const Buff: TKDT3DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DI16_Node; overload;
    function Search(const Buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DI16_Node; overload;
    function Search(const Buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double): PKDT3DI16_Node; overload;
    function Search(const Buff: TKDT3DI16_Vec): PKDT3DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3DI16_DynamicVecBuffer; var OutBuff: TKDT3DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT4DI16_Vec = array [0 .. TKDT4DI16_AxisCount - 1] of TKDT4DI16_VecType;
  PKDT4DI16_Vec = ^TKDT4DI16_Vec;

  TKDT4DI16_DynamicVecBuffer = array of TKDT4DI16_Vec;
  PKDT4DI16_DynamicVecBuffer = ^TKDT4DI16_DynamicVecBuffer;

  TKDT4DI16_Source = packed record
    Buff: TKDT4DI16_Vec;
    index: Int64;
  end;

  PKDT4DI16_Source       = ^TKDT4DI16_Source;
  TKDT4DI16_SourceBuffer = array [0 .. 0] of PKDT4DI16_Source;
  PKDT4DI16_SourceBuffer = ^TKDT4DI16_SourceBuffer;

  TKDT4DI16yanmicSourceBuffer = array of PKDT4DI16_Source;
  PKDT4DI16yanmicSourceBuffer = ^TKDT4DI16yanmicSourceBuffer;

  TKDT4DI16yanmicStoreBuffer = array of TKDT4DI16_Source;
  PKDT4DI16yanmicStoreBuffer = ^TKDT4DI16yanmicStoreBuffer;

  PKDT4DI16_Node = ^TKDT4DI16_Node;

  TKDT4DI16_Node = packed record
    Parent, Right, Left: PKDT4DI16_Node;
    vec: PKDT4DI16_Source;
  end;

  TKDT4DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT4DI16_Source);
  TKDT4DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT4DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT4DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT4DI16_Source);
  {$ENDIF}

  TKDT4DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT4DI16yanmicStoreBuffer;
    KDBuff     : TKDT4DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT4DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT4DI16yanmicStoreBuffer; const Buff: TKDT4DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT4DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT4DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DI16_Node; overload;
    function Search(const Buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DI16_Node; overload;
    function Search(const Buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double): PKDT4DI16_Node; overload;
    function Search(const Buff: TKDT4DI16_Vec): PKDT4DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4DI16_DynamicVecBuffer; var OutBuff: TKDT4DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT4DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT4DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT6DI16_Vec = array [0 .. TKDT6DI16_AxisCount - 1] of TKDT6DI16_VecType;
  PKDT6DI16_Vec = ^TKDT6DI16_Vec;

  TKDT6DI16_DynamicVecBuffer = array of TKDT6DI16_Vec;
  PKDT6DI16_DynamicVecBuffer = ^TKDT6DI16_DynamicVecBuffer;

  TKDT6DI16_Source = packed record
    Buff: TKDT6DI16_Vec;
    index: Int64;
  end;

  PKDT6DI16_Source       = ^TKDT6DI16_Source;
  TKDT6DI16_SourceBuffer = array [0 .. 0] of PKDT6DI16_Source;
  PKDT6DI16_SourceBuffer = ^TKDT6DI16_SourceBuffer;

  TKDT6DI16yanmicSourceBuffer = array of PKDT6DI16_Source;
  PKDT6DI16yanmicSourceBuffer = ^TKDT6DI16yanmicSourceBuffer;

  TKDT6DI16yanmicStoreBuffer = array of TKDT6DI16_Source;
  PKDT6DI16yanmicStoreBuffer = ^TKDT6DI16yanmicStoreBuffer;

  PKDT6DI16_Node = ^TKDT6DI16_Node;

  TKDT6DI16_Node = packed record
    Parent, Right, Left: PKDT6DI16_Node;
    vec: PKDT6DI16_Source;
  end;

  TKDT6DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT6DI16_Source);
  TKDT6DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT6DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT6DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT6DI16_Source);
  {$ENDIF}

  TKDT6DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT6DI16yanmicStoreBuffer;
    KDBuff     : TKDT6DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT6DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT6DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT6DI16yanmicStoreBuffer; const Buff: TKDT6DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT6DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT6DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT6DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DI16_Node; overload;
    function Search(const Buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DI16_Node; overload;
    function Search(const Buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double): PKDT6DI16_Node; overload;
    function Search(const Buff: TKDT6DI16_Vec): PKDT6DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT6DI16_DynamicVecBuffer; var OutBuff: TKDT6DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT6DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT6DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT8DI16_Vec = array [0 .. TKDT8DI16_AxisCount - 1] of TKDT8DI16_VecType;
  PKDT8DI16_Vec = ^TKDT8DI16_Vec;

  TKDT8DI16_DynamicVecBuffer = array of TKDT8DI16_Vec;
  PKDT8DI16_DynamicVecBuffer = ^TKDT8DI16_DynamicVecBuffer;

  TKDT8DI16_Source = packed record
    Buff: TKDT8DI16_Vec;
    index: Int64;
  end;

  PKDT8DI16_Source       = ^TKDT8DI16_Source;
  TKDT8DI16_SourceBuffer = array [0 .. 0] of PKDT8DI16_Source;
  PKDT8DI16_SourceBuffer = ^TKDT8DI16_SourceBuffer;

  TKDT8DI16yanmicSourceBuffer = array of PKDT8DI16_Source;
  PKDT8DI16yanmicSourceBuffer = ^TKDT8DI16yanmicSourceBuffer;

  TKDT8DI16yanmicStoreBuffer = array of TKDT8DI16_Source;
  PKDT8DI16yanmicStoreBuffer = ^TKDT8DI16yanmicStoreBuffer;

  PKDT8DI16_Node = ^TKDT8DI16_Node;

  TKDT8DI16_Node = packed record
    Parent, Right, Left: PKDT8DI16_Node;
    vec: PKDT8DI16_Source;
  end;

  TKDT8DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT8DI16_Source);
  TKDT8DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT8DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT8DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT8DI16_Source);
  {$ENDIF}

  TKDT8DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT8DI16yanmicStoreBuffer;
    KDBuff     : TKDT8DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT8DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT8DI16yanmicStoreBuffer; const Buff: TKDT8DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT8DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT8DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DI16_Node; overload;
    function Search(const Buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DI16_Node; overload;
    function Search(const Buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double): PKDT8DI16_Node; overload;
    function Search(const Buff: TKDT8DI16_Vec): PKDT8DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8DI16_DynamicVecBuffer; var OutBuff: TKDT8DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT8DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT8DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT10DI16_Vec = array [0 .. TKDT10DI16_AxisCount - 1] of TKDT10DI16_VecType;
  PKDT10DI16_Vec = ^TKDT10DI16_Vec;

  TKDT10DI16_DynamicVecBuffer = array of TKDT10DI16_Vec;
  PKDT10DI16_DynamicVecBuffer = ^TKDT10DI16_DynamicVecBuffer;

  TKDT10DI16_Source = packed record
    Buff: TKDT10DI16_Vec;
    index: Int64;
  end;

  PKDT10DI16_Source       = ^TKDT10DI16_Source;
  TKDT10DI16_SourceBuffer = array [0 .. 0] of PKDT10DI16_Source;
  PKDT10DI16_SourceBuffer = ^TKDT10DI16_SourceBuffer;

  TKDT10DI16yanmicSourceBuffer = array of PKDT10DI16_Source;
  PKDT10DI16yanmicSourceBuffer = ^TKDT10DI16yanmicSourceBuffer;

  TKDT10DI16yanmicStoreBuffer = array of TKDT10DI16_Source;
  PKDT10DI16yanmicStoreBuffer = ^TKDT10DI16yanmicStoreBuffer;

  PKDT10DI16_Node = ^TKDT10DI16_Node;

  TKDT10DI16_Node = packed record
    Parent, Right, Left: PKDT10DI16_Node;
    vec: PKDT10DI16_Source;
  end;

  TKDT10DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT10DI16_Source);
  TKDT10DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT10DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT10DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT10DI16_Source);
  {$ENDIF}

  TKDT10DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT10DI16yanmicStoreBuffer;
    KDBuff     : TKDT10DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT10DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT10DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT10DI16yanmicStoreBuffer; const Buff: TKDT10DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT10DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT10DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT10DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DI16_Node; overload;
    function Search(const Buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DI16_Node; overload;
    function Search(const Buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double): PKDT10DI16_Node; overload;
    function Search(const Buff: TKDT10DI16_Vec): PKDT10DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT10DI16_DynamicVecBuffer; var OutBuff: TKDT10DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT10DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT10DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT12DI16_Vec = array [0 .. TKDT12DI16_AxisCount - 1] of TKDT12DI16_VecType;
  PKDT12DI16_Vec = ^TKDT12DI16_Vec;

  TKDT12DI16_DynamicVecBuffer = array of TKDT12DI16_Vec;
  PKDT12DI16_DynamicVecBuffer = ^TKDT12DI16_DynamicVecBuffer;

  TKDT12DI16_Source = packed record
    Buff: TKDT12DI16_Vec;
    index: Int64;
  end;

  PKDT12DI16_Source       = ^TKDT12DI16_Source;
  TKDT12DI16_SourceBuffer = array [0 .. 0] of PKDT12DI16_Source;
  PKDT12DI16_SourceBuffer = ^TKDT12DI16_SourceBuffer;

  TKDT12DI16yanmicSourceBuffer = array of PKDT12DI16_Source;
  PKDT12DI16yanmicSourceBuffer = ^TKDT12DI16yanmicSourceBuffer;

  TKDT12DI16yanmicStoreBuffer = array of TKDT12DI16_Source;
  PKDT12DI16yanmicStoreBuffer = ^TKDT12DI16yanmicStoreBuffer;

  PKDT12DI16_Node = ^TKDT12DI16_Node;

  TKDT12DI16_Node = packed record
    Parent, Right, Left: PKDT12DI16_Node;
    vec: PKDT12DI16_Source;
  end;

  TKDT12DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT12DI16_Source);
  TKDT12DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT12DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT12DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT12DI16_Source);
  {$ENDIF}

  TKDT12DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT12DI16yanmicStoreBuffer;
    KDBuff     : TKDT12DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT12DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT12DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT12DI16yanmicStoreBuffer; const Buff: TKDT12DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT12DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT12DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT12DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DI16_Node; overload;
    function Search(const Buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DI16_Node; overload;
    function Search(const Buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double): PKDT12DI16_Node; overload;
    function Search(const Buff: TKDT12DI16_Vec): PKDT12DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT12DI16_DynamicVecBuffer; var OutBuff: TKDT12DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT12DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT12DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT14DI16_Vec = array [0 .. TKDT14DI16_AxisCount - 1] of TKDT14DI16_VecType;
  PKDT14DI16_Vec = ^TKDT14DI16_Vec;

  TKDT14DI16_DynamicVecBuffer = array of TKDT14DI16_Vec;
  PKDT14DI16_DynamicVecBuffer = ^TKDT14DI16_DynamicVecBuffer;

  TKDT14DI16_Source = packed record
    Buff: TKDT14DI16_Vec;
    index: Int64;
  end;

  PKDT14DI16_Source       = ^TKDT14DI16_Source;
  TKDT14DI16_SourceBuffer = array [0 .. 0] of PKDT14DI16_Source;
  PKDT14DI16_SourceBuffer = ^TKDT14DI16_SourceBuffer;

  TKDT14DI16yanmicSourceBuffer = array of PKDT14DI16_Source;
  PKDT14DI16yanmicSourceBuffer = ^TKDT14DI16yanmicSourceBuffer;

  TKDT14DI16yanmicStoreBuffer = array of TKDT14DI16_Source;
  PKDT14DI16yanmicStoreBuffer = ^TKDT14DI16yanmicStoreBuffer;

  PKDT14DI16_Node = ^TKDT14DI16_Node;

  TKDT14DI16_Node = packed record
    Parent, Right, Left: PKDT14DI16_Node;
    vec: PKDT14DI16_Source;
  end;

  TKDT14DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT14DI16_Source);
  TKDT14DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT14DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT14DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT14DI16_Source);
  {$ENDIF}

  TKDT14DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT14DI16yanmicStoreBuffer;
    KDBuff     : TKDT14DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT14DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT14DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT14DI16yanmicStoreBuffer; const Buff: TKDT14DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT14DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT14DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT14DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DI16_Node; overload;
    function Search(const Buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DI16_Node; overload;
    function Search(const Buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double): PKDT14DI16_Node; overload;
    function Search(const Buff: TKDT14DI16_Vec): PKDT14DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT14DI16_DynamicVecBuffer; var OutBuff: TKDT14DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT14DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT14DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT16DI16_Vec = array [0 .. TKDT16DI16_AxisCount - 1] of TKDT16DI16_VecType;
  PKDT16DI16_Vec = ^TKDT16DI16_Vec;

  TKDT16DI16_DynamicVecBuffer = array of TKDT16DI16_Vec;
  PKDT16DI16_DynamicVecBuffer = ^TKDT16DI16_DynamicVecBuffer;

  TKDT16DI16_Source = packed record
    Buff: TKDT16DI16_Vec;
    index: Int64;
  end;

  PKDT16DI16_Source       = ^TKDT16DI16_Source;
  TKDT16DI16_SourceBuffer = array [0 .. 0] of PKDT16DI16_Source;
  PKDT16DI16_SourceBuffer = ^TKDT16DI16_SourceBuffer;

  TKDT16DI16yanmicSourceBuffer = array of PKDT16DI16_Source;
  PKDT16DI16yanmicSourceBuffer = ^TKDT16DI16yanmicSourceBuffer;

  TKDT16DI16yanmicStoreBuffer = array of TKDT16DI16_Source;
  PKDT16DI16yanmicStoreBuffer = ^TKDT16DI16yanmicStoreBuffer;

  PKDT16DI16_Node = ^TKDT16DI16_Node;

  TKDT16DI16_Node = packed record
    Parent, Right, Left: PKDT16DI16_Node;
    vec: PKDT16DI16_Source;
  end;

  TKDT16DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT16DI16_Source);
  TKDT16DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT16DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT16DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT16DI16_Source);
  {$ENDIF}

  TKDT16DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT16DI16yanmicStoreBuffer;
    KDBuff     : TKDT16DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT16DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT16DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT16DI16yanmicStoreBuffer; const Buff: TKDT16DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT16DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT16DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT16DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DI16_Node; overload;
    function Search(const Buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DI16_Node; overload;
    function Search(const Buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double): PKDT16DI16_Node; overload;
    function Search(const Buff: TKDT16DI16_Vec): PKDT16DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT16DI16_DynamicVecBuffer; var OutBuff: TKDT16DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT16DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT16DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT18DI16_Vec = array [0 .. TKDT18DI16_AxisCount - 1] of TKDT18DI16_VecType;
  PKDT18DI16_Vec = ^TKDT18DI16_Vec;

  TKDT18DI16_DynamicVecBuffer = array of TKDT18DI16_Vec;
  PKDT18DI16_DynamicVecBuffer = ^TKDT18DI16_DynamicVecBuffer;

  TKDT18DI16_Source = packed record
    Buff: TKDT18DI16_Vec;
    index: Int64;
  end;

  PKDT18DI16_Source       = ^TKDT18DI16_Source;
  TKDT18DI16_SourceBuffer = array [0 .. 0] of PKDT18DI16_Source;
  PKDT18DI16_SourceBuffer = ^TKDT18DI16_SourceBuffer;

  TKDT18DI16yanmicSourceBuffer = array of PKDT18DI16_Source;
  PKDT18DI16yanmicSourceBuffer = ^TKDT18DI16yanmicSourceBuffer;

  TKDT18DI16yanmicStoreBuffer = array of TKDT18DI16_Source;
  PKDT18DI16yanmicStoreBuffer = ^TKDT18DI16yanmicStoreBuffer;

  PKDT18DI16_Node = ^TKDT18DI16_Node;

  TKDT18DI16_Node = packed record
    Parent, Right, Left: PKDT18DI16_Node;
    vec: PKDT18DI16_Source;
  end;

  TKDT18DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT18DI16_Source);
  TKDT18DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT18DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT18DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT18DI16_Source);
  {$ENDIF}

  TKDT18DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT18DI16yanmicStoreBuffer;
    KDBuff     : TKDT18DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT18DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT18DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT18DI16yanmicStoreBuffer; const Buff: TKDT18DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT18DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT18DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT18DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DI16_Node; overload;
    function Search(const Buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DI16_Node; overload;
    function Search(const Buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double): PKDT18DI16_Node; overload;
    function Search(const Buff: TKDT18DI16_Vec): PKDT18DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT18DI16_DynamicVecBuffer; var OutBuff: TKDT18DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT18DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT18DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT20DI16_Vec = array [0 .. TKDT20DI16_AxisCount - 1] of TKDT20DI16_VecType;
  PKDT20DI16_Vec = ^TKDT20DI16_Vec;

  TKDT20DI16_DynamicVecBuffer = array of TKDT20DI16_Vec;
  PKDT20DI16_DynamicVecBuffer = ^TKDT20DI16_DynamicVecBuffer;

  TKDT20DI16_Source = packed record
    Buff: TKDT20DI16_Vec;
    index: Int64;
  end;

  PKDT20DI16_Source       = ^TKDT20DI16_Source;
  TKDT20DI16_SourceBuffer = array [0 .. 0] of PKDT20DI16_Source;
  PKDT20DI16_SourceBuffer = ^TKDT20DI16_SourceBuffer;

  TKDT20DI16yanmicSourceBuffer = array of PKDT20DI16_Source;
  PKDT20DI16yanmicSourceBuffer = ^TKDT20DI16yanmicSourceBuffer;

  TKDT20DI16yanmicStoreBuffer = array of TKDT20DI16_Source;
  PKDT20DI16yanmicStoreBuffer = ^TKDT20DI16yanmicStoreBuffer;

  PKDT20DI16_Node = ^TKDT20DI16_Node;

  TKDT20DI16_Node = packed record
    Parent, Right, Left: PKDT20DI16_Node;
    vec: PKDT20DI16_Source;
  end;

  TKDT20DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT20DI16_Source);
  TKDT20DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT20DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT20DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT20DI16_Source);
  {$ENDIF}

  TKDT20DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT20DI16yanmicStoreBuffer;
    KDBuff     : TKDT20DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT20DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT20DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT20DI16yanmicStoreBuffer; const Buff: TKDT20DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT20DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT20DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT20DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DI16_Node; overload;
    function Search(const Buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DI16_Node; overload;
    function Search(const Buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double): PKDT20DI16_Node; overload;
    function Search(const Buff: TKDT20DI16_Vec): PKDT20DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT20DI16_DynamicVecBuffer; var OutBuff: TKDT20DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT20DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT20DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT22DI16_Vec = array [0 .. TKDT22DI16_AxisCount - 1] of TKDT22DI16_VecType;
  PKDT22DI16_Vec = ^TKDT22DI16_Vec;

  TKDT22DI16_DynamicVecBuffer = array of TKDT22DI16_Vec;
  PKDT22DI16_DynamicVecBuffer = ^TKDT22DI16_DynamicVecBuffer;

  TKDT22DI16_Source = packed record
    Buff: TKDT22DI16_Vec;
    index: Int64;
  end;

  PKDT22DI16_Source       = ^TKDT22DI16_Source;
  TKDT22DI16_SourceBuffer = array [0 .. 0] of PKDT22DI16_Source;
  PKDT22DI16_SourceBuffer = ^TKDT22DI16_SourceBuffer;

  TKDT22DI16yanmicSourceBuffer = array of PKDT22DI16_Source;
  PKDT22DI16yanmicSourceBuffer = ^TKDT22DI16yanmicSourceBuffer;

  TKDT22DI16yanmicStoreBuffer = array of TKDT22DI16_Source;
  PKDT22DI16yanmicStoreBuffer = ^TKDT22DI16yanmicStoreBuffer;

  PKDT22DI16_Node = ^TKDT22DI16_Node;

  TKDT22DI16_Node = packed record
    Parent, Right, Left: PKDT22DI16_Node;
    vec: PKDT22DI16_Source;
  end;

  TKDT22DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT22DI16_Source);
  TKDT22DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT22DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT22DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT22DI16_Source);
  {$ENDIF}

  TKDT22DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT22DI16yanmicStoreBuffer;
    KDBuff     : TKDT22DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT22DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT22DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT22DI16yanmicStoreBuffer; const Buff: TKDT22DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT22DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT22DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT22DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DI16_Node; overload;
    function Search(const Buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DI16_Node; overload;
    function Search(const Buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double): PKDT22DI16_Node; overload;
    function Search(const Buff: TKDT22DI16_Vec): PKDT22DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT22DI16_DynamicVecBuffer; var OutBuff: TKDT22DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT22DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT22DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT24DI16_Vec = array [0 .. TKDT24DI16_AxisCount - 1] of TKDT24DI16_VecType;
  PKDT24DI16_Vec = ^TKDT24DI16_Vec;

  TKDT24DI16_DynamicVecBuffer = array of TKDT24DI16_Vec;
  PKDT24DI16_DynamicVecBuffer = ^TKDT24DI16_DynamicVecBuffer;

  TKDT24DI16_Source = packed record
    Buff: TKDT24DI16_Vec;
    index: Int64;
  end;

  PKDT24DI16_Source       = ^TKDT24DI16_Source;
  TKDT24DI16_SourceBuffer = array [0 .. 0] of PKDT24DI16_Source;
  PKDT24DI16_SourceBuffer = ^TKDT24DI16_SourceBuffer;

  TKDT24DI16yanmicSourceBuffer = array of PKDT24DI16_Source;
  PKDT24DI16yanmicSourceBuffer = ^TKDT24DI16yanmicSourceBuffer;

  TKDT24DI16yanmicStoreBuffer = array of TKDT24DI16_Source;
  PKDT24DI16yanmicStoreBuffer = ^TKDT24DI16yanmicStoreBuffer;

  PKDT24DI16_Node = ^TKDT24DI16_Node;

  TKDT24DI16_Node = packed record
    Parent, Right, Left: PKDT24DI16_Node;
    vec: PKDT24DI16_Source;
  end;

  TKDT24DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT24DI16_Source);
  TKDT24DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT24DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT24DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT24DI16_Source);
  {$ENDIF}

  TKDT24DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT24DI16yanmicStoreBuffer;
    KDBuff     : TKDT24DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT24DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT24DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT24DI16yanmicStoreBuffer; const Buff: TKDT24DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT24DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT24DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT24DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DI16_Node; overload;
    function Search(const Buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DI16_Node; overload;
    function Search(const Buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double): PKDT24DI16_Node; overload;
    function Search(const Buff: TKDT24DI16_Vec): PKDT24DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT24DI16_DynamicVecBuffer; var OutBuff: TKDT24DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT24DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT24DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT28DI16_Vec = array [0 .. TKDT28DI16_AxisCount - 1] of TKDT28DI16_VecType;
  PKDT28DI16_Vec = ^TKDT28DI16_Vec;

  TKDT28DI16_DynamicVecBuffer = array of TKDT28DI16_Vec;
  PKDT28DI16_DynamicVecBuffer = ^TKDT28DI16_DynamicVecBuffer;

  TKDT28DI16_Source = packed record
    Buff: TKDT28DI16_Vec;
    index: Int64;
  end;

  PKDT28DI16_Source       = ^TKDT28DI16_Source;
  TKDT28DI16_SourceBuffer = array [0 .. 0] of PKDT28DI16_Source;
  PKDT28DI16_SourceBuffer = ^TKDT28DI16_SourceBuffer;

  TKDT28DI16yanmicSourceBuffer = array of PKDT28DI16_Source;
  PKDT28DI16yanmicSourceBuffer = ^TKDT28DI16yanmicSourceBuffer;

  TKDT28DI16yanmicStoreBuffer = array of TKDT28DI16_Source;
  PKDT28DI16yanmicStoreBuffer = ^TKDT28DI16yanmicStoreBuffer;

  PKDT28DI16_Node = ^TKDT28DI16_Node;

  TKDT28DI16_Node = packed record
    Parent, Right, Left: PKDT28DI16_Node;
    vec: PKDT28DI16_Source;
  end;

  TKDT28DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT28DI16_Source);
  TKDT28DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT28DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT28DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT28DI16_Source);
  {$ENDIF}

  TKDT28DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT28DI16yanmicStoreBuffer;
    KDBuff     : TKDT28DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT28DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT28DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT28DI16yanmicStoreBuffer; const Buff: TKDT28DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT28DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT28DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT28DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT28DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT28DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DI16_Node; overload;
    function Search(const Buff: TKDT28DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DI16_Node; overload;
    function Search(const Buff: TKDT28DI16_Vec; var SearchedDistanceMin: Double): PKDT28DI16_Node; overload;
    function Search(const Buff: TKDT28DI16_Vec): PKDT28DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT28DI16_DynamicVecBuffer; var OutBuff: TKDT28DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT28DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT28DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT30DI16_Vec = array [0 .. TKDT30DI16_AxisCount - 1] of TKDT30DI16_VecType;
  PKDT30DI16_Vec = ^TKDT30DI16_Vec;

  TKDT30DI16_DynamicVecBuffer = array of TKDT30DI16_Vec;
  PKDT30DI16_DynamicVecBuffer = ^TKDT30DI16_DynamicVecBuffer;

  TKDT30DI16_Source = packed record
    Buff: TKDT30DI16_Vec;
    index: Int64;
  end;

  PKDT30DI16_Source       = ^TKDT30DI16_Source;
  TKDT30DI16_SourceBuffer = array [0 .. 0] of PKDT30DI16_Source;
  PKDT30DI16_SourceBuffer = ^TKDT30DI16_SourceBuffer;

  TKDT30DI16yanmicSourceBuffer = array of PKDT30DI16_Source;
  PKDT30DI16yanmicSourceBuffer = ^TKDT30DI16yanmicSourceBuffer;

  TKDT30DI16yanmicStoreBuffer = array of TKDT30DI16_Source;
  PKDT30DI16yanmicStoreBuffer = ^TKDT30DI16yanmicStoreBuffer;

  PKDT30DI16_Node = ^TKDT30DI16_Node;

  TKDT30DI16_Node = packed record
    Parent, Right, Left: PKDT30DI16_Node;
    vec: PKDT30DI16_Source;
  end;

  TKDT30DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT30DI16_Source);
  TKDT30DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT30DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT30DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT30DI16_Source);
  {$ENDIF}

  TKDT30DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT30DI16yanmicStoreBuffer;
    KDBuff     : TKDT30DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT30DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT30DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT30DI16yanmicStoreBuffer; const Buff: TKDT30DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT30DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT30DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT30DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT30DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT30DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DI16_Node; overload;
    function Search(const Buff: TKDT30DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DI16_Node; overload;
    function Search(const Buff: TKDT30DI16_Vec; var SearchedDistanceMin: Double): PKDT30DI16_Node; overload;
    function Search(const Buff: TKDT30DI16_Vec): PKDT30DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT30DI16_DynamicVecBuffer; var OutBuff: TKDT30DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT30DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT30DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT32DI16_Vec = array [0 .. TKDT32DI16_AxisCount - 1] of TKDT32DI16_VecType;
  PKDT32DI16_Vec = ^TKDT32DI16_Vec;

  TKDT32DI16_DynamicVecBuffer = array of TKDT32DI16_Vec;
  PKDT32DI16_DynamicVecBuffer = ^TKDT32DI16_DynamicVecBuffer;

  TKDT32DI16_Source = packed record
    Buff: TKDT32DI16_Vec;
    index: Int64;
  end;

  PKDT32DI16_Source       = ^TKDT32DI16_Source;
  TKDT32DI16_SourceBuffer = array [0 .. 0] of PKDT32DI16_Source;
  PKDT32DI16_SourceBuffer = ^TKDT32DI16_SourceBuffer;

  TKDT32DI16yanmicSourceBuffer = array of PKDT32DI16_Source;
  PKDT32DI16yanmicSourceBuffer = ^TKDT32DI16yanmicSourceBuffer;

  TKDT32DI16yanmicStoreBuffer = array of TKDT32DI16_Source;
  PKDT32DI16yanmicStoreBuffer = ^TKDT32DI16yanmicStoreBuffer;

  PKDT32DI16_Node = ^TKDT32DI16_Node;

  TKDT32DI16_Node = packed record
    Parent, Right, Left: PKDT32DI16_Node;
    vec: PKDT32DI16_Source;
  end;

  TKDT32DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT32DI16_Source);
  TKDT32DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT32DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT32DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT32DI16_Source);
  {$ENDIF}

  TKDT32DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT32DI16yanmicStoreBuffer;
    KDBuff     : TKDT32DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT32DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT32DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT32DI16yanmicStoreBuffer; const Buff: TKDT32DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT32DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT32DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT32DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT32DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT32DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DI16_Node; overload;
    function Search(const Buff: TKDT32DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DI16_Node; overload;
    function Search(const Buff: TKDT32DI16_Vec; var SearchedDistanceMin: Double): PKDT32DI16_Node; overload;
    function Search(const Buff: TKDT32DI16_Vec): PKDT32DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT32DI16_DynamicVecBuffer; var OutBuff: TKDT32DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT32DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT32DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT34DI16_Vec = array [0 .. TKDT34DI16_AxisCount - 1] of TKDT34DI16_VecType;
  PKDT34DI16_Vec = ^TKDT34DI16_Vec;

  TKDT34DI16_DynamicVecBuffer = array of TKDT34DI16_Vec;
  PKDT34DI16_DynamicVecBuffer = ^TKDT34DI16_DynamicVecBuffer;

  TKDT34DI16_Source = packed record
    Buff: TKDT34DI16_Vec;
    index: Int64;
  end;

  PKDT34DI16_Source       = ^TKDT34DI16_Source;
  TKDT34DI16_SourceBuffer = array [0 .. 0] of PKDT34DI16_Source;
  PKDT34DI16_SourceBuffer = ^TKDT34DI16_SourceBuffer;

  TKDT34DI16yanmicSourceBuffer = array of PKDT34DI16_Source;
  PKDT34DI16yanmicSourceBuffer = ^TKDT34DI16yanmicSourceBuffer;

  TKDT34DI16yanmicStoreBuffer = array of TKDT34DI16_Source;
  PKDT34DI16yanmicStoreBuffer = ^TKDT34DI16yanmicStoreBuffer;

  PKDT34DI16_Node = ^TKDT34DI16_Node;

  TKDT34DI16_Node = packed record
    Parent, Right, Left: PKDT34DI16_Node;
    vec: PKDT34DI16_Source;
  end;

  TKDT34DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT34DI16_Source);
  TKDT34DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT34DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT34DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT34DI16_Source);
  {$ENDIF}

  TKDT34DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT34DI16yanmicStoreBuffer;
    KDBuff     : TKDT34DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT34DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT34DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT34DI16yanmicStoreBuffer; const Buff: TKDT34DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT34DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT34DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT34DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT34DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT34DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DI16_Node; overload;
    function Search(const Buff: TKDT34DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DI16_Node; overload;
    function Search(const Buff: TKDT34DI16_Vec; var SearchedDistanceMin: Double): PKDT34DI16_Node; overload;
    function Search(const Buff: TKDT34DI16_Vec): PKDT34DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT34DI16_DynamicVecBuffer; var OutBuff: TKDT34DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT34DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT34DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT36DI16_Vec = array [0 .. TKDT36DI16_AxisCount - 1] of TKDT36DI16_VecType;
  PKDT36DI16_Vec = ^TKDT36DI16_Vec;

  TKDT36DI16_DynamicVecBuffer = array of TKDT36DI16_Vec;
  PKDT36DI16_DynamicVecBuffer = ^TKDT36DI16_DynamicVecBuffer;

  TKDT36DI16_Source = packed record
    Buff: TKDT36DI16_Vec;
    index: Int64;
  end;

  PKDT36DI16_Source       = ^TKDT36DI16_Source;
  TKDT36DI16_SourceBuffer = array [0 .. 0] of PKDT36DI16_Source;
  PKDT36DI16_SourceBuffer = ^TKDT36DI16_SourceBuffer;

  TKDT36DI16yanmicSourceBuffer = array of PKDT36DI16_Source;
  PKDT36DI16yanmicSourceBuffer = ^TKDT36DI16yanmicSourceBuffer;

  TKDT36DI16yanmicStoreBuffer = array of TKDT36DI16_Source;
  PKDT36DI16yanmicStoreBuffer = ^TKDT36DI16yanmicStoreBuffer;

  PKDT36DI16_Node = ^TKDT36DI16_Node;

  TKDT36DI16_Node = packed record
    Parent, Right, Left: PKDT36DI16_Node;
    vec: PKDT36DI16_Source;
  end;

  TKDT36DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT36DI16_Source);
  TKDT36DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT36DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT36DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT36DI16_Source);
  {$ENDIF}

  TKDT36DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT36DI16yanmicStoreBuffer;
    KDBuff     : TKDT36DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT36DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT36DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT36DI16yanmicStoreBuffer; const Buff: TKDT36DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT36DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT36DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT36DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT36DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT36DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DI16_Node; overload;
    function Search(const Buff: TKDT36DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DI16_Node; overload;
    function Search(const Buff: TKDT36DI16_Vec; var SearchedDistanceMin: Double): PKDT36DI16_Node; overload;
    function Search(const Buff: TKDT36DI16_Vec): PKDT36DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT36DI16_DynamicVecBuffer; var OutBuff: TKDT36DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT36DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT36DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT40DI16_Vec = array [0 .. TKDT40DI16_AxisCount - 1] of TKDT40DI16_VecType;
  PKDT40DI16_Vec = ^TKDT40DI16_Vec;

  TKDT40DI16_DynamicVecBuffer = array of TKDT40DI16_Vec;
  PKDT40DI16_DynamicVecBuffer = ^TKDT40DI16_DynamicVecBuffer;

  TKDT40DI16_Source = packed record
    Buff: TKDT40DI16_Vec;
    index: Int64;
  end;

  PKDT40DI16_Source       = ^TKDT40DI16_Source;
  TKDT40DI16_SourceBuffer = array [0 .. 0] of PKDT40DI16_Source;
  PKDT40DI16_SourceBuffer = ^TKDT40DI16_SourceBuffer;

  TKDT40DI16yanmicSourceBuffer = array of PKDT40DI16_Source;
  PKDT40DI16yanmicSourceBuffer = ^TKDT40DI16yanmicSourceBuffer;

  TKDT40DI16yanmicStoreBuffer = array of TKDT40DI16_Source;
  PKDT40DI16yanmicStoreBuffer = ^TKDT40DI16yanmicStoreBuffer;

  PKDT40DI16_Node = ^TKDT40DI16_Node;

  TKDT40DI16_Node = packed record
    Parent, Right, Left: PKDT40DI16_Node;
    vec: PKDT40DI16_Source;
  end;

  TKDT40DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT40DI16_Source);
  TKDT40DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT40DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT40DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT40DI16_Source);
  {$ENDIF}

  TKDT40DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT40DI16yanmicStoreBuffer;
    KDBuff     : TKDT40DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT40DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT40DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT40DI16yanmicStoreBuffer; const Buff: TKDT40DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT40DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT40DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT40DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT40DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT40DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DI16_Node; overload;
    function Search(const Buff: TKDT40DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DI16_Node; overload;
    function Search(const Buff: TKDT40DI16_Vec; var SearchedDistanceMin: Double): PKDT40DI16_Node; overload;
    function Search(const Buff: TKDT40DI16_Vec): PKDT40DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT40DI16_DynamicVecBuffer; var OutBuff: TKDT40DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT40DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT40DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT48DI16_Vec = array [0 .. TKDT48DI16_AxisCount - 1] of TKDT48DI16_VecType;
  PKDT48DI16_Vec = ^TKDT48DI16_Vec;

  TKDT48DI16_DynamicVecBuffer = array of TKDT48DI16_Vec;
  PKDT48DI16_DynamicVecBuffer = ^TKDT48DI16_DynamicVecBuffer;

  TKDT48DI16_Source = packed record
    Buff: TKDT48DI16_Vec;
    index: Int64;
  end;

  PKDT48DI16_Source       = ^TKDT48DI16_Source;
  TKDT48DI16_SourceBuffer = array [0 .. 0] of PKDT48DI16_Source;
  PKDT48DI16_SourceBuffer = ^TKDT48DI16_SourceBuffer;

  TKDT48DI16yanmicSourceBuffer = array of PKDT48DI16_Source;
  PKDT48DI16yanmicSourceBuffer = ^TKDT48DI16yanmicSourceBuffer;

  TKDT48DI16yanmicStoreBuffer = array of TKDT48DI16_Source;
  PKDT48DI16yanmicStoreBuffer = ^TKDT48DI16yanmicStoreBuffer;

  PKDT48DI16_Node = ^TKDT48DI16_Node;

  TKDT48DI16_Node = packed record
    Parent, Right, Left: PKDT48DI16_Node;
    vec: PKDT48DI16_Source;
  end;

  TKDT48DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT48DI16_Source);
  TKDT48DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT48DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT48DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT48DI16_Source);
  {$ENDIF}

  TKDT48DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT48DI16yanmicStoreBuffer;
    KDBuff     : TKDT48DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT48DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT48DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT48DI16yanmicStoreBuffer; const Buff: TKDT48DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT48DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT48DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT48DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DI16_Node; overload;
    function Search(const Buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DI16_Node; overload;
    function Search(const Buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double): PKDT48DI16_Node; overload;
    function Search(const Buff: TKDT48DI16_Vec): PKDT48DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT48DI16_DynamicVecBuffer; var OutBuff: TKDT48DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT48DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT48DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT64DI16_Vec = array [0 .. TKDT64DI16_AxisCount - 1] of TKDT64DI16_VecType;
  PKDT64DI16_Vec = ^TKDT64DI16_Vec;

  TKDT64DI16_DynamicVecBuffer = array of TKDT64DI16_Vec;
  PKDT64DI16_DynamicVecBuffer = ^TKDT64DI16_DynamicVecBuffer;

  TKDT64DI16_Source = packed record
    Buff: TKDT64DI16_Vec;
    index: Int64;
  end;

  PKDT64DI16_Source       = ^TKDT64DI16_Source;
  TKDT64DI16_SourceBuffer = array [0 .. 0] of PKDT64DI16_Source;
  PKDT64DI16_SourceBuffer = ^TKDT64DI16_SourceBuffer;

  TKDT64DI16yanmicSourceBuffer = array of PKDT64DI16_Source;
  PKDT64DI16yanmicSourceBuffer = ^TKDT64DI16yanmicSourceBuffer;

  TKDT64DI16yanmicStoreBuffer = array of TKDT64DI16_Source;
  PKDT64DI16yanmicStoreBuffer = ^TKDT64DI16yanmicStoreBuffer;

  PKDT64DI16_Node = ^TKDT64DI16_Node;

  TKDT64DI16_Node = packed record
    Parent, Right, Left: PKDT64DI16_Node;
    vec: PKDT64DI16_Source;
  end;

  TKDT64DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT64DI16_Source);
  TKDT64DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT64DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT64DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT64DI16_Source);
  {$ENDIF}

  TKDT64DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT64DI16yanmicStoreBuffer;
    KDBuff     : TKDT64DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT64DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT64DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT64DI16yanmicStoreBuffer; const Buff: TKDT64DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT64DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT64DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT64DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DI16_Node; overload;
    function Search(const Buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DI16_Node; overload;
    function Search(const Buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double): PKDT64DI16_Node; overload;
    function Search(const Buff: TKDT64DI16_Vec): PKDT64DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT64DI16_DynamicVecBuffer; var OutBuff: TKDT64DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT64DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT64DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT96DI16_Vec = array [0 .. TKDT96DI16_AxisCount - 1] of TKDT96DI16_VecType;
  PKDT96DI16_Vec = ^TKDT96DI16_Vec;

  TKDT96DI16_DynamicVecBuffer = array of TKDT96DI16_Vec;
  PKDT96DI16_DynamicVecBuffer = ^TKDT96DI16_DynamicVecBuffer;

  TKDT96DI16_Source = packed record
    Buff: TKDT96DI16_Vec;
    index: Int64;
  end;

  PKDT96DI16_Source       = ^TKDT96DI16_Source;
  TKDT96DI16_SourceBuffer = array [0 .. 0] of PKDT96DI16_Source;
  PKDT96DI16_SourceBuffer = ^TKDT96DI16_SourceBuffer;

  TKDT96DI16yanmicSourceBuffer = array of PKDT96DI16_Source;
  PKDT96DI16yanmicSourceBuffer = ^TKDT96DI16yanmicSourceBuffer;

  TKDT96DI16yanmicStoreBuffer = array of TKDT96DI16_Source;
  PKDT96DI16yanmicStoreBuffer = ^TKDT96DI16yanmicStoreBuffer;

  PKDT96DI16_Node = ^TKDT96DI16_Node;

  TKDT96DI16_Node = packed record
    Parent, Right, Left: PKDT96DI16_Node;
    vec: PKDT96DI16_Source;
  end;

  TKDT96DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT96DI16_Source);
  TKDT96DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT96DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT96DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT96DI16_Source);
  {$ENDIF}

  TKDT96DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT96DI16yanmicStoreBuffer;
    KDBuff     : TKDT96DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT96DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT96DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT96DI16yanmicStoreBuffer; const Buff: TKDT96DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT96DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT96DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT96DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DI16_Node; overload;
    function Search(const Buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DI16_Node; overload;
    function Search(const Buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double): PKDT96DI16_Node; overload;
    function Search(const Buff: TKDT96DI16_Vec): PKDT96DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT96DI16_DynamicVecBuffer; var OutBuff: TKDT96DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT96DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT96DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT128DI16_Vec = array [0 .. TKDT128DI16_AxisCount - 1] of TKDT128DI16_VecType;
  PKDT128DI16_Vec = ^TKDT128DI16_Vec;

  TKDT128DI16_DynamicVecBuffer = array of TKDT128DI16_Vec;
  PKDT128DI16_DynamicVecBuffer = ^TKDT128DI16_DynamicVecBuffer;

  TKDT128DI16_Source = packed record
    Buff: TKDT128DI16_Vec;
    index: Int64;
  end;

  PKDT128DI16_Source       = ^TKDT128DI16_Source;
  TKDT128DI16_SourceBuffer = array [0 .. 0] of PKDT128DI16_Source;
  PKDT128DI16_SourceBuffer = ^TKDT128DI16_SourceBuffer;

  TKDT128DI16yanmicSourceBuffer = array of PKDT128DI16_Source;
  PKDT128DI16yanmicSourceBuffer = ^TKDT128DI16yanmicSourceBuffer;

  TKDT128DI16yanmicStoreBuffer = array of TKDT128DI16_Source;
  PKDT128DI16yanmicStoreBuffer = ^TKDT128DI16yanmicStoreBuffer;

  PKDT128DI16_Node = ^TKDT128DI16_Node;

  TKDT128DI16_Node = packed record
    Parent, Right, Left: PKDT128DI16_Node;
    vec: PKDT128DI16_Source;
  end;

  TKDT128DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT128DI16_Source);
  TKDT128DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT128DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT128DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT128DI16_Source);
  {$ENDIF}

  TKDT128DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT128DI16yanmicStoreBuffer;
    KDBuff     : TKDT128DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT128DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT128DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT128DI16yanmicStoreBuffer; const Buff: TKDT128DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT128DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT128DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT128DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DI16_Node; overload;
    function Search(const Buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DI16_Node; overload;
    function Search(const Buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double): PKDT128DI16_Node; overload;
    function Search(const Buff: TKDT128DI16_Vec): PKDT128DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT128DI16_DynamicVecBuffer; var OutBuff: TKDT128DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT128DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT128DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT256DI16_Vec = array [0 .. TKDT256DI16_AxisCount - 1] of TKDT256DI16_VecType;
  PKDT256DI16_Vec = ^TKDT256DI16_Vec;

  TKDT256DI16_DynamicVecBuffer = array of TKDT256DI16_Vec;
  PKDT256DI16_DynamicVecBuffer = ^TKDT256DI16_DynamicVecBuffer;

  TKDT256DI16_Source = packed record
    Buff: TKDT256DI16_Vec;
    index: Int64;
  end;

  PKDT256DI16_Source       = ^TKDT256DI16_Source;
  TKDT256DI16_SourceBuffer = array [0 .. 0] of PKDT256DI16_Source;
  PKDT256DI16_SourceBuffer = ^TKDT256DI16_SourceBuffer;

  TKDT256DI16yanmicSourceBuffer = array of PKDT256DI16_Source;
  PKDT256DI16yanmicSourceBuffer = ^TKDT256DI16yanmicSourceBuffer;

  TKDT256DI16yanmicStoreBuffer = array of TKDT256DI16_Source;
  PKDT256DI16yanmicStoreBuffer = ^TKDT256DI16yanmicStoreBuffer;

  PKDT256DI16_Node = ^TKDT256DI16_Node;

  TKDT256DI16_Node = packed record
    Parent, Right, Left: PKDT256DI16_Node;
    vec: PKDT256DI16_Source;
  end;

  TKDT256DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT256DI16_Source);
  TKDT256DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT256DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT256DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT256DI16_Source);
  {$ENDIF}

  TKDT256DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT256DI16yanmicStoreBuffer;
    KDBuff     : TKDT256DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT256DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT256DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT256DI16yanmicStoreBuffer; const Buff: TKDT256DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT256DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT256DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT256DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DI16_Node; overload;
    function Search(const Buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DI16_Node; overload;
    function Search(const Buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double): PKDT256DI16_Node; overload;
    function Search(const Buff: TKDT256DI16_Vec): PKDT256DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT256DI16_DynamicVecBuffer; var OutBuff: TKDT256DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT256DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT256DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT372DI16_Vec = array [0 .. TKDT372DI16_AxisCount - 1] of TKDT372DI16_VecType;
  PKDT372DI16_Vec = ^TKDT372DI16_Vec;

  TKDT372DI16_DynamicVecBuffer = array of TKDT372DI16_Vec;
  PKDT372DI16_DynamicVecBuffer = ^TKDT372DI16_DynamicVecBuffer;

  TKDT372DI16_Source = packed record
    Buff: TKDT372DI16_Vec;
    index: Int64;
  end;

  PKDT372DI16_Source       = ^TKDT372DI16_Source;
  TKDT372DI16_SourceBuffer = array [0 .. 0] of PKDT372DI16_Source;
  PKDT372DI16_SourceBuffer = ^TKDT372DI16_SourceBuffer;

  TKDT372DI16yanmicSourceBuffer = array of PKDT372DI16_Source;
  PKDT372DI16yanmicSourceBuffer = ^TKDT372DI16yanmicSourceBuffer;

  TKDT372DI16yanmicStoreBuffer = array of TKDT372DI16_Source;
  PKDT372DI16yanmicStoreBuffer = ^TKDT372DI16yanmicStoreBuffer;

  PKDT372DI16_Node = ^TKDT372DI16_Node;

  TKDT372DI16_Node = packed record
    Parent, Right, Left: PKDT372DI16_Node;
    vec: PKDT372DI16_Source;
  end;

  TKDT372DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT372DI16_Source);
  TKDT372DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT372DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT372DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT372DI16_Source);
  {$ENDIF}

  TKDT372DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT372DI16yanmicStoreBuffer;
    KDBuff     : TKDT372DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT372DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT372DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT372DI16yanmicStoreBuffer; const Buff: TKDT372DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT372DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT372DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT372DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT372DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT372DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DI16_Node; overload;
    function Search(const Buff: TKDT372DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DI16_Node; overload;
    function Search(const Buff: TKDT372DI16_Vec; var SearchedDistanceMin: Double): PKDT372DI16_Node; overload;
    function Search(const Buff: TKDT372DI16_Vec): PKDT372DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT372DI16_DynamicVecBuffer; var OutBuff: TKDT372DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT372DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT372DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT512DI16_Vec = array [0 .. TKDT512DI16_AxisCount - 1] of TKDT512DI16_VecType;
  PKDT512DI16_Vec = ^TKDT512DI16_Vec;

  TKDT512DI16_DynamicVecBuffer = array of TKDT512DI16_Vec;
  PKDT512DI16_DynamicVecBuffer = ^TKDT512DI16_DynamicVecBuffer;

  TKDT512DI16_Source = packed record
    Buff: TKDT512DI16_Vec;
    index: Int64;
  end;

  PKDT512DI16_Source       = ^TKDT512DI16_Source;
  TKDT512DI16_SourceBuffer = array [0 .. 0] of PKDT512DI16_Source;
  PKDT512DI16_SourceBuffer = ^TKDT512DI16_SourceBuffer;

  TKDT512DI16yanmicSourceBuffer = array of PKDT512DI16_Source;
  PKDT512DI16yanmicSourceBuffer = ^TKDT512DI16yanmicSourceBuffer;

  TKDT512DI16yanmicStoreBuffer = array of TKDT512DI16_Source;
  PKDT512DI16yanmicStoreBuffer = ^TKDT512DI16yanmicStoreBuffer;

  PKDT512DI16_Node = ^TKDT512DI16_Node;

  TKDT512DI16_Node = packed record
    Parent, Right, Left: PKDT512DI16_Node;
    vec: PKDT512DI16_Source;
  end;

  TKDT512DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT512DI16_Source);
  TKDT512DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT512DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT512DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT512DI16_Source);
  {$ENDIF}

  TKDT512DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT512DI16yanmicStoreBuffer;
    KDBuff     : TKDT512DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT512DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT512DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT512DI16yanmicStoreBuffer; const Buff: TKDT512DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT512DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT512DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT512DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DI16_Node; overload;
    function Search(const Buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DI16_Node; overload;
    function Search(const Buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double): PKDT512DI16_Node; overload;
    function Search(const Buff: TKDT512DI16_Vec): PKDT512DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT512DI16_DynamicVecBuffer; var OutBuff: TKDT512DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT512DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT512DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT640DI16_Vec = array [0 .. TKDT640DI16_AxisCount - 1] of TKDT640DI16_VecType;
  PKDT640DI16_Vec = ^TKDT640DI16_Vec;

  TKDT640DI16_DynamicVecBuffer = array of TKDT640DI16_Vec;
  PKDT640DI16_DynamicVecBuffer = ^TKDT640DI16_DynamicVecBuffer;

  TKDT640DI16_Source = packed record
    Buff: TKDT640DI16_Vec;
    index: Int64;
  end;

  PKDT640DI16_Source       = ^TKDT640DI16_Source;
  TKDT640DI16_SourceBuffer = array [0 .. 0] of PKDT640DI16_Source;
  PKDT640DI16_SourceBuffer = ^TKDT640DI16_SourceBuffer;

  TKDT640DI16yanmicSourceBuffer = array of PKDT640DI16_Source;
  PKDT640DI16yanmicSourceBuffer = ^TKDT640DI16yanmicSourceBuffer;

  TKDT640DI16yanmicStoreBuffer = array of TKDT640DI16_Source;
  PKDT640DI16yanmicStoreBuffer = ^TKDT640DI16yanmicStoreBuffer;

  PKDT640DI16_Node = ^TKDT640DI16_Node;

  TKDT640DI16_Node = packed record
    Parent, Right, Left: PKDT640DI16_Node;
    vec: PKDT640DI16_Source;
  end;

  TKDT640DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT640DI16_Source);
  TKDT640DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT640DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT640DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT640DI16_Source);
  {$ENDIF}

  TKDT640DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT640DI16yanmicStoreBuffer;
    KDBuff     : TKDT640DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT640DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT640DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT640DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT640DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT640DI16yanmicStoreBuffer; const Buff: TKDT640DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT640DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT640DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT640DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT640DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT640DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT640DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT640DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT640DI16_Node; overload;
    function Search(const Buff: TKDT640DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT640DI16_Node; overload;
    function Search(const Buff: TKDT640DI16_Vec; var SearchedDistanceMin: Double): PKDT640DI16_Node; overload;
    function Search(const Buff: TKDT640DI16_Vec): PKDT640DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT640DI16_DynamicVecBuffer; var OutBuff: TKDT640DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT640DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT640DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT768DI16_Vec = array [0 .. TKDT768DI16_AxisCount - 1] of TKDT768DI16_VecType;
  PKDT768DI16_Vec = ^TKDT768DI16_Vec;

  TKDT768DI16_DynamicVecBuffer = array of TKDT768DI16_Vec;
  PKDT768DI16_DynamicVecBuffer = ^TKDT768DI16_DynamicVecBuffer;

  TKDT768DI16_Source = packed record
    Buff: TKDT768DI16_Vec;
    index: Int64;
  end;

  PKDT768DI16_Source       = ^TKDT768DI16_Source;
  TKDT768DI16_SourceBuffer = array [0 .. 0] of PKDT768DI16_Source;
  PKDT768DI16_SourceBuffer = ^TKDT768DI16_SourceBuffer;

  TKDT768DI16yanmicSourceBuffer = array of PKDT768DI16_Source;
  PKDT768DI16yanmicSourceBuffer = ^TKDT768DI16yanmicSourceBuffer;

  TKDT768DI16yanmicStoreBuffer = array of TKDT768DI16_Source;
  PKDT768DI16yanmicStoreBuffer = ^TKDT768DI16yanmicStoreBuffer;

  PKDT768DI16_Node = ^TKDT768DI16_Node;

  TKDT768DI16_Node = packed record
    Parent, Right, Left: PKDT768DI16_Node;
    vec: PKDT768DI16_Source;
  end;

  TKDT768DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT768DI16_Source);
  TKDT768DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT768DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT768DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT768DI16_Source);
  {$ENDIF}

  TKDT768DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT768DI16yanmicStoreBuffer;
    KDBuff     : TKDT768DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT768DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT768DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT768DI16yanmicStoreBuffer; const Buff: TKDT768DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT768DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT768DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT768DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT768DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT768DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DI16_Node; overload;
    function Search(const Buff: TKDT768DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DI16_Node; overload;
    function Search(const Buff: TKDT768DI16_Vec; var SearchedDistanceMin: Double): PKDT768DI16_Node; overload;
    function Search(const Buff: TKDT768DI16_Vec): PKDT768DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT768DI16_DynamicVecBuffer; var OutBuff: TKDT768DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT768DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT768DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1024DI16_Vec = array [0 .. TKDT1024DI16_AxisCount - 1] of TKDT1024DI16_VecType;
  PKDT1024DI16_Vec = ^TKDT1024DI16_Vec;

  TKDT1024DI16_DynamicVecBuffer = array of TKDT1024DI16_Vec;
  PKDT1024DI16_DynamicVecBuffer = ^TKDT1024DI16_DynamicVecBuffer;

  TKDT1024DI16_Source = packed record
    Buff: TKDT1024DI16_Vec;
    index: Int64;
  end;

  PKDT1024DI16_Source       = ^TKDT1024DI16_Source;
  TKDT1024DI16_SourceBuffer = array [0 .. 0] of PKDT1024DI16_Source;
  PKDT1024DI16_SourceBuffer = ^TKDT1024DI16_SourceBuffer;

  TKDT1024DI16yanmicSourceBuffer = array of PKDT1024DI16_Source;
  PKDT1024DI16yanmicSourceBuffer = ^TKDT1024DI16yanmicSourceBuffer;

  TKDT1024DI16yanmicStoreBuffer = array of TKDT1024DI16_Source;
  PKDT1024DI16yanmicStoreBuffer = ^TKDT1024DI16yanmicStoreBuffer;

  PKDT1024DI16_Node = ^TKDT1024DI16_Node;

  TKDT1024DI16_Node = packed record
    Parent, Right, Left: PKDT1024DI16_Node;
    vec: PKDT1024DI16_Source;
  end;

  TKDT1024DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1024DI16_Source);
  TKDT1024DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1024DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT1024DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1024DI16_Source);
  {$ENDIF}

  TKDT1024DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1024DI16yanmicStoreBuffer;
    KDBuff     : TKDT1024DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1024DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1024DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1024DI16yanmicStoreBuffer; const Buff: TKDT1024DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1024DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1024DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1024DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DI16_Node; overload;
    function Search(const Buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DI16_Node; overload;
    function Search(const Buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double): PKDT1024DI16_Node; overload;
    function Search(const Buff: TKDT1024DI16_Vec): PKDT1024DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1024DI16_DynamicVecBuffer; var OutBuff: TKDT1024DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1024DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1024DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1080DI16_Vec = array [0 .. TKDT1080DI16_AxisCount - 1] of TKDT1080DI16_VecType;
  PKDT1080DI16_Vec = ^TKDT1080DI16_Vec;

  TKDT1080DI16_DynamicVecBuffer = array of TKDT1080DI16_Vec;
  PKDT1080DI16_DynamicVecBuffer = ^TKDT1080DI16_DynamicVecBuffer;

  TKDT1080DI16_Source = packed record
    Buff: TKDT1080DI16_Vec;
    index: Int64;
  end;

  PKDT1080DI16_Source       = ^TKDT1080DI16_Source;
  TKDT1080DI16_SourceBuffer = array [0 .. 0] of PKDT1080DI16_Source;
  PKDT1080DI16_SourceBuffer = ^TKDT1080DI16_SourceBuffer;

  TKDT1080DI16yanmicSourceBuffer = array of PKDT1080DI16_Source;
  PKDT1080DI16yanmicSourceBuffer = ^TKDT1080DI16yanmicSourceBuffer;

  TKDT1080DI16yanmicStoreBuffer = array of TKDT1080DI16_Source;
  PKDT1080DI16yanmicStoreBuffer = ^TKDT1080DI16yanmicStoreBuffer;

  PKDT1080DI16_Node = ^TKDT1080DI16_Node;

  TKDT1080DI16_Node = packed record
    Parent, Right, Left: PKDT1080DI16_Node;
    vec: PKDT1080DI16_Source;
  end;

  TKDT1080DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1080DI16_Source);
  TKDT1080DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1080DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT1080DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1080DI16_Source);
  {$ENDIF}

  TKDT1080DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1080DI16yanmicStoreBuffer;
    KDBuff     : TKDT1080DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1080DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1080DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1080DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1080DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1080DI16yanmicStoreBuffer; const Buff: TKDT1080DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1080DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1080DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1080DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1080DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1080DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1080DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1080DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1080DI16_Node; overload;
    function Search(const Buff: TKDT1080DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1080DI16_Node; overload;
    function Search(const Buff: TKDT1080DI16_Vec; var SearchedDistanceMin: Double): PKDT1080DI16_Node; overload;
    function Search(const Buff: TKDT1080DI16_Vec): PKDT1080DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1080DI16_DynamicVecBuffer; var OutBuff: TKDT1080DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1080DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1080DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1536DI16_Vec = array [0 .. TKDT1536DI16_AxisCount - 1] of TKDT1536DI16_VecType;
  PKDT1536DI16_Vec = ^TKDT1536DI16_Vec;

  TKDT1536DI16_DynamicVecBuffer = array of TKDT1536DI16_Vec;
  PKDT1536DI16_DynamicVecBuffer = ^TKDT1536DI16_DynamicVecBuffer;

  TKDT1536DI16_Source = packed record
    Buff: TKDT1536DI16_Vec;
    index: Int64;
  end;

  PKDT1536DI16_Source       = ^TKDT1536DI16_Source;
  TKDT1536DI16_SourceBuffer = array [0 .. 0] of PKDT1536DI16_Source;
  PKDT1536DI16_SourceBuffer = ^TKDT1536DI16_SourceBuffer;

  TKDT1536DI16yanmicSourceBuffer = array of PKDT1536DI16_Source;
  PKDT1536DI16yanmicSourceBuffer = ^TKDT1536DI16yanmicSourceBuffer;

  TKDT1536DI16yanmicStoreBuffer = array of TKDT1536DI16_Source;
  PKDT1536DI16yanmicStoreBuffer = ^TKDT1536DI16yanmicStoreBuffer;

  PKDT1536DI16_Node = ^TKDT1536DI16_Node;

  TKDT1536DI16_Node = packed record
    Parent, Right, Left: PKDT1536DI16_Node;
    vec: PKDT1536DI16_Source;
  end;

  TKDT1536DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1536DI16_Source);
  TKDT1536DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1536DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT1536DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1536DI16_Source);
  {$ENDIF}

  TKDT1536DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1536DI16yanmicStoreBuffer;
    KDBuff     : TKDT1536DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1536DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1536DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1536DI16yanmicStoreBuffer; const Buff: TKDT1536DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1536DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1536DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1536DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1536DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1536DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DI16_Node; overload;
    function Search(const Buff: TKDT1536DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DI16_Node; overload;
    function Search(const Buff: TKDT1536DI16_Vec; var SearchedDistanceMin: Double): PKDT1536DI16_Node; overload;
    function Search(const Buff: TKDT1536DI16_Vec): PKDT1536DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1536DI16_DynamicVecBuffer; var OutBuff: TKDT1536DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1536DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1536DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1920DI16_Vec = array [0 .. TKDT1920DI16_AxisCount - 1] of TKDT1920DI16_VecType;
  PKDT1920DI16_Vec = ^TKDT1920DI16_Vec;

  TKDT1920DI16_DynamicVecBuffer = array of TKDT1920DI16_Vec;
  PKDT1920DI16_DynamicVecBuffer = ^TKDT1920DI16_DynamicVecBuffer;

  TKDT1920DI16_Source = packed record
    Buff: TKDT1920DI16_Vec;
    index: Int64;
  end;

  PKDT1920DI16_Source       = ^TKDT1920DI16_Source;
  TKDT1920DI16_SourceBuffer = array [0 .. 0] of PKDT1920DI16_Source;
  PKDT1920DI16_SourceBuffer = ^TKDT1920DI16_SourceBuffer;

  TKDT1920DI16yanmicSourceBuffer = array of PKDT1920DI16_Source;
  PKDT1920DI16yanmicSourceBuffer = ^TKDT1920DI16yanmicSourceBuffer;

  TKDT1920DI16yanmicStoreBuffer = array of TKDT1920DI16_Source;
  PKDT1920DI16yanmicStoreBuffer = ^TKDT1920DI16yanmicStoreBuffer;

  PKDT1920DI16_Node = ^TKDT1920DI16_Node;

  TKDT1920DI16_Node = packed record
    Parent, Right, Left: PKDT1920DI16_Node;
    vec: PKDT1920DI16_Source;
  end;

  TKDT1920DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1920DI16_Source);
  TKDT1920DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1920DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT1920DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1920DI16_Source);
  {$ENDIF}

  TKDT1920DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1920DI16yanmicStoreBuffer;
    KDBuff     : TKDT1920DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1920DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1920DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1920DI16yanmicStoreBuffer; const Buff: TKDT1920DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1920DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1920DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1920DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1920DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1920DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DI16_Node; overload;
    function Search(const Buff: TKDT1920DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DI16_Node; overload;
    function Search(const Buff: TKDT1920DI16_Vec; var SearchedDistanceMin: Double): PKDT1920DI16_Node; overload;
    function Search(const Buff: TKDT1920DI16_Vec): PKDT1920DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1920DI16_DynamicVecBuffer; var OutBuff: TKDT1920DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1920DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1920DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT2048DI16_Vec = array [0 .. TKDT2048DI16_AxisCount - 1] of TKDT2048DI16_VecType;
  PKDT2048DI16_Vec = ^TKDT2048DI16_Vec;

  TKDT2048DI16_DynamicVecBuffer = array of TKDT2048DI16_Vec;
  PKDT2048DI16_DynamicVecBuffer = ^TKDT2048DI16_DynamicVecBuffer;

  TKDT2048DI16_Source = packed record
    Buff: TKDT2048DI16_Vec;
    index: Int64;
  end;

  PKDT2048DI16_Source       = ^TKDT2048DI16_Source;
  TKDT2048DI16_SourceBuffer = array [0 .. 0] of PKDT2048DI16_Source;
  PKDT2048DI16_SourceBuffer = ^TKDT2048DI16_SourceBuffer;

  TKDT2048DI16yanmicSourceBuffer = array of PKDT2048DI16_Source;
  PKDT2048DI16yanmicSourceBuffer = ^TKDT2048DI16yanmicSourceBuffer;

  TKDT2048DI16yanmicStoreBuffer = array of TKDT2048DI16_Source;
  PKDT2048DI16yanmicStoreBuffer = ^TKDT2048DI16yanmicStoreBuffer;

  PKDT2048DI16_Node = ^TKDT2048DI16_Node;

  TKDT2048DI16_Node = packed record
    Parent, Right, Left: PKDT2048DI16_Node;
    vec: PKDT2048DI16_Source;
  end;

  TKDT2048DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT2048DI16_Source);
  TKDT2048DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT2048DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT2048DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT2048DI16_Source);
  {$ENDIF}

  TKDT2048DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2048DI16yanmicStoreBuffer;
    KDBuff     : TKDT2048DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2048DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT2048DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT2048DI16yanmicStoreBuffer; const Buff: TKDT2048DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT2048DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2048DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2048DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2048DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2048DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DI16_Node; overload;
    function Search(const Buff: TKDT2048DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DI16_Node; overload;
    function Search(const Buff: TKDT2048DI16_Vec; var SearchedDistanceMin: Double): PKDT2048DI16_Node; overload;
    function Search(const Buff: TKDT2048DI16_Vec): PKDT2048DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2048DI16_DynamicVecBuffer; var OutBuff: TKDT2048DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT2048DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT2048DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3072DI16_Vec = array [0 .. TKDT3072DI16_AxisCount - 1] of TKDT3072DI16_VecType;
  PKDT3072DI16_Vec = ^TKDT3072DI16_Vec;

  TKDT3072DI16_DynamicVecBuffer = array of TKDT3072DI16_Vec;
  PKDT3072DI16_DynamicVecBuffer = ^TKDT3072DI16_DynamicVecBuffer;

  TKDT3072DI16_Source = packed record
    Buff: TKDT3072DI16_Vec;
    index: Int64;
  end;

  PKDT3072DI16_Source       = ^TKDT3072DI16_Source;
  TKDT3072DI16_SourceBuffer = array [0 .. 0] of PKDT3072DI16_Source;
  PKDT3072DI16_SourceBuffer = ^TKDT3072DI16_SourceBuffer;

  TKDT3072DI16yanmicSourceBuffer = array of PKDT3072DI16_Source;
  PKDT3072DI16yanmicSourceBuffer = ^TKDT3072DI16yanmicSourceBuffer;

  TKDT3072DI16yanmicStoreBuffer = array of TKDT3072DI16_Source;
  PKDT3072DI16yanmicStoreBuffer = ^TKDT3072DI16yanmicStoreBuffer;

  PKDT3072DI16_Node = ^TKDT3072DI16_Node;

  TKDT3072DI16_Node = packed record
    Parent, Right, Left: PKDT3072DI16_Node;
    vec: PKDT3072DI16_Source;
  end;

  TKDT3072DI16_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3072DI16_Source);
  TKDT3072DI16_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3072DI16_Source) of object;
  {$IFNDEF FPC}
  TKDT3072DI16_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3072DI16_Source);
  {$ENDIF}

  TKDT3072DI16 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3072DI16yanmicStoreBuffer;
    KDBuff     : TKDT3072DI16yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3072DI16_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3072DI16_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DI16_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3072DI16yanmicStoreBuffer; const Buff: TKDT3072DI16_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3072DI16_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3072DI16_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3072DI16yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3072DI16_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI16_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI16_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI16_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DI16_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI16_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI16_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI16_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI16_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI16_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3072DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DI16_Node; overload;
    function Search(const Buff: TKDT3072DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DI16_Node; overload;
    function Search(const Buff: TKDT3072DI16_Vec; var SearchedDistanceMin: Double): PKDT3072DI16_Node; overload;
    function Search(const Buff: TKDT3072DI16_Vec): PKDT3072DI16_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3072DI16_DynamicVecBuffer; var OutBuff: TKDT3072DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3072DI16_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3072DI16_Source);
    class procedure Test;
    {$ENDIF}
  end;






  // SmallInt KDTree
function KDT1DI16Vec(const s: string): TKDT1DI16_Vec; overload;
function KDT1DI16Vec(const v: TKDT1DI16_Vec): string; overload;
function KDT1DI16Pow(const v: TKDT1DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1DI16Distance(const v1, v2: TKDT1DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1DI16Cmpare(const v1, v2: TKDT1DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT2DI16Vec(const s: string): TKDT2DI16_Vec; overload;
function KDT2DI16Vec(const v: TKDT2DI16_Vec): string; overload;
function KDT2DI16Pow(const v: TKDT2DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2DI16Distance(const v1, v2: TKDT2DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2DI16Cmpare(const v1, v2: TKDT2DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3DI16Vec(const s: string): TKDT3DI16_Vec; overload;
function KDT3DI16Vec(const v: TKDT3DI16_Vec): string; overload;
function KDT3DI16Pow(const v: TKDT3DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3DI16Distance(const v1, v2: TKDT3DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3DI16Cmpare(const v1, v2: TKDT3DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT4DI16Vec(const s: string): TKDT4DI16_Vec; overload;
function KDT4DI16Vec(const v: TKDT4DI16_Vec): string; overload;
function KDT4DI16Pow(const v: TKDT4DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4DI16Distance(const v1, v2: TKDT4DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4DI16Cmpare(const v1, v2: TKDT4DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT6DI16Vec(const s: string): TKDT6DI16_Vec; overload;
function KDT6DI16Vec(const v: TKDT6DI16_Vec): string; overload;
function KDT6DI16Pow(const v: TKDT6DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT6DI16Distance(const v1, v2: TKDT6DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT6DI16Cmpare(const v1, v2: TKDT6DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT8DI16Vec(const s: string): TKDT8DI16_Vec; overload;
function KDT8DI16Vec(const v: TKDT8DI16_Vec): string; overload;
function KDT8DI16Pow(const v: TKDT8DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8DI16Distance(const v1, v2: TKDT8DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8DI16Cmpare(const v1, v2: TKDT8DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT10DI16Vec(const s: string): TKDT10DI16_Vec; overload;
function KDT10DI16Vec(const v: TKDT10DI16_Vec): string; overload;
function KDT10DI16Pow(const v: TKDT10DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT10DI16Distance(const v1, v2: TKDT10DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT10DI16Cmpare(const v1, v2: TKDT10DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT12DI16Vec(const s: string): TKDT12DI16_Vec; overload;
function KDT12DI16Vec(const v: TKDT12DI16_Vec): string; overload;
function KDT12DI16Pow(const v: TKDT12DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT12DI16Distance(const v1, v2: TKDT12DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT12DI16Cmpare(const v1, v2: TKDT12DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT14DI16Vec(const s: string): TKDT14DI16_Vec; overload;
function KDT14DI16Vec(const v: TKDT14DI16_Vec): string; overload;
function KDT14DI16Pow(const v: TKDT14DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT14DI16Distance(const v1, v2: TKDT14DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT14DI16Cmpare(const v1, v2: TKDT14DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT16DI16Vec(const s: string): TKDT16DI16_Vec; overload;
function KDT16DI16Vec(const v: TKDT16DI16_Vec): string; overload;
function KDT16DI16Pow(const v: TKDT16DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT16DI16Distance(const v1, v2: TKDT16DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT16DI16Cmpare(const v1, v2: TKDT16DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT18DI16Vec(const s: string): TKDT18DI16_Vec; overload;
function KDT18DI16Vec(const v: TKDT18DI16_Vec): string; overload;
function KDT18DI16Pow(const v: TKDT18DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT18DI16Distance(const v1, v2: TKDT18DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT18DI16Cmpare(const v1, v2: TKDT18DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT20DI16Vec(const s: string): TKDT20DI16_Vec; overload;
function KDT20DI16Vec(const v: TKDT20DI16_Vec): string; overload;
function KDT20DI16Pow(const v: TKDT20DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT20DI16Distance(const v1, v2: TKDT20DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT20DI16Cmpare(const v1, v2: TKDT20DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT22DI16Vec(const s: string): TKDT22DI16_Vec; overload;
function KDT22DI16Vec(const v: TKDT22DI16_Vec): string; overload;
function KDT22DI16Pow(const v: TKDT22DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT22DI16Distance(const v1, v2: TKDT22DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT22DI16Cmpare(const v1, v2: TKDT22DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT24DI16Vec(const s: string): TKDT24DI16_Vec; overload;
function KDT24DI16Vec(const v: TKDT24DI16_Vec): string; overload;
function KDT24DI16Pow(const v: TKDT24DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT24DI16Distance(const v1, v2: TKDT24DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT24DI16Cmpare(const v1, v2: TKDT24DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT28DI16Vec(const s: string): TKDT28DI16_Vec; overload;
function KDT28DI16Vec(const v: TKDT28DI16_Vec): string; overload;
function KDT28DI16Pow(const v: TKDT28DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT28DI16Distance(const v1, v2: TKDT28DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT28DI16Cmpare(const v1, v2: TKDT28DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT30DI16Vec(const s: string): TKDT30DI16_Vec; overload;
function KDT30DI16Vec(const v: TKDT30DI16_Vec): string; overload;
function KDT30DI16Pow(const v: TKDT30DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT30DI16Distance(const v1, v2: TKDT30DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT30DI16Cmpare(const v1, v2: TKDT30DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT32DI16Vec(const s: string): TKDT32DI16_Vec; overload;
function KDT32DI16Vec(const v: TKDT32DI16_Vec): string; overload;
function KDT32DI16Pow(const v: TKDT32DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT32DI16Distance(const v1, v2: TKDT32DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT32DI16Cmpare(const v1, v2: TKDT32DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT34DI16Vec(const s: string): TKDT34DI16_Vec; overload;
function KDT34DI16Vec(const v: TKDT34DI16_Vec): string; overload;
function KDT34DI16Pow(const v: TKDT34DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT34DI16Distance(const v1, v2: TKDT34DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT34DI16Cmpare(const v1, v2: TKDT34DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT36DI16Vec(const s: string): TKDT36DI16_Vec; overload;
function KDT36DI16Vec(const v: TKDT36DI16_Vec): string; overload;
function KDT36DI16Pow(const v: TKDT36DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT36DI16Distance(const v1, v2: TKDT36DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT36DI16Cmpare(const v1, v2: TKDT36DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT40DI16Vec(const s: string): TKDT40DI16_Vec; overload;
function KDT40DI16Vec(const v: TKDT40DI16_Vec): string; overload;
function KDT40DI16Pow(const v: TKDT40DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT40DI16Distance(const v1, v2: TKDT40DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT40DI16Cmpare(const v1, v2: TKDT40DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT48DI16Vec(const s: string): TKDT48DI16_Vec; overload;
function KDT48DI16Vec(const v: TKDT48DI16_Vec): string; overload;
function KDT48DI16Pow(const v: TKDT48DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT48DI16Distance(const v1, v2: TKDT48DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT48DI16Cmpare(const v1, v2: TKDT48DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT64DI16Vec(const s: string): TKDT64DI16_Vec; overload;
function KDT64DI16Vec(const v: TKDT64DI16_Vec): string; overload;
function KDT64DI16Pow(const v: TKDT64DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT64DI16Distance(const v1, v2: TKDT64DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT64DI16Cmpare(const v1, v2: TKDT64DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT96DI16Vec(const s: string): TKDT96DI16_Vec; overload;
function KDT96DI16Vec(const v: TKDT96DI16_Vec): string; overload;
function KDT96DI16Pow(const v: TKDT96DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT96DI16Distance(const v1, v2: TKDT96DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT96DI16Cmpare(const v1, v2: TKDT96DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT128DI16Vec(const s: string): TKDT128DI16_Vec; overload;
function KDT128DI16Vec(const v: TKDT128DI16_Vec): string; overload;
function KDT128DI16Pow(const v: TKDT128DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT128DI16Distance(const v1, v2: TKDT128DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT128DI16Cmpare(const v1, v2: TKDT128DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT256DI16Vec(const s: string): TKDT256DI16_Vec; overload;
function KDT256DI16Vec(const v: TKDT256DI16_Vec): string; overload;
function KDT256DI16Pow(const v: TKDT256DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT256DI16Distance(const v1, v2: TKDT256DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT256DI16Cmpare(const v1, v2: TKDT256DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT372DI16Vec(const s: string): TKDT372DI16_Vec; overload;
function KDT372DI16Vec(const v: TKDT372DI16_Vec): string; overload;
function KDT372DI16Pow(const v: TKDT372DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT372DI16Distance(const v1, v2: TKDT372DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT372DI16Cmpare(const v1, v2: TKDT372DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT512DI16Vec(const s: string): TKDT512DI16_Vec; overload;
function KDT512DI16Vec(const v: TKDT512DI16_Vec): string; overload;
function KDT512DI16Pow(const v: TKDT512DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT512DI16Distance(const v1, v2: TKDT512DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT512DI16Cmpare(const v1, v2: TKDT512DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT640DI16Vec(const s: string): TKDT640DI16_Vec; overload;
function KDT640DI16Vec(const v: TKDT640DI16_Vec): string; overload;
function KDT640DI16Pow(const v: TKDT640DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT640DI16Distance(const v1, v2: TKDT640DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT640DI16Cmpare(const v1, v2: TKDT640DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT768DI16Vec(const s: string): TKDT768DI16_Vec; overload;
function KDT768DI16Vec(const v: TKDT768DI16_Vec): string; overload;
function KDT768DI16Pow(const v: TKDT768DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT768DI16Distance(const v1, v2: TKDT768DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT768DI16Cmpare(const v1, v2: TKDT768DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1024DI16Vec(const s: string): TKDT1024DI16_Vec; overload;
function KDT1024DI16Vec(const v: TKDT1024DI16_Vec): string; overload;
function KDT1024DI16Pow(const v: TKDT1024DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1024DI16Distance(const v1, v2: TKDT1024DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1024DI16Cmpare(const v1, v2: TKDT1024DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1080DI16Vec(const s: string): TKDT1080DI16_Vec; overload;
function KDT1080DI16Vec(const v: TKDT1080DI16_Vec): string; overload;
function KDT1080DI16Pow(const v: TKDT1080DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1080DI16Distance(const v1, v2: TKDT1080DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1080DI16Cmpare(const v1, v2: TKDT1080DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1536DI16Vec(const s: string): TKDT1536DI16_Vec; overload;
function KDT1536DI16Vec(const v: TKDT1536DI16_Vec): string; overload;
function KDT1536DI16Pow(const v: TKDT1536DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1536DI16Distance(const v1, v2: TKDT1536DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1536DI16Cmpare(const v1, v2: TKDT1536DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1920DI16Vec(const s: string): TKDT1920DI16_Vec; overload;
function KDT1920DI16Vec(const v: TKDT1920DI16_Vec): string; overload;
function KDT1920DI16Pow(const v: TKDT1920DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1920DI16Distance(const v1, v2: TKDT1920DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1920DI16Cmpare(const v1, v2: TKDT1920DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT2048DI16Vec(const s: string): TKDT2048DI16_Vec; overload;
function KDT2048DI16Vec(const v: TKDT2048DI16_Vec): string; overload;
function KDT2048DI16Pow(const v: TKDT2048DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2048DI16Distance(const v1, v2: TKDT2048DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2048DI16Cmpare(const v1, v2: TKDT2048DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3072DI16Vec(const s: string): TKDT3072DI16_Vec; overload;
function KDT3072DI16Vec(const v: TKDT3072DI16_Vec): string; overload;
function KDT3072DI16Pow(const v: TKDT3072DI16_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3072DI16Distance(const v1, v2: TKDT3072DI16_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3072DI16Cmpare(const v1, v2: TKDT3072DI16_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

{$IFDEF DEBUG}
procedure Test_All;
{$ENDIF}


implementation

uses
  {$IFDEF FPC}
  mtprocs,
  {$ELSE FPC}
  Threading,
  {$ENDIF FPC}
  PascalStrings, TextParsing, UnicodeMixedLib, DoStatusIO;






function KDT1DI16Vec(const s: string): TKDT1DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1DI16Vec(const v: TKDT1DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1DI16Pow(const v: TKDT1DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT1DI16Distance(const v1, v2: TKDT1DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1DI16_AxisCount - 1 do
      Result := Result + KDT1DI16Pow(v2[i] - v1[i]);
end;

function KDT1DI16Cmpare(const v1, v2: TKDT1DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1DI16_Vec));
end;

function TKDT1DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DI16_Node;
  function SortCompare(const p1, p2: PKDT1DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1DI16_SourceBuffer;
  dynBuff  : PKDT1DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DI16.SearchStoreBuff(const StoreBuffPtr: PKDT1DI16yanmicStoreBuffer; const Buff: TKDT1DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1DI16.GetData(const index: NativeInt): PKDT1DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DI16.StoreBuffPtr: PKDT1DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1DI16.BuildKDTreeWithCluster(const inBuff: TKDT1DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DI16.BuildKDTreeWithCluster(const inBuff: TKDT1DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI16_BuildCall);
var
  TempStoreBuff: TKDT1DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI16_BuildMethod);
var
  TempStoreBuff: TKDT1DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI16_BuildProc);
var
  TempStoreBuff: TKDT1DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1DI16.Search(const Buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DI16_Node;

var
  NearestNeighbour: PKDT1DI16_Node;

  function FindParentNode(const BuffPtr: PKDT1DI16_Vec; NodePtr: PKDT1DI16_Node): PKDT1DI16_Node;
  var
    Next       : PKDT1DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DI16_Node; const BuffPtr: PKDT1DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1DI16_Vec; const p1, p2: PKDT1DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT1DI16.Search(const Buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DI16.Search(const Buff: TKDT1DI16_Vec; var SearchedDistanceMin: Double): PKDT1DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DI16.Search(const Buff: TKDT1DI16_Vec): PKDT1DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1DI16.Search(const inBuff: TKDT1DI16_DynamicVecBuffer; var OutBuff: TKDT1DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DI16_DynamicVecBuffer;
  outBuffPtr : PKDT1DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1DI16_Source));
end;

procedure TKDT1DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1DI16.PrintNodeTree(const NodePtr: PKDT1DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1DI16.Test;
var
  TKDT1DI16_Test    : TKDT1DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1DI16_Test := TKDT1DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT1DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT1DI16_AxisCount - 1 do
        TKDT1DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1DI16_Test.TestBuff), length(TKDT1DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1DI16_Test.BuildKDTreeM(False, length(TKDT1DI16_Test.TestBuff), @TKDT1DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1DI16_Test.BuildKDTreeM(False, length(TKDT1DI16_Test.TestBuff), TKDT1DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1DI16_Test.TestBuff));
  TKDT1DI16_Test.Search(TKDT1DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1DI16Distance(TKDT1DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1DI16_Test.Clear;
  { kMean test }
  TKDT1DI16_Test.BuildKDTreeWithCluster(TKDT1DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1DI16_Test.Search(TKDT1DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1DI16_Test);
end;

{$ENDIF DEBUG}


function KDT2DI16Vec(const s: string): TKDT2DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT2DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT2DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT2DI16Vec(const v: TKDT2DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT2DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT2DI16Pow(const v: TKDT2DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT2DI16Distance(const v1, v2: TKDT2DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT2DI16_AxisCount - 1 do
      Result := Result + KDT2DI16Pow(v2[i] - v1[i]);
end;

function KDT2DI16Cmpare(const v1, v2: TKDT2DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT2DI16_Vec));
end;

function TKDT2DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DI16_Node;
  function SortCompare(const p1, p2: PKDT2DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2DI16_SourceBuffer;
  dynBuff  : PKDT2DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT2DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DI16.SearchStoreBuff(const StoreBuffPtr: PKDT2DI16yanmicStoreBuffer; const Buff: TKDT2DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT2DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT2DI16.GetData(const index: NativeInt): PKDT2DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DI16.StoreBuffPtr: PKDT2DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2DI16.BuildKDTreeWithCluster(const inBuff: TKDT2DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT2DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT2DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT2DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DI16.BuildKDTreeWithCluster(const inBuff: TKDT2DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI16_BuildCall);
var
  TempStoreBuff: TKDT2DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI16_BuildMethod);
var
  TempStoreBuff: TKDT2DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI16_BuildProc);
var
  TempStoreBuff: TKDT2DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2DI16.Search(const Buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DI16_Node;

var
  NearestNeighbour: PKDT2DI16_Node;

  function FindParentNode(const BuffPtr: PKDT2DI16_Vec; NodePtr: PKDT2DI16_Node): PKDT2DI16_Node;
  var
    Next       : PKDT2DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT2DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DI16_Node; const BuffPtr: PKDT2DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT2DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2DI16_Vec; const p1, p2: PKDT2DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT2DI16.Search(const Buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DI16.Search(const Buff: TKDT2DI16_Vec; var SearchedDistanceMin: Double): PKDT2DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DI16.Search(const Buff: TKDT2DI16_Vec): PKDT2DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2DI16.Search(const inBuff: TKDT2DI16_DynamicVecBuffer; var OutBuff: TKDT2DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DI16_DynamicVecBuffer;
  outBuffPtr : PKDT2DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2DI16_Source));
end;

procedure TKDT2DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT2DI16.PrintNodeTree(const NodePtr: PKDT2DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT2DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT2DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2DI16.Test;
var
  TKDT2DI16_Test    : TKDT2DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2DI16_Test := TKDT2DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT2DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT2DI16_AxisCount - 1 do
        TKDT2DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT2DI16_Test.TestBuff), length(TKDT2DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2DI16_Test.BuildKDTreeM(False, length(TKDT2DI16_Test.TestBuff), @TKDT2DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2DI16_Test.BuildKDTreeM(False, length(TKDT2DI16_Test.TestBuff), TKDT2DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2DI16_Test.TestBuff));
  TKDT2DI16_Test.Search(TKDT2DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2DI16Distance(TKDT2DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2DI16_Test.Clear;
  { kMean test }
  TKDT2DI16_Test.BuildKDTreeWithCluster(TKDT2DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2DI16_Test.Search(TKDT2DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2DI16_Test);
end;

{$ENDIF DEBUG}


function KDT3DI16Vec(const s: string): TKDT3DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3DI16Vec(const v: TKDT3DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT3DI16Pow(const v: TKDT3DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT3DI16Distance(const v1, v2: TKDT3DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3DI16_AxisCount - 1 do
      Result := Result + KDT3DI16Pow(v2[i] - v1[i]);
end;

function KDT3DI16Cmpare(const v1, v2: TKDT3DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3DI16_Vec));
end;

function TKDT3DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DI16_Node;
  function SortCompare(const p1, p2: PKDT3DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3DI16_SourceBuffer;
  dynBuff  : PKDT3DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DI16.SearchStoreBuff(const StoreBuffPtr: PKDT3DI16yanmicStoreBuffer; const Buff: TKDT3DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3DI16.GetData(const index: NativeInt): PKDT3DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DI16.StoreBuffPtr: PKDT3DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3DI16.BuildKDTreeWithCluster(const inBuff: TKDT3DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DI16.BuildKDTreeWithCluster(const inBuff: TKDT3DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI16_BuildCall);
var
  TempStoreBuff: TKDT3DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI16_BuildMethod);
var
  TempStoreBuff: TKDT3DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI16_BuildProc);
var
  TempStoreBuff: TKDT3DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3DI16.Search(const Buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DI16_Node;

var
  NearestNeighbour: PKDT3DI16_Node;

  function FindParentNode(const BuffPtr: PKDT3DI16_Vec; NodePtr: PKDT3DI16_Node): PKDT3DI16_Node;
  var
    Next       : PKDT3DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DI16_Node; const BuffPtr: PKDT3DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3DI16_Vec; const p1, p2: PKDT3DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT3DI16.Search(const Buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DI16.Search(const Buff: TKDT3DI16_Vec; var SearchedDistanceMin: Double): PKDT3DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DI16.Search(const Buff: TKDT3DI16_Vec): PKDT3DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3DI16.Search(const inBuff: TKDT3DI16_DynamicVecBuffer; var OutBuff: TKDT3DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DI16_DynamicVecBuffer;
  outBuffPtr : PKDT3DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3DI16_Source));
end;

procedure TKDT3DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3DI16.PrintNodeTree(const NodePtr: PKDT3DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3DI16.Test;
var
  TKDT3DI16_Test    : TKDT3DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3DI16_Test := TKDT3DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT3DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT3DI16_AxisCount - 1 do
        TKDT3DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT3DI16_Test.TestBuff), length(TKDT3DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3DI16_Test.BuildKDTreeM(False, length(TKDT3DI16_Test.TestBuff), @TKDT3DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3DI16_Test.BuildKDTreeM(False, length(TKDT3DI16_Test.TestBuff), TKDT3DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3DI16_Test.TestBuff));
  TKDT3DI16_Test.Search(TKDT3DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3DI16Distance(TKDT3DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3DI16_Test.Clear;
  { kMean test }
  TKDT3DI16_Test.BuildKDTreeWithCluster(TKDT3DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3DI16_Test.Search(TKDT3DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3DI16_Test);
end;

{$ENDIF DEBUG}


function KDT4DI16Vec(const s: string): TKDT4DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT4DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT4DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT4DI16Vec(const v: TKDT4DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT4DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT4DI16Pow(const v: TKDT4DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT4DI16Distance(const v1, v2: TKDT4DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT4DI16_AxisCount - 1 do
      Result := Result + KDT4DI16Pow(v2[i] - v1[i]);
end;

function KDT4DI16Cmpare(const v1, v2: TKDT4DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT4DI16_Vec));
end;

function TKDT4DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DI16_Node;
  function SortCompare(const p1, p2: PKDT4DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4DI16_SourceBuffer;
  dynBuff  : PKDT4DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT4DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DI16.SearchStoreBuff(const StoreBuffPtr: PKDT4DI16yanmicStoreBuffer; const Buff: TKDT4DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT4DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT4DI16.GetData(const index: NativeInt): PKDT4DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DI16.StoreBuffPtr: PKDT4DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4DI16.BuildKDTreeWithCluster(const inBuff: TKDT4DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT4DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT4DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT4DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DI16.BuildKDTreeWithCluster(const inBuff: TKDT4DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI16_BuildCall);
var
  TempStoreBuff: TKDT4DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI16_BuildMethod);
var
  TempStoreBuff: TKDT4DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI16_BuildProc);
var
  TempStoreBuff: TKDT4DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT4DI16.Search(const Buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DI16_Node;

var
  NearestNeighbour: PKDT4DI16_Node;

  function FindParentNode(const BuffPtr: PKDT4DI16_Vec; NodePtr: PKDT4DI16_Node): PKDT4DI16_Node;
  var
    Next       : PKDT4DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT4DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DI16_Node; const BuffPtr: PKDT4DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT4DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4DI16_Vec; const p1, p2: PKDT4DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT4DI16.Search(const Buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DI16.Search(const Buff: TKDT4DI16_Vec; var SearchedDistanceMin: Double): PKDT4DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DI16.Search(const Buff: TKDT4DI16_Vec): PKDT4DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4DI16.Search(const inBuff: TKDT4DI16_DynamicVecBuffer; var OutBuff: TKDT4DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DI16_DynamicVecBuffer;
  outBuffPtr : PKDT4DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4DI16_Source));
end;

procedure TKDT4DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT4DI16.PrintNodeTree(const NodePtr: PKDT4DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT4DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT4DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4DI16.Test;
var
  TKDT4DI16_Test    : TKDT4DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4DI16_Test := TKDT4DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT4DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT4DI16_AxisCount - 1 do
        TKDT4DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT4DI16_Test.TestBuff), length(TKDT4DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4DI16_Test.BuildKDTreeM(False, length(TKDT4DI16_Test.TestBuff), @TKDT4DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4DI16_Test.BuildKDTreeM(False, length(TKDT4DI16_Test.TestBuff), TKDT4DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4DI16_Test.TestBuff));
  TKDT4DI16_Test.Search(TKDT4DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4DI16Distance(TKDT4DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4DI16_Test.Clear;
  { kMean test }
  TKDT4DI16_Test.BuildKDTreeWithCluster(TKDT4DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4DI16_Test.Search(TKDT4DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4DI16_Test);
end;

{$ENDIF DEBUG}


function KDT6DI16Vec(const s: string): TKDT6DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT6DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT6DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT6DI16Vec(const v: TKDT6DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT6DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT6DI16Pow(const v: TKDT6DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT6DI16Distance(const v1, v2: TKDT6DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT6DI16_AxisCount - 1 do
      Result := Result + KDT6DI16Pow(v2[i] - v1[i]);
end;

function KDT6DI16Cmpare(const v1, v2: TKDT6DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT6DI16_Vec));
end;

function TKDT6DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DI16_Node;
  function SortCompare(const p1, p2: PKDT6DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT6DI16_SourceBuffer;
  dynBuff  : PKDT6DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT6DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DI16.SearchStoreBuff(const StoreBuffPtr: PKDT6DI16yanmicStoreBuffer; const Buff: TKDT6DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT6DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT6DI16.GetData(const index: NativeInt): PKDT6DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT6DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DI16.StoreBuffPtr: PKDT6DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT6DI16.BuildKDTreeWithCluster(const inBuff: TKDT6DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT6DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT6DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT6DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DI16.BuildKDTreeWithCluster(const inBuff: TKDT6DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI16_BuildCall);
var
  TempStoreBuff: TKDT6DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI16_BuildMethod);
var
  TempStoreBuff: TKDT6DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI16_BuildProc);
var
  TempStoreBuff: TKDT6DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT6DI16.Search(const Buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DI16_Node;

var
  NearestNeighbour: PKDT6DI16_Node;

  function FindParentNode(const BuffPtr: PKDT6DI16_Vec; NodePtr: PKDT6DI16_Node): PKDT6DI16_Node;
  var
    Next       : PKDT6DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT6DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DI16_Node; const BuffPtr: PKDT6DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT6DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT6DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT6DI16_Vec; const p1, p2: PKDT6DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT6DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT6DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT6DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT6DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT6DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT6DI16.Search(const Buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DI16.Search(const Buff: TKDT6DI16_Vec; var SearchedDistanceMin: Double): PKDT6DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DI16.Search(const Buff: TKDT6DI16_Vec): PKDT6DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT6DI16.Search(const inBuff: TKDT6DI16_DynamicVecBuffer; var OutBuff: TKDT6DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DI16_DynamicVecBuffer;
  outBuffPtr : PKDT6DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT6DI16_Source));
end;

procedure TKDT6DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT6DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT6DI16.PrintNodeTree(const NodePtr: PKDT6DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT6DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT6DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT6DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT6DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT6DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT6DI16.Test;
var
  TKDT6DI16_Test    : TKDT6DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT6DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT6DI16_Test := TKDT6DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT6DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT6DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT6DI16_AxisCount - 1 do
        TKDT6DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT6DI16_Test.TestBuff), length(TKDT6DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT6DI16_Test.BuildKDTreeM(False, length(TKDT6DI16_Test.TestBuff), @TKDT6DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT6DI16_Test.BuildKDTreeM(False, length(TKDT6DI16_Test.TestBuff), TKDT6DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT6DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT6DI16_Test.TestBuff));
  TKDT6DI16_Test.Search(TKDT6DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT6DI16Distance(TKDT6DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT6DI16_Test.Clear;
  { kMean test }
  TKDT6DI16_Test.BuildKDTreeWithCluster(TKDT6DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT6DI16_Test.Search(TKDT6DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT6DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT6DI16_Test);
end;

{$ENDIF DEBUG}


function KDT8DI16Vec(const s: string): TKDT8DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT8DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT8DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT8DI16Vec(const v: TKDT8DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT8DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT8DI16Pow(const v: TKDT8DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT8DI16Distance(const v1, v2: TKDT8DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT8DI16_AxisCount - 1 do
      Result := Result + KDT8DI16Pow(v2[i] - v1[i]);
end;

function KDT8DI16Cmpare(const v1, v2: TKDT8DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT8DI16_Vec));
end;

function TKDT8DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DI16_Node;
  function SortCompare(const p1, p2: PKDT8DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8DI16_SourceBuffer;
  dynBuff  : PKDT8DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT8DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DI16.SearchStoreBuff(const StoreBuffPtr: PKDT8DI16yanmicStoreBuffer; const Buff: TKDT8DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT8DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT8DI16.GetData(const index: NativeInt): PKDT8DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DI16.StoreBuffPtr: PKDT8DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8DI16.BuildKDTreeWithCluster(const inBuff: TKDT8DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT8DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT8DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT8DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DI16.BuildKDTreeWithCluster(const inBuff: TKDT8DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI16_BuildCall);
var
  TempStoreBuff: TKDT8DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI16_BuildMethod);
var
  TempStoreBuff: TKDT8DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI16_BuildProc);
var
  TempStoreBuff: TKDT8DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT8DI16.Search(const Buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DI16_Node;

var
  NearestNeighbour: PKDT8DI16_Node;

  function FindParentNode(const BuffPtr: PKDT8DI16_Vec; NodePtr: PKDT8DI16_Node): PKDT8DI16_Node;
  var
    Next       : PKDT8DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT8DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DI16_Node; const BuffPtr: PKDT8DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT8DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8DI16_Vec; const p1, p2: PKDT8DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT8DI16.Search(const Buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DI16.Search(const Buff: TKDT8DI16_Vec; var SearchedDistanceMin: Double): PKDT8DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DI16.Search(const Buff: TKDT8DI16_Vec): PKDT8DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8DI16.Search(const inBuff: TKDT8DI16_DynamicVecBuffer; var OutBuff: TKDT8DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DI16_DynamicVecBuffer;
  outBuffPtr : PKDT8DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8DI16_Source));
end;

procedure TKDT8DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT8DI16.PrintNodeTree(const NodePtr: PKDT8DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT8DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT8DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8DI16.Test;
var
  TKDT8DI16_Test    : TKDT8DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8DI16_Test := TKDT8DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT8DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT8DI16_AxisCount - 1 do
        TKDT8DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT8DI16_Test.TestBuff), length(TKDT8DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8DI16_Test.BuildKDTreeM(False, length(TKDT8DI16_Test.TestBuff), @TKDT8DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8DI16_Test.BuildKDTreeM(False, length(TKDT8DI16_Test.TestBuff), TKDT8DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8DI16_Test.TestBuff));
  TKDT8DI16_Test.Search(TKDT8DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8DI16Distance(TKDT8DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8DI16_Test.Clear;
  { kMean test }
  TKDT8DI16_Test.BuildKDTreeWithCluster(TKDT8DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8DI16_Test.Search(TKDT8DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8DI16_Test);
end;

{$ENDIF DEBUG}


function KDT10DI16Vec(const s: string): TKDT10DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT10DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT10DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT10DI16Vec(const v: TKDT10DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT10DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT10DI16Pow(const v: TKDT10DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT10DI16Distance(const v1, v2: TKDT10DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT10DI16_AxisCount - 1 do
      Result := Result + KDT10DI16Pow(v2[i] - v1[i]);
end;

function KDT10DI16Cmpare(const v1, v2: TKDT10DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT10DI16_Vec));
end;

function TKDT10DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DI16_Node;
  function SortCompare(const p1, p2: PKDT10DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT10DI16_SourceBuffer;
  dynBuff  : PKDT10DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT10DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DI16.SearchStoreBuff(const StoreBuffPtr: PKDT10DI16yanmicStoreBuffer; const Buff: TKDT10DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT10DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT10DI16.GetData(const index: NativeInt): PKDT10DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT10DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DI16.StoreBuffPtr: PKDT10DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT10DI16.BuildKDTreeWithCluster(const inBuff: TKDT10DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT10DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT10DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT10DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DI16.BuildKDTreeWithCluster(const inBuff: TKDT10DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI16_BuildCall);
var
  TempStoreBuff: TKDT10DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI16_BuildMethod);
var
  TempStoreBuff: TKDT10DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI16_BuildProc);
var
  TempStoreBuff: TKDT10DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT10DI16.Search(const Buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DI16_Node;

var
  NearestNeighbour: PKDT10DI16_Node;

  function FindParentNode(const BuffPtr: PKDT10DI16_Vec; NodePtr: PKDT10DI16_Node): PKDT10DI16_Node;
  var
    Next       : PKDT10DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT10DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DI16_Node; const BuffPtr: PKDT10DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT10DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT10DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT10DI16_Vec; const p1, p2: PKDT10DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT10DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT10DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT10DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT10DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT10DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT10DI16.Search(const Buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DI16.Search(const Buff: TKDT10DI16_Vec; var SearchedDistanceMin: Double): PKDT10DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DI16.Search(const Buff: TKDT10DI16_Vec): PKDT10DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT10DI16.Search(const inBuff: TKDT10DI16_DynamicVecBuffer; var OutBuff: TKDT10DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DI16_DynamicVecBuffer;
  outBuffPtr : PKDT10DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT10DI16_Source));
end;

procedure TKDT10DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT10DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT10DI16.PrintNodeTree(const NodePtr: PKDT10DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT10DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT10DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT10DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT10DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT10DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT10DI16.Test;
var
  TKDT10DI16_Test    : TKDT10DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT10DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT10DI16_Test := TKDT10DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT10DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT10DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT10DI16_AxisCount - 1 do
        TKDT10DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT10DI16_Test.TestBuff), length(TKDT10DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT10DI16_Test.BuildKDTreeM(False, length(TKDT10DI16_Test.TestBuff), @TKDT10DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT10DI16_Test.BuildKDTreeM(False, length(TKDT10DI16_Test.TestBuff), TKDT10DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT10DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT10DI16_Test.TestBuff));
  TKDT10DI16_Test.Search(TKDT10DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT10DI16Distance(TKDT10DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT10DI16_Test.Clear;
  { kMean test }
  TKDT10DI16_Test.BuildKDTreeWithCluster(TKDT10DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT10DI16_Test.Search(TKDT10DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT10DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT10DI16_Test);
end;

{$ENDIF DEBUG}


function KDT12DI16Vec(const s: string): TKDT12DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT12DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT12DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT12DI16Vec(const v: TKDT12DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT12DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT12DI16Pow(const v: TKDT12DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT12DI16Distance(const v1, v2: TKDT12DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT12DI16_AxisCount - 1 do
      Result := Result + KDT12DI16Pow(v2[i] - v1[i]);
end;

function KDT12DI16Cmpare(const v1, v2: TKDT12DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT12DI16_Vec));
end;

function TKDT12DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DI16_Node;
  function SortCompare(const p1, p2: PKDT12DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT12DI16_SourceBuffer;
  dynBuff  : PKDT12DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT12DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DI16.SearchStoreBuff(const StoreBuffPtr: PKDT12DI16yanmicStoreBuffer; const Buff: TKDT12DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT12DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT12DI16.GetData(const index: NativeInt): PKDT12DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT12DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DI16.StoreBuffPtr: PKDT12DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT12DI16.BuildKDTreeWithCluster(const inBuff: TKDT12DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT12DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT12DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT12DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DI16.BuildKDTreeWithCluster(const inBuff: TKDT12DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI16_BuildCall);
var
  TempStoreBuff: TKDT12DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI16_BuildMethod);
var
  TempStoreBuff: TKDT12DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI16_BuildProc);
var
  TempStoreBuff: TKDT12DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT12DI16.Search(const Buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DI16_Node;

var
  NearestNeighbour: PKDT12DI16_Node;

  function FindParentNode(const BuffPtr: PKDT12DI16_Vec; NodePtr: PKDT12DI16_Node): PKDT12DI16_Node;
  var
    Next       : PKDT12DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT12DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DI16_Node; const BuffPtr: PKDT12DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT12DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT12DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT12DI16_Vec; const p1, p2: PKDT12DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT12DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT12DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT12DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT12DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT12DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT12DI16.Search(const Buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DI16.Search(const Buff: TKDT12DI16_Vec; var SearchedDistanceMin: Double): PKDT12DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DI16.Search(const Buff: TKDT12DI16_Vec): PKDT12DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT12DI16.Search(const inBuff: TKDT12DI16_DynamicVecBuffer; var OutBuff: TKDT12DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DI16_DynamicVecBuffer;
  outBuffPtr : PKDT12DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT12DI16_Source));
end;

procedure TKDT12DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT12DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT12DI16.PrintNodeTree(const NodePtr: PKDT12DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT12DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT12DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT12DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT12DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT12DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT12DI16.Test;
var
  TKDT12DI16_Test    : TKDT12DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT12DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT12DI16_Test := TKDT12DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT12DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT12DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT12DI16_AxisCount - 1 do
        TKDT12DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT12DI16_Test.TestBuff), length(TKDT12DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT12DI16_Test.BuildKDTreeM(False, length(TKDT12DI16_Test.TestBuff), @TKDT12DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT12DI16_Test.BuildKDTreeM(False, length(TKDT12DI16_Test.TestBuff), TKDT12DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT12DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT12DI16_Test.TestBuff));
  TKDT12DI16_Test.Search(TKDT12DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT12DI16Distance(TKDT12DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT12DI16_Test.Clear;
  { kMean test }
  TKDT12DI16_Test.BuildKDTreeWithCluster(TKDT12DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT12DI16_Test.Search(TKDT12DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT12DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT12DI16_Test);
end;

{$ENDIF DEBUG}


function KDT14DI16Vec(const s: string): TKDT14DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT14DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT14DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT14DI16Vec(const v: TKDT14DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT14DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT14DI16Pow(const v: TKDT14DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT14DI16Distance(const v1, v2: TKDT14DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT14DI16_AxisCount - 1 do
      Result := Result + KDT14DI16Pow(v2[i] - v1[i]);
end;

function KDT14DI16Cmpare(const v1, v2: TKDT14DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT14DI16_Vec));
end;

function TKDT14DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DI16_Node;
  function SortCompare(const p1, p2: PKDT14DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT14DI16_SourceBuffer;
  dynBuff  : PKDT14DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT14DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DI16.SearchStoreBuff(const StoreBuffPtr: PKDT14DI16yanmicStoreBuffer; const Buff: TKDT14DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT14DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT14DI16.GetData(const index: NativeInt): PKDT14DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT14DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DI16.StoreBuffPtr: PKDT14DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT14DI16.BuildKDTreeWithCluster(const inBuff: TKDT14DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT14DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT14DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT14DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DI16.BuildKDTreeWithCluster(const inBuff: TKDT14DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI16_BuildCall);
var
  TempStoreBuff: TKDT14DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI16_BuildMethod);
var
  TempStoreBuff: TKDT14DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI16_BuildProc);
var
  TempStoreBuff: TKDT14DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT14DI16.Search(const Buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DI16_Node;

var
  NearestNeighbour: PKDT14DI16_Node;

  function FindParentNode(const BuffPtr: PKDT14DI16_Vec; NodePtr: PKDT14DI16_Node): PKDT14DI16_Node;
  var
    Next       : PKDT14DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT14DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DI16_Node; const BuffPtr: PKDT14DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT14DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT14DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT14DI16_Vec; const p1, p2: PKDT14DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT14DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT14DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT14DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT14DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT14DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT14DI16.Search(const Buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DI16.Search(const Buff: TKDT14DI16_Vec; var SearchedDistanceMin: Double): PKDT14DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DI16.Search(const Buff: TKDT14DI16_Vec): PKDT14DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT14DI16.Search(const inBuff: TKDT14DI16_DynamicVecBuffer; var OutBuff: TKDT14DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DI16_DynamicVecBuffer;
  outBuffPtr : PKDT14DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT14DI16_Source));
end;

procedure TKDT14DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT14DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT14DI16.PrintNodeTree(const NodePtr: PKDT14DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT14DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT14DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT14DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT14DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT14DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT14DI16.Test;
var
  TKDT14DI16_Test    : TKDT14DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT14DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT14DI16_Test := TKDT14DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT14DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT14DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT14DI16_AxisCount - 1 do
        TKDT14DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT14DI16_Test.TestBuff), length(TKDT14DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT14DI16_Test.BuildKDTreeM(False, length(TKDT14DI16_Test.TestBuff), @TKDT14DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT14DI16_Test.BuildKDTreeM(False, length(TKDT14DI16_Test.TestBuff), TKDT14DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT14DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT14DI16_Test.TestBuff));
  TKDT14DI16_Test.Search(TKDT14DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT14DI16Distance(TKDT14DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT14DI16_Test.Clear;
  { kMean test }
  TKDT14DI16_Test.BuildKDTreeWithCluster(TKDT14DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT14DI16_Test.Search(TKDT14DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT14DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT14DI16_Test);
end;

{$ENDIF DEBUG}


function KDT16DI16Vec(const s: string): TKDT16DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT16DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT16DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT16DI16Vec(const v: TKDT16DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT16DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT16DI16Pow(const v: TKDT16DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT16DI16Distance(const v1, v2: TKDT16DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT16DI16_AxisCount - 1 do
      Result := Result + KDT16DI16Pow(v2[i] - v1[i]);
end;

function KDT16DI16Cmpare(const v1, v2: TKDT16DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT16DI16_Vec));
end;

function TKDT16DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DI16_Node;
  function SortCompare(const p1, p2: PKDT16DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT16DI16_SourceBuffer;
  dynBuff  : PKDT16DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT16DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DI16.SearchStoreBuff(const StoreBuffPtr: PKDT16DI16yanmicStoreBuffer; const Buff: TKDT16DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT16DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT16DI16.GetData(const index: NativeInt): PKDT16DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT16DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DI16.StoreBuffPtr: PKDT16DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT16DI16.BuildKDTreeWithCluster(const inBuff: TKDT16DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT16DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT16DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT16DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DI16.BuildKDTreeWithCluster(const inBuff: TKDT16DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI16_BuildCall);
var
  TempStoreBuff: TKDT16DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI16_BuildMethod);
var
  TempStoreBuff: TKDT16DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI16_BuildProc);
var
  TempStoreBuff: TKDT16DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT16DI16.Search(const Buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DI16_Node;

var
  NearestNeighbour: PKDT16DI16_Node;

  function FindParentNode(const BuffPtr: PKDT16DI16_Vec; NodePtr: PKDT16DI16_Node): PKDT16DI16_Node;
  var
    Next       : PKDT16DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT16DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DI16_Node; const BuffPtr: PKDT16DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT16DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT16DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT16DI16_Vec; const p1, p2: PKDT16DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT16DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT16DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT16DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT16DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT16DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT16DI16.Search(const Buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DI16.Search(const Buff: TKDT16DI16_Vec; var SearchedDistanceMin: Double): PKDT16DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DI16.Search(const Buff: TKDT16DI16_Vec): PKDT16DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT16DI16.Search(const inBuff: TKDT16DI16_DynamicVecBuffer; var OutBuff: TKDT16DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DI16_DynamicVecBuffer;
  outBuffPtr : PKDT16DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT16DI16_Source));
end;

procedure TKDT16DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT16DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT16DI16.PrintNodeTree(const NodePtr: PKDT16DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT16DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT16DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT16DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT16DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT16DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT16DI16.Test;
var
  TKDT16DI16_Test    : TKDT16DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT16DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT16DI16_Test := TKDT16DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT16DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT16DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT16DI16_AxisCount - 1 do
        TKDT16DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT16DI16_Test.TestBuff), length(TKDT16DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT16DI16_Test.BuildKDTreeM(False, length(TKDT16DI16_Test.TestBuff), @TKDT16DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT16DI16_Test.BuildKDTreeM(False, length(TKDT16DI16_Test.TestBuff), TKDT16DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT16DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT16DI16_Test.TestBuff));
  TKDT16DI16_Test.Search(TKDT16DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT16DI16Distance(TKDT16DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT16DI16_Test.Clear;
  { kMean test }
  TKDT16DI16_Test.BuildKDTreeWithCluster(TKDT16DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT16DI16_Test.Search(TKDT16DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT16DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT16DI16_Test);
end;

{$ENDIF DEBUG}


function KDT18DI16Vec(const s: string): TKDT18DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT18DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT18DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT18DI16Vec(const v: TKDT18DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT18DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT18DI16Pow(const v: TKDT18DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT18DI16Distance(const v1, v2: TKDT18DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT18DI16_AxisCount - 1 do
      Result := Result + KDT18DI16Pow(v2[i] - v1[i]);
end;

function KDT18DI16Cmpare(const v1, v2: TKDT18DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT18DI16_Vec));
end;

function TKDT18DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DI16_Node;
  function SortCompare(const p1, p2: PKDT18DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT18DI16_SourceBuffer;
  dynBuff  : PKDT18DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT18DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DI16.SearchStoreBuff(const StoreBuffPtr: PKDT18DI16yanmicStoreBuffer; const Buff: TKDT18DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT18DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT18DI16.GetData(const index: NativeInt): PKDT18DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT18DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DI16.StoreBuffPtr: PKDT18DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT18DI16.BuildKDTreeWithCluster(const inBuff: TKDT18DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT18DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT18DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT18DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DI16.BuildKDTreeWithCluster(const inBuff: TKDT18DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI16_BuildCall);
var
  TempStoreBuff: TKDT18DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI16_BuildMethod);
var
  TempStoreBuff: TKDT18DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI16_BuildProc);
var
  TempStoreBuff: TKDT18DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT18DI16.Search(const Buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DI16_Node;

var
  NearestNeighbour: PKDT18DI16_Node;

  function FindParentNode(const BuffPtr: PKDT18DI16_Vec; NodePtr: PKDT18DI16_Node): PKDT18DI16_Node;
  var
    Next       : PKDT18DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT18DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DI16_Node; const BuffPtr: PKDT18DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT18DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT18DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT18DI16_Vec; const p1, p2: PKDT18DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT18DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT18DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT18DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT18DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT18DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT18DI16.Search(const Buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DI16.Search(const Buff: TKDT18DI16_Vec; var SearchedDistanceMin: Double): PKDT18DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DI16.Search(const Buff: TKDT18DI16_Vec): PKDT18DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT18DI16.Search(const inBuff: TKDT18DI16_DynamicVecBuffer; var OutBuff: TKDT18DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DI16_DynamicVecBuffer;
  outBuffPtr : PKDT18DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT18DI16_Source));
end;

procedure TKDT18DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT18DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT18DI16.PrintNodeTree(const NodePtr: PKDT18DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT18DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT18DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT18DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT18DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT18DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT18DI16.Test;
var
  TKDT18DI16_Test    : TKDT18DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT18DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT18DI16_Test := TKDT18DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT18DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT18DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT18DI16_AxisCount - 1 do
        TKDT18DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT18DI16_Test.TestBuff), length(TKDT18DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT18DI16_Test.BuildKDTreeM(False, length(TKDT18DI16_Test.TestBuff), @TKDT18DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT18DI16_Test.BuildKDTreeM(False, length(TKDT18DI16_Test.TestBuff), TKDT18DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT18DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT18DI16_Test.TestBuff));
  TKDT18DI16_Test.Search(TKDT18DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT18DI16Distance(TKDT18DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT18DI16_Test.Clear;
  { kMean test }
  TKDT18DI16_Test.BuildKDTreeWithCluster(TKDT18DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT18DI16_Test.Search(TKDT18DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT18DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT18DI16_Test);
end;

{$ENDIF DEBUG}


function KDT20DI16Vec(const s: string): TKDT20DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT20DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT20DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT20DI16Vec(const v: TKDT20DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT20DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT20DI16Pow(const v: TKDT20DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT20DI16Distance(const v1, v2: TKDT20DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT20DI16_AxisCount - 1 do
      Result := Result + KDT20DI16Pow(v2[i] - v1[i]);
end;

function KDT20DI16Cmpare(const v1, v2: TKDT20DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT20DI16_Vec));
end;

function TKDT20DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DI16_Node;
  function SortCompare(const p1, p2: PKDT20DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT20DI16_SourceBuffer;
  dynBuff  : PKDT20DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT20DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DI16.SearchStoreBuff(const StoreBuffPtr: PKDT20DI16yanmicStoreBuffer; const Buff: TKDT20DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT20DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT20DI16.GetData(const index: NativeInt): PKDT20DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT20DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DI16.StoreBuffPtr: PKDT20DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT20DI16.BuildKDTreeWithCluster(const inBuff: TKDT20DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT20DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT20DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT20DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DI16.BuildKDTreeWithCluster(const inBuff: TKDT20DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI16_BuildCall);
var
  TempStoreBuff: TKDT20DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI16_BuildMethod);
var
  TempStoreBuff: TKDT20DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI16_BuildProc);
var
  TempStoreBuff: TKDT20DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT20DI16.Search(const Buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DI16_Node;

var
  NearestNeighbour: PKDT20DI16_Node;

  function FindParentNode(const BuffPtr: PKDT20DI16_Vec; NodePtr: PKDT20DI16_Node): PKDT20DI16_Node;
  var
    Next       : PKDT20DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT20DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DI16_Node; const BuffPtr: PKDT20DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT20DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT20DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT20DI16_Vec; const p1, p2: PKDT20DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT20DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT20DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT20DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT20DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT20DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT20DI16.Search(const Buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DI16.Search(const Buff: TKDT20DI16_Vec; var SearchedDistanceMin: Double): PKDT20DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DI16.Search(const Buff: TKDT20DI16_Vec): PKDT20DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT20DI16.Search(const inBuff: TKDT20DI16_DynamicVecBuffer; var OutBuff: TKDT20DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DI16_DynamicVecBuffer;
  outBuffPtr : PKDT20DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT20DI16_Source));
end;

procedure TKDT20DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT20DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT20DI16.PrintNodeTree(const NodePtr: PKDT20DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT20DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT20DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT20DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT20DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT20DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT20DI16.Test;
var
  TKDT20DI16_Test    : TKDT20DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT20DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT20DI16_Test := TKDT20DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT20DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT20DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT20DI16_AxisCount - 1 do
        TKDT20DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT20DI16_Test.TestBuff), length(TKDT20DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT20DI16_Test.BuildKDTreeM(False, length(TKDT20DI16_Test.TestBuff), @TKDT20DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT20DI16_Test.BuildKDTreeM(False, length(TKDT20DI16_Test.TestBuff), TKDT20DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT20DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT20DI16_Test.TestBuff));
  TKDT20DI16_Test.Search(TKDT20DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT20DI16Distance(TKDT20DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT20DI16_Test.Clear;
  { kMean test }
  TKDT20DI16_Test.BuildKDTreeWithCluster(TKDT20DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT20DI16_Test.Search(TKDT20DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT20DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT20DI16_Test);
end;

{$ENDIF DEBUG}


function KDT22DI16Vec(const s: string): TKDT22DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT22DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT22DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT22DI16Vec(const v: TKDT22DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT22DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT22DI16Pow(const v: TKDT22DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT22DI16Distance(const v1, v2: TKDT22DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT22DI16_AxisCount - 1 do
      Result := Result + KDT22DI16Pow(v2[i] - v1[i]);
end;

function KDT22DI16Cmpare(const v1, v2: TKDT22DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT22DI16_Vec));
end;

function TKDT22DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DI16_Node;
  function SortCompare(const p1, p2: PKDT22DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT22DI16_SourceBuffer;
  dynBuff  : PKDT22DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT22DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DI16.SearchStoreBuff(const StoreBuffPtr: PKDT22DI16yanmicStoreBuffer; const Buff: TKDT22DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT22DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT22DI16.GetData(const index: NativeInt): PKDT22DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT22DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DI16.StoreBuffPtr: PKDT22DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT22DI16.BuildKDTreeWithCluster(const inBuff: TKDT22DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT22DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT22DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT22DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DI16.BuildKDTreeWithCluster(const inBuff: TKDT22DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI16_BuildCall);
var
  TempStoreBuff: TKDT22DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI16_BuildMethod);
var
  TempStoreBuff: TKDT22DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI16_BuildProc);
var
  TempStoreBuff: TKDT22DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT22DI16.Search(const Buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DI16_Node;

var
  NearestNeighbour: PKDT22DI16_Node;

  function FindParentNode(const BuffPtr: PKDT22DI16_Vec; NodePtr: PKDT22DI16_Node): PKDT22DI16_Node;
  var
    Next       : PKDT22DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT22DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DI16_Node; const BuffPtr: PKDT22DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT22DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT22DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT22DI16_Vec; const p1, p2: PKDT22DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT22DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT22DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT22DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT22DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT22DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT22DI16.Search(const Buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DI16.Search(const Buff: TKDT22DI16_Vec; var SearchedDistanceMin: Double): PKDT22DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DI16.Search(const Buff: TKDT22DI16_Vec): PKDT22DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT22DI16.Search(const inBuff: TKDT22DI16_DynamicVecBuffer; var OutBuff: TKDT22DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DI16_DynamicVecBuffer;
  outBuffPtr : PKDT22DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT22DI16_Source));
end;

procedure TKDT22DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT22DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT22DI16.PrintNodeTree(const NodePtr: PKDT22DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT22DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT22DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT22DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT22DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT22DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT22DI16.Test;
var
  TKDT22DI16_Test    : TKDT22DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT22DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT22DI16_Test := TKDT22DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT22DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT22DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT22DI16_AxisCount - 1 do
        TKDT22DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT22DI16_Test.TestBuff), length(TKDT22DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT22DI16_Test.BuildKDTreeM(False, length(TKDT22DI16_Test.TestBuff), @TKDT22DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT22DI16_Test.BuildKDTreeM(False, length(TKDT22DI16_Test.TestBuff), TKDT22DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT22DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT22DI16_Test.TestBuff));
  TKDT22DI16_Test.Search(TKDT22DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT22DI16Distance(TKDT22DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT22DI16_Test.Clear;
  { kMean test }
  TKDT22DI16_Test.BuildKDTreeWithCluster(TKDT22DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT22DI16_Test.Search(TKDT22DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT22DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT22DI16_Test);
end;

{$ENDIF DEBUG}


function KDT24DI16Vec(const s: string): TKDT24DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT24DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT24DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT24DI16Vec(const v: TKDT24DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT24DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT24DI16Pow(const v: TKDT24DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT24DI16Distance(const v1, v2: TKDT24DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT24DI16_AxisCount - 1 do
      Result := Result + KDT24DI16Pow(v2[i] - v1[i]);
end;

function KDT24DI16Cmpare(const v1, v2: TKDT24DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT24DI16_Vec));
end;

function TKDT24DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DI16_Node;
  function SortCompare(const p1, p2: PKDT24DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT24DI16_SourceBuffer;
  dynBuff  : PKDT24DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT24DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DI16.SearchStoreBuff(const StoreBuffPtr: PKDT24DI16yanmicStoreBuffer; const Buff: TKDT24DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT24DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT24DI16.GetData(const index: NativeInt): PKDT24DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT24DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DI16.StoreBuffPtr: PKDT24DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT24DI16.BuildKDTreeWithCluster(const inBuff: TKDT24DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT24DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT24DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT24DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DI16.BuildKDTreeWithCluster(const inBuff: TKDT24DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI16_BuildCall);
var
  TempStoreBuff: TKDT24DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI16_BuildMethod);
var
  TempStoreBuff: TKDT24DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI16_BuildProc);
var
  TempStoreBuff: TKDT24DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT24DI16.Search(const Buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DI16_Node;

var
  NearestNeighbour: PKDT24DI16_Node;

  function FindParentNode(const BuffPtr: PKDT24DI16_Vec; NodePtr: PKDT24DI16_Node): PKDT24DI16_Node;
  var
    Next       : PKDT24DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT24DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DI16_Node; const BuffPtr: PKDT24DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT24DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT24DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT24DI16_Vec; const p1, p2: PKDT24DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT24DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT24DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT24DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT24DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT24DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT24DI16.Search(const Buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DI16.Search(const Buff: TKDT24DI16_Vec; var SearchedDistanceMin: Double): PKDT24DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DI16.Search(const Buff: TKDT24DI16_Vec): PKDT24DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT24DI16.Search(const inBuff: TKDT24DI16_DynamicVecBuffer; var OutBuff: TKDT24DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DI16_DynamicVecBuffer;
  outBuffPtr : PKDT24DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT24DI16_Source));
end;

procedure TKDT24DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT24DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT24DI16.PrintNodeTree(const NodePtr: PKDT24DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT24DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT24DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT24DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT24DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT24DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT24DI16.Test;
var
  TKDT24DI16_Test    : TKDT24DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT24DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT24DI16_Test := TKDT24DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT24DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT24DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT24DI16_AxisCount - 1 do
        TKDT24DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT24DI16_Test.TestBuff), length(TKDT24DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT24DI16_Test.BuildKDTreeM(False, length(TKDT24DI16_Test.TestBuff), @TKDT24DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT24DI16_Test.BuildKDTreeM(False, length(TKDT24DI16_Test.TestBuff), TKDT24DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT24DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT24DI16_Test.TestBuff));
  TKDT24DI16_Test.Search(TKDT24DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT24DI16Distance(TKDT24DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT24DI16_Test.Clear;
  { kMean test }
  TKDT24DI16_Test.BuildKDTreeWithCluster(TKDT24DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT24DI16_Test.Search(TKDT24DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT24DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT24DI16_Test);
end;

{$ENDIF DEBUG}


function KDT28DI16Vec(const s: string): TKDT28DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT28DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT28DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT28DI16Vec(const v: TKDT28DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT28DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT28DI16Pow(const v: TKDT28DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT28DI16Distance(const v1, v2: TKDT28DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT28DI16_AxisCount - 1 do
      Result := Result + KDT28DI16Pow(v2[i] - v1[i]);
end;

function KDT28DI16Cmpare(const v1, v2: TKDT28DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT28DI16_Vec));
end;

function TKDT28DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DI16_Node;
  function SortCompare(const p1, p2: PKDT28DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT28DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT28DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT28DI16_SourceBuffer;
  dynBuff  : PKDT28DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT28DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT28DI16.SearchStoreBuff(const StoreBuffPtr: PKDT28DI16yanmicStoreBuffer; const Buff: TKDT28DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT28DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT28DI16.GetData(const index: NativeInt): PKDT28DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT28DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT28DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT28DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT28DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT28DI16.StoreBuffPtr: PKDT28DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT28DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT28DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT28DI16.BuildKDTreeWithCluster(const inBuff: TKDT28DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT28DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT28DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT28DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT28DI16.BuildKDTreeWithCluster(const inBuff: TKDT28DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI16_BuildCall);
var
  TempStoreBuff: TKDT28DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI16_BuildMethod);
var
  TempStoreBuff: TKDT28DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI16_BuildProc);
var
  TempStoreBuff: TKDT28DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT28DI16.Search(const Buff: TKDT28DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DI16_Node;

var
  NearestNeighbour: PKDT28DI16_Node;

  function FindParentNode(const BuffPtr: PKDT28DI16_Vec; NodePtr: PKDT28DI16_Node): PKDT28DI16_Node;
  var
    Next       : PKDT28DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT28DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT28DI16_Node; const BuffPtr: PKDT28DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT28DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT28DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT28DI16_Vec; const p1, p2: PKDT28DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT28DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT28DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT28DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT28DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT28DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT28DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT28DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT28DI16.Search(const Buff: TKDT28DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT28DI16.Search(const Buff: TKDT28DI16_Vec; var SearchedDistanceMin: Double): PKDT28DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT28DI16.Search(const Buff: TKDT28DI16_Vec): PKDT28DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT28DI16.Search(const inBuff: TKDT28DI16_DynamicVecBuffer; var OutBuff: TKDT28DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DI16_DynamicVecBuffer;
  outBuffPtr : PKDT28DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT28DI16_Source));
end;

procedure TKDT28DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT28DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT28DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT28DI16.PrintNodeTree(const NodePtr: PKDT28DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT28DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT28DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT28DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT28DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT28DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT28DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT28DI16.Test;
var
  TKDT28DI16_Test    : TKDT28DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT28DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT28DI16_Test := TKDT28DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT28DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT28DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT28DI16_AxisCount - 1 do
        TKDT28DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT28DI16_Test.TestBuff), length(TKDT28DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT28DI16_Test.BuildKDTreeM(False, length(TKDT28DI16_Test.TestBuff), @TKDT28DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT28DI16_Test.BuildKDTreeM(False, length(TKDT28DI16_Test.TestBuff), TKDT28DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT28DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT28DI16_Test.TestBuff));
  TKDT28DI16_Test.Search(TKDT28DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT28DI16Distance(TKDT28DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT28DI16_Test.Clear;
  { kMean test }
  TKDT28DI16_Test.BuildKDTreeWithCluster(TKDT28DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT28DI16_Test.Search(TKDT28DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT28DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT28DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT28DI16_Test);
end;

{$ENDIF DEBUG}


function KDT30DI16Vec(const s: string): TKDT30DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT30DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT30DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT30DI16Vec(const v: TKDT30DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT30DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT30DI16Pow(const v: TKDT30DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT30DI16Distance(const v1, v2: TKDT30DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT30DI16_AxisCount - 1 do
      Result := Result + KDT30DI16Pow(v2[i] - v1[i]);
end;

function KDT30DI16Cmpare(const v1, v2: TKDT30DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT30DI16_Vec));
end;

function TKDT30DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DI16_Node;
  function SortCompare(const p1, p2: PKDT30DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT30DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT30DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT30DI16_SourceBuffer;
  dynBuff  : PKDT30DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT30DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT30DI16.SearchStoreBuff(const StoreBuffPtr: PKDT30DI16yanmicStoreBuffer; const Buff: TKDT30DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT30DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT30DI16.GetData(const index: NativeInt): PKDT30DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT30DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT30DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT30DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT30DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT30DI16.StoreBuffPtr: PKDT30DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT30DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT30DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT30DI16.BuildKDTreeWithCluster(const inBuff: TKDT30DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT30DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT30DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT30DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT30DI16.BuildKDTreeWithCluster(const inBuff: TKDT30DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI16_BuildCall);
var
  TempStoreBuff: TKDT30DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI16_BuildMethod);
var
  TempStoreBuff: TKDT30DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI16_BuildProc);
var
  TempStoreBuff: TKDT30DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT30DI16.Search(const Buff: TKDT30DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DI16_Node;

var
  NearestNeighbour: PKDT30DI16_Node;

  function FindParentNode(const BuffPtr: PKDT30DI16_Vec; NodePtr: PKDT30DI16_Node): PKDT30DI16_Node;
  var
    Next       : PKDT30DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT30DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT30DI16_Node; const BuffPtr: PKDT30DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT30DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT30DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT30DI16_Vec; const p1, p2: PKDT30DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT30DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT30DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT30DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT30DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT30DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT30DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT30DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT30DI16.Search(const Buff: TKDT30DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT30DI16.Search(const Buff: TKDT30DI16_Vec; var SearchedDistanceMin: Double): PKDT30DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT30DI16.Search(const Buff: TKDT30DI16_Vec): PKDT30DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT30DI16.Search(const inBuff: TKDT30DI16_DynamicVecBuffer; var OutBuff: TKDT30DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DI16_DynamicVecBuffer;
  outBuffPtr : PKDT30DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT30DI16_Source));
end;

procedure TKDT30DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT30DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT30DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT30DI16.PrintNodeTree(const NodePtr: PKDT30DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT30DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT30DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT30DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT30DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT30DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT30DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT30DI16.Test;
var
  TKDT30DI16_Test    : TKDT30DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT30DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT30DI16_Test := TKDT30DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT30DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT30DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT30DI16_AxisCount - 1 do
        TKDT30DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT30DI16_Test.TestBuff), length(TKDT30DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT30DI16_Test.BuildKDTreeM(False, length(TKDT30DI16_Test.TestBuff), @TKDT30DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT30DI16_Test.BuildKDTreeM(False, length(TKDT30DI16_Test.TestBuff), TKDT30DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT30DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT30DI16_Test.TestBuff));
  TKDT30DI16_Test.Search(TKDT30DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT30DI16Distance(TKDT30DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT30DI16_Test.Clear;
  { kMean test }
  TKDT30DI16_Test.BuildKDTreeWithCluster(TKDT30DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT30DI16_Test.Search(TKDT30DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT30DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT30DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT30DI16_Test);
end;

{$ENDIF DEBUG}


function KDT32DI16Vec(const s: string): TKDT32DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT32DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT32DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT32DI16Vec(const v: TKDT32DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT32DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT32DI16Pow(const v: TKDT32DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT32DI16Distance(const v1, v2: TKDT32DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT32DI16_AxisCount - 1 do
      Result := Result + KDT32DI16Pow(v2[i] - v1[i]);
end;

function KDT32DI16Cmpare(const v1, v2: TKDT32DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT32DI16_Vec));
end;

function TKDT32DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DI16_Node;
  function SortCompare(const p1, p2: PKDT32DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT32DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT32DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT32DI16_SourceBuffer;
  dynBuff  : PKDT32DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT32DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT32DI16.SearchStoreBuff(const StoreBuffPtr: PKDT32DI16yanmicStoreBuffer; const Buff: TKDT32DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT32DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT32DI16.GetData(const index: NativeInt): PKDT32DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT32DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT32DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT32DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT32DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT32DI16.StoreBuffPtr: PKDT32DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT32DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT32DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT32DI16.BuildKDTreeWithCluster(const inBuff: TKDT32DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT32DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT32DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT32DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT32DI16.BuildKDTreeWithCluster(const inBuff: TKDT32DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI16_BuildCall);
var
  TempStoreBuff: TKDT32DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI16_BuildMethod);
var
  TempStoreBuff: TKDT32DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI16_BuildProc);
var
  TempStoreBuff: TKDT32DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT32DI16.Search(const Buff: TKDT32DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DI16_Node;

var
  NearestNeighbour: PKDT32DI16_Node;

  function FindParentNode(const BuffPtr: PKDT32DI16_Vec; NodePtr: PKDT32DI16_Node): PKDT32DI16_Node;
  var
    Next       : PKDT32DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT32DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT32DI16_Node; const BuffPtr: PKDT32DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT32DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT32DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT32DI16_Vec; const p1, p2: PKDT32DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT32DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT32DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT32DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT32DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT32DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT32DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT32DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT32DI16.Search(const Buff: TKDT32DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT32DI16.Search(const Buff: TKDT32DI16_Vec; var SearchedDistanceMin: Double): PKDT32DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT32DI16.Search(const Buff: TKDT32DI16_Vec): PKDT32DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT32DI16.Search(const inBuff: TKDT32DI16_DynamicVecBuffer; var OutBuff: TKDT32DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DI16_DynamicVecBuffer;
  outBuffPtr : PKDT32DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT32DI16_Source));
end;

procedure TKDT32DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT32DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT32DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT32DI16.PrintNodeTree(const NodePtr: PKDT32DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT32DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT32DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT32DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT32DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT32DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT32DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT32DI16.Test;
var
  TKDT32DI16_Test    : TKDT32DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT32DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT32DI16_Test := TKDT32DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT32DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT32DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT32DI16_AxisCount - 1 do
        TKDT32DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT32DI16_Test.TestBuff), length(TKDT32DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT32DI16_Test.BuildKDTreeM(False, length(TKDT32DI16_Test.TestBuff), @TKDT32DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT32DI16_Test.BuildKDTreeM(False, length(TKDT32DI16_Test.TestBuff), TKDT32DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT32DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT32DI16_Test.TestBuff));
  TKDT32DI16_Test.Search(TKDT32DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT32DI16Distance(TKDT32DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT32DI16_Test.Clear;
  { kMean test }
  TKDT32DI16_Test.BuildKDTreeWithCluster(TKDT32DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT32DI16_Test.Search(TKDT32DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT32DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT32DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT32DI16_Test);
end;

{$ENDIF DEBUG}


function KDT34DI16Vec(const s: string): TKDT34DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT34DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT34DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT34DI16Vec(const v: TKDT34DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT34DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT34DI16Pow(const v: TKDT34DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT34DI16Distance(const v1, v2: TKDT34DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT34DI16_AxisCount - 1 do
      Result := Result + KDT34DI16Pow(v2[i] - v1[i]);
end;

function KDT34DI16Cmpare(const v1, v2: TKDT34DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT34DI16_Vec));
end;

function TKDT34DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DI16_Node;
  function SortCompare(const p1, p2: PKDT34DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT34DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT34DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT34DI16_SourceBuffer;
  dynBuff  : PKDT34DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT34DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT34DI16.SearchStoreBuff(const StoreBuffPtr: PKDT34DI16yanmicStoreBuffer; const Buff: TKDT34DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT34DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT34DI16.GetData(const index: NativeInt): PKDT34DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT34DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT34DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT34DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT34DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT34DI16.StoreBuffPtr: PKDT34DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT34DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT34DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT34DI16.BuildKDTreeWithCluster(const inBuff: TKDT34DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT34DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT34DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT34DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT34DI16.BuildKDTreeWithCluster(const inBuff: TKDT34DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI16_BuildCall);
var
  TempStoreBuff: TKDT34DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI16_BuildMethod);
var
  TempStoreBuff: TKDT34DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI16_BuildProc);
var
  TempStoreBuff: TKDT34DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT34DI16.Search(const Buff: TKDT34DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DI16_Node;

var
  NearestNeighbour: PKDT34DI16_Node;

  function FindParentNode(const BuffPtr: PKDT34DI16_Vec; NodePtr: PKDT34DI16_Node): PKDT34DI16_Node;
  var
    Next       : PKDT34DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT34DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT34DI16_Node; const BuffPtr: PKDT34DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT34DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT34DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT34DI16_Vec; const p1, p2: PKDT34DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT34DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT34DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT34DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT34DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT34DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT34DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT34DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT34DI16.Search(const Buff: TKDT34DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT34DI16.Search(const Buff: TKDT34DI16_Vec; var SearchedDistanceMin: Double): PKDT34DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT34DI16.Search(const Buff: TKDT34DI16_Vec): PKDT34DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT34DI16.Search(const inBuff: TKDT34DI16_DynamicVecBuffer; var OutBuff: TKDT34DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DI16_DynamicVecBuffer;
  outBuffPtr : PKDT34DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT34DI16_Source));
end;

procedure TKDT34DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT34DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT34DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT34DI16.PrintNodeTree(const NodePtr: PKDT34DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT34DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT34DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT34DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT34DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT34DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT34DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT34DI16.Test;
var
  TKDT34DI16_Test    : TKDT34DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT34DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT34DI16_Test := TKDT34DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT34DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT34DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT34DI16_AxisCount - 1 do
        TKDT34DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT34DI16_Test.TestBuff), length(TKDT34DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT34DI16_Test.BuildKDTreeM(False, length(TKDT34DI16_Test.TestBuff), @TKDT34DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT34DI16_Test.BuildKDTreeM(False, length(TKDT34DI16_Test.TestBuff), TKDT34DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT34DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT34DI16_Test.TestBuff));
  TKDT34DI16_Test.Search(TKDT34DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT34DI16Distance(TKDT34DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT34DI16_Test.Clear;
  { kMean test }
  TKDT34DI16_Test.BuildKDTreeWithCluster(TKDT34DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT34DI16_Test.Search(TKDT34DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT34DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT34DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT34DI16_Test);
end;

{$ENDIF DEBUG}


function KDT36DI16Vec(const s: string): TKDT36DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT36DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT36DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT36DI16Vec(const v: TKDT36DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT36DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT36DI16Pow(const v: TKDT36DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT36DI16Distance(const v1, v2: TKDT36DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT36DI16_AxisCount - 1 do
      Result := Result + KDT36DI16Pow(v2[i] - v1[i]);
end;

function KDT36DI16Cmpare(const v1, v2: TKDT36DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT36DI16_Vec));
end;

function TKDT36DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DI16_Node;
  function SortCompare(const p1, p2: PKDT36DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT36DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT36DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT36DI16_SourceBuffer;
  dynBuff  : PKDT36DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT36DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT36DI16.SearchStoreBuff(const StoreBuffPtr: PKDT36DI16yanmicStoreBuffer; const Buff: TKDT36DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT36DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT36DI16.GetData(const index: NativeInt): PKDT36DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT36DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT36DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT36DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT36DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT36DI16.StoreBuffPtr: PKDT36DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT36DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT36DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT36DI16.BuildKDTreeWithCluster(const inBuff: TKDT36DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT36DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT36DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT36DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT36DI16.BuildKDTreeWithCluster(const inBuff: TKDT36DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI16_BuildCall);
var
  TempStoreBuff: TKDT36DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI16_BuildMethod);
var
  TempStoreBuff: TKDT36DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI16_BuildProc);
var
  TempStoreBuff: TKDT36DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT36DI16.Search(const Buff: TKDT36DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DI16_Node;

var
  NearestNeighbour: PKDT36DI16_Node;

  function FindParentNode(const BuffPtr: PKDT36DI16_Vec; NodePtr: PKDT36DI16_Node): PKDT36DI16_Node;
  var
    Next       : PKDT36DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT36DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT36DI16_Node; const BuffPtr: PKDT36DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT36DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT36DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT36DI16_Vec; const p1, p2: PKDT36DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT36DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT36DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT36DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT36DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT36DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT36DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT36DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT36DI16.Search(const Buff: TKDT36DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT36DI16.Search(const Buff: TKDT36DI16_Vec; var SearchedDistanceMin: Double): PKDT36DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT36DI16.Search(const Buff: TKDT36DI16_Vec): PKDT36DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT36DI16.Search(const inBuff: TKDT36DI16_DynamicVecBuffer; var OutBuff: TKDT36DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DI16_DynamicVecBuffer;
  outBuffPtr : PKDT36DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT36DI16_Source));
end;

procedure TKDT36DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT36DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT36DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT36DI16.PrintNodeTree(const NodePtr: PKDT36DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT36DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT36DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT36DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT36DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT36DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT36DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT36DI16.Test;
var
  TKDT36DI16_Test    : TKDT36DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT36DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT36DI16_Test := TKDT36DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT36DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT36DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT36DI16_AxisCount - 1 do
        TKDT36DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT36DI16_Test.TestBuff), length(TKDT36DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT36DI16_Test.BuildKDTreeM(False, length(TKDT36DI16_Test.TestBuff), @TKDT36DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT36DI16_Test.BuildKDTreeM(False, length(TKDT36DI16_Test.TestBuff), TKDT36DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT36DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT36DI16_Test.TestBuff));
  TKDT36DI16_Test.Search(TKDT36DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT36DI16Distance(TKDT36DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT36DI16_Test.Clear;
  { kMean test }
  TKDT36DI16_Test.BuildKDTreeWithCluster(TKDT36DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT36DI16_Test.Search(TKDT36DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT36DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT36DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT36DI16_Test);
end;

{$ENDIF DEBUG}


function KDT40DI16Vec(const s: string): TKDT40DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT40DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT40DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT40DI16Vec(const v: TKDT40DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT40DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT40DI16Pow(const v: TKDT40DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT40DI16Distance(const v1, v2: TKDT40DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT40DI16_AxisCount - 1 do
      Result := Result + KDT40DI16Pow(v2[i] - v1[i]);
end;

function KDT40DI16Cmpare(const v1, v2: TKDT40DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT40DI16_Vec));
end;

function TKDT40DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DI16_Node;
  function SortCompare(const p1, p2: PKDT40DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT40DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT40DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT40DI16_SourceBuffer;
  dynBuff  : PKDT40DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT40DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT40DI16.SearchStoreBuff(const StoreBuffPtr: PKDT40DI16yanmicStoreBuffer; const Buff: TKDT40DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT40DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT40DI16.GetData(const index: NativeInt): PKDT40DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT40DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT40DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT40DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT40DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT40DI16.StoreBuffPtr: PKDT40DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT40DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT40DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT40DI16.BuildKDTreeWithCluster(const inBuff: TKDT40DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT40DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT40DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT40DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT40DI16.BuildKDTreeWithCluster(const inBuff: TKDT40DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI16_BuildCall);
var
  TempStoreBuff: TKDT40DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI16_BuildMethod);
var
  TempStoreBuff: TKDT40DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI16_BuildProc);
var
  TempStoreBuff: TKDT40DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT40DI16.Search(const Buff: TKDT40DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DI16_Node;

var
  NearestNeighbour: PKDT40DI16_Node;

  function FindParentNode(const BuffPtr: PKDT40DI16_Vec; NodePtr: PKDT40DI16_Node): PKDT40DI16_Node;
  var
    Next       : PKDT40DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT40DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT40DI16_Node; const BuffPtr: PKDT40DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT40DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT40DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT40DI16_Vec; const p1, p2: PKDT40DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT40DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT40DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT40DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT40DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT40DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT40DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT40DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT40DI16.Search(const Buff: TKDT40DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT40DI16.Search(const Buff: TKDT40DI16_Vec; var SearchedDistanceMin: Double): PKDT40DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT40DI16.Search(const Buff: TKDT40DI16_Vec): PKDT40DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT40DI16.Search(const inBuff: TKDT40DI16_DynamicVecBuffer; var OutBuff: TKDT40DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DI16_DynamicVecBuffer;
  outBuffPtr : PKDT40DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT40DI16_Source));
end;

procedure TKDT40DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT40DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT40DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT40DI16.PrintNodeTree(const NodePtr: PKDT40DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT40DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT40DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT40DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT40DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT40DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT40DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT40DI16.Test;
var
  TKDT40DI16_Test    : TKDT40DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT40DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT40DI16_Test := TKDT40DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT40DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT40DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT40DI16_AxisCount - 1 do
        TKDT40DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT40DI16_Test.TestBuff), length(TKDT40DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT40DI16_Test.BuildKDTreeM(False, length(TKDT40DI16_Test.TestBuff), @TKDT40DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT40DI16_Test.BuildKDTreeM(False, length(TKDT40DI16_Test.TestBuff), TKDT40DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT40DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT40DI16_Test.TestBuff));
  TKDT40DI16_Test.Search(TKDT40DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT40DI16Distance(TKDT40DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT40DI16_Test.Clear;
  { kMean test }
  TKDT40DI16_Test.BuildKDTreeWithCluster(TKDT40DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT40DI16_Test.Search(TKDT40DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT40DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT40DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT40DI16_Test);
end;

{$ENDIF DEBUG}


function KDT48DI16Vec(const s: string): TKDT48DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT48DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT48DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT48DI16Vec(const v: TKDT48DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT48DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT48DI16Pow(const v: TKDT48DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT48DI16Distance(const v1, v2: TKDT48DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT48DI16_AxisCount - 1 do
      Result := Result + KDT48DI16Pow(v2[i] - v1[i]);
end;

function KDT48DI16Cmpare(const v1, v2: TKDT48DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT48DI16_Vec));
end;

function TKDT48DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DI16_Node;
  function SortCompare(const p1, p2: PKDT48DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT48DI16_SourceBuffer;
  dynBuff  : PKDT48DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT48DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DI16.SearchStoreBuff(const StoreBuffPtr: PKDT48DI16yanmicStoreBuffer; const Buff: TKDT48DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT48DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT48DI16.GetData(const index: NativeInt): PKDT48DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT48DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DI16.StoreBuffPtr: PKDT48DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT48DI16.BuildKDTreeWithCluster(const inBuff: TKDT48DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT48DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT48DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT48DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DI16.BuildKDTreeWithCluster(const inBuff: TKDT48DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI16_BuildCall);
var
  TempStoreBuff: TKDT48DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI16_BuildMethod);
var
  TempStoreBuff: TKDT48DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI16_BuildProc);
var
  TempStoreBuff: TKDT48DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT48DI16.Search(const Buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DI16_Node;

var
  NearestNeighbour: PKDT48DI16_Node;

  function FindParentNode(const BuffPtr: PKDT48DI16_Vec; NodePtr: PKDT48DI16_Node): PKDT48DI16_Node;
  var
    Next       : PKDT48DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT48DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DI16_Node; const BuffPtr: PKDT48DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT48DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT48DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT48DI16_Vec; const p1, p2: PKDT48DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT48DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT48DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT48DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT48DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT48DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT48DI16.Search(const Buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DI16.Search(const Buff: TKDT48DI16_Vec; var SearchedDistanceMin: Double): PKDT48DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DI16.Search(const Buff: TKDT48DI16_Vec): PKDT48DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT48DI16.Search(const inBuff: TKDT48DI16_DynamicVecBuffer; var OutBuff: TKDT48DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DI16_DynamicVecBuffer;
  outBuffPtr : PKDT48DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT48DI16_Source));
end;

procedure TKDT48DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT48DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT48DI16.PrintNodeTree(const NodePtr: PKDT48DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT48DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT48DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT48DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT48DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT48DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT48DI16.Test;
var
  TKDT48DI16_Test    : TKDT48DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT48DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT48DI16_Test := TKDT48DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT48DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT48DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT48DI16_AxisCount - 1 do
        TKDT48DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT48DI16_Test.TestBuff), length(TKDT48DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT48DI16_Test.BuildKDTreeM(False, length(TKDT48DI16_Test.TestBuff), @TKDT48DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT48DI16_Test.BuildKDTreeM(False, length(TKDT48DI16_Test.TestBuff), TKDT48DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT48DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT48DI16_Test.TestBuff));
  TKDT48DI16_Test.Search(TKDT48DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT48DI16Distance(TKDT48DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT48DI16_Test.Clear;
  { kMean test }
  TKDT48DI16_Test.BuildKDTreeWithCluster(TKDT48DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT48DI16_Test.Search(TKDT48DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT48DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT48DI16_Test);
end;

{$ENDIF DEBUG}


function KDT64DI16Vec(const s: string): TKDT64DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT64DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT64DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT64DI16Vec(const v: TKDT64DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT64DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT64DI16Pow(const v: TKDT64DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT64DI16Distance(const v1, v2: TKDT64DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT64DI16_AxisCount - 1 do
      Result := Result + KDT64DI16Pow(v2[i] - v1[i]);
end;

function KDT64DI16Cmpare(const v1, v2: TKDT64DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT64DI16_Vec));
end;

function TKDT64DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DI16_Node;
  function SortCompare(const p1, p2: PKDT64DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT64DI16_SourceBuffer;
  dynBuff  : PKDT64DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT64DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DI16.SearchStoreBuff(const StoreBuffPtr: PKDT64DI16yanmicStoreBuffer; const Buff: TKDT64DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT64DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT64DI16.GetData(const index: NativeInt): PKDT64DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT64DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DI16.StoreBuffPtr: PKDT64DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT64DI16.BuildKDTreeWithCluster(const inBuff: TKDT64DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT64DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT64DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT64DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DI16.BuildKDTreeWithCluster(const inBuff: TKDT64DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI16_BuildCall);
var
  TempStoreBuff: TKDT64DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI16_BuildMethod);
var
  TempStoreBuff: TKDT64DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI16_BuildProc);
var
  TempStoreBuff: TKDT64DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT64DI16.Search(const Buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DI16_Node;

var
  NearestNeighbour: PKDT64DI16_Node;

  function FindParentNode(const BuffPtr: PKDT64DI16_Vec; NodePtr: PKDT64DI16_Node): PKDT64DI16_Node;
  var
    Next       : PKDT64DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT64DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DI16_Node; const BuffPtr: PKDT64DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT64DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT64DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT64DI16_Vec; const p1, p2: PKDT64DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT64DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT64DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT64DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT64DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT64DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT64DI16.Search(const Buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DI16.Search(const Buff: TKDT64DI16_Vec; var SearchedDistanceMin: Double): PKDT64DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DI16.Search(const Buff: TKDT64DI16_Vec): PKDT64DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT64DI16.Search(const inBuff: TKDT64DI16_DynamicVecBuffer; var OutBuff: TKDT64DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DI16_DynamicVecBuffer;
  outBuffPtr : PKDT64DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT64DI16_Source));
end;

procedure TKDT64DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT64DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT64DI16.PrintNodeTree(const NodePtr: PKDT64DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT64DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT64DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT64DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT64DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT64DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT64DI16.Test;
var
  TKDT64DI16_Test    : TKDT64DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT64DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT64DI16_Test := TKDT64DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT64DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT64DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT64DI16_AxisCount - 1 do
        TKDT64DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT64DI16_Test.TestBuff), length(TKDT64DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT64DI16_Test.BuildKDTreeM(False, length(TKDT64DI16_Test.TestBuff), @TKDT64DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT64DI16_Test.BuildKDTreeM(False, length(TKDT64DI16_Test.TestBuff), TKDT64DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT64DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT64DI16_Test.TestBuff));
  TKDT64DI16_Test.Search(TKDT64DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT64DI16Distance(TKDT64DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT64DI16_Test.Clear;
  { kMean test }
  TKDT64DI16_Test.BuildKDTreeWithCluster(TKDT64DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT64DI16_Test.Search(TKDT64DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT64DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT64DI16_Test);
end;

{$ENDIF DEBUG}


function KDT96DI16Vec(const s: string): TKDT96DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT96DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT96DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT96DI16Vec(const v: TKDT96DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT96DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT96DI16Pow(const v: TKDT96DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT96DI16Distance(const v1, v2: TKDT96DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT96DI16_AxisCount - 1 do
      Result := Result + KDT96DI16Pow(v2[i] - v1[i]);
end;

function KDT96DI16Cmpare(const v1, v2: TKDT96DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT96DI16_Vec));
end;

function TKDT96DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DI16_Node;
  function SortCompare(const p1, p2: PKDT96DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT96DI16_SourceBuffer;
  dynBuff  : PKDT96DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT96DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DI16.SearchStoreBuff(const StoreBuffPtr: PKDT96DI16yanmicStoreBuffer; const Buff: TKDT96DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT96DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT96DI16.GetData(const index: NativeInt): PKDT96DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT96DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DI16.StoreBuffPtr: PKDT96DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT96DI16.BuildKDTreeWithCluster(const inBuff: TKDT96DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT96DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT96DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT96DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DI16.BuildKDTreeWithCluster(const inBuff: TKDT96DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI16_BuildCall);
var
  TempStoreBuff: TKDT96DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI16_BuildMethod);
var
  TempStoreBuff: TKDT96DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI16_BuildProc);
var
  TempStoreBuff: TKDT96DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT96DI16.Search(const Buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DI16_Node;

var
  NearestNeighbour: PKDT96DI16_Node;

  function FindParentNode(const BuffPtr: PKDT96DI16_Vec; NodePtr: PKDT96DI16_Node): PKDT96DI16_Node;
  var
    Next       : PKDT96DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT96DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DI16_Node; const BuffPtr: PKDT96DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT96DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT96DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT96DI16_Vec; const p1, p2: PKDT96DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT96DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT96DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT96DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT96DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT96DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT96DI16.Search(const Buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DI16.Search(const Buff: TKDT96DI16_Vec; var SearchedDistanceMin: Double): PKDT96DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DI16.Search(const Buff: TKDT96DI16_Vec): PKDT96DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT96DI16.Search(const inBuff: TKDT96DI16_DynamicVecBuffer; var OutBuff: TKDT96DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DI16_DynamicVecBuffer;
  outBuffPtr : PKDT96DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT96DI16_Source));
end;

procedure TKDT96DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT96DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT96DI16.PrintNodeTree(const NodePtr: PKDT96DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT96DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT96DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT96DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT96DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT96DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT96DI16.Test;
var
  TKDT96DI16_Test    : TKDT96DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT96DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT96DI16_Test := TKDT96DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT96DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT96DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT96DI16_AxisCount - 1 do
        TKDT96DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT96DI16_Test.TestBuff), length(TKDT96DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT96DI16_Test.BuildKDTreeM(False, length(TKDT96DI16_Test.TestBuff), @TKDT96DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT96DI16_Test.BuildKDTreeM(False, length(TKDT96DI16_Test.TestBuff), TKDT96DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT96DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT96DI16_Test.TestBuff));
  TKDT96DI16_Test.Search(TKDT96DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT96DI16Distance(TKDT96DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT96DI16_Test.Clear;
  { kMean test }
  TKDT96DI16_Test.BuildKDTreeWithCluster(TKDT96DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT96DI16_Test.Search(TKDT96DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT96DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT96DI16_Test);
end;

{$ENDIF DEBUG}


function KDT128DI16Vec(const s: string): TKDT128DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT128DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT128DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT128DI16Vec(const v: TKDT128DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT128DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT128DI16Pow(const v: TKDT128DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT128DI16Distance(const v1, v2: TKDT128DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT128DI16_AxisCount - 1 do
      Result := Result + KDT128DI16Pow(v2[i] - v1[i]);
end;

function KDT128DI16Cmpare(const v1, v2: TKDT128DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT128DI16_Vec));
end;

function TKDT128DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DI16_Node;
  function SortCompare(const p1, p2: PKDT128DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT128DI16_SourceBuffer;
  dynBuff  : PKDT128DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT128DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DI16.SearchStoreBuff(const StoreBuffPtr: PKDT128DI16yanmicStoreBuffer; const Buff: TKDT128DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT128DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT128DI16.GetData(const index: NativeInt): PKDT128DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT128DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DI16.StoreBuffPtr: PKDT128DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT128DI16.BuildKDTreeWithCluster(const inBuff: TKDT128DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT128DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT128DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT128DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DI16.BuildKDTreeWithCluster(const inBuff: TKDT128DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI16_BuildCall);
var
  TempStoreBuff: TKDT128DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI16_BuildMethod);
var
  TempStoreBuff: TKDT128DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI16_BuildProc);
var
  TempStoreBuff: TKDT128DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT128DI16.Search(const Buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DI16_Node;

var
  NearestNeighbour: PKDT128DI16_Node;

  function FindParentNode(const BuffPtr: PKDT128DI16_Vec; NodePtr: PKDT128DI16_Node): PKDT128DI16_Node;
  var
    Next       : PKDT128DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT128DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DI16_Node; const BuffPtr: PKDT128DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT128DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT128DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT128DI16_Vec; const p1, p2: PKDT128DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT128DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT128DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT128DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT128DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT128DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT128DI16.Search(const Buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DI16.Search(const Buff: TKDT128DI16_Vec; var SearchedDistanceMin: Double): PKDT128DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DI16.Search(const Buff: TKDT128DI16_Vec): PKDT128DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT128DI16.Search(const inBuff: TKDT128DI16_DynamicVecBuffer; var OutBuff: TKDT128DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DI16_DynamicVecBuffer;
  outBuffPtr : PKDT128DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT128DI16_Source));
end;

procedure TKDT128DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT128DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT128DI16.PrintNodeTree(const NodePtr: PKDT128DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT128DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT128DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT128DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT128DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT128DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT128DI16.Test;
var
  TKDT128DI16_Test    : TKDT128DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT128DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT128DI16_Test := TKDT128DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT128DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT128DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT128DI16_AxisCount - 1 do
        TKDT128DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT128DI16_Test.TestBuff), length(TKDT128DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT128DI16_Test.BuildKDTreeM(False, length(TKDT128DI16_Test.TestBuff), @TKDT128DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT128DI16_Test.BuildKDTreeM(False, length(TKDT128DI16_Test.TestBuff), TKDT128DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT128DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT128DI16_Test.TestBuff));
  TKDT128DI16_Test.Search(TKDT128DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT128DI16Distance(TKDT128DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT128DI16_Test.Clear;
  { kMean test }
  TKDT128DI16_Test.BuildKDTreeWithCluster(TKDT128DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT128DI16_Test.Search(TKDT128DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT128DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT128DI16_Test);
end;

{$ENDIF DEBUG}


function KDT256DI16Vec(const s: string): TKDT256DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT256DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT256DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT256DI16Vec(const v: TKDT256DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT256DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT256DI16Pow(const v: TKDT256DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT256DI16Distance(const v1, v2: TKDT256DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT256DI16_AxisCount - 1 do
      Result := Result + KDT256DI16Pow(v2[i] - v1[i]);
end;

function KDT256DI16Cmpare(const v1, v2: TKDT256DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT256DI16_Vec));
end;

function TKDT256DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DI16_Node;
  function SortCompare(const p1, p2: PKDT256DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT256DI16_SourceBuffer;
  dynBuff  : PKDT256DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT256DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DI16.SearchStoreBuff(const StoreBuffPtr: PKDT256DI16yanmicStoreBuffer; const Buff: TKDT256DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT256DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT256DI16.GetData(const index: NativeInt): PKDT256DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT256DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DI16.StoreBuffPtr: PKDT256DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT256DI16.BuildKDTreeWithCluster(const inBuff: TKDT256DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT256DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT256DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT256DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DI16.BuildKDTreeWithCluster(const inBuff: TKDT256DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI16_BuildCall);
var
  TempStoreBuff: TKDT256DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI16_BuildMethod);
var
  TempStoreBuff: TKDT256DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI16_BuildProc);
var
  TempStoreBuff: TKDT256DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT256DI16.Search(const Buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DI16_Node;

var
  NearestNeighbour: PKDT256DI16_Node;

  function FindParentNode(const BuffPtr: PKDT256DI16_Vec; NodePtr: PKDT256DI16_Node): PKDT256DI16_Node;
  var
    Next       : PKDT256DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT256DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DI16_Node; const BuffPtr: PKDT256DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT256DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT256DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT256DI16_Vec; const p1, p2: PKDT256DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT256DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT256DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT256DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT256DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT256DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT256DI16.Search(const Buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DI16.Search(const Buff: TKDT256DI16_Vec; var SearchedDistanceMin: Double): PKDT256DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DI16.Search(const Buff: TKDT256DI16_Vec): PKDT256DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT256DI16.Search(const inBuff: TKDT256DI16_DynamicVecBuffer; var OutBuff: TKDT256DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DI16_DynamicVecBuffer;
  outBuffPtr : PKDT256DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT256DI16_Source));
end;

procedure TKDT256DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT256DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT256DI16.PrintNodeTree(const NodePtr: PKDT256DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT256DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT256DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT256DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT256DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT256DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT256DI16.Test;
var
  TKDT256DI16_Test    : TKDT256DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT256DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT256DI16_Test := TKDT256DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT256DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT256DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT256DI16_AxisCount - 1 do
        TKDT256DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT256DI16_Test.TestBuff), length(TKDT256DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT256DI16_Test.BuildKDTreeM(False, length(TKDT256DI16_Test.TestBuff), @TKDT256DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT256DI16_Test.BuildKDTreeM(False, length(TKDT256DI16_Test.TestBuff), TKDT256DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT256DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT256DI16_Test.TestBuff));
  TKDT256DI16_Test.Search(TKDT256DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT256DI16Distance(TKDT256DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT256DI16_Test.Clear;
  { kMean test }
  TKDT256DI16_Test.BuildKDTreeWithCluster(TKDT256DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT256DI16_Test.Search(TKDT256DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT256DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT256DI16_Test);
end;

{$ENDIF DEBUG}


function KDT372DI16Vec(const s: string): TKDT372DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT372DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT372DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT372DI16Vec(const v: TKDT372DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT372DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT372DI16Pow(const v: TKDT372DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT372DI16Distance(const v1, v2: TKDT372DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT372DI16_AxisCount - 1 do
      Result := Result + KDT372DI16Pow(v2[i] - v1[i]);
end;

function KDT372DI16Cmpare(const v1, v2: TKDT372DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT372DI16_Vec));
end;

function TKDT372DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DI16_Node;
  function SortCompare(const p1, p2: PKDT372DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT372DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT372DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT372DI16_SourceBuffer;
  dynBuff  : PKDT372DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT372DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT372DI16.SearchStoreBuff(const StoreBuffPtr: PKDT372DI16yanmicStoreBuffer; const Buff: TKDT372DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT372DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT372DI16.GetData(const index: NativeInt): PKDT372DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT372DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT372DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT372DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT372DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT372DI16.StoreBuffPtr: PKDT372DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT372DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT372DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT372DI16.BuildKDTreeWithCluster(const inBuff: TKDT372DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT372DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT372DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT372DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT372DI16.BuildKDTreeWithCluster(const inBuff: TKDT372DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI16_BuildCall);
var
  TempStoreBuff: TKDT372DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI16_BuildMethod);
var
  TempStoreBuff: TKDT372DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI16_BuildProc);
var
  TempStoreBuff: TKDT372DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT372DI16.Search(const Buff: TKDT372DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DI16_Node;

var
  NearestNeighbour: PKDT372DI16_Node;

  function FindParentNode(const BuffPtr: PKDT372DI16_Vec; NodePtr: PKDT372DI16_Node): PKDT372DI16_Node;
  var
    Next       : PKDT372DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT372DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT372DI16_Node; const BuffPtr: PKDT372DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT372DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT372DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT372DI16_Vec; const p1, p2: PKDT372DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT372DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT372DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT372DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT372DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT372DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT372DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT372DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT372DI16.Search(const Buff: TKDT372DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT372DI16.Search(const Buff: TKDT372DI16_Vec; var SearchedDistanceMin: Double): PKDT372DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT372DI16.Search(const Buff: TKDT372DI16_Vec): PKDT372DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT372DI16.Search(const inBuff: TKDT372DI16_DynamicVecBuffer; var OutBuff: TKDT372DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DI16_DynamicVecBuffer;
  outBuffPtr : PKDT372DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT372DI16_Source));
end;

procedure TKDT372DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT372DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT372DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT372DI16.PrintNodeTree(const NodePtr: PKDT372DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT372DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT372DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT372DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT372DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT372DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT372DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT372DI16.Test;
var
  TKDT372DI16_Test    : TKDT372DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT372DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT372DI16_Test := TKDT372DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT372DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT372DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT372DI16_AxisCount - 1 do
        TKDT372DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT372DI16_Test.TestBuff), length(TKDT372DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT372DI16_Test.BuildKDTreeM(False, length(TKDT372DI16_Test.TestBuff), @TKDT372DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT372DI16_Test.BuildKDTreeM(False, length(TKDT372DI16_Test.TestBuff), TKDT372DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT372DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT372DI16_Test.TestBuff));
  TKDT372DI16_Test.Search(TKDT372DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT372DI16Distance(TKDT372DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT372DI16_Test.Clear;
  { kMean test }
  TKDT372DI16_Test.BuildKDTreeWithCluster(TKDT372DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT372DI16_Test.Search(TKDT372DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT372DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT372DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT372DI16_Test);
end;

{$ENDIF DEBUG}


function KDT512DI16Vec(const s: string): TKDT512DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT512DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT512DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT512DI16Vec(const v: TKDT512DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT512DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT512DI16Pow(const v: TKDT512DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT512DI16Distance(const v1, v2: TKDT512DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT512DI16_AxisCount - 1 do
      Result := Result + KDT512DI16Pow(v2[i] - v1[i]);
end;

function KDT512DI16Cmpare(const v1, v2: TKDT512DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT512DI16_Vec));
end;

function TKDT512DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DI16_Node;
  function SortCompare(const p1, p2: PKDT512DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT512DI16_SourceBuffer;
  dynBuff  : PKDT512DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT512DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DI16.SearchStoreBuff(const StoreBuffPtr: PKDT512DI16yanmicStoreBuffer; const Buff: TKDT512DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT512DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT512DI16.GetData(const index: NativeInt): PKDT512DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT512DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DI16.StoreBuffPtr: PKDT512DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT512DI16.BuildKDTreeWithCluster(const inBuff: TKDT512DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT512DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT512DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT512DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DI16.BuildKDTreeWithCluster(const inBuff: TKDT512DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI16_BuildCall);
var
  TempStoreBuff: TKDT512DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI16_BuildMethod);
var
  TempStoreBuff: TKDT512DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI16_BuildProc);
var
  TempStoreBuff: TKDT512DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT512DI16.Search(const Buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DI16_Node;

var
  NearestNeighbour: PKDT512DI16_Node;

  function FindParentNode(const BuffPtr: PKDT512DI16_Vec; NodePtr: PKDT512DI16_Node): PKDT512DI16_Node;
  var
    Next       : PKDT512DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT512DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DI16_Node; const BuffPtr: PKDT512DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT512DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT512DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT512DI16_Vec; const p1, p2: PKDT512DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT512DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT512DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT512DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT512DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT512DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT512DI16.Search(const Buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DI16.Search(const Buff: TKDT512DI16_Vec; var SearchedDistanceMin: Double): PKDT512DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DI16.Search(const Buff: TKDT512DI16_Vec): PKDT512DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT512DI16.Search(const inBuff: TKDT512DI16_DynamicVecBuffer; var OutBuff: TKDT512DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DI16_DynamicVecBuffer;
  outBuffPtr : PKDT512DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT512DI16_Source));
end;

procedure TKDT512DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT512DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT512DI16.PrintNodeTree(const NodePtr: PKDT512DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT512DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT512DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT512DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT512DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT512DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT512DI16.Test;
var
  TKDT512DI16_Test    : TKDT512DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT512DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT512DI16_Test := TKDT512DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT512DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT512DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT512DI16_AxisCount - 1 do
        TKDT512DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT512DI16_Test.TestBuff), length(TKDT512DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT512DI16_Test.BuildKDTreeM(False, length(TKDT512DI16_Test.TestBuff), @TKDT512DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT512DI16_Test.BuildKDTreeM(False, length(TKDT512DI16_Test.TestBuff), TKDT512DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT512DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT512DI16_Test.TestBuff));
  TKDT512DI16_Test.Search(TKDT512DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT512DI16Distance(TKDT512DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT512DI16_Test.Clear;
  { kMean test }
  TKDT512DI16_Test.BuildKDTreeWithCluster(TKDT512DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT512DI16_Test.Search(TKDT512DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT512DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT512DI16_Test);
end;

{$ENDIF DEBUG}


function KDT640DI16Vec(const s: string): TKDT640DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT640DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT640DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT640DI16Vec(const v: TKDT640DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT640DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT640DI16Pow(const v: TKDT640DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT640DI16Distance(const v1, v2: TKDT640DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT640DI16_AxisCount - 1 do
      Result := Result + KDT640DI16Pow(v2[i] - v1[i]);
end;

function KDT640DI16Cmpare(const v1, v2: TKDT640DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT640DI16_Vec));
end;

function TKDT640DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT640DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT640DI16_Node;
  function SortCompare(const p1, p2: PKDT640DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT640DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT640DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT640DI16_SourceBuffer;
  dynBuff  : PKDT640DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT640DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT640DI16.SearchStoreBuff(const StoreBuffPtr: PKDT640DI16yanmicStoreBuffer; const Buff: TKDT640DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT640DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT640DI16.GetData(const index: NativeInt): PKDT640DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT640DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT640DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT640DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT640DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT640DI16.StoreBuffPtr: PKDT640DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT640DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT640DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT640DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT640DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT640DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT640DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT640DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT640DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT640DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT640DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT640DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT640DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT640DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT640DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT640DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT640DI16.BuildKDTreeWithCluster(const inBuff: TKDT640DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT640DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT640DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT640DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT640DI16.BuildKDTreeWithCluster(const inBuff: TKDT640DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT640DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DI16_BuildCall);
var
  TempStoreBuff: TKDT640DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT640DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT640DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT640DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT640DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT640DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT640DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DI16_BuildMethod);
var
  TempStoreBuff: TKDT640DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT640DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT640DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT640DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT640DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT640DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT640DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DI16_BuildProc);
var
  TempStoreBuff: TKDT640DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT640DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT640DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT640DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT640DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT640DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT640DI16.Search(const Buff: TKDT640DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT640DI16_Node;

var
  NearestNeighbour: PKDT640DI16_Node;

  function FindParentNode(const BuffPtr: PKDT640DI16_Vec; NodePtr: PKDT640DI16_Node): PKDT640DI16_Node;
  var
    Next       : PKDT640DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT640DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT640DI16_Node; const BuffPtr: PKDT640DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT640DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT640DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT640DI16_Vec; const p1, p2: PKDT640DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT640DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT640DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT640DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT640DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT640DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT640DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT640DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT640DI16.Search(const Buff: TKDT640DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT640DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT640DI16.Search(const Buff: TKDT640DI16_Vec; var SearchedDistanceMin: Double): PKDT640DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT640DI16.Search(const Buff: TKDT640DI16_Vec): PKDT640DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT640DI16.Search(const inBuff: TKDT640DI16_DynamicVecBuffer; var OutBuff: TKDT640DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT640DI16_DynamicVecBuffer;
  outBuffPtr : PKDT640DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT640DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT640DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT640DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT640DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT640DI16_Source));
end;

procedure TKDT640DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT640DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT640DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT640DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT640DI16.PrintNodeTree(const NodePtr: PKDT640DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT640DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT640DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT640DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT640DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT640DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT640DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT640DI16.Test;
var
  TKDT640DI16_Test    : TKDT640DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT640DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT640DI16_Test := TKDT640DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT640DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT640DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT640DI16_AxisCount - 1 do
        TKDT640DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT640DI16_Test.TestBuff), length(TKDT640DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT640DI16_Test.BuildKDTreeM(False, length(TKDT640DI16_Test.TestBuff), @TKDT640DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT640DI16_Test.BuildKDTreeM(False, length(TKDT640DI16_Test.TestBuff), TKDT640DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT640DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT640DI16_Test.TestBuff));
  TKDT640DI16_Test.Search(TKDT640DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT640DI16Distance(TKDT640DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT640DI16_Test.Clear;
  { kMean test }
  TKDT640DI16_Test.BuildKDTreeWithCluster(TKDT640DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT640DI16_Test.Search(TKDT640DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT640DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT640DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT640DI16_Test);
end;

{$ENDIF DEBUG}


function KDT768DI16Vec(const s: string): TKDT768DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT768DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT768DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT768DI16Vec(const v: TKDT768DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT768DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT768DI16Pow(const v: TKDT768DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT768DI16Distance(const v1, v2: TKDT768DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT768DI16_AxisCount - 1 do
      Result := Result + KDT768DI16Pow(v2[i] - v1[i]);
end;

function KDT768DI16Cmpare(const v1, v2: TKDT768DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT768DI16_Vec));
end;

function TKDT768DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DI16_Node;
  function SortCompare(const p1, p2: PKDT768DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT768DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT768DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT768DI16_SourceBuffer;
  dynBuff  : PKDT768DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT768DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT768DI16.SearchStoreBuff(const StoreBuffPtr: PKDT768DI16yanmicStoreBuffer; const Buff: TKDT768DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT768DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT768DI16.GetData(const index: NativeInt): PKDT768DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT768DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT768DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT768DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT768DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT768DI16.StoreBuffPtr: PKDT768DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT768DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT768DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT768DI16.BuildKDTreeWithCluster(const inBuff: TKDT768DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT768DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT768DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT768DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT768DI16.BuildKDTreeWithCluster(const inBuff: TKDT768DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI16_BuildCall);
var
  TempStoreBuff: TKDT768DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI16_BuildMethod);
var
  TempStoreBuff: TKDT768DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI16_BuildProc);
var
  TempStoreBuff: TKDT768DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT768DI16.Search(const Buff: TKDT768DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DI16_Node;

var
  NearestNeighbour: PKDT768DI16_Node;

  function FindParentNode(const BuffPtr: PKDT768DI16_Vec; NodePtr: PKDT768DI16_Node): PKDT768DI16_Node;
  var
    Next       : PKDT768DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT768DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT768DI16_Node; const BuffPtr: PKDT768DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT768DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT768DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT768DI16_Vec; const p1, p2: PKDT768DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT768DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT768DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT768DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT768DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT768DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT768DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT768DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT768DI16.Search(const Buff: TKDT768DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT768DI16.Search(const Buff: TKDT768DI16_Vec; var SearchedDistanceMin: Double): PKDT768DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT768DI16.Search(const Buff: TKDT768DI16_Vec): PKDT768DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT768DI16.Search(const inBuff: TKDT768DI16_DynamicVecBuffer; var OutBuff: TKDT768DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DI16_DynamicVecBuffer;
  outBuffPtr : PKDT768DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT768DI16_Source));
end;

procedure TKDT768DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT768DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT768DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT768DI16.PrintNodeTree(const NodePtr: PKDT768DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT768DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT768DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT768DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT768DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT768DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT768DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT768DI16.Test;
var
  TKDT768DI16_Test    : TKDT768DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT768DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT768DI16_Test := TKDT768DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT768DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT768DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT768DI16_AxisCount - 1 do
        TKDT768DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT768DI16_Test.TestBuff), length(TKDT768DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT768DI16_Test.BuildKDTreeM(False, length(TKDT768DI16_Test.TestBuff), @TKDT768DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT768DI16_Test.BuildKDTreeM(False, length(TKDT768DI16_Test.TestBuff), TKDT768DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT768DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT768DI16_Test.TestBuff));
  TKDT768DI16_Test.Search(TKDT768DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT768DI16Distance(TKDT768DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT768DI16_Test.Clear;
  { kMean test }
  TKDT768DI16_Test.BuildKDTreeWithCluster(TKDT768DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT768DI16_Test.Search(TKDT768DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT768DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT768DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT768DI16_Test);
end;

{$ENDIF DEBUG}


function KDT1024DI16Vec(const s: string): TKDT1024DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1024DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1024DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1024DI16Vec(const v: TKDT1024DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1024DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1024DI16Pow(const v: TKDT1024DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT1024DI16Distance(const v1, v2: TKDT1024DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1024DI16_AxisCount - 1 do
      Result := Result + KDT1024DI16Pow(v2[i] - v1[i]);
end;

function KDT1024DI16Cmpare(const v1, v2: TKDT1024DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1024DI16_Vec));
end;

function TKDT1024DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DI16_Node;
  function SortCompare(const p1, p2: PKDT1024DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1024DI16_SourceBuffer;
  dynBuff  : PKDT1024DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1024DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DI16.SearchStoreBuff(const StoreBuffPtr: PKDT1024DI16yanmicStoreBuffer; const Buff: TKDT1024DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1024DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1024DI16.GetData(const index: NativeInt): PKDT1024DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1024DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DI16.StoreBuffPtr: PKDT1024DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1024DI16.BuildKDTreeWithCluster(const inBuff: TKDT1024DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1024DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1024DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1024DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DI16.BuildKDTreeWithCluster(const inBuff: TKDT1024DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI16_BuildCall);
var
  TempStoreBuff: TKDT1024DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI16_BuildMethod);
var
  TempStoreBuff: TKDT1024DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI16_BuildProc);
var
  TempStoreBuff: TKDT1024DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1024DI16.Search(const Buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DI16_Node;

var
  NearestNeighbour: PKDT1024DI16_Node;

  function FindParentNode(const BuffPtr: PKDT1024DI16_Vec; NodePtr: PKDT1024DI16_Node): PKDT1024DI16_Node;
  var
    Next       : PKDT1024DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1024DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DI16_Node; const BuffPtr: PKDT1024DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1024DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1024DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1024DI16_Vec; const p1, p2: PKDT1024DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1024DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1024DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1024DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1024DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1024DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DI16.Search(const Buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DI16.Search(const Buff: TKDT1024DI16_Vec; var SearchedDistanceMin: Double): PKDT1024DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DI16.Search(const Buff: TKDT1024DI16_Vec): PKDT1024DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1024DI16.Search(const inBuff: TKDT1024DI16_DynamicVecBuffer; var OutBuff: TKDT1024DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DI16_DynamicVecBuffer;
  outBuffPtr : PKDT1024DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1024DI16_Source));
end;

procedure TKDT1024DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1024DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1024DI16.PrintNodeTree(const NodePtr: PKDT1024DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1024DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1024DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1024DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1024DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1024DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1024DI16.Test;
var
  TKDT1024DI16_Test    : TKDT1024DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1024DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1024DI16_Test := TKDT1024DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1024DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT1024DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT1024DI16_AxisCount - 1 do
        TKDT1024DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1024DI16_Test.TestBuff), length(TKDT1024DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1024DI16_Test.BuildKDTreeM(False, length(TKDT1024DI16_Test.TestBuff), @TKDT1024DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1024DI16_Test.BuildKDTreeM(False, length(TKDT1024DI16_Test.TestBuff), TKDT1024DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1024DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1024DI16_Test.TestBuff));
  TKDT1024DI16_Test.Search(TKDT1024DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1024DI16Distance(TKDT1024DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1024DI16_Test.Clear;
  { kMean test }
  TKDT1024DI16_Test.BuildKDTreeWithCluster(TKDT1024DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1024DI16_Test.Search(TKDT1024DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1024DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1024DI16_Test);
end;

{$ENDIF DEBUG}


function KDT1080DI16Vec(const s: string): TKDT1080DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1080DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1080DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1080DI16Vec(const v: TKDT1080DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1080DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1080DI16Pow(const v: TKDT1080DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT1080DI16Distance(const v1, v2: TKDT1080DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1080DI16_AxisCount - 1 do
      Result := Result + KDT1080DI16Pow(v2[i] - v1[i]);
end;

function KDT1080DI16Cmpare(const v1, v2: TKDT1080DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1080DI16_Vec));
end;

function TKDT1080DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1080DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1080DI16_Node;
  function SortCompare(const p1, p2: PKDT1080DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1080DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1080DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1080DI16_SourceBuffer;
  dynBuff  : PKDT1080DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1080DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1080DI16.SearchStoreBuff(const StoreBuffPtr: PKDT1080DI16yanmicStoreBuffer; const Buff: TKDT1080DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1080DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1080DI16.GetData(const index: NativeInt): PKDT1080DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1080DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1080DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1080DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1080DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1080DI16.StoreBuffPtr: PKDT1080DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1080DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1080DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1080DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1080DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1080DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1080DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1080DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1080DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1080DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1080DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1080DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1080DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1080DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1080DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1080DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1080DI16.BuildKDTreeWithCluster(const inBuff: TKDT1080DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1080DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1080DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1080DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1080DI16.BuildKDTreeWithCluster(const inBuff: TKDT1080DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1080DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DI16_BuildCall);
var
  TempStoreBuff: TKDT1080DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1080DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1080DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1080DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1080DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1080DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1080DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DI16_BuildMethod);
var
  TempStoreBuff: TKDT1080DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1080DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1080DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1080DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1080DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1080DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1080DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DI16_BuildProc);
var
  TempStoreBuff: TKDT1080DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1080DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1080DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1080DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1080DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1080DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1080DI16.Search(const Buff: TKDT1080DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1080DI16_Node;

var
  NearestNeighbour: PKDT1080DI16_Node;

  function FindParentNode(const BuffPtr: PKDT1080DI16_Vec; NodePtr: PKDT1080DI16_Node): PKDT1080DI16_Node;
  var
    Next       : PKDT1080DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1080DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1080DI16_Node; const BuffPtr: PKDT1080DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1080DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1080DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1080DI16_Vec; const p1, p2: PKDT1080DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1080DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1080DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1080DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1080DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1080DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1080DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1080DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT1080DI16.Search(const Buff: TKDT1080DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1080DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1080DI16.Search(const Buff: TKDT1080DI16_Vec; var SearchedDistanceMin: Double): PKDT1080DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1080DI16.Search(const Buff: TKDT1080DI16_Vec): PKDT1080DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1080DI16.Search(const inBuff: TKDT1080DI16_DynamicVecBuffer; var OutBuff: TKDT1080DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1080DI16_DynamicVecBuffer;
  outBuffPtr : PKDT1080DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1080DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1080DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1080DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1080DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1080DI16_Source));
end;

procedure TKDT1080DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1080DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1080DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1080DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1080DI16.PrintNodeTree(const NodePtr: PKDT1080DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1080DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1080DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1080DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1080DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1080DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1080DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1080DI16.Test;
var
  TKDT1080DI16_Test    : TKDT1080DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1080DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1080DI16_Test := TKDT1080DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1080DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT1080DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT1080DI16_AxisCount - 1 do
        TKDT1080DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1080DI16_Test.TestBuff), length(TKDT1080DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1080DI16_Test.BuildKDTreeM(False, length(TKDT1080DI16_Test.TestBuff), @TKDT1080DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1080DI16_Test.BuildKDTreeM(False, length(TKDT1080DI16_Test.TestBuff), TKDT1080DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1080DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1080DI16_Test.TestBuff));
  TKDT1080DI16_Test.Search(TKDT1080DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1080DI16Distance(TKDT1080DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1080DI16_Test.Clear;
  { kMean test }
  TKDT1080DI16_Test.BuildKDTreeWithCluster(TKDT1080DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1080DI16_Test.Search(TKDT1080DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1080DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1080DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1080DI16_Test);
end;

{$ENDIF DEBUG}


function KDT1536DI16Vec(const s: string): TKDT1536DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1536DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1536DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1536DI16Vec(const v: TKDT1536DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1536DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1536DI16Pow(const v: TKDT1536DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT1536DI16Distance(const v1, v2: TKDT1536DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1536DI16_AxisCount - 1 do
      Result := Result + KDT1536DI16Pow(v2[i] - v1[i]);
end;

function KDT1536DI16Cmpare(const v1, v2: TKDT1536DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1536DI16_Vec));
end;

function TKDT1536DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DI16_Node;
  function SortCompare(const p1, p2: PKDT1536DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1536DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1536DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1536DI16_SourceBuffer;
  dynBuff  : PKDT1536DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1536DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1536DI16.SearchStoreBuff(const StoreBuffPtr: PKDT1536DI16yanmicStoreBuffer; const Buff: TKDT1536DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1536DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1536DI16.GetData(const index: NativeInt): PKDT1536DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1536DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1536DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1536DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1536DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1536DI16.StoreBuffPtr: PKDT1536DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1536DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1536DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1536DI16.BuildKDTreeWithCluster(const inBuff: TKDT1536DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1536DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1536DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1536DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1536DI16.BuildKDTreeWithCluster(const inBuff: TKDT1536DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI16_BuildCall);
var
  TempStoreBuff: TKDT1536DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI16_BuildMethod);
var
  TempStoreBuff: TKDT1536DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI16_BuildProc);
var
  TempStoreBuff: TKDT1536DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1536DI16.Search(const Buff: TKDT1536DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DI16_Node;

var
  NearestNeighbour: PKDT1536DI16_Node;

  function FindParentNode(const BuffPtr: PKDT1536DI16_Vec; NodePtr: PKDT1536DI16_Node): PKDT1536DI16_Node;
  var
    Next       : PKDT1536DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1536DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1536DI16_Node; const BuffPtr: PKDT1536DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1536DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1536DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1536DI16_Vec; const p1, p2: PKDT1536DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1536DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1536DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1536DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1536DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1536DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1536DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1536DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT1536DI16.Search(const Buff: TKDT1536DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1536DI16.Search(const Buff: TKDT1536DI16_Vec; var SearchedDistanceMin: Double): PKDT1536DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1536DI16.Search(const Buff: TKDT1536DI16_Vec): PKDT1536DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1536DI16.Search(const inBuff: TKDT1536DI16_DynamicVecBuffer; var OutBuff: TKDT1536DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DI16_DynamicVecBuffer;
  outBuffPtr : PKDT1536DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1536DI16_Source));
end;

procedure TKDT1536DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1536DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1536DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1536DI16.PrintNodeTree(const NodePtr: PKDT1536DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1536DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1536DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1536DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1536DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1536DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1536DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1536DI16.Test;
var
  TKDT1536DI16_Test    : TKDT1536DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1536DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1536DI16_Test := TKDT1536DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1536DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT1536DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT1536DI16_AxisCount - 1 do
        TKDT1536DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1536DI16_Test.TestBuff), length(TKDT1536DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1536DI16_Test.BuildKDTreeM(False, length(TKDT1536DI16_Test.TestBuff), @TKDT1536DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1536DI16_Test.BuildKDTreeM(False, length(TKDT1536DI16_Test.TestBuff), TKDT1536DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1536DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1536DI16_Test.TestBuff));
  TKDT1536DI16_Test.Search(TKDT1536DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1536DI16Distance(TKDT1536DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1536DI16_Test.Clear;
  { kMean test }
  TKDT1536DI16_Test.BuildKDTreeWithCluster(TKDT1536DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1536DI16_Test.Search(TKDT1536DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1536DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1536DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1536DI16_Test);
end;

{$ENDIF DEBUG}


function KDT1920DI16Vec(const s: string): TKDT1920DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1920DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1920DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1920DI16Vec(const v: TKDT1920DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1920DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1920DI16Pow(const v: TKDT1920DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT1920DI16Distance(const v1, v2: TKDT1920DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1920DI16_AxisCount - 1 do
      Result := Result + KDT1920DI16Pow(v2[i] - v1[i]);
end;

function KDT1920DI16Cmpare(const v1, v2: TKDT1920DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1920DI16_Vec));
end;

function TKDT1920DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DI16_Node;
  function SortCompare(const p1, p2: PKDT1920DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1920DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1920DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1920DI16_SourceBuffer;
  dynBuff  : PKDT1920DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1920DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1920DI16.SearchStoreBuff(const StoreBuffPtr: PKDT1920DI16yanmicStoreBuffer; const Buff: TKDT1920DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1920DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1920DI16.GetData(const index: NativeInt): PKDT1920DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1920DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1920DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1920DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1920DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1920DI16.StoreBuffPtr: PKDT1920DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1920DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1920DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1920DI16.BuildKDTreeWithCluster(const inBuff: TKDT1920DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1920DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1920DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1920DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1920DI16.BuildKDTreeWithCluster(const inBuff: TKDT1920DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI16_BuildCall);
var
  TempStoreBuff: TKDT1920DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI16_BuildMethod);
var
  TempStoreBuff: TKDT1920DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI16_BuildProc);
var
  TempStoreBuff: TKDT1920DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1920DI16.Search(const Buff: TKDT1920DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DI16_Node;

var
  NearestNeighbour: PKDT1920DI16_Node;

  function FindParentNode(const BuffPtr: PKDT1920DI16_Vec; NodePtr: PKDT1920DI16_Node): PKDT1920DI16_Node;
  var
    Next       : PKDT1920DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1920DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1920DI16_Node; const BuffPtr: PKDT1920DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1920DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1920DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1920DI16_Vec; const p1, p2: PKDT1920DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1920DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1920DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1920DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1920DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1920DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1920DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1920DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT1920DI16.Search(const Buff: TKDT1920DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1920DI16.Search(const Buff: TKDT1920DI16_Vec; var SearchedDistanceMin: Double): PKDT1920DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1920DI16.Search(const Buff: TKDT1920DI16_Vec): PKDT1920DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1920DI16.Search(const inBuff: TKDT1920DI16_DynamicVecBuffer; var OutBuff: TKDT1920DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DI16_DynamicVecBuffer;
  outBuffPtr : PKDT1920DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1920DI16_Source));
end;

procedure TKDT1920DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1920DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1920DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1920DI16.PrintNodeTree(const NodePtr: PKDT1920DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1920DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1920DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1920DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1920DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1920DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1920DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1920DI16.Test;
var
  TKDT1920DI16_Test    : TKDT1920DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1920DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1920DI16_Test := TKDT1920DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1920DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT1920DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT1920DI16_AxisCount - 1 do
        TKDT1920DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1920DI16_Test.TestBuff), length(TKDT1920DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1920DI16_Test.BuildKDTreeM(False, length(TKDT1920DI16_Test.TestBuff), @TKDT1920DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1920DI16_Test.BuildKDTreeM(False, length(TKDT1920DI16_Test.TestBuff), TKDT1920DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1920DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1920DI16_Test.TestBuff));
  TKDT1920DI16_Test.Search(TKDT1920DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1920DI16Distance(TKDT1920DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1920DI16_Test.Clear;
  { kMean test }
  TKDT1920DI16_Test.BuildKDTreeWithCluster(TKDT1920DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1920DI16_Test.Search(TKDT1920DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1920DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1920DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1920DI16_Test);
end;

{$ENDIF DEBUG}


function KDT2048DI16Vec(const s: string): TKDT2048DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT2048DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT2048DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT2048DI16Vec(const v: TKDT2048DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT2048DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT2048DI16Pow(const v: TKDT2048DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT2048DI16Distance(const v1, v2: TKDT2048DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT2048DI16_AxisCount - 1 do
      Result := Result + KDT2048DI16Pow(v2[i] - v1[i]);
end;

function KDT2048DI16Cmpare(const v1, v2: TKDT2048DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT2048DI16_Vec));
end;

function TKDT2048DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DI16_Node;
  function SortCompare(const p1, p2: PKDT2048DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2048DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2048DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2048DI16_SourceBuffer;
  dynBuff  : PKDT2048DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT2048DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2048DI16.SearchStoreBuff(const StoreBuffPtr: PKDT2048DI16yanmicStoreBuffer; const Buff: TKDT2048DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT2048DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT2048DI16.GetData(const index: NativeInt): PKDT2048DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2048DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2048DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2048DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2048DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2048DI16.StoreBuffPtr: PKDT2048DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2048DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2048DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2048DI16.BuildKDTreeWithCluster(const inBuff: TKDT2048DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT2048DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT2048DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT2048DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2048DI16.BuildKDTreeWithCluster(const inBuff: TKDT2048DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI16_BuildCall);
var
  TempStoreBuff: TKDT2048DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI16_BuildMethod);
var
  TempStoreBuff: TKDT2048DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI16_BuildProc);
var
  TempStoreBuff: TKDT2048DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2048DI16.Search(const Buff: TKDT2048DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DI16_Node;

var
  NearestNeighbour: PKDT2048DI16_Node;

  function FindParentNode(const BuffPtr: PKDT2048DI16_Vec; NodePtr: PKDT2048DI16_Node): PKDT2048DI16_Node;
  var
    Next       : PKDT2048DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT2048DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2048DI16_Node; const BuffPtr: PKDT2048DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2048DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT2048DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2048DI16_Vec; const p1, p2: PKDT2048DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2048DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2048DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2048DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2048DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2048DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2048DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2048DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT2048DI16.Search(const Buff: TKDT2048DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2048DI16.Search(const Buff: TKDT2048DI16_Vec; var SearchedDistanceMin: Double): PKDT2048DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2048DI16.Search(const Buff: TKDT2048DI16_Vec): PKDT2048DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2048DI16.Search(const inBuff: TKDT2048DI16_DynamicVecBuffer; var OutBuff: TKDT2048DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DI16_DynamicVecBuffer;
  outBuffPtr : PKDT2048DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2048DI16_Source));
end;

procedure TKDT2048DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2048DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2048DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT2048DI16.PrintNodeTree(const NodePtr: PKDT2048DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2048DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2048DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2048DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2048DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT2048DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT2048DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2048DI16.Test;
var
  TKDT2048DI16_Test    : TKDT2048DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2048DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2048DI16_Test := TKDT2048DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2048DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT2048DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT2048DI16_AxisCount - 1 do
        TKDT2048DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT2048DI16_Test.TestBuff), length(TKDT2048DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2048DI16_Test.BuildKDTreeM(False, length(TKDT2048DI16_Test.TestBuff), @TKDT2048DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2048DI16_Test.BuildKDTreeM(False, length(TKDT2048DI16_Test.TestBuff), TKDT2048DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2048DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2048DI16_Test.TestBuff));
  TKDT2048DI16_Test.Search(TKDT2048DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2048DI16Distance(TKDT2048DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2048DI16_Test.Clear;
  { kMean test }
  TKDT2048DI16_Test.BuildKDTreeWithCluster(TKDT2048DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2048DI16_Test.Search(TKDT2048DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2048DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2048DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2048DI16_Test);
end;

{$ENDIF DEBUG}


function KDT3072DI16Vec(const s: string): TKDT3072DI16_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3072DI16_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3072DI16_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3072DI16Vec(const v: TKDT3072DI16_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3072DI16_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT3072DI16Pow(const v: TKDT3072DI16_VecType): Double;
begin
  Result := v * v;
end;

function KDT3072DI16Distance(const v1, v2: TKDT3072DI16_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3072DI16_AxisCount - 1 do
      Result := Result + KDT3072DI16Pow(v2[i] - v1[i]);
end;

function KDT3072DI16Cmpare(const v1, v2: TKDT3072DI16_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3072DI16_Vec));
end;

function TKDT3072DI16.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DI16_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DI16_Node;
  function SortCompare(const p1, p2: PKDT3072DI16_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3072DI16_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3072DI16_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3072DI16_SourceBuffer;
  dynBuff  : PKDT3072DI16yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3072DI16_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3072DI16.SearchStoreBuff(const StoreBuffPtr: PKDT3072DI16yanmicStoreBuffer; const Buff: TKDT3072DI16_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3072DI16Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3072DI16.GetData(const index: NativeInt): PKDT3072DI16_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3072DI16.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3072DI16.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3072DI16.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3072DI16_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3072DI16.StoreBuffPtr: PKDT3072DI16yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3072DI16.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI16_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3072DI16.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI16_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DI16.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI16_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DI16yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DI16_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DI16_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DI16_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3072DI16.BuildKDTreeWithCluster(const inBuff: TKDT3072DI16_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3072DI16_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3072DI16_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3072DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3072DI16.BuildKDTreeWithCluster(const inBuff: TKDT3072DI16_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI16_BuildCall);
var
  TempStoreBuff: TKDT3072DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DI16.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI16_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI16_BuildMethod);
var
  TempStoreBuff: TKDT3072DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DI16.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI16_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI16_BuildProc);
var
  TempStoreBuff: TKDT3072DI16yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DI16_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DI16_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DI16_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DI16_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DI16_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DI16.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI16_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3072DI16.Search(const Buff: TKDT3072DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DI16_Node;

var
  NearestNeighbour: PKDT3072DI16_Node;

  function FindParentNode(const BuffPtr: PKDT3072DI16_Vec; NodePtr: PKDT3072DI16_Node): PKDT3072DI16_Node;
  var
    Next       : PKDT3072DI16_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3072DI16_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3072DI16_Node; const BuffPtr: PKDT3072DI16_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3072DI16Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3072DI16_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3072DI16_Vec; const p1, p2: PKDT3072DI16_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3072DI16Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3072DI16Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3072DI16_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3072DI16_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3072DI16_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3072DI16Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3072DI16_Node(NearestNodes[0]);
    end;
end;

function TKDT3072DI16.Search(const Buff: TKDT3072DI16_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DI16_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3072DI16.Search(const Buff: TKDT3072DI16_Vec; var SearchedDistanceMin: Double): PKDT3072DI16_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3072DI16.Search(const Buff: TKDT3072DI16_Vec): PKDT3072DI16_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3072DI16.Search(const inBuff: TKDT3072DI16_DynamicVecBuffer; var OutBuff: TKDT3072DI16_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DI16_DynamicVecBuffer;
  outBuffPtr : PKDT3072DI16_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DI16_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DI16_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DI16_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DI16.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3072DI16_Source));
end;

procedure TKDT3072DI16.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3072DI16_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3072DI16.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DI16.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3072DI16.PrintNodeTree(const NodePtr: PKDT3072DI16_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3072DI16_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3072DI16Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3072DI16.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3072DI16Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3072DI16.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3072DI16_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3072DI16.Test;
var
  TKDT3072DI16_Test    : TKDT3072DI16;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3072DI16_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3072DI16_Test := TKDT3072DI16.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3072DI16_Test.TestBuff, 300);
  for i := 0 to length(TKDT3072DI16_Test.TestBuff) - 1 do
    for j := 0 to TKDT3072DI16_AxisCount - 1 do
        TKDT3072DI16_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT3072DI16_Test.TestBuff), length(TKDT3072DI16_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3072DI16_Test.BuildKDTreeM(False, length(TKDT3072DI16_Test.TestBuff), @TKDT3072DI16_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3072DI16_Test.BuildKDTreeM(False, length(TKDT3072DI16_Test.TestBuff), TKDT3072DI16_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3072DI16_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3072DI16_Test.TestBuff));
  TKDT3072DI16_Test.Search(TKDT3072DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3072DI16Distance(TKDT3072DI16_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3072DI16_Test.Clear;
  { kMean test }
  TKDT3072DI16_Test.BuildKDTreeWithCluster(TKDT3072DI16_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3072DI16_Test.Search(TKDT3072DI16_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3072DI16_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3072DI16_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3072DI16_Test);
end;

{$ENDIF DEBUG}

{$IFDEF DEBUG}
procedure Test_All;
begin
  TKDT1DI16.Test();
  TKDT2DI16.Test();
  TKDT3DI16.Test();
  TKDT4DI16.Test();
  TKDT6DI16.Test();
  TKDT8DI16.Test();
  TKDT10DI16.Test();
  TKDT12DI16.Test();
  TKDT14DI16.Test();
  TKDT16DI16.Test();
  TKDT18DI16.Test();
  TKDT20DI16.Test();
  TKDT22DI16.Test();
  TKDT24DI16.Test();
  TKDT28DI16.Test();
  TKDT30DI16.Test();
  TKDT32DI16.Test();
  TKDT34DI16.Test();
  TKDT36DI16.Test();
  TKDT40DI16.Test();
  TKDT48DI16.Test();
  TKDT64DI16.Test();
  TKDT96DI16.Test();
  TKDT128DI16.Test();
  TKDT256DI16.Test();
  TKDT372DI16.Test();
  TKDT512DI16.Test();
  TKDT640DI16.Test();
  TKDT768DI16.Test();
  TKDT1024DI16.Test();
  TKDT1080DI16.Test();
  TKDT1536DI16.Test();
  TKDT1920DI16.Test();
  TKDT2048DI16.Test();
  TKDT3072DI16.Test();
  DoStatus('All Test Finished');
end;
{$ENDIF}




initialization

finalization

end.

