{ Fast KDTree Currency Type support                                                }
{ ****************************************************************************** }
{ * fast KDTree Support,writen by QQ 600585@qq.com                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ ****************************************************************************** }

unit FastKDTreeC;

interface

uses CoreClasses, KM;

{$I zDefine.inc}

{$IFDEF FPC}
{$DEFINE DEBUG}
{$ENDIF FPC}

const

  // Currency float: KDTree
  TKDT1DC_AxisCount = 1;
  TKDT2DC_AxisCount = 2;
  TKDT3DC_AxisCount = 3;
  TKDT4DC_AxisCount = 4;
  TKDT6DC_AxisCount = 6;
  TKDT8DC_AxisCount = 8;
  TKDT10DC_AxisCount = 10;
  TKDT12DC_AxisCount = 12;
  TKDT14DC_AxisCount = 14;
  TKDT16DC_AxisCount = 16;
  TKDT18DC_AxisCount = 18;
  TKDT20DC_AxisCount = 20;
  TKDT22DC_AxisCount = 22;
  TKDT24DC_AxisCount = 24;
  TKDT28DC_AxisCount = 28;
  TKDT30DC_AxisCount = 30;
  TKDT32DC_AxisCount = 32;
  TKDT34DC_AxisCount = 34;
  TKDT36DC_AxisCount = 36;
  TKDT40DC_AxisCount = 40;
  TKDT48DC_AxisCount = 48;
  TKDT64DC_AxisCount = 64;
  TKDT96DC_AxisCount = 96;
  TKDT128DC_AxisCount = 128;
  TKDT256DC_AxisCount = 256;
  TKDT372DC_AxisCount = 372;
  TKDT512DC_AxisCount = 512;
  TKDT640DC_AxisCount = 640;
  TKDT768DC_AxisCount = 768;
  TKDT1024DC_AxisCount = 1024;
  TKDT1080DC_AxisCount = 1080;
  TKDT1536DC_AxisCount = 1536;
  TKDT1920DC_AxisCount = 1920;
  TKDT2048DC_AxisCount = 2048;
  TKDT3072DC_AxisCount = 3072;

type

  // Currency float: KDTree
  TKDT1DC = class;  TKDT1DC_VecType = Currency; // 1D
  TKDT2DC = class;  TKDT2DC_VecType = Currency; // 2D
  TKDT3DC = class;  TKDT3DC_VecType = Currency; // 3D
  TKDT4DC = class;  TKDT4DC_VecType = Currency; // 4D
  TKDT6DC = class;  TKDT6DC_VecType = Currency; // 6D
  TKDT8DC = class;  TKDT8DC_VecType = Currency; // 8D
  TKDT10DC = class;  TKDT10DC_VecType = Currency; // 10D
  TKDT12DC = class;  TKDT12DC_VecType = Currency; // 12D
  TKDT14DC = class;  TKDT14DC_VecType = Currency; // 14D
  TKDT16DC = class;  TKDT16DC_VecType = Currency; // 16D
  TKDT18DC = class;  TKDT18DC_VecType = Currency; // 18D
  TKDT20DC = class;  TKDT20DC_VecType = Currency; // 20D
  TKDT22DC = class;  TKDT22DC_VecType = Currency; // 22D
  TKDT24DC = class;  TKDT24DC_VecType = Currency; // 24D
  TKDT28DC = class;  TKDT28DC_VecType = Currency; // 28D
  TKDT30DC = class;  TKDT30DC_VecType = Currency; // 30D
  TKDT32DC = class;  TKDT32DC_VecType = Currency; // 32D
  TKDT34DC = class;  TKDT34DC_VecType = Currency; // 34D
  TKDT36DC = class;  TKDT36DC_VecType = Currency; // 36D
  TKDT40DC = class;  TKDT40DC_VecType = Currency; // 40D
  TKDT48DC = class;  TKDT48DC_VecType = Currency; // 48D
  TKDT64DC = class;  TKDT64DC_VecType = Currency; // 64D
  TKDT96DC = class;  TKDT96DC_VecType = Currency; // 96D
  TKDT128DC = class;  TKDT128DC_VecType = Currency; // 128D
  TKDT256DC = class;  TKDT256DC_VecType = Currency; // 256D
  TKDT372DC = class;  TKDT372DC_VecType = Currency; // 372D
  TKDT512DC = class;  TKDT512DC_VecType = Currency; // 512D
  TKDT640DC = class;  TKDT640DC_VecType = Currency; // 640D
  TKDT768DC = class;  TKDT768DC_VecType = Currency; // 768D
  TKDT1024DC = class;  TKDT1024DC_VecType = Currency; // 1024D
  TKDT1080DC = class;  TKDT1080DC_VecType = Currency; // 1080D
  TKDT1536DC = class;  TKDT1536DC_VecType = Currency; // 1536D
  TKDT1920DC = class;  TKDT1920DC_VecType = Currency; // 1920D
  TKDT2048DC = class;  TKDT2048DC_VecType = Currency; // 2048D
  TKDT3072DC = class;  TKDT3072DC_VecType = Currency; // 3072D










  // Currency float: KDTree


  TKDT1DC_Vec = array [0 .. TKDT1DC_AxisCount - 1] of TKDT1DC_VecType;
  PKDT1DC_Vec = ^TKDT1DC_Vec;

  TKDT1DC_DynamicVecBuffer = array of TKDT1DC_Vec;
  PKDT1DC_DynamicVecBuffer = ^TKDT1DC_DynamicVecBuffer;

  TKDT1DC_Source = packed record
    Buff: TKDT1DC_Vec;
    index: Int64;
  end;

  PKDT1DC_Source       = ^TKDT1DC_Source;
  TKDT1DC_SourceBuffer = array [0 .. 0] of PKDT1DC_Source;
  PKDT1DC_SourceBuffer = ^TKDT1DC_SourceBuffer;

  TKDT1DCyanmicSourceBuffer = array of PKDT1DC_Source;
  PKDT1DCyanmicSourceBuffer = ^TKDT1DCyanmicSourceBuffer;

  TKDT1DCyanmicStoreBuffer = array of TKDT1DC_Source;
  PKDT1DCyanmicStoreBuffer = ^TKDT1DCyanmicStoreBuffer;

  PKDT1DC_Node = ^TKDT1DC_Node;

  TKDT1DC_Node = packed record
    Parent, Right, Left: PKDT1DC_Node;
    vec: PKDT1DC_Source;
  end;

  TKDT1DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1DC_Source);
  TKDT1DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1DC_Source) of object;
  {$IFNDEF FPC}
  TKDT1DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1DC_Source);
  {$ENDIF}

  TKDT1DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1DCyanmicStoreBuffer;
    KDBuff     : TKDT1DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1DCyanmicStoreBuffer; const Buff: TKDT1DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DC_Node; overload;
    function Search(const Buff: TKDT1DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DC_Node; overload;
    function Search(const Buff: TKDT1DC_Vec; var SearchedDistanceMin: Double): PKDT1DC_Node; overload;
    function Search(const Buff: TKDT1DC_Vec): PKDT1DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1DC_DynamicVecBuffer; var OutBuff: TKDT1DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT2DC_Vec = array [0 .. TKDT2DC_AxisCount - 1] of TKDT2DC_VecType;
  PKDT2DC_Vec = ^TKDT2DC_Vec;

  TKDT2DC_DynamicVecBuffer = array of TKDT2DC_Vec;
  PKDT2DC_DynamicVecBuffer = ^TKDT2DC_DynamicVecBuffer;

  TKDT2DC_Source = packed record
    Buff: TKDT2DC_Vec;
    index: Int64;
  end;

  PKDT2DC_Source       = ^TKDT2DC_Source;
  TKDT2DC_SourceBuffer = array [0 .. 0] of PKDT2DC_Source;
  PKDT2DC_SourceBuffer = ^TKDT2DC_SourceBuffer;

  TKDT2DCyanmicSourceBuffer = array of PKDT2DC_Source;
  PKDT2DCyanmicSourceBuffer = ^TKDT2DCyanmicSourceBuffer;

  TKDT2DCyanmicStoreBuffer = array of TKDT2DC_Source;
  PKDT2DCyanmicStoreBuffer = ^TKDT2DCyanmicStoreBuffer;

  PKDT2DC_Node = ^TKDT2DC_Node;

  TKDT2DC_Node = packed record
    Parent, Right, Left: PKDT2DC_Node;
    vec: PKDT2DC_Source;
  end;

  TKDT2DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT2DC_Source);
  TKDT2DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT2DC_Source) of object;
  {$IFNDEF FPC}
  TKDT2DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT2DC_Source);
  {$ENDIF}

  TKDT2DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2DCyanmicStoreBuffer;
    KDBuff     : TKDT2DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT2DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT2DCyanmicStoreBuffer; const Buff: TKDT2DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT2DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DC_Node; overload;
    function Search(const Buff: TKDT2DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DC_Node; overload;
    function Search(const Buff: TKDT2DC_Vec; var SearchedDistanceMin: Double): PKDT2DC_Node; overload;
    function Search(const Buff: TKDT2DC_Vec): PKDT2DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2DC_DynamicVecBuffer; var OutBuff: TKDT2DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT2DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT2DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3DC_Vec = array [0 .. TKDT3DC_AxisCount - 1] of TKDT3DC_VecType;
  PKDT3DC_Vec = ^TKDT3DC_Vec;

  TKDT3DC_DynamicVecBuffer = array of TKDT3DC_Vec;
  PKDT3DC_DynamicVecBuffer = ^TKDT3DC_DynamicVecBuffer;

  TKDT3DC_Source = packed record
    Buff: TKDT3DC_Vec;
    index: Int64;
  end;

  PKDT3DC_Source       = ^TKDT3DC_Source;
  TKDT3DC_SourceBuffer = array [0 .. 0] of PKDT3DC_Source;
  PKDT3DC_SourceBuffer = ^TKDT3DC_SourceBuffer;

  TKDT3DCyanmicSourceBuffer = array of PKDT3DC_Source;
  PKDT3DCyanmicSourceBuffer = ^TKDT3DCyanmicSourceBuffer;

  TKDT3DCyanmicStoreBuffer = array of TKDT3DC_Source;
  PKDT3DCyanmicStoreBuffer = ^TKDT3DCyanmicStoreBuffer;

  PKDT3DC_Node = ^TKDT3DC_Node;

  TKDT3DC_Node = packed record
    Parent, Right, Left: PKDT3DC_Node;
    vec: PKDT3DC_Source;
  end;

  TKDT3DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3DC_Source);
  TKDT3DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3DC_Source) of object;
  {$IFNDEF FPC}
  TKDT3DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3DC_Source);
  {$ENDIF}

  TKDT3DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3DCyanmicStoreBuffer;
    KDBuff     : TKDT3DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3DCyanmicStoreBuffer; const Buff: TKDT3DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DC_Node; overload;
    function Search(const Buff: TKDT3DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DC_Node; overload;
    function Search(const Buff: TKDT3DC_Vec; var SearchedDistanceMin: Double): PKDT3DC_Node; overload;
    function Search(const Buff: TKDT3DC_Vec): PKDT3DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3DC_DynamicVecBuffer; var OutBuff: TKDT3DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT4DC_Vec = array [0 .. TKDT4DC_AxisCount - 1] of TKDT4DC_VecType;
  PKDT4DC_Vec = ^TKDT4DC_Vec;

  TKDT4DC_DynamicVecBuffer = array of TKDT4DC_Vec;
  PKDT4DC_DynamicVecBuffer = ^TKDT4DC_DynamicVecBuffer;

  TKDT4DC_Source = packed record
    Buff: TKDT4DC_Vec;
    index: Int64;
  end;

  PKDT4DC_Source       = ^TKDT4DC_Source;
  TKDT4DC_SourceBuffer = array [0 .. 0] of PKDT4DC_Source;
  PKDT4DC_SourceBuffer = ^TKDT4DC_SourceBuffer;

  TKDT4DCyanmicSourceBuffer = array of PKDT4DC_Source;
  PKDT4DCyanmicSourceBuffer = ^TKDT4DCyanmicSourceBuffer;

  TKDT4DCyanmicStoreBuffer = array of TKDT4DC_Source;
  PKDT4DCyanmicStoreBuffer = ^TKDT4DCyanmicStoreBuffer;

  PKDT4DC_Node = ^TKDT4DC_Node;

  TKDT4DC_Node = packed record
    Parent, Right, Left: PKDT4DC_Node;
    vec: PKDT4DC_Source;
  end;

  TKDT4DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT4DC_Source);
  TKDT4DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT4DC_Source) of object;
  {$IFNDEF FPC}
  TKDT4DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT4DC_Source);
  {$ENDIF}

  TKDT4DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT4DCyanmicStoreBuffer;
    KDBuff     : TKDT4DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT4DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT4DCyanmicStoreBuffer; const Buff: TKDT4DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT4DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT4DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DC_Node; overload;
    function Search(const Buff: TKDT4DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DC_Node; overload;
    function Search(const Buff: TKDT4DC_Vec; var SearchedDistanceMin: Double): PKDT4DC_Node; overload;
    function Search(const Buff: TKDT4DC_Vec): PKDT4DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4DC_DynamicVecBuffer; var OutBuff: TKDT4DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT4DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT4DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT6DC_Vec = array [0 .. TKDT6DC_AxisCount - 1] of TKDT6DC_VecType;
  PKDT6DC_Vec = ^TKDT6DC_Vec;

  TKDT6DC_DynamicVecBuffer = array of TKDT6DC_Vec;
  PKDT6DC_DynamicVecBuffer = ^TKDT6DC_DynamicVecBuffer;

  TKDT6DC_Source = packed record
    Buff: TKDT6DC_Vec;
    index: Int64;
  end;

  PKDT6DC_Source       = ^TKDT6DC_Source;
  TKDT6DC_SourceBuffer = array [0 .. 0] of PKDT6DC_Source;
  PKDT6DC_SourceBuffer = ^TKDT6DC_SourceBuffer;

  TKDT6DCyanmicSourceBuffer = array of PKDT6DC_Source;
  PKDT6DCyanmicSourceBuffer = ^TKDT6DCyanmicSourceBuffer;

  TKDT6DCyanmicStoreBuffer = array of TKDT6DC_Source;
  PKDT6DCyanmicStoreBuffer = ^TKDT6DCyanmicStoreBuffer;

  PKDT6DC_Node = ^TKDT6DC_Node;

  TKDT6DC_Node = packed record
    Parent, Right, Left: PKDT6DC_Node;
    vec: PKDT6DC_Source;
  end;

  TKDT6DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT6DC_Source);
  TKDT6DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT6DC_Source) of object;
  {$IFNDEF FPC}
  TKDT6DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT6DC_Source);
  {$ENDIF}

  TKDT6DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT6DCyanmicStoreBuffer;
    KDBuff     : TKDT6DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT6DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT6DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT6DCyanmicStoreBuffer; const Buff: TKDT6DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT6DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT6DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT6DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT6DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DC_Node; overload;
    function Search(const Buff: TKDT6DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DC_Node; overload;
    function Search(const Buff: TKDT6DC_Vec; var SearchedDistanceMin: Double): PKDT6DC_Node; overload;
    function Search(const Buff: TKDT6DC_Vec): PKDT6DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT6DC_DynamicVecBuffer; var OutBuff: TKDT6DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT6DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT6DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT8DC_Vec = array [0 .. TKDT8DC_AxisCount - 1] of TKDT8DC_VecType;
  PKDT8DC_Vec = ^TKDT8DC_Vec;

  TKDT8DC_DynamicVecBuffer = array of TKDT8DC_Vec;
  PKDT8DC_DynamicVecBuffer = ^TKDT8DC_DynamicVecBuffer;

  TKDT8DC_Source = packed record
    Buff: TKDT8DC_Vec;
    index: Int64;
  end;

  PKDT8DC_Source       = ^TKDT8DC_Source;
  TKDT8DC_SourceBuffer = array [0 .. 0] of PKDT8DC_Source;
  PKDT8DC_SourceBuffer = ^TKDT8DC_SourceBuffer;

  TKDT8DCyanmicSourceBuffer = array of PKDT8DC_Source;
  PKDT8DCyanmicSourceBuffer = ^TKDT8DCyanmicSourceBuffer;

  TKDT8DCyanmicStoreBuffer = array of TKDT8DC_Source;
  PKDT8DCyanmicStoreBuffer = ^TKDT8DCyanmicStoreBuffer;

  PKDT8DC_Node = ^TKDT8DC_Node;

  TKDT8DC_Node = packed record
    Parent, Right, Left: PKDT8DC_Node;
    vec: PKDT8DC_Source;
  end;

  TKDT8DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT8DC_Source);
  TKDT8DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT8DC_Source) of object;
  {$IFNDEF FPC}
  TKDT8DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT8DC_Source);
  {$ENDIF}

  TKDT8DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT8DCyanmicStoreBuffer;
    KDBuff     : TKDT8DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT8DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT8DCyanmicStoreBuffer; const Buff: TKDT8DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT8DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT8DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DC_Node; overload;
    function Search(const Buff: TKDT8DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DC_Node; overload;
    function Search(const Buff: TKDT8DC_Vec; var SearchedDistanceMin: Double): PKDT8DC_Node; overload;
    function Search(const Buff: TKDT8DC_Vec): PKDT8DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8DC_DynamicVecBuffer; var OutBuff: TKDT8DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT8DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT8DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT10DC_Vec = array [0 .. TKDT10DC_AxisCount - 1] of TKDT10DC_VecType;
  PKDT10DC_Vec = ^TKDT10DC_Vec;

  TKDT10DC_DynamicVecBuffer = array of TKDT10DC_Vec;
  PKDT10DC_DynamicVecBuffer = ^TKDT10DC_DynamicVecBuffer;

  TKDT10DC_Source = packed record
    Buff: TKDT10DC_Vec;
    index: Int64;
  end;

  PKDT10DC_Source       = ^TKDT10DC_Source;
  TKDT10DC_SourceBuffer = array [0 .. 0] of PKDT10DC_Source;
  PKDT10DC_SourceBuffer = ^TKDT10DC_SourceBuffer;

  TKDT10DCyanmicSourceBuffer = array of PKDT10DC_Source;
  PKDT10DCyanmicSourceBuffer = ^TKDT10DCyanmicSourceBuffer;

  TKDT10DCyanmicStoreBuffer = array of TKDT10DC_Source;
  PKDT10DCyanmicStoreBuffer = ^TKDT10DCyanmicStoreBuffer;

  PKDT10DC_Node = ^TKDT10DC_Node;

  TKDT10DC_Node = packed record
    Parent, Right, Left: PKDT10DC_Node;
    vec: PKDT10DC_Source;
  end;

  TKDT10DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT10DC_Source);
  TKDT10DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT10DC_Source) of object;
  {$IFNDEF FPC}
  TKDT10DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT10DC_Source);
  {$ENDIF}

  TKDT10DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT10DCyanmicStoreBuffer;
    KDBuff     : TKDT10DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT10DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT10DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT10DCyanmicStoreBuffer; const Buff: TKDT10DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT10DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT10DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT10DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT10DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DC_Node; overload;
    function Search(const Buff: TKDT10DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DC_Node; overload;
    function Search(const Buff: TKDT10DC_Vec; var SearchedDistanceMin: Double): PKDT10DC_Node; overload;
    function Search(const Buff: TKDT10DC_Vec): PKDT10DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT10DC_DynamicVecBuffer; var OutBuff: TKDT10DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT10DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT10DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT12DC_Vec = array [0 .. TKDT12DC_AxisCount - 1] of TKDT12DC_VecType;
  PKDT12DC_Vec = ^TKDT12DC_Vec;

  TKDT12DC_DynamicVecBuffer = array of TKDT12DC_Vec;
  PKDT12DC_DynamicVecBuffer = ^TKDT12DC_DynamicVecBuffer;

  TKDT12DC_Source = packed record
    Buff: TKDT12DC_Vec;
    index: Int64;
  end;

  PKDT12DC_Source       = ^TKDT12DC_Source;
  TKDT12DC_SourceBuffer = array [0 .. 0] of PKDT12DC_Source;
  PKDT12DC_SourceBuffer = ^TKDT12DC_SourceBuffer;

  TKDT12DCyanmicSourceBuffer = array of PKDT12DC_Source;
  PKDT12DCyanmicSourceBuffer = ^TKDT12DCyanmicSourceBuffer;

  TKDT12DCyanmicStoreBuffer = array of TKDT12DC_Source;
  PKDT12DCyanmicStoreBuffer = ^TKDT12DCyanmicStoreBuffer;

  PKDT12DC_Node = ^TKDT12DC_Node;

  TKDT12DC_Node = packed record
    Parent, Right, Left: PKDT12DC_Node;
    vec: PKDT12DC_Source;
  end;

  TKDT12DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT12DC_Source);
  TKDT12DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT12DC_Source) of object;
  {$IFNDEF FPC}
  TKDT12DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT12DC_Source);
  {$ENDIF}

  TKDT12DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT12DCyanmicStoreBuffer;
    KDBuff     : TKDT12DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT12DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT12DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT12DCyanmicStoreBuffer; const Buff: TKDT12DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT12DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT12DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT12DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT12DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DC_Node; overload;
    function Search(const Buff: TKDT12DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DC_Node; overload;
    function Search(const Buff: TKDT12DC_Vec; var SearchedDistanceMin: Double): PKDT12DC_Node; overload;
    function Search(const Buff: TKDT12DC_Vec): PKDT12DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT12DC_DynamicVecBuffer; var OutBuff: TKDT12DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT12DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT12DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT14DC_Vec = array [0 .. TKDT14DC_AxisCount - 1] of TKDT14DC_VecType;
  PKDT14DC_Vec = ^TKDT14DC_Vec;

  TKDT14DC_DynamicVecBuffer = array of TKDT14DC_Vec;
  PKDT14DC_DynamicVecBuffer = ^TKDT14DC_DynamicVecBuffer;

  TKDT14DC_Source = packed record
    Buff: TKDT14DC_Vec;
    index: Int64;
  end;

  PKDT14DC_Source       = ^TKDT14DC_Source;
  TKDT14DC_SourceBuffer = array [0 .. 0] of PKDT14DC_Source;
  PKDT14DC_SourceBuffer = ^TKDT14DC_SourceBuffer;

  TKDT14DCyanmicSourceBuffer = array of PKDT14DC_Source;
  PKDT14DCyanmicSourceBuffer = ^TKDT14DCyanmicSourceBuffer;

  TKDT14DCyanmicStoreBuffer = array of TKDT14DC_Source;
  PKDT14DCyanmicStoreBuffer = ^TKDT14DCyanmicStoreBuffer;

  PKDT14DC_Node = ^TKDT14DC_Node;

  TKDT14DC_Node = packed record
    Parent, Right, Left: PKDT14DC_Node;
    vec: PKDT14DC_Source;
  end;

  TKDT14DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT14DC_Source);
  TKDT14DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT14DC_Source) of object;
  {$IFNDEF FPC}
  TKDT14DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT14DC_Source);
  {$ENDIF}

  TKDT14DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT14DCyanmicStoreBuffer;
    KDBuff     : TKDT14DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT14DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT14DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT14DCyanmicStoreBuffer; const Buff: TKDT14DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT14DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT14DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT14DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT14DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DC_Node; overload;
    function Search(const Buff: TKDT14DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DC_Node; overload;
    function Search(const Buff: TKDT14DC_Vec; var SearchedDistanceMin: Double): PKDT14DC_Node; overload;
    function Search(const Buff: TKDT14DC_Vec): PKDT14DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT14DC_DynamicVecBuffer; var OutBuff: TKDT14DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT14DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT14DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT16DC_Vec = array [0 .. TKDT16DC_AxisCount - 1] of TKDT16DC_VecType;
  PKDT16DC_Vec = ^TKDT16DC_Vec;

  TKDT16DC_DynamicVecBuffer = array of TKDT16DC_Vec;
  PKDT16DC_DynamicVecBuffer = ^TKDT16DC_DynamicVecBuffer;

  TKDT16DC_Source = packed record
    Buff: TKDT16DC_Vec;
    index: Int64;
  end;

  PKDT16DC_Source       = ^TKDT16DC_Source;
  TKDT16DC_SourceBuffer = array [0 .. 0] of PKDT16DC_Source;
  PKDT16DC_SourceBuffer = ^TKDT16DC_SourceBuffer;

  TKDT16DCyanmicSourceBuffer = array of PKDT16DC_Source;
  PKDT16DCyanmicSourceBuffer = ^TKDT16DCyanmicSourceBuffer;

  TKDT16DCyanmicStoreBuffer = array of TKDT16DC_Source;
  PKDT16DCyanmicStoreBuffer = ^TKDT16DCyanmicStoreBuffer;

  PKDT16DC_Node = ^TKDT16DC_Node;

  TKDT16DC_Node = packed record
    Parent, Right, Left: PKDT16DC_Node;
    vec: PKDT16DC_Source;
  end;

  TKDT16DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT16DC_Source);
  TKDT16DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT16DC_Source) of object;
  {$IFNDEF FPC}
  TKDT16DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT16DC_Source);
  {$ENDIF}

  TKDT16DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT16DCyanmicStoreBuffer;
    KDBuff     : TKDT16DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT16DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT16DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT16DCyanmicStoreBuffer; const Buff: TKDT16DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT16DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT16DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT16DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT16DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DC_Node; overload;
    function Search(const Buff: TKDT16DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DC_Node; overload;
    function Search(const Buff: TKDT16DC_Vec; var SearchedDistanceMin: Double): PKDT16DC_Node; overload;
    function Search(const Buff: TKDT16DC_Vec): PKDT16DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT16DC_DynamicVecBuffer; var OutBuff: TKDT16DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT16DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT16DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT18DC_Vec = array [0 .. TKDT18DC_AxisCount - 1] of TKDT18DC_VecType;
  PKDT18DC_Vec = ^TKDT18DC_Vec;

  TKDT18DC_DynamicVecBuffer = array of TKDT18DC_Vec;
  PKDT18DC_DynamicVecBuffer = ^TKDT18DC_DynamicVecBuffer;

  TKDT18DC_Source = packed record
    Buff: TKDT18DC_Vec;
    index: Int64;
  end;

  PKDT18DC_Source       = ^TKDT18DC_Source;
  TKDT18DC_SourceBuffer = array [0 .. 0] of PKDT18DC_Source;
  PKDT18DC_SourceBuffer = ^TKDT18DC_SourceBuffer;

  TKDT18DCyanmicSourceBuffer = array of PKDT18DC_Source;
  PKDT18DCyanmicSourceBuffer = ^TKDT18DCyanmicSourceBuffer;

  TKDT18DCyanmicStoreBuffer = array of TKDT18DC_Source;
  PKDT18DCyanmicStoreBuffer = ^TKDT18DCyanmicStoreBuffer;

  PKDT18DC_Node = ^TKDT18DC_Node;

  TKDT18DC_Node = packed record
    Parent, Right, Left: PKDT18DC_Node;
    vec: PKDT18DC_Source;
  end;

  TKDT18DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT18DC_Source);
  TKDT18DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT18DC_Source) of object;
  {$IFNDEF FPC}
  TKDT18DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT18DC_Source);
  {$ENDIF}

  TKDT18DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT18DCyanmicStoreBuffer;
    KDBuff     : TKDT18DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT18DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT18DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT18DCyanmicStoreBuffer; const Buff: TKDT18DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT18DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT18DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT18DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT18DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DC_Node; overload;
    function Search(const Buff: TKDT18DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DC_Node; overload;
    function Search(const Buff: TKDT18DC_Vec; var SearchedDistanceMin: Double): PKDT18DC_Node; overload;
    function Search(const Buff: TKDT18DC_Vec): PKDT18DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT18DC_DynamicVecBuffer; var OutBuff: TKDT18DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT18DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT18DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT20DC_Vec = array [0 .. TKDT20DC_AxisCount - 1] of TKDT20DC_VecType;
  PKDT20DC_Vec = ^TKDT20DC_Vec;

  TKDT20DC_DynamicVecBuffer = array of TKDT20DC_Vec;
  PKDT20DC_DynamicVecBuffer = ^TKDT20DC_DynamicVecBuffer;

  TKDT20DC_Source = packed record
    Buff: TKDT20DC_Vec;
    index: Int64;
  end;

  PKDT20DC_Source       = ^TKDT20DC_Source;
  TKDT20DC_SourceBuffer = array [0 .. 0] of PKDT20DC_Source;
  PKDT20DC_SourceBuffer = ^TKDT20DC_SourceBuffer;

  TKDT20DCyanmicSourceBuffer = array of PKDT20DC_Source;
  PKDT20DCyanmicSourceBuffer = ^TKDT20DCyanmicSourceBuffer;

  TKDT20DCyanmicStoreBuffer = array of TKDT20DC_Source;
  PKDT20DCyanmicStoreBuffer = ^TKDT20DCyanmicStoreBuffer;

  PKDT20DC_Node = ^TKDT20DC_Node;

  TKDT20DC_Node = packed record
    Parent, Right, Left: PKDT20DC_Node;
    vec: PKDT20DC_Source;
  end;

  TKDT20DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT20DC_Source);
  TKDT20DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT20DC_Source) of object;
  {$IFNDEF FPC}
  TKDT20DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT20DC_Source);
  {$ENDIF}

  TKDT20DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT20DCyanmicStoreBuffer;
    KDBuff     : TKDT20DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT20DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT20DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT20DCyanmicStoreBuffer; const Buff: TKDT20DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT20DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT20DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT20DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT20DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DC_Node; overload;
    function Search(const Buff: TKDT20DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DC_Node; overload;
    function Search(const Buff: TKDT20DC_Vec; var SearchedDistanceMin: Double): PKDT20DC_Node; overload;
    function Search(const Buff: TKDT20DC_Vec): PKDT20DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT20DC_DynamicVecBuffer; var OutBuff: TKDT20DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT20DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT20DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT22DC_Vec = array [0 .. TKDT22DC_AxisCount - 1] of TKDT22DC_VecType;
  PKDT22DC_Vec = ^TKDT22DC_Vec;

  TKDT22DC_DynamicVecBuffer = array of TKDT22DC_Vec;
  PKDT22DC_DynamicVecBuffer = ^TKDT22DC_DynamicVecBuffer;

  TKDT22DC_Source = packed record
    Buff: TKDT22DC_Vec;
    index: Int64;
  end;

  PKDT22DC_Source       = ^TKDT22DC_Source;
  TKDT22DC_SourceBuffer = array [0 .. 0] of PKDT22DC_Source;
  PKDT22DC_SourceBuffer = ^TKDT22DC_SourceBuffer;

  TKDT22DCyanmicSourceBuffer = array of PKDT22DC_Source;
  PKDT22DCyanmicSourceBuffer = ^TKDT22DCyanmicSourceBuffer;

  TKDT22DCyanmicStoreBuffer = array of TKDT22DC_Source;
  PKDT22DCyanmicStoreBuffer = ^TKDT22DCyanmicStoreBuffer;

  PKDT22DC_Node = ^TKDT22DC_Node;

  TKDT22DC_Node = packed record
    Parent, Right, Left: PKDT22DC_Node;
    vec: PKDT22DC_Source;
  end;

  TKDT22DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT22DC_Source);
  TKDT22DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT22DC_Source) of object;
  {$IFNDEF FPC}
  TKDT22DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT22DC_Source);
  {$ENDIF}

  TKDT22DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT22DCyanmicStoreBuffer;
    KDBuff     : TKDT22DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT22DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT22DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT22DCyanmicStoreBuffer; const Buff: TKDT22DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT22DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT22DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT22DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT22DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DC_Node; overload;
    function Search(const Buff: TKDT22DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DC_Node; overload;
    function Search(const Buff: TKDT22DC_Vec; var SearchedDistanceMin: Double): PKDT22DC_Node; overload;
    function Search(const Buff: TKDT22DC_Vec): PKDT22DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT22DC_DynamicVecBuffer; var OutBuff: TKDT22DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT22DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT22DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT24DC_Vec = array [0 .. TKDT24DC_AxisCount - 1] of TKDT24DC_VecType;
  PKDT24DC_Vec = ^TKDT24DC_Vec;

  TKDT24DC_DynamicVecBuffer = array of TKDT24DC_Vec;
  PKDT24DC_DynamicVecBuffer = ^TKDT24DC_DynamicVecBuffer;

  TKDT24DC_Source = packed record
    Buff: TKDT24DC_Vec;
    index: Int64;
  end;

  PKDT24DC_Source       = ^TKDT24DC_Source;
  TKDT24DC_SourceBuffer = array [0 .. 0] of PKDT24DC_Source;
  PKDT24DC_SourceBuffer = ^TKDT24DC_SourceBuffer;

  TKDT24DCyanmicSourceBuffer = array of PKDT24DC_Source;
  PKDT24DCyanmicSourceBuffer = ^TKDT24DCyanmicSourceBuffer;

  TKDT24DCyanmicStoreBuffer = array of TKDT24DC_Source;
  PKDT24DCyanmicStoreBuffer = ^TKDT24DCyanmicStoreBuffer;

  PKDT24DC_Node = ^TKDT24DC_Node;

  TKDT24DC_Node = packed record
    Parent, Right, Left: PKDT24DC_Node;
    vec: PKDT24DC_Source;
  end;

  TKDT24DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT24DC_Source);
  TKDT24DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT24DC_Source) of object;
  {$IFNDEF FPC}
  TKDT24DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT24DC_Source);
  {$ENDIF}

  TKDT24DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT24DCyanmicStoreBuffer;
    KDBuff     : TKDT24DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT24DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT24DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT24DCyanmicStoreBuffer; const Buff: TKDT24DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT24DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT24DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT24DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT24DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DC_Node; overload;
    function Search(const Buff: TKDT24DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DC_Node; overload;
    function Search(const Buff: TKDT24DC_Vec; var SearchedDistanceMin: Double): PKDT24DC_Node; overload;
    function Search(const Buff: TKDT24DC_Vec): PKDT24DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT24DC_DynamicVecBuffer; var OutBuff: TKDT24DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT24DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT24DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT28DC_Vec = array [0 .. TKDT28DC_AxisCount - 1] of TKDT28DC_VecType;
  PKDT28DC_Vec = ^TKDT28DC_Vec;

  TKDT28DC_DynamicVecBuffer = array of TKDT28DC_Vec;
  PKDT28DC_DynamicVecBuffer = ^TKDT28DC_DynamicVecBuffer;

  TKDT28DC_Source = packed record
    Buff: TKDT28DC_Vec;
    index: Int64;
  end;

  PKDT28DC_Source       = ^TKDT28DC_Source;
  TKDT28DC_SourceBuffer = array [0 .. 0] of PKDT28DC_Source;
  PKDT28DC_SourceBuffer = ^TKDT28DC_SourceBuffer;

  TKDT28DCyanmicSourceBuffer = array of PKDT28DC_Source;
  PKDT28DCyanmicSourceBuffer = ^TKDT28DCyanmicSourceBuffer;

  TKDT28DCyanmicStoreBuffer = array of TKDT28DC_Source;
  PKDT28DCyanmicStoreBuffer = ^TKDT28DCyanmicStoreBuffer;

  PKDT28DC_Node = ^TKDT28DC_Node;

  TKDT28DC_Node = packed record
    Parent, Right, Left: PKDT28DC_Node;
    vec: PKDT28DC_Source;
  end;

  TKDT28DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT28DC_Source);
  TKDT28DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT28DC_Source) of object;
  {$IFNDEF FPC}
  TKDT28DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT28DC_Source);
  {$ENDIF}

  TKDT28DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT28DCyanmicStoreBuffer;
    KDBuff     : TKDT28DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT28DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT28DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT28DCyanmicStoreBuffer; const Buff: TKDT28DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT28DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT28DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT28DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT28DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT28DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DC_Node; overload;
    function Search(const Buff: TKDT28DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DC_Node; overload;
    function Search(const Buff: TKDT28DC_Vec; var SearchedDistanceMin: Double): PKDT28DC_Node; overload;
    function Search(const Buff: TKDT28DC_Vec): PKDT28DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT28DC_DynamicVecBuffer; var OutBuff: TKDT28DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT28DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT28DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT30DC_Vec = array [0 .. TKDT30DC_AxisCount - 1] of TKDT30DC_VecType;
  PKDT30DC_Vec = ^TKDT30DC_Vec;

  TKDT30DC_DynamicVecBuffer = array of TKDT30DC_Vec;
  PKDT30DC_DynamicVecBuffer = ^TKDT30DC_DynamicVecBuffer;

  TKDT30DC_Source = packed record
    Buff: TKDT30DC_Vec;
    index: Int64;
  end;

  PKDT30DC_Source       = ^TKDT30DC_Source;
  TKDT30DC_SourceBuffer = array [0 .. 0] of PKDT30DC_Source;
  PKDT30DC_SourceBuffer = ^TKDT30DC_SourceBuffer;

  TKDT30DCyanmicSourceBuffer = array of PKDT30DC_Source;
  PKDT30DCyanmicSourceBuffer = ^TKDT30DCyanmicSourceBuffer;

  TKDT30DCyanmicStoreBuffer = array of TKDT30DC_Source;
  PKDT30DCyanmicStoreBuffer = ^TKDT30DCyanmicStoreBuffer;

  PKDT30DC_Node = ^TKDT30DC_Node;

  TKDT30DC_Node = packed record
    Parent, Right, Left: PKDT30DC_Node;
    vec: PKDT30DC_Source;
  end;

  TKDT30DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT30DC_Source);
  TKDT30DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT30DC_Source) of object;
  {$IFNDEF FPC}
  TKDT30DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT30DC_Source);
  {$ENDIF}

  TKDT30DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT30DCyanmicStoreBuffer;
    KDBuff     : TKDT30DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT30DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT30DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT30DCyanmicStoreBuffer; const Buff: TKDT30DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT30DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT30DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT30DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT30DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT30DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DC_Node; overload;
    function Search(const Buff: TKDT30DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DC_Node; overload;
    function Search(const Buff: TKDT30DC_Vec; var SearchedDistanceMin: Double): PKDT30DC_Node; overload;
    function Search(const Buff: TKDT30DC_Vec): PKDT30DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT30DC_DynamicVecBuffer; var OutBuff: TKDT30DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT30DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT30DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT32DC_Vec = array [0 .. TKDT32DC_AxisCount - 1] of TKDT32DC_VecType;
  PKDT32DC_Vec = ^TKDT32DC_Vec;

  TKDT32DC_DynamicVecBuffer = array of TKDT32DC_Vec;
  PKDT32DC_DynamicVecBuffer = ^TKDT32DC_DynamicVecBuffer;

  TKDT32DC_Source = packed record
    Buff: TKDT32DC_Vec;
    index: Int64;
  end;

  PKDT32DC_Source       = ^TKDT32DC_Source;
  TKDT32DC_SourceBuffer = array [0 .. 0] of PKDT32DC_Source;
  PKDT32DC_SourceBuffer = ^TKDT32DC_SourceBuffer;

  TKDT32DCyanmicSourceBuffer = array of PKDT32DC_Source;
  PKDT32DCyanmicSourceBuffer = ^TKDT32DCyanmicSourceBuffer;

  TKDT32DCyanmicStoreBuffer = array of TKDT32DC_Source;
  PKDT32DCyanmicStoreBuffer = ^TKDT32DCyanmicStoreBuffer;

  PKDT32DC_Node = ^TKDT32DC_Node;

  TKDT32DC_Node = packed record
    Parent, Right, Left: PKDT32DC_Node;
    vec: PKDT32DC_Source;
  end;

  TKDT32DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT32DC_Source);
  TKDT32DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT32DC_Source) of object;
  {$IFNDEF FPC}
  TKDT32DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT32DC_Source);
  {$ENDIF}

  TKDT32DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT32DCyanmicStoreBuffer;
    KDBuff     : TKDT32DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT32DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT32DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT32DCyanmicStoreBuffer; const Buff: TKDT32DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT32DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT32DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT32DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT32DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT32DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DC_Node; overload;
    function Search(const Buff: TKDT32DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DC_Node; overload;
    function Search(const Buff: TKDT32DC_Vec; var SearchedDistanceMin: Double): PKDT32DC_Node; overload;
    function Search(const Buff: TKDT32DC_Vec): PKDT32DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT32DC_DynamicVecBuffer; var OutBuff: TKDT32DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT32DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT32DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT34DC_Vec = array [0 .. TKDT34DC_AxisCount - 1] of TKDT34DC_VecType;
  PKDT34DC_Vec = ^TKDT34DC_Vec;

  TKDT34DC_DynamicVecBuffer = array of TKDT34DC_Vec;
  PKDT34DC_DynamicVecBuffer = ^TKDT34DC_DynamicVecBuffer;

  TKDT34DC_Source = packed record
    Buff: TKDT34DC_Vec;
    index: Int64;
  end;

  PKDT34DC_Source       = ^TKDT34DC_Source;
  TKDT34DC_SourceBuffer = array [0 .. 0] of PKDT34DC_Source;
  PKDT34DC_SourceBuffer = ^TKDT34DC_SourceBuffer;

  TKDT34DCyanmicSourceBuffer = array of PKDT34DC_Source;
  PKDT34DCyanmicSourceBuffer = ^TKDT34DCyanmicSourceBuffer;

  TKDT34DCyanmicStoreBuffer = array of TKDT34DC_Source;
  PKDT34DCyanmicStoreBuffer = ^TKDT34DCyanmicStoreBuffer;

  PKDT34DC_Node = ^TKDT34DC_Node;

  TKDT34DC_Node = packed record
    Parent, Right, Left: PKDT34DC_Node;
    vec: PKDT34DC_Source;
  end;

  TKDT34DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT34DC_Source);
  TKDT34DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT34DC_Source) of object;
  {$IFNDEF FPC}
  TKDT34DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT34DC_Source);
  {$ENDIF}

  TKDT34DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT34DCyanmicStoreBuffer;
    KDBuff     : TKDT34DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT34DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT34DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT34DCyanmicStoreBuffer; const Buff: TKDT34DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT34DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT34DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT34DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT34DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT34DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DC_Node; overload;
    function Search(const Buff: TKDT34DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DC_Node; overload;
    function Search(const Buff: TKDT34DC_Vec; var SearchedDistanceMin: Double): PKDT34DC_Node; overload;
    function Search(const Buff: TKDT34DC_Vec): PKDT34DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT34DC_DynamicVecBuffer; var OutBuff: TKDT34DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT34DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT34DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT36DC_Vec = array [0 .. TKDT36DC_AxisCount - 1] of TKDT36DC_VecType;
  PKDT36DC_Vec = ^TKDT36DC_Vec;

  TKDT36DC_DynamicVecBuffer = array of TKDT36DC_Vec;
  PKDT36DC_DynamicVecBuffer = ^TKDT36DC_DynamicVecBuffer;

  TKDT36DC_Source = packed record
    Buff: TKDT36DC_Vec;
    index: Int64;
  end;

  PKDT36DC_Source       = ^TKDT36DC_Source;
  TKDT36DC_SourceBuffer = array [0 .. 0] of PKDT36DC_Source;
  PKDT36DC_SourceBuffer = ^TKDT36DC_SourceBuffer;

  TKDT36DCyanmicSourceBuffer = array of PKDT36DC_Source;
  PKDT36DCyanmicSourceBuffer = ^TKDT36DCyanmicSourceBuffer;

  TKDT36DCyanmicStoreBuffer = array of TKDT36DC_Source;
  PKDT36DCyanmicStoreBuffer = ^TKDT36DCyanmicStoreBuffer;

  PKDT36DC_Node = ^TKDT36DC_Node;

  TKDT36DC_Node = packed record
    Parent, Right, Left: PKDT36DC_Node;
    vec: PKDT36DC_Source;
  end;

  TKDT36DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT36DC_Source);
  TKDT36DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT36DC_Source) of object;
  {$IFNDEF FPC}
  TKDT36DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT36DC_Source);
  {$ENDIF}

  TKDT36DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT36DCyanmicStoreBuffer;
    KDBuff     : TKDT36DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT36DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT36DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT36DCyanmicStoreBuffer; const Buff: TKDT36DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT36DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT36DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT36DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT36DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT36DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DC_Node; overload;
    function Search(const Buff: TKDT36DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DC_Node; overload;
    function Search(const Buff: TKDT36DC_Vec; var SearchedDistanceMin: Double): PKDT36DC_Node; overload;
    function Search(const Buff: TKDT36DC_Vec): PKDT36DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT36DC_DynamicVecBuffer; var OutBuff: TKDT36DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT36DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT36DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT40DC_Vec = array [0 .. TKDT40DC_AxisCount - 1] of TKDT40DC_VecType;
  PKDT40DC_Vec = ^TKDT40DC_Vec;

  TKDT40DC_DynamicVecBuffer = array of TKDT40DC_Vec;
  PKDT40DC_DynamicVecBuffer = ^TKDT40DC_DynamicVecBuffer;

  TKDT40DC_Source = packed record
    Buff: TKDT40DC_Vec;
    index: Int64;
  end;

  PKDT40DC_Source       = ^TKDT40DC_Source;
  TKDT40DC_SourceBuffer = array [0 .. 0] of PKDT40DC_Source;
  PKDT40DC_SourceBuffer = ^TKDT40DC_SourceBuffer;

  TKDT40DCyanmicSourceBuffer = array of PKDT40DC_Source;
  PKDT40DCyanmicSourceBuffer = ^TKDT40DCyanmicSourceBuffer;

  TKDT40DCyanmicStoreBuffer = array of TKDT40DC_Source;
  PKDT40DCyanmicStoreBuffer = ^TKDT40DCyanmicStoreBuffer;

  PKDT40DC_Node = ^TKDT40DC_Node;

  TKDT40DC_Node = packed record
    Parent, Right, Left: PKDT40DC_Node;
    vec: PKDT40DC_Source;
  end;

  TKDT40DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT40DC_Source);
  TKDT40DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT40DC_Source) of object;
  {$IFNDEF FPC}
  TKDT40DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT40DC_Source);
  {$ENDIF}

  TKDT40DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT40DCyanmicStoreBuffer;
    KDBuff     : TKDT40DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT40DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT40DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT40DCyanmicStoreBuffer; const Buff: TKDT40DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT40DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT40DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT40DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT40DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT40DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DC_Node; overload;
    function Search(const Buff: TKDT40DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DC_Node; overload;
    function Search(const Buff: TKDT40DC_Vec; var SearchedDistanceMin: Double): PKDT40DC_Node; overload;
    function Search(const Buff: TKDT40DC_Vec): PKDT40DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT40DC_DynamicVecBuffer; var OutBuff: TKDT40DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT40DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT40DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT48DC_Vec = array [0 .. TKDT48DC_AxisCount - 1] of TKDT48DC_VecType;
  PKDT48DC_Vec = ^TKDT48DC_Vec;

  TKDT48DC_DynamicVecBuffer = array of TKDT48DC_Vec;
  PKDT48DC_DynamicVecBuffer = ^TKDT48DC_DynamicVecBuffer;

  TKDT48DC_Source = packed record
    Buff: TKDT48DC_Vec;
    index: Int64;
  end;

  PKDT48DC_Source       = ^TKDT48DC_Source;
  TKDT48DC_SourceBuffer = array [0 .. 0] of PKDT48DC_Source;
  PKDT48DC_SourceBuffer = ^TKDT48DC_SourceBuffer;

  TKDT48DCyanmicSourceBuffer = array of PKDT48DC_Source;
  PKDT48DCyanmicSourceBuffer = ^TKDT48DCyanmicSourceBuffer;

  TKDT48DCyanmicStoreBuffer = array of TKDT48DC_Source;
  PKDT48DCyanmicStoreBuffer = ^TKDT48DCyanmicStoreBuffer;

  PKDT48DC_Node = ^TKDT48DC_Node;

  TKDT48DC_Node = packed record
    Parent, Right, Left: PKDT48DC_Node;
    vec: PKDT48DC_Source;
  end;

  TKDT48DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT48DC_Source);
  TKDT48DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT48DC_Source) of object;
  {$IFNDEF FPC}
  TKDT48DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT48DC_Source);
  {$ENDIF}

  TKDT48DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT48DCyanmicStoreBuffer;
    KDBuff     : TKDT48DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT48DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT48DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT48DCyanmicStoreBuffer; const Buff: TKDT48DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT48DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT48DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT48DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT48DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DC_Node; overload;
    function Search(const Buff: TKDT48DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DC_Node; overload;
    function Search(const Buff: TKDT48DC_Vec; var SearchedDistanceMin: Double): PKDT48DC_Node; overload;
    function Search(const Buff: TKDT48DC_Vec): PKDT48DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT48DC_DynamicVecBuffer; var OutBuff: TKDT48DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT48DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT48DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT64DC_Vec = array [0 .. TKDT64DC_AxisCount - 1] of TKDT64DC_VecType;
  PKDT64DC_Vec = ^TKDT64DC_Vec;

  TKDT64DC_DynamicVecBuffer = array of TKDT64DC_Vec;
  PKDT64DC_DynamicVecBuffer = ^TKDT64DC_DynamicVecBuffer;

  TKDT64DC_Source = packed record
    Buff: TKDT64DC_Vec;
    index: Int64;
  end;

  PKDT64DC_Source       = ^TKDT64DC_Source;
  TKDT64DC_SourceBuffer = array [0 .. 0] of PKDT64DC_Source;
  PKDT64DC_SourceBuffer = ^TKDT64DC_SourceBuffer;

  TKDT64DCyanmicSourceBuffer = array of PKDT64DC_Source;
  PKDT64DCyanmicSourceBuffer = ^TKDT64DCyanmicSourceBuffer;

  TKDT64DCyanmicStoreBuffer = array of TKDT64DC_Source;
  PKDT64DCyanmicStoreBuffer = ^TKDT64DCyanmicStoreBuffer;

  PKDT64DC_Node = ^TKDT64DC_Node;

  TKDT64DC_Node = packed record
    Parent, Right, Left: PKDT64DC_Node;
    vec: PKDT64DC_Source;
  end;

  TKDT64DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT64DC_Source);
  TKDT64DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT64DC_Source) of object;
  {$IFNDEF FPC}
  TKDT64DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT64DC_Source);
  {$ENDIF}

  TKDT64DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT64DCyanmicStoreBuffer;
    KDBuff     : TKDT64DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT64DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT64DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT64DCyanmicStoreBuffer; const Buff: TKDT64DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT64DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT64DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT64DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT64DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DC_Node; overload;
    function Search(const Buff: TKDT64DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DC_Node; overload;
    function Search(const Buff: TKDT64DC_Vec; var SearchedDistanceMin: Double): PKDT64DC_Node; overload;
    function Search(const Buff: TKDT64DC_Vec): PKDT64DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT64DC_DynamicVecBuffer; var OutBuff: TKDT64DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT64DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT64DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT96DC_Vec = array [0 .. TKDT96DC_AxisCount - 1] of TKDT96DC_VecType;
  PKDT96DC_Vec = ^TKDT96DC_Vec;

  TKDT96DC_DynamicVecBuffer = array of TKDT96DC_Vec;
  PKDT96DC_DynamicVecBuffer = ^TKDT96DC_DynamicVecBuffer;

  TKDT96DC_Source = packed record
    Buff: TKDT96DC_Vec;
    index: Int64;
  end;

  PKDT96DC_Source       = ^TKDT96DC_Source;
  TKDT96DC_SourceBuffer = array [0 .. 0] of PKDT96DC_Source;
  PKDT96DC_SourceBuffer = ^TKDT96DC_SourceBuffer;

  TKDT96DCyanmicSourceBuffer = array of PKDT96DC_Source;
  PKDT96DCyanmicSourceBuffer = ^TKDT96DCyanmicSourceBuffer;

  TKDT96DCyanmicStoreBuffer = array of TKDT96DC_Source;
  PKDT96DCyanmicStoreBuffer = ^TKDT96DCyanmicStoreBuffer;

  PKDT96DC_Node = ^TKDT96DC_Node;

  TKDT96DC_Node = packed record
    Parent, Right, Left: PKDT96DC_Node;
    vec: PKDT96DC_Source;
  end;

  TKDT96DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT96DC_Source);
  TKDT96DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT96DC_Source) of object;
  {$IFNDEF FPC}
  TKDT96DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT96DC_Source);
  {$ENDIF}

  TKDT96DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT96DCyanmicStoreBuffer;
    KDBuff     : TKDT96DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT96DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT96DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT96DCyanmicStoreBuffer; const Buff: TKDT96DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT96DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT96DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT96DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT96DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DC_Node; overload;
    function Search(const Buff: TKDT96DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DC_Node; overload;
    function Search(const Buff: TKDT96DC_Vec; var SearchedDistanceMin: Double): PKDT96DC_Node; overload;
    function Search(const Buff: TKDT96DC_Vec): PKDT96DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT96DC_DynamicVecBuffer; var OutBuff: TKDT96DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT96DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT96DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT128DC_Vec = array [0 .. TKDT128DC_AxisCount - 1] of TKDT128DC_VecType;
  PKDT128DC_Vec = ^TKDT128DC_Vec;

  TKDT128DC_DynamicVecBuffer = array of TKDT128DC_Vec;
  PKDT128DC_DynamicVecBuffer = ^TKDT128DC_DynamicVecBuffer;

  TKDT128DC_Source = packed record
    Buff: TKDT128DC_Vec;
    index: Int64;
  end;

  PKDT128DC_Source       = ^TKDT128DC_Source;
  TKDT128DC_SourceBuffer = array [0 .. 0] of PKDT128DC_Source;
  PKDT128DC_SourceBuffer = ^TKDT128DC_SourceBuffer;

  TKDT128DCyanmicSourceBuffer = array of PKDT128DC_Source;
  PKDT128DCyanmicSourceBuffer = ^TKDT128DCyanmicSourceBuffer;

  TKDT128DCyanmicStoreBuffer = array of TKDT128DC_Source;
  PKDT128DCyanmicStoreBuffer = ^TKDT128DCyanmicStoreBuffer;

  PKDT128DC_Node = ^TKDT128DC_Node;

  TKDT128DC_Node = packed record
    Parent, Right, Left: PKDT128DC_Node;
    vec: PKDT128DC_Source;
  end;

  TKDT128DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT128DC_Source);
  TKDT128DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT128DC_Source) of object;
  {$IFNDEF FPC}
  TKDT128DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT128DC_Source);
  {$ENDIF}

  TKDT128DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT128DCyanmicStoreBuffer;
    KDBuff     : TKDT128DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT128DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT128DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT128DCyanmicStoreBuffer; const Buff: TKDT128DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT128DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT128DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT128DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT128DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DC_Node; overload;
    function Search(const Buff: TKDT128DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DC_Node; overload;
    function Search(const Buff: TKDT128DC_Vec; var SearchedDistanceMin: Double): PKDT128DC_Node; overload;
    function Search(const Buff: TKDT128DC_Vec): PKDT128DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT128DC_DynamicVecBuffer; var OutBuff: TKDT128DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT128DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT128DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT256DC_Vec = array [0 .. TKDT256DC_AxisCount - 1] of TKDT256DC_VecType;
  PKDT256DC_Vec = ^TKDT256DC_Vec;

  TKDT256DC_DynamicVecBuffer = array of TKDT256DC_Vec;
  PKDT256DC_DynamicVecBuffer = ^TKDT256DC_DynamicVecBuffer;

  TKDT256DC_Source = packed record
    Buff: TKDT256DC_Vec;
    index: Int64;
  end;

  PKDT256DC_Source       = ^TKDT256DC_Source;
  TKDT256DC_SourceBuffer = array [0 .. 0] of PKDT256DC_Source;
  PKDT256DC_SourceBuffer = ^TKDT256DC_SourceBuffer;

  TKDT256DCyanmicSourceBuffer = array of PKDT256DC_Source;
  PKDT256DCyanmicSourceBuffer = ^TKDT256DCyanmicSourceBuffer;

  TKDT256DCyanmicStoreBuffer = array of TKDT256DC_Source;
  PKDT256DCyanmicStoreBuffer = ^TKDT256DCyanmicStoreBuffer;

  PKDT256DC_Node = ^TKDT256DC_Node;

  TKDT256DC_Node = packed record
    Parent, Right, Left: PKDT256DC_Node;
    vec: PKDT256DC_Source;
  end;

  TKDT256DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT256DC_Source);
  TKDT256DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT256DC_Source) of object;
  {$IFNDEF FPC}
  TKDT256DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT256DC_Source);
  {$ENDIF}

  TKDT256DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT256DCyanmicStoreBuffer;
    KDBuff     : TKDT256DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT256DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT256DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT256DCyanmicStoreBuffer; const Buff: TKDT256DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT256DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT256DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT256DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT256DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DC_Node; overload;
    function Search(const Buff: TKDT256DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DC_Node; overload;
    function Search(const Buff: TKDT256DC_Vec; var SearchedDistanceMin: Double): PKDT256DC_Node; overload;
    function Search(const Buff: TKDT256DC_Vec): PKDT256DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT256DC_DynamicVecBuffer; var OutBuff: TKDT256DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT256DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT256DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT372DC_Vec = array [0 .. TKDT372DC_AxisCount - 1] of TKDT372DC_VecType;
  PKDT372DC_Vec = ^TKDT372DC_Vec;

  TKDT372DC_DynamicVecBuffer = array of TKDT372DC_Vec;
  PKDT372DC_DynamicVecBuffer = ^TKDT372DC_DynamicVecBuffer;

  TKDT372DC_Source = packed record
    Buff: TKDT372DC_Vec;
    index: Int64;
  end;

  PKDT372DC_Source       = ^TKDT372DC_Source;
  TKDT372DC_SourceBuffer = array [0 .. 0] of PKDT372DC_Source;
  PKDT372DC_SourceBuffer = ^TKDT372DC_SourceBuffer;

  TKDT372DCyanmicSourceBuffer = array of PKDT372DC_Source;
  PKDT372DCyanmicSourceBuffer = ^TKDT372DCyanmicSourceBuffer;

  TKDT372DCyanmicStoreBuffer = array of TKDT372DC_Source;
  PKDT372DCyanmicStoreBuffer = ^TKDT372DCyanmicStoreBuffer;

  PKDT372DC_Node = ^TKDT372DC_Node;

  TKDT372DC_Node = packed record
    Parent, Right, Left: PKDT372DC_Node;
    vec: PKDT372DC_Source;
  end;

  TKDT372DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT372DC_Source);
  TKDT372DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT372DC_Source) of object;
  {$IFNDEF FPC}
  TKDT372DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT372DC_Source);
  {$ENDIF}

  TKDT372DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT372DCyanmicStoreBuffer;
    KDBuff     : TKDT372DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT372DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT372DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT372DCyanmicStoreBuffer; const Buff: TKDT372DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT372DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT372DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT372DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT372DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT372DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DC_Node; overload;
    function Search(const Buff: TKDT372DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DC_Node; overload;
    function Search(const Buff: TKDT372DC_Vec; var SearchedDistanceMin: Double): PKDT372DC_Node; overload;
    function Search(const Buff: TKDT372DC_Vec): PKDT372DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT372DC_DynamicVecBuffer; var OutBuff: TKDT372DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT372DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT372DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT512DC_Vec = array [0 .. TKDT512DC_AxisCount - 1] of TKDT512DC_VecType;
  PKDT512DC_Vec = ^TKDT512DC_Vec;

  TKDT512DC_DynamicVecBuffer = array of TKDT512DC_Vec;
  PKDT512DC_DynamicVecBuffer = ^TKDT512DC_DynamicVecBuffer;

  TKDT512DC_Source = packed record
    Buff: TKDT512DC_Vec;
    index: Int64;
  end;

  PKDT512DC_Source       = ^TKDT512DC_Source;
  TKDT512DC_SourceBuffer = array [0 .. 0] of PKDT512DC_Source;
  PKDT512DC_SourceBuffer = ^TKDT512DC_SourceBuffer;

  TKDT512DCyanmicSourceBuffer = array of PKDT512DC_Source;
  PKDT512DCyanmicSourceBuffer = ^TKDT512DCyanmicSourceBuffer;

  TKDT512DCyanmicStoreBuffer = array of TKDT512DC_Source;
  PKDT512DCyanmicStoreBuffer = ^TKDT512DCyanmicStoreBuffer;

  PKDT512DC_Node = ^TKDT512DC_Node;

  TKDT512DC_Node = packed record
    Parent, Right, Left: PKDT512DC_Node;
    vec: PKDT512DC_Source;
  end;

  TKDT512DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT512DC_Source);
  TKDT512DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT512DC_Source) of object;
  {$IFNDEF FPC}
  TKDT512DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT512DC_Source);
  {$ENDIF}

  TKDT512DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT512DCyanmicStoreBuffer;
    KDBuff     : TKDT512DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT512DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT512DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT512DCyanmicStoreBuffer; const Buff: TKDT512DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT512DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT512DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT512DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT512DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DC_Node; overload;
    function Search(const Buff: TKDT512DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DC_Node; overload;
    function Search(const Buff: TKDT512DC_Vec; var SearchedDistanceMin: Double): PKDT512DC_Node; overload;
    function Search(const Buff: TKDT512DC_Vec): PKDT512DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT512DC_DynamicVecBuffer; var OutBuff: TKDT512DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT512DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT512DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT640DC_Vec = array [0 .. TKDT640DC_AxisCount - 1] of TKDT640DC_VecType;
  PKDT640DC_Vec = ^TKDT640DC_Vec;

  TKDT640DC_DynamicVecBuffer = array of TKDT640DC_Vec;
  PKDT640DC_DynamicVecBuffer = ^TKDT640DC_DynamicVecBuffer;

  TKDT640DC_Source = packed record
    Buff: TKDT640DC_Vec;
    index: Int64;
  end;

  PKDT640DC_Source       = ^TKDT640DC_Source;
  TKDT640DC_SourceBuffer = array [0 .. 0] of PKDT640DC_Source;
  PKDT640DC_SourceBuffer = ^TKDT640DC_SourceBuffer;

  TKDT640DCyanmicSourceBuffer = array of PKDT640DC_Source;
  PKDT640DCyanmicSourceBuffer = ^TKDT640DCyanmicSourceBuffer;

  TKDT640DCyanmicStoreBuffer = array of TKDT640DC_Source;
  PKDT640DCyanmicStoreBuffer = ^TKDT640DCyanmicStoreBuffer;

  PKDT640DC_Node = ^TKDT640DC_Node;

  TKDT640DC_Node = packed record
    Parent, Right, Left: PKDT640DC_Node;
    vec: PKDT640DC_Source;
  end;

  TKDT640DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT640DC_Source);
  TKDT640DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT640DC_Source) of object;
  {$IFNDEF FPC}
  TKDT640DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT640DC_Source);
  {$ENDIF}

  TKDT640DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT640DCyanmicStoreBuffer;
    KDBuff     : TKDT640DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT640DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT640DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT640DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT640DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT640DCyanmicStoreBuffer; const Buff: TKDT640DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT640DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT640DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT640DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT640DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT640DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT640DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT640DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT640DC_Node; overload;
    function Search(const Buff: TKDT640DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT640DC_Node; overload;
    function Search(const Buff: TKDT640DC_Vec; var SearchedDistanceMin: Double): PKDT640DC_Node; overload;
    function Search(const Buff: TKDT640DC_Vec): PKDT640DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT640DC_DynamicVecBuffer; var OutBuff: TKDT640DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT640DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT640DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT768DC_Vec = array [0 .. TKDT768DC_AxisCount - 1] of TKDT768DC_VecType;
  PKDT768DC_Vec = ^TKDT768DC_Vec;

  TKDT768DC_DynamicVecBuffer = array of TKDT768DC_Vec;
  PKDT768DC_DynamicVecBuffer = ^TKDT768DC_DynamicVecBuffer;

  TKDT768DC_Source = packed record
    Buff: TKDT768DC_Vec;
    index: Int64;
  end;

  PKDT768DC_Source       = ^TKDT768DC_Source;
  TKDT768DC_SourceBuffer = array [0 .. 0] of PKDT768DC_Source;
  PKDT768DC_SourceBuffer = ^TKDT768DC_SourceBuffer;

  TKDT768DCyanmicSourceBuffer = array of PKDT768DC_Source;
  PKDT768DCyanmicSourceBuffer = ^TKDT768DCyanmicSourceBuffer;

  TKDT768DCyanmicStoreBuffer = array of TKDT768DC_Source;
  PKDT768DCyanmicStoreBuffer = ^TKDT768DCyanmicStoreBuffer;

  PKDT768DC_Node = ^TKDT768DC_Node;

  TKDT768DC_Node = packed record
    Parent, Right, Left: PKDT768DC_Node;
    vec: PKDT768DC_Source;
  end;

  TKDT768DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT768DC_Source);
  TKDT768DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT768DC_Source) of object;
  {$IFNDEF FPC}
  TKDT768DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT768DC_Source);
  {$ENDIF}

  TKDT768DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT768DCyanmicStoreBuffer;
    KDBuff     : TKDT768DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT768DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT768DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT768DCyanmicStoreBuffer; const Buff: TKDT768DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT768DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT768DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT768DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT768DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT768DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DC_Node; overload;
    function Search(const Buff: TKDT768DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DC_Node; overload;
    function Search(const Buff: TKDT768DC_Vec; var SearchedDistanceMin: Double): PKDT768DC_Node; overload;
    function Search(const Buff: TKDT768DC_Vec): PKDT768DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT768DC_DynamicVecBuffer; var OutBuff: TKDT768DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT768DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT768DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1024DC_Vec = array [0 .. TKDT1024DC_AxisCount - 1] of TKDT1024DC_VecType;
  PKDT1024DC_Vec = ^TKDT1024DC_Vec;

  TKDT1024DC_DynamicVecBuffer = array of TKDT1024DC_Vec;
  PKDT1024DC_DynamicVecBuffer = ^TKDT1024DC_DynamicVecBuffer;

  TKDT1024DC_Source = packed record
    Buff: TKDT1024DC_Vec;
    index: Int64;
  end;

  PKDT1024DC_Source       = ^TKDT1024DC_Source;
  TKDT1024DC_SourceBuffer = array [0 .. 0] of PKDT1024DC_Source;
  PKDT1024DC_SourceBuffer = ^TKDT1024DC_SourceBuffer;

  TKDT1024DCyanmicSourceBuffer = array of PKDT1024DC_Source;
  PKDT1024DCyanmicSourceBuffer = ^TKDT1024DCyanmicSourceBuffer;

  TKDT1024DCyanmicStoreBuffer = array of TKDT1024DC_Source;
  PKDT1024DCyanmicStoreBuffer = ^TKDT1024DCyanmicStoreBuffer;

  PKDT1024DC_Node = ^TKDT1024DC_Node;

  TKDT1024DC_Node = packed record
    Parent, Right, Left: PKDT1024DC_Node;
    vec: PKDT1024DC_Source;
  end;

  TKDT1024DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1024DC_Source);
  TKDT1024DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1024DC_Source) of object;
  {$IFNDEF FPC}
  TKDT1024DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1024DC_Source);
  {$ENDIF}

  TKDT1024DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1024DCyanmicStoreBuffer;
    KDBuff     : TKDT1024DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1024DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1024DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1024DCyanmicStoreBuffer; const Buff: TKDT1024DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1024DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1024DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1024DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DC_Node; overload;
    function Search(const Buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DC_Node; overload;
    function Search(const Buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double): PKDT1024DC_Node; overload;
    function Search(const Buff: TKDT1024DC_Vec): PKDT1024DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1024DC_DynamicVecBuffer; var OutBuff: TKDT1024DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1024DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1024DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1080DC_Vec = array [0 .. TKDT1080DC_AxisCount - 1] of TKDT1080DC_VecType;
  PKDT1080DC_Vec = ^TKDT1080DC_Vec;

  TKDT1080DC_DynamicVecBuffer = array of TKDT1080DC_Vec;
  PKDT1080DC_DynamicVecBuffer = ^TKDT1080DC_DynamicVecBuffer;

  TKDT1080DC_Source = packed record
    Buff: TKDT1080DC_Vec;
    index: Int64;
  end;

  PKDT1080DC_Source       = ^TKDT1080DC_Source;
  TKDT1080DC_SourceBuffer = array [0 .. 0] of PKDT1080DC_Source;
  PKDT1080DC_SourceBuffer = ^TKDT1080DC_SourceBuffer;

  TKDT1080DCyanmicSourceBuffer = array of PKDT1080DC_Source;
  PKDT1080DCyanmicSourceBuffer = ^TKDT1080DCyanmicSourceBuffer;

  TKDT1080DCyanmicStoreBuffer = array of TKDT1080DC_Source;
  PKDT1080DCyanmicStoreBuffer = ^TKDT1080DCyanmicStoreBuffer;

  PKDT1080DC_Node = ^TKDT1080DC_Node;

  TKDT1080DC_Node = packed record
    Parent, Right, Left: PKDT1080DC_Node;
    vec: PKDT1080DC_Source;
  end;

  TKDT1080DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1080DC_Source);
  TKDT1080DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1080DC_Source) of object;
  {$IFNDEF FPC}
  TKDT1080DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1080DC_Source);
  {$ENDIF}

  TKDT1080DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1080DCyanmicStoreBuffer;
    KDBuff     : TKDT1080DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1080DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1080DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1080DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1080DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1080DCyanmicStoreBuffer; const Buff: TKDT1080DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1080DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1080DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1080DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1080DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1080DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1080DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1080DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1080DC_Node; overload;
    function Search(const Buff: TKDT1080DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1080DC_Node; overload;
    function Search(const Buff: TKDT1080DC_Vec; var SearchedDistanceMin: Double): PKDT1080DC_Node; overload;
    function Search(const Buff: TKDT1080DC_Vec): PKDT1080DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1080DC_DynamicVecBuffer; var OutBuff: TKDT1080DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1080DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1080DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1536DC_Vec = array [0 .. TKDT1536DC_AxisCount - 1] of TKDT1536DC_VecType;
  PKDT1536DC_Vec = ^TKDT1536DC_Vec;

  TKDT1536DC_DynamicVecBuffer = array of TKDT1536DC_Vec;
  PKDT1536DC_DynamicVecBuffer = ^TKDT1536DC_DynamicVecBuffer;

  TKDT1536DC_Source = packed record
    Buff: TKDT1536DC_Vec;
    index: Int64;
  end;

  PKDT1536DC_Source       = ^TKDT1536DC_Source;
  TKDT1536DC_SourceBuffer = array [0 .. 0] of PKDT1536DC_Source;
  PKDT1536DC_SourceBuffer = ^TKDT1536DC_SourceBuffer;

  TKDT1536DCyanmicSourceBuffer = array of PKDT1536DC_Source;
  PKDT1536DCyanmicSourceBuffer = ^TKDT1536DCyanmicSourceBuffer;

  TKDT1536DCyanmicStoreBuffer = array of TKDT1536DC_Source;
  PKDT1536DCyanmicStoreBuffer = ^TKDT1536DCyanmicStoreBuffer;

  PKDT1536DC_Node = ^TKDT1536DC_Node;

  TKDT1536DC_Node = packed record
    Parent, Right, Left: PKDT1536DC_Node;
    vec: PKDT1536DC_Source;
  end;

  TKDT1536DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1536DC_Source);
  TKDT1536DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1536DC_Source) of object;
  {$IFNDEF FPC}
  TKDT1536DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1536DC_Source);
  {$ENDIF}

  TKDT1536DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1536DCyanmicStoreBuffer;
    KDBuff     : TKDT1536DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1536DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1536DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1536DCyanmicStoreBuffer; const Buff: TKDT1536DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1536DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1536DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1536DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1536DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1536DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DC_Node; overload;
    function Search(const Buff: TKDT1536DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DC_Node; overload;
    function Search(const Buff: TKDT1536DC_Vec; var SearchedDistanceMin: Double): PKDT1536DC_Node; overload;
    function Search(const Buff: TKDT1536DC_Vec): PKDT1536DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1536DC_DynamicVecBuffer; var OutBuff: TKDT1536DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1536DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1536DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1920DC_Vec = array [0 .. TKDT1920DC_AxisCount - 1] of TKDT1920DC_VecType;
  PKDT1920DC_Vec = ^TKDT1920DC_Vec;

  TKDT1920DC_DynamicVecBuffer = array of TKDT1920DC_Vec;
  PKDT1920DC_DynamicVecBuffer = ^TKDT1920DC_DynamicVecBuffer;

  TKDT1920DC_Source = packed record
    Buff: TKDT1920DC_Vec;
    index: Int64;
  end;

  PKDT1920DC_Source       = ^TKDT1920DC_Source;
  TKDT1920DC_SourceBuffer = array [0 .. 0] of PKDT1920DC_Source;
  PKDT1920DC_SourceBuffer = ^TKDT1920DC_SourceBuffer;

  TKDT1920DCyanmicSourceBuffer = array of PKDT1920DC_Source;
  PKDT1920DCyanmicSourceBuffer = ^TKDT1920DCyanmicSourceBuffer;

  TKDT1920DCyanmicStoreBuffer = array of TKDT1920DC_Source;
  PKDT1920DCyanmicStoreBuffer = ^TKDT1920DCyanmicStoreBuffer;

  PKDT1920DC_Node = ^TKDT1920DC_Node;

  TKDT1920DC_Node = packed record
    Parent, Right, Left: PKDT1920DC_Node;
    vec: PKDT1920DC_Source;
  end;

  TKDT1920DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1920DC_Source);
  TKDT1920DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1920DC_Source) of object;
  {$IFNDEF FPC}
  TKDT1920DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1920DC_Source);
  {$ENDIF}

  TKDT1920DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1920DCyanmicStoreBuffer;
    KDBuff     : TKDT1920DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1920DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1920DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1920DCyanmicStoreBuffer; const Buff: TKDT1920DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1920DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1920DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1920DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1920DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1920DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DC_Node; overload;
    function Search(const Buff: TKDT1920DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DC_Node; overload;
    function Search(const Buff: TKDT1920DC_Vec; var SearchedDistanceMin: Double): PKDT1920DC_Node; overload;
    function Search(const Buff: TKDT1920DC_Vec): PKDT1920DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1920DC_DynamicVecBuffer; var OutBuff: TKDT1920DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1920DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1920DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT2048DC_Vec = array [0 .. TKDT2048DC_AxisCount - 1] of TKDT2048DC_VecType;
  PKDT2048DC_Vec = ^TKDT2048DC_Vec;

  TKDT2048DC_DynamicVecBuffer = array of TKDT2048DC_Vec;
  PKDT2048DC_DynamicVecBuffer = ^TKDT2048DC_DynamicVecBuffer;

  TKDT2048DC_Source = packed record
    Buff: TKDT2048DC_Vec;
    index: Int64;
  end;

  PKDT2048DC_Source       = ^TKDT2048DC_Source;
  TKDT2048DC_SourceBuffer = array [0 .. 0] of PKDT2048DC_Source;
  PKDT2048DC_SourceBuffer = ^TKDT2048DC_SourceBuffer;

  TKDT2048DCyanmicSourceBuffer = array of PKDT2048DC_Source;
  PKDT2048DCyanmicSourceBuffer = ^TKDT2048DCyanmicSourceBuffer;

  TKDT2048DCyanmicStoreBuffer = array of TKDT2048DC_Source;
  PKDT2048DCyanmicStoreBuffer = ^TKDT2048DCyanmicStoreBuffer;

  PKDT2048DC_Node = ^TKDT2048DC_Node;

  TKDT2048DC_Node = packed record
    Parent, Right, Left: PKDT2048DC_Node;
    vec: PKDT2048DC_Source;
  end;

  TKDT2048DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT2048DC_Source);
  TKDT2048DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT2048DC_Source) of object;
  {$IFNDEF FPC}
  TKDT2048DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT2048DC_Source);
  {$ENDIF}

  TKDT2048DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2048DCyanmicStoreBuffer;
    KDBuff     : TKDT2048DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2048DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT2048DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT2048DCyanmicStoreBuffer; const Buff: TKDT2048DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT2048DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2048DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2048DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2048DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2048DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DC_Node; overload;
    function Search(const Buff: TKDT2048DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DC_Node; overload;
    function Search(const Buff: TKDT2048DC_Vec; var SearchedDistanceMin: Double): PKDT2048DC_Node; overload;
    function Search(const Buff: TKDT2048DC_Vec): PKDT2048DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2048DC_DynamicVecBuffer; var OutBuff: TKDT2048DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT2048DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT2048DC_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3072DC_Vec = array [0 .. TKDT3072DC_AxisCount - 1] of TKDT3072DC_VecType;
  PKDT3072DC_Vec = ^TKDT3072DC_Vec;

  TKDT3072DC_DynamicVecBuffer = array of TKDT3072DC_Vec;
  PKDT3072DC_DynamicVecBuffer = ^TKDT3072DC_DynamicVecBuffer;

  TKDT3072DC_Source = packed record
    Buff: TKDT3072DC_Vec;
    index: Int64;
  end;

  PKDT3072DC_Source       = ^TKDT3072DC_Source;
  TKDT3072DC_SourceBuffer = array [0 .. 0] of PKDT3072DC_Source;
  PKDT3072DC_SourceBuffer = ^TKDT3072DC_SourceBuffer;

  TKDT3072DCyanmicSourceBuffer = array of PKDT3072DC_Source;
  PKDT3072DCyanmicSourceBuffer = ^TKDT3072DCyanmicSourceBuffer;

  TKDT3072DCyanmicStoreBuffer = array of TKDT3072DC_Source;
  PKDT3072DCyanmicStoreBuffer = ^TKDT3072DCyanmicStoreBuffer;

  PKDT3072DC_Node = ^TKDT3072DC_Node;

  TKDT3072DC_Node = packed record
    Parent, Right, Left: PKDT3072DC_Node;
    vec: PKDT3072DC_Source;
  end;

  TKDT3072DC_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3072DC_Source);
  TKDT3072DC_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3072DC_Source) of object;
  {$IFNDEF FPC}
  TKDT3072DC_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3072DC_Source);
  {$ENDIF}

  TKDT3072DC = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3072DCyanmicStoreBuffer;
    KDBuff     : TKDT3072DCyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3072DC_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3072DC_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DC_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3072DCyanmicStoreBuffer; const Buff: TKDT3072DC_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3072DC_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3072DC_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3072DCyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3072DC_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DC_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DC_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DC_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DC_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DC_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DC_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DC_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DC_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DC_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3072DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DC_Node; overload;
    function Search(const Buff: TKDT3072DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DC_Node; overload;
    function Search(const Buff: TKDT3072DC_Vec; var SearchedDistanceMin: Double): PKDT3072DC_Node; overload;
    function Search(const Buff: TKDT3072DC_Vec): PKDT3072DC_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3072DC_DynamicVecBuffer; var OutBuff: TKDT3072DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3072DC_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3072DC_Source);
    class procedure Test;
    {$ENDIF}
  end;






  // Currency float: KDTree
function KDT1DCVec(const s: string): TKDT1DC_Vec; overload;
function KDT1DCVec(const v: TKDT1DC_Vec): string; overload;
function KDT1DCPow(const v: TKDT1DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1DCDistance(const v1, v2: TKDT1DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1DCCmpare(const v1, v2: TKDT1DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT2DCVec(const s: string): TKDT2DC_Vec; overload;
function KDT2DCVec(const v: TKDT2DC_Vec): string; overload;
function KDT2DCPow(const v: TKDT2DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2DCDistance(const v1, v2: TKDT2DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2DCCmpare(const v1, v2: TKDT2DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3DCVec(const s: string): TKDT3DC_Vec; overload;
function KDT3DCVec(const v: TKDT3DC_Vec): string; overload;
function KDT3DCPow(const v: TKDT3DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3DCDistance(const v1, v2: TKDT3DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3DCCmpare(const v1, v2: TKDT3DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT4DCVec(const s: string): TKDT4DC_Vec; overload;
function KDT4DCVec(const v: TKDT4DC_Vec): string; overload;
function KDT4DCPow(const v: TKDT4DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4DCDistance(const v1, v2: TKDT4DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4DCCmpare(const v1, v2: TKDT4DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT6DCVec(const s: string): TKDT6DC_Vec; overload;
function KDT6DCVec(const v: TKDT6DC_Vec): string; overload;
function KDT6DCPow(const v: TKDT6DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT6DCDistance(const v1, v2: TKDT6DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT6DCCmpare(const v1, v2: TKDT6DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT8DCVec(const s: string): TKDT8DC_Vec; overload;
function KDT8DCVec(const v: TKDT8DC_Vec): string; overload;
function KDT8DCPow(const v: TKDT8DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8DCDistance(const v1, v2: TKDT8DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8DCCmpare(const v1, v2: TKDT8DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT10DCVec(const s: string): TKDT10DC_Vec; overload;
function KDT10DCVec(const v: TKDT10DC_Vec): string; overload;
function KDT10DCPow(const v: TKDT10DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT10DCDistance(const v1, v2: TKDT10DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT10DCCmpare(const v1, v2: TKDT10DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT12DCVec(const s: string): TKDT12DC_Vec; overload;
function KDT12DCVec(const v: TKDT12DC_Vec): string; overload;
function KDT12DCPow(const v: TKDT12DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT12DCDistance(const v1, v2: TKDT12DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT12DCCmpare(const v1, v2: TKDT12DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT14DCVec(const s: string): TKDT14DC_Vec; overload;
function KDT14DCVec(const v: TKDT14DC_Vec): string; overload;
function KDT14DCPow(const v: TKDT14DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT14DCDistance(const v1, v2: TKDT14DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT14DCCmpare(const v1, v2: TKDT14DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT16DCVec(const s: string): TKDT16DC_Vec; overload;
function KDT16DCVec(const v: TKDT16DC_Vec): string; overload;
function KDT16DCPow(const v: TKDT16DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT16DCDistance(const v1, v2: TKDT16DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT16DCCmpare(const v1, v2: TKDT16DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT18DCVec(const s: string): TKDT18DC_Vec; overload;
function KDT18DCVec(const v: TKDT18DC_Vec): string; overload;
function KDT18DCPow(const v: TKDT18DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT18DCDistance(const v1, v2: TKDT18DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT18DCCmpare(const v1, v2: TKDT18DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT20DCVec(const s: string): TKDT20DC_Vec; overload;
function KDT20DCVec(const v: TKDT20DC_Vec): string; overload;
function KDT20DCPow(const v: TKDT20DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT20DCDistance(const v1, v2: TKDT20DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT20DCCmpare(const v1, v2: TKDT20DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT22DCVec(const s: string): TKDT22DC_Vec; overload;
function KDT22DCVec(const v: TKDT22DC_Vec): string; overload;
function KDT22DCPow(const v: TKDT22DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT22DCDistance(const v1, v2: TKDT22DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT22DCCmpare(const v1, v2: TKDT22DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT24DCVec(const s: string): TKDT24DC_Vec; overload;
function KDT24DCVec(const v: TKDT24DC_Vec): string; overload;
function KDT24DCPow(const v: TKDT24DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT24DCDistance(const v1, v2: TKDT24DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT24DCCmpare(const v1, v2: TKDT24DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT28DCVec(const s: string): TKDT28DC_Vec; overload;
function KDT28DCVec(const v: TKDT28DC_Vec): string; overload;
function KDT28DCPow(const v: TKDT28DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT28DCDistance(const v1, v2: TKDT28DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT28DCCmpare(const v1, v2: TKDT28DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT30DCVec(const s: string): TKDT30DC_Vec; overload;
function KDT30DCVec(const v: TKDT30DC_Vec): string; overload;
function KDT30DCPow(const v: TKDT30DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT30DCDistance(const v1, v2: TKDT30DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT30DCCmpare(const v1, v2: TKDT30DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT32DCVec(const s: string): TKDT32DC_Vec; overload;
function KDT32DCVec(const v: TKDT32DC_Vec): string; overload;
function KDT32DCPow(const v: TKDT32DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT32DCDistance(const v1, v2: TKDT32DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT32DCCmpare(const v1, v2: TKDT32DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT34DCVec(const s: string): TKDT34DC_Vec; overload;
function KDT34DCVec(const v: TKDT34DC_Vec): string; overload;
function KDT34DCPow(const v: TKDT34DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT34DCDistance(const v1, v2: TKDT34DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT34DCCmpare(const v1, v2: TKDT34DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT36DCVec(const s: string): TKDT36DC_Vec; overload;
function KDT36DCVec(const v: TKDT36DC_Vec): string; overload;
function KDT36DCPow(const v: TKDT36DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT36DCDistance(const v1, v2: TKDT36DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT36DCCmpare(const v1, v2: TKDT36DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT40DCVec(const s: string): TKDT40DC_Vec; overload;
function KDT40DCVec(const v: TKDT40DC_Vec): string; overload;
function KDT40DCPow(const v: TKDT40DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT40DCDistance(const v1, v2: TKDT40DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT40DCCmpare(const v1, v2: TKDT40DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT48DCVec(const s: string): TKDT48DC_Vec; overload;
function KDT48DCVec(const v: TKDT48DC_Vec): string; overload;
function KDT48DCPow(const v: TKDT48DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT48DCDistance(const v1, v2: TKDT48DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT48DCCmpare(const v1, v2: TKDT48DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT64DCVec(const s: string): TKDT64DC_Vec; overload;
function KDT64DCVec(const v: TKDT64DC_Vec): string; overload;
function KDT64DCPow(const v: TKDT64DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT64DCDistance(const v1, v2: TKDT64DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT64DCCmpare(const v1, v2: TKDT64DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT96DCVec(const s: string): TKDT96DC_Vec; overload;
function KDT96DCVec(const v: TKDT96DC_Vec): string; overload;
function KDT96DCPow(const v: TKDT96DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT96DCDistance(const v1, v2: TKDT96DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT96DCCmpare(const v1, v2: TKDT96DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT128DCVec(const s: string): TKDT128DC_Vec; overload;
function KDT128DCVec(const v: TKDT128DC_Vec): string; overload;
function KDT128DCPow(const v: TKDT128DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT128DCDistance(const v1, v2: TKDT128DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT128DCCmpare(const v1, v2: TKDT128DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT256DCVec(const s: string): TKDT256DC_Vec; overload;
function KDT256DCVec(const v: TKDT256DC_Vec): string; overload;
function KDT256DCPow(const v: TKDT256DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT256DCDistance(const v1, v2: TKDT256DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT256DCCmpare(const v1, v2: TKDT256DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT372DCVec(const s: string): TKDT372DC_Vec; overload;
function KDT372DCVec(const v: TKDT372DC_Vec): string; overload;
function KDT372DCPow(const v: TKDT372DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT372DCDistance(const v1, v2: TKDT372DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT372DCCmpare(const v1, v2: TKDT372DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT512DCVec(const s: string): TKDT512DC_Vec; overload;
function KDT512DCVec(const v: TKDT512DC_Vec): string; overload;
function KDT512DCPow(const v: TKDT512DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT512DCDistance(const v1, v2: TKDT512DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT512DCCmpare(const v1, v2: TKDT512DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT640DCVec(const s: string): TKDT640DC_Vec; overload;
function KDT640DCVec(const v: TKDT640DC_Vec): string; overload;
function KDT640DCPow(const v: TKDT640DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT640DCDistance(const v1, v2: TKDT640DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT640DCCmpare(const v1, v2: TKDT640DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT768DCVec(const s: string): TKDT768DC_Vec; overload;
function KDT768DCVec(const v: TKDT768DC_Vec): string; overload;
function KDT768DCPow(const v: TKDT768DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT768DCDistance(const v1, v2: TKDT768DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT768DCCmpare(const v1, v2: TKDT768DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1024DCVec(const s: string): TKDT1024DC_Vec; overload;
function KDT1024DCVec(const v: TKDT1024DC_Vec): string; overload;
function KDT1024DCPow(const v: TKDT1024DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1024DCDistance(const v1, v2: TKDT1024DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1024DCCmpare(const v1, v2: TKDT1024DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1080DCVec(const s: string): TKDT1080DC_Vec; overload;
function KDT1080DCVec(const v: TKDT1080DC_Vec): string; overload;
function KDT1080DCPow(const v: TKDT1080DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1080DCDistance(const v1, v2: TKDT1080DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1080DCCmpare(const v1, v2: TKDT1080DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1536DCVec(const s: string): TKDT1536DC_Vec; overload;
function KDT1536DCVec(const v: TKDT1536DC_Vec): string; overload;
function KDT1536DCPow(const v: TKDT1536DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1536DCDistance(const v1, v2: TKDT1536DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1536DCCmpare(const v1, v2: TKDT1536DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1920DCVec(const s: string): TKDT1920DC_Vec; overload;
function KDT1920DCVec(const v: TKDT1920DC_Vec): string; overload;
function KDT1920DCPow(const v: TKDT1920DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1920DCDistance(const v1, v2: TKDT1920DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1920DCCmpare(const v1, v2: TKDT1920DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT2048DCVec(const s: string): TKDT2048DC_Vec; overload;
function KDT2048DCVec(const v: TKDT2048DC_Vec): string; overload;
function KDT2048DCPow(const v: TKDT2048DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2048DCDistance(const v1, v2: TKDT2048DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2048DCCmpare(const v1, v2: TKDT2048DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3072DCVec(const s: string): TKDT3072DC_Vec; overload;
function KDT3072DCVec(const v: TKDT3072DC_Vec): string; overload;
function KDT3072DCPow(const v: TKDT3072DC_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3072DCDistance(const v1, v2: TKDT3072DC_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3072DCCmpare(const v1, v2: TKDT3072DC_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

{$IFDEF DEBUG}
procedure Test_All;
{$ENDIF}


implementation

uses
  {$IFDEF FPC}
  mtprocs,
  {$ELSE FPC}
  Threading,
  {$ENDIF FPC}
  PascalStrings, TextParsing, UnicodeMixedLib, DoStatusIO;






function KDT1DCVec(const s: string): TKDT1DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1DCVec(const v: TKDT1DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1DCPow(const v: TKDT1DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT1DCDistance(const v1, v2: TKDT1DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1DC_AxisCount - 1 do
      Result := Result + KDT1DCPow(v2[i] - v1[i]);
end;

function KDT1DCCmpare(const v1, v2: TKDT1DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1DC_Vec));
end;

function TKDT1DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DC_Node;
  function SortCompare(const p1, p2: PKDT1DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1DC_SourceBuffer;
  dynBuff  : PKDT1DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DC.SearchStoreBuff(const StoreBuffPtr: PKDT1DCyanmicStoreBuffer; const Buff: TKDT1DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1DC.GetData(const index: NativeInt): PKDT1DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DC.StoreBuffPtr: PKDT1DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1DC.BuildKDTreeWithCluster(const inBuff: TKDT1DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DC.BuildKDTreeWithCluster(const inBuff: TKDT1DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DC_BuildCall);
var
  TempStoreBuff: TKDT1DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DC_BuildMethod);
var
  TempStoreBuff: TKDT1DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DC_BuildProc);
var
  TempStoreBuff: TKDT1DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1DC.Search(const Buff: TKDT1DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DC_Node;

var
  NearestNeighbour: PKDT1DC_Node;

  function FindParentNode(const BuffPtr: PKDT1DC_Vec; NodePtr: PKDT1DC_Node): PKDT1DC_Node;
  var
    Next       : PKDT1DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DC_Node; const BuffPtr: PKDT1DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1DC_Vec; const p1, p2: PKDT1DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DC_Node(NearestNodes[0]);
    end;
end;

function TKDT1DC.Search(const Buff: TKDT1DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DC.Search(const Buff: TKDT1DC_Vec; var SearchedDistanceMin: Double): PKDT1DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DC.Search(const Buff: TKDT1DC_Vec): PKDT1DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1DC.Search(const inBuff: TKDT1DC_DynamicVecBuffer; var OutBuff: TKDT1DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DC_DynamicVecBuffer;
  outBuffPtr : PKDT1DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1DC_Source));
end;

procedure TKDT1DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1DC.PrintNodeTree(const NodePtr: PKDT1DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1DC.Test;
var
  TKDT1DC_Test    : TKDT1DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1DC_Test := TKDT1DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT1DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT1DC_AxisCount - 1 do
        TKDT1DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1DC_Test.TestBuff), length(TKDT1DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1DC_Test.BuildKDTreeM(False, length(TKDT1DC_Test.TestBuff), @TKDT1DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1DC_Test.BuildKDTreeM(False, length(TKDT1DC_Test.TestBuff), TKDT1DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1DC_Test.TestBuff));
  TKDT1DC_Test.Search(TKDT1DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1DCDistance(TKDT1DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1DC_Test.Clear;
  { kMean test }
  TKDT1DC_Test.BuildKDTreeWithCluster(TKDT1DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1DC_Test.Search(TKDT1DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1DC_Test);
end;

{$ENDIF DEBUG}


function KDT2DCVec(const s: string): TKDT2DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT2DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT2DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT2DCVec(const v: TKDT2DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT2DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT2DCPow(const v: TKDT2DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT2DCDistance(const v1, v2: TKDT2DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT2DC_AxisCount - 1 do
      Result := Result + KDT2DCPow(v2[i] - v1[i]);
end;

function KDT2DCCmpare(const v1, v2: TKDT2DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT2DC_Vec));
end;

function TKDT2DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DC_Node;
  function SortCompare(const p1, p2: PKDT2DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2DC_SourceBuffer;
  dynBuff  : PKDT2DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT2DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DC.SearchStoreBuff(const StoreBuffPtr: PKDT2DCyanmicStoreBuffer; const Buff: TKDT2DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT2DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT2DC.GetData(const index: NativeInt): PKDT2DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DC.StoreBuffPtr: PKDT2DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2DC.BuildKDTreeWithCluster(const inBuff: TKDT2DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT2DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT2DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT2DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DC.BuildKDTreeWithCluster(const inBuff: TKDT2DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DC_BuildCall);
var
  TempStoreBuff: TKDT2DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DC_BuildMethod);
var
  TempStoreBuff: TKDT2DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DC_BuildProc);
var
  TempStoreBuff: TKDT2DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2DC.Search(const Buff: TKDT2DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DC_Node;

var
  NearestNeighbour: PKDT2DC_Node;

  function FindParentNode(const BuffPtr: PKDT2DC_Vec; NodePtr: PKDT2DC_Node): PKDT2DC_Node;
  var
    Next       : PKDT2DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT2DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DC_Node; const BuffPtr: PKDT2DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT2DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2DC_Vec; const p1, p2: PKDT2DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DC_Node(NearestNodes[0]);
    end;
end;

function TKDT2DC.Search(const Buff: TKDT2DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DC.Search(const Buff: TKDT2DC_Vec; var SearchedDistanceMin: Double): PKDT2DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DC.Search(const Buff: TKDT2DC_Vec): PKDT2DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2DC.Search(const inBuff: TKDT2DC_DynamicVecBuffer; var OutBuff: TKDT2DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DC_DynamicVecBuffer;
  outBuffPtr : PKDT2DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2DC_Source));
end;

procedure TKDT2DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT2DC.PrintNodeTree(const NodePtr: PKDT2DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT2DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT2DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2DC.Test;
var
  TKDT2DC_Test    : TKDT2DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2DC_Test := TKDT2DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT2DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT2DC_AxisCount - 1 do
        TKDT2DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2DC_Test.TestBuff), length(TKDT2DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2DC_Test.BuildKDTreeM(False, length(TKDT2DC_Test.TestBuff), @TKDT2DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2DC_Test.BuildKDTreeM(False, length(TKDT2DC_Test.TestBuff), TKDT2DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2DC_Test.TestBuff));
  TKDT2DC_Test.Search(TKDT2DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2DCDistance(TKDT2DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2DC_Test.Clear;
  { kMean test }
  TKDT2DC_Test.BuildKDTreeWithCluster(TKDT2DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2DC_Test.Search(TKDT2DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2DC_Test);
end;

{$ENDIF DEBUG}


function KDT3DCVec(const s: string): TKDT3DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3DCVec(const v: TKDT3DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT3DCPow(const v: TKDT3DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT3DCDistance(const v1, v2: TKDT3DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3DC_AxisCount - 1 do
      Result := Result + KDT3DCPow(v2[i] - v1[i]);
end;

function KDT3DCCmpare(const v1, v2: TKDT3DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3DC_Vec));
end;

function TKDT3DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DC_Node;
  function SortCompare(const p1, p2: PKDT3DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3DC_SourceBuffer;
  dynBuff  : PKDT3DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DC.SearchStoreBuff(const StoreBuffPtr: PKDT3DCyanmicStoreBuffer; const Buff: TKDT3DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3DC.GetData(const index: NativeInt): PKDT3DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DC.StoreBuffPtr: PKDT3DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3DC.BuildKDTreeWithCluster(const inBuff: TKDT3DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DC.BuildKDTreeWithCluster(const inBuff: TKDT3DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DC_BuildCall);
var
  TempStoreBuff: TKDT3DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DC_BuildMethod);
var
  TempStoreBuff: TKDT3DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DC_BuildProc);
var
  TempStoreBuff: TKDT3DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3DC.Search(const Buff: TKDT3DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DC_Node;

var
  NearestNeighbour: PKDT3DC_Node;

  function FindParentNode(const BuffPtr: PKDT3DC_Vec; NodePtr: PKDT3DC_Node): PKDT3DC_Node;
  var
    Next       : PKDT3DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DC_Node; const BuffPtr: PKDT3DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3DC_Vec; const p1, p2: PKDT3DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DC_Node(NearestNodes[0]);
    end;
end;

function TKDT3DC.Search(const Buff: TKDT3DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DC.Search(const Buff: TKDT3DC_Vec; var SearchedDistanceMin: Double): PKDT3DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DC.Search(const Buff: TKDT3DC_Vec): PKDT3DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3DC.Search(const inBuff: TKDT3DC_DynamicVecBuffer; var OutBuff: TKDT3DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DC_DynamicVecBuffer;
  outBuffPtr : PKDT3DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3DC_Source));
end;

procedure TKDT3DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3DC.PrintNodeTree(const NodePtr: PKDT3DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3DC.Test;
var
  TKDT3DC_Test    : TKDT3DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3DC_Test := TKDT3DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT3DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT3DC_AxisCount - 1 do
        TKDT3DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3DC_Test.TestBuff), length(TKDT3DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3DC_Test.BuildKDTreeM(False, length(TKDT3DC_Test.TestBuff), @TKDT3DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3DC_Test.BuildKDTreeM(False, length(TKDT3DC_Test.TestBuff), TKDT3DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3DC_Test.TestBuff));
  TKDT3DC_Test.Search(TKDT3DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3DCDistance(TKDT3DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3DC_Test.Clear;
  { kMean test }
  TKDT3DC_Test.BuildKDTreeWithCluster(TKDT3DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3DC_Test.Search(TKDT3DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3DC_Test);
end;

{$ENDIF DEBUG}


function KDT4DCVec(const s: string): TKDT4DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT4DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT4DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT4DCVec(const v: TKDT4DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT4DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT4DCPow(const v: TKDT4DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT4DCDistance(const v1, v2: TKDT4DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT4DC_AxisCount - 1 do
      Result := Result + KDT4DCPow(v2[i] - v1[i]);
end;

function KDT4DCCmpare(const v1, v2: TKDT4DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT4DC_Vec));
end;

function TKDT4DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DC_Node;
  function SortCompare(const p1, p2: PKDT4DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4DC_SourceBuffer;
  dynBuff  : PKDT4DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT4DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DC.SearchStoreBuff(const StoreBuffPtr: PKDT4DCyanmicStoreBuffer; const Buff: TKDT4DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT4DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT4DC.GetData(const index: NativeInt): PKDT4DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DC.StoreBuffPtr: PKDT4DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4DC.BuildKDTreeWithCluster(const inBuff: TKDT4DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT4DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT4DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT4DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DC.BuildKDTreeWithCluster(const inBuff: TKDT4DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DC_BuildCall);
var
  TempStoreBuff: TKDT4DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DC_BuildMethod);
var
  TempStoreBuff: TKDT4DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DC_BuildProc);
var
  TempStoreBuff: TKDT4DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT4DC.Search(const Buff: TKDT4DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DC_Node;

var
  NearestNeighbour: PKDT4DC_Node;

  function FindParentNode(const BuffPtr: PKDT4DC_Vec; NodePtr: PKDT4DC_Node): PKDT4DC_Node;
  var
    Next       : PKDT4DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT4DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DC_Node; const BuffPtr: PKDT4DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT4DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4DC_Vec; const p1, p2: PKDT4DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DC_Node(NearestNodes[0]);
    end;
end;

function TKDT4DC.Search(const Buff: TKDT4DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DC.Search(const Buff: TKDT4DC_Vec; var SearchedDistanceMin: Double): PKDT4DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DC.Search(const Buff: TKDT4DC_Vec): PKDT4DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4DC.Search(const inBuff: TKDT4DC_DynamicVecBuffer; var OutBuff: TKDT4DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DC_DynamicVecBuffer;
  outBuffPtr : PKDT4DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4DC_Source));
end;

procedure TKDT4DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT4DC.PrintNodeTree(const NodePtr: PKDT4DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT4DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT4DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4DC.Test;
var
  TKDT4DC_Test    : TKDT4DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4DC_Test := TKDT4DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT4DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT4DC_AxisCount - 1 do
        TKDT4DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT4DC_Test.TestBuff), length(TKDT4DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4DC_Test.BuildKDTreeM(False, length(TKDT4DC_Test.TestBuff), @TKDT4DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4DC_Test.BuildKDTreeM(False, length(TKDT4DC_Test.TestBuff), TKDT4DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4DC_Test.TestBuff));
  TKDT4DC_Test.Search(TKDT4DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4DCDistance(TKDT4DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4DC_Test.Clear;
  { kMean test }
  TKDT4DC_Test.BuildKDTreeWithCluster(TKDT4DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4DC_Test.Search(TKDT4DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4DC_Test);
end;

{$ENDIF DEBUG}


function KDT6DCVec(const s: string): TKDT6DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT6DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT6DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT6DCVec(const v: TKDT6DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT6DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT6DCPow(const v: TKDT6DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT6DCDistance(const v1, v2: TKDT6DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT6DC_AxisCount - 1 do
      Result := Result + KDT6DCPow(v2[i] - v1[i]);
end;

function KDT6DCCmpare(const v1, v2: TKDT6DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT6DC_Vec));
end;

function TKDT6DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DC_Node;
  function SortCompare(const p1, p2: PKDT6DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT6DC_SourceBuffer;
  dynBuff  : PKDT6DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT6DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DC.SearchStoreBuff(const StoreBuffPtr: PKDT6DCyanmicStoreBuffer; const Buff: TKDT6DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT6DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT6DC.GetData(const index: NativeInt): PKDT6DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT6DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DC.StoreBuffPtr: PKDT6DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT6DC.BuildKDTreeWithCluster(const inBuff: TKDT6DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT6DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT6DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT6DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DC.BuildKDTreeWithCluster(const inBuff: TKDT6DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DC_BuildCall);
var
  TempStoreBuff: TKDT6DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DC_BuildMethod);
var
  TempStoreBuff: TKDT6DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DC_BuildProc);
var
  TempStoreBuff: TKDT6DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT6DC.Search(const Buff: TKDT6DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DC_Node;

var
  NearestNeighbour: PKDT6DC_Node;

  function FindParentNode(const BuffPtr: PKDT6DC_Vec; NodePtr: PKDT6DC_Node): PKDT6DC_Node;
  var
    Next       : PKDT6DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT6DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DC_Node; const BuffPtr: PKDT6DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT6DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT6DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT6DC_Vec; const p1, p2: PKDT6DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT6DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT6DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT6DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT6DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT6DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DC_Node(NearestNodes[0]);
    end;
end;

function TKDT6DC.Search(const Buff: TKDT6DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DC.Search(const Buff: TKDT6DC_Vec; var SearchedDistanceMin: Double): PKDT6DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DC.Search(const Buff: TKDT6DC_Vec): PKDT6DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT6DC.Search(const inBuff: TKDT6DC_DynamicVecBuffer; var OutBuff: TKDT6DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DC_DynamicVecBuffer;
  outBuffPtr : PKDT6DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT6DC_Source));
end;

procedure TKDT6DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT6DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT6DC.PrintNodeTree(const NodePtr: PKDT6DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT6DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT6DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT6DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT6DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT6DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT6DC.Test;
var
  TKDT6DC_Test    : TKDT6DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT6DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT6DC_Test := TKDT6DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT6DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT6DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT6DC_AxisCount - 1 do
        TKDT6DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT6DC_Test.TestBuff), length(TKDT6DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT6DC_Test.BuildKDTreeM(False, length(TKDT6DC_Test.TestBuff), @TKDT6DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT6DC_Test.BuildKDTreeM(False, length(TKDT6DC_Test.TestBuff), TKDT6DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT6DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT6DC_Test.TestBuff));
  TKDT6DC_Test.Search(TKDT6DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT6DCDistance(TKDT6DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT6DC_Test.Clear;
  { kMean test }
  TKDT6DC_Test.BuildKDTreeWithCluster(TKDT6DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT6DC_Test.Search(TKDT6DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT6DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT6DC_Test);
end;

{$ENDIF DEBUG}


function KDT8DCVec(const s: string): TKDT8DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT8DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT8DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT8DCVec(const v: TKDT8DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT8DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT8DCPow(const v: TKDT8DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT8DCDistance(const v1, v2: TKDT8DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT8DC_AxisCount - 1 do
      Result := Result + KDT8DCPow(v2[i] - v1[i]);
end;

function KDT8DCCmpare(const v1, v2: TKDT8DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT8DC_Vec));
end;

function TKDT8DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DC_Node;
  function SortCompare(const p1, p2: PKDT8DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8DC_SourceBuffer;
  dynBuff  : PKDT8DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT8DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DC.SearchStoreBuff(const StoreBuffPtr: PKDT8DCyanmicStoreBuffer; const Buff: TKDT8DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT8DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT8DC.GetData(const index: NativeInt): PKDT8DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DC.StoreBuffPtr: PKDT8DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8DC.BuildKDTreeWithCluster(const inBuff: TKDT8DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT8DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT8DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT8DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DC.BuildKDTreeWithCluster(const inBuff: TKDT8DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DC_BuildCall);
var
  TempStoreBuff: TKDT8DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DC_BuildMethod);
var
  TempStoreBuff: TKDT8DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DC_BuildProc);
var
  TempStoreBuff: TKDT8DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT8DC.Search(const Buff: TKDT8DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DC_Node;

var
  NearestNeighbour: PKDT8DC_Node;

  function FindParentNode(const BuffPtr: PKDT8DC_Vec; NodePtr: PKDT8DC_Node): PKDT8DC_Node;
  var
    Next       : PKDT8DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT8DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DC_Node; const BuffPtr: PKDT8DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT8DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8DC_Vec; const p1, p2: PKDT8DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DC_Node(NearestNodes[0]);
    end;
end;

function TKDT8DC.Search(const Buff: TKDT8DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DC.Search(const Buff: TKDT8DC_Vec; var SearchedDistanceMin: Double): PKDT8DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DC.Search(const Buff: TKDT8DC_Vec): PKDT8DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8DC.Search(const inBuff: TKDT8DC_DynamicVecBuffer; var OutBuff: TKDT8DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DC_DynamicVecBuffer;
  outBuffPtr : PKDT8DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8DC_Source));
end;

procedure TKDT8DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT8DC.PrintNodeTree(const NodePtr: PKDT8DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT8DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT8DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8DC.Test;
var
  TKDT8DC_Test    : TKDT8DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8DC_Test := TKDT8DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT8DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT8DC_AxisCount - 1 do
        TKDT8DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT8DC_Test.TestBuff), length(TKDT8DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8DC_Test.BuildKDTreeM(False, length(TKDT8DC_Test.TestBuff), @TKDT8DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8DC_Test.BuildKDTreeM(False, length(TKDT8DC_Test.TestBuff), TKDT8DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8DC_Test.TestBuff));
  TKDT8DC_Test.Search(TKDT8DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8DCDistance(TKDT8DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8DC_Test.Clear;
  { kMean test }
  TKDT8DC_Test.BuildKDTreeWithCluster(TKDT8DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8DC_Test.Search(TKDT8DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8DC_Test);
end;

{$ENDIF DEBUG}


function KDT10DCVec(const s: string): TKDT10DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT10DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT10DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT10DCVec(const v: TKDT10DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT10DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT10DCPow(const v: TKDT10DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT10DCDistance(const v1, v2: TKDT10DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT10DC_AxisCount - 1 do
      Result := Result + KDT10DCPow(v2[i] - v1[i]);
end;

function KDT10DCCmpare(const v1, v2: TKDT10DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT10DC_Vec));
end;

function TKDT10DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DC_Node;
  function SortCompare(const p1, p2: PKDT10DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT10DC_SourceBuffer;
  dynBuff  : PKDT10DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT10DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DC.SearchStoreBuff(const StoreBuffPtr: PKDT10DCyanmicStoreBuffer; const Buff: TKDT10DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT10DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT10DC.GetData(const index: NativeInt): PKDT10DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT10DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DC.StoreBuffPtr: PKDT10DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT10DC.BuildKDTreeWithCluster(const inBuff: TKDT10DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT10DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT10DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT10DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DC.BuildKDTreeWithCluster(const inBuff: TKDT10DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DC_BuildCall);
var
  TempStoreBuff: TKDT10DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DC_BuildMethod);
var
  TempStoreBuff: TKDT10DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DC_BuildProc);
var
  TempStoreBuff: TKDT10DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT10DC.Search(const Buff: TKDT10DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DC_Node;

var
  NearestNeighbour: PKDT10DC_Node;

  function FindParentNode(const BuffPtr: PKDT10DC_Vec; NodePtr: PKDT10DC_Node): PKDT10DC_Node;
  var
    Next       : PKDT10DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT10DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DC_Node; const BuffPtr: PKDT10DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT10DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT10DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT10DC_Vec; const p1, p2: PKDT10DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT10DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT10DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT10DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT10DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT10DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DC_Node(NearestNodes[0]);
    end;
end;

function TKDT10DC.Search(const Buff: TKDT10DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DC.Search(const Buff: TKDT10DC_Vec; var SearchedDistanceMin: Double): PKDT10DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DC.Search(const Buff: TKDT10DC_Vec): PKDT10DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT10DC.Search(const inBuff: TKDT10DC_DynamicVecBuffer; var OutBuff: TKDT10DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DC_DynamicVecBuffer;
  outBuffPtr : PKDT10DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT10DC_Source));
end;

procedure TKDT10DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT10DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT10DC.PrintNodeTree(const NodePtr: PKDT10DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT10DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT10DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT10DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT10DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT10DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT10DC.Test;
var
  TKDT10DC_Test    : TKDT10DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT10DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT10DC_Test := TKDT10DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT10DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT10DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT10DC_AxisCount - 1 do
        TKDT10DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT10DC_Test.TestBuff), length(TKDT10DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT10DC_Test.BuildKDTreeM(False, length(TKDT10DC_Test.TestBuff), @TKDT10DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT10DC_Test.BuildKDTreeM(False, length(TKDT10DC_Test.TestBuff), TKDT10DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT10DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT10DC_Test.TestBuff));
  TKDT10DC_Test.Search(TKDT10DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT10DCDistance(TKDT10DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT10DC_Test.Clear;
  { kMean test }
  TKDT10DC_Test.BuildKDTreeWithCluster(TKDT10DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT10DC_Test.Search(TKDT10DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT10DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT10DC_Test);
end;

{$ENDIF DEBUG}


function KDT12DCVec(const s: string): TKDT12DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT12DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT12DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT12DCVec(const v: TKDT12DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT12DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT12DCPow(const v: TKDT12DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT12DCDistance(const v1, v2: TKDT12DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT12DC_AxisCount - 1 do
      Result := Result + KDT12DCPow(v2[i] - v1[i]);
end;

function KDT12DCCmpare(const v1, v2: TKDT12DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT12DC_Vec));
end;

function TKDT12DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DC_Node;
  function SortCompare(const p1, p2: PKDT12DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT12DC_SourceBuffer;
  dynBuff  : PKDT12DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT12DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DC.SearchStoreBuff(const StoreBuffPtr: PKDT12DCyanmicStoreBuffer; const Buff: TKDT12DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT12DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT12DC.GetData(const index: NativeInt): PKDT12DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT12DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DC.StoreBuffPtr: PKDT12DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT12DC.BuildKDTreeWithCluster(const inBuff: TKDT12DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT12DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT12DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT12DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DC.BuildKDTreeWithCluster(const inBuff: TKDT12DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DC_BuildCall);
var
  TempStoreBuff: TKDT12DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DC_BuildMethod);
var
  TempStoreBuff: TKDT12DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DC_BuildProc);
var
  TempStoreBuff: TKDT12DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT12DC.Search(const Buff: TKDT12DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DC_Node;

var
  NearestNeighbour: PKDT12DC_Node;

  function FindParentNode(const BuffPtr: PKDT12DC_Vec; NodePtr: PKDT12DC_Node): PKDT12DC_Node;
  var
    Next       : PKDT12DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT12DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DC_Node; const BuffPtr: PKDT12DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT12DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT12DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT12DC_Vec; const p1, p2: PKDT12DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT12DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT12DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT12DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT12DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT12DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DC_Node(NearestNodes[0]);
    end;
end;

function TKDT12DC.Search(const Buff: TKDT12DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DC.Search(const Buff: TKDT12DC_Vec; var SearchedDistanceMin: Double): PKDT12DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DC.Search(const Buff: TKDT12DC_Vec): PKDT12DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT12DC.Search(const inBuff: TKDT12DC_DynamicVecBuffer; var OutBuff: TKDT12DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DC_DynamicVecBuffer;
  outBuffPtr : PKDT12DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT12DC_Source));
end;

procedure TKDT12DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT12DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT12DC.PrintNodeTree(const NodePtr: PKDT12DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT12DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT12DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT12DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT12DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT12DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT12DC.Test;
var
  TKDT12DC_Test    : TKDT12DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT12DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT12DC_Test := TKDT12DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT12DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT12DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT12DC_AxisCount - 1 do
        TKDT12DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT12DC_Test.TestBuff), length(TKDT12DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT12DC_Test.BuildKDTreeM(False, length(TKDT12DC_Test.TestBuff), @TKDT12DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT12DC_Test.BuildKDTreeM(False, length(TKDT12DC_Test.TestBuff), TKDT12DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT12DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT12DC_Test.TestBuff));
  TKDT12DC_Test.Search(TKDT12DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT12DCDistance(TKDT12DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT12DC_Test.Clear;
  { kMean test }
  TKDT12DC_Test.BuildKDTreeWithCluster(TKDT12DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT12DC_Test.Search(TKDT12DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT12DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT12DC_Test);
end;

{$ENDIF DEBUG}


function KDT14DCVec(const s: string): TKDT14DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT14DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT14DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT14DCVec(const v: TKDT14DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT14DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT14DCPow(const v: TKDT14DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT14DCDistance(const v1, v2: TKDT14DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT14DC_AxisCount - 1 do
      Result := Result + KDT14DCPow(v2[i] - v1[i]);
end;

function KDT14DCCmpare(const v1, v2: TKDT14DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT14DC_Vec));
end;

function TKDT14DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DC_Node;
  function SortCompare(const p1, p2: PKDT14DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT14DC_SourceBuffer;
  dynBuff  : PKDT14DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT14DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DC.SearchStoreBuff(const StoreBuffPtr: PKDT14DCyanmicStoreBuffer; const Buff: TKDT14DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT14DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT14DC.GetData(const index: NativeInt): PKDT14DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT14DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DC.StoreBuffPtr: PKDT14DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT14DC.BuildKDTreeWithCluster(const inBuff: TKDT14DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT14DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT14DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT14DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DC.BuildKDTreeWithCluster(const inBuff: TKDT14DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DC_BuildCall);
var
  TempStoreBuff: TKDT14DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DC_BuildMethod);
var
  TempStoreBuff: TKDT14DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DC_BuildProc);
var
  TempStoreBuff: TKDT14DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT14DC.Search(const Buff: TKDT14DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DC_Node;

var
  NearestNeighbour: PKDT14DC_Node;

  function FindParentNode(const BuffPtr: PKDT14DC_Vec; NodePtr: PKDT14DC_Node): PKDT14DC_Node;
  var
    Next       : PKDT14DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT14DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DC_Node; const BuffPtr: PKDT14DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT14DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT14DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT14DC_Vec; const p1, p2: PKDT14DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT14DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT14DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT14DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT14DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT14DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DC_Node(NearestNodes[0]);
    end;
end;

function TKDT14DC.Search(const Buff: TKDT14DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DC.Search(const Buff: TKDT14DC_Vec; var SearchedDistanceMin: Double): PKDT14DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DC.Search(const Buff: TKDT14DC_Vec): PKDT14DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT14DC.Search(const inBuff: TKDT14DC_DynamicVecBuffer; var OutBuff: TKDT14DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DC_DynamicVecBuffer;
  outBuffPtr : PKDT14DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT14DC_Source));
end;

procedure TKDT14DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT14DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT14DC.PrintNodeTree(const NodePtr: PKDT14DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT14DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT14DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT14DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT14DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT14DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT14DC.Test;
var
  TKDT14DC_Test    : TKDT14DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT14DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT14DC_Test := TKDT14DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT14DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT14DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT14DC_AxisCount - 1 do
        TKDT14DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT14DC_Test.TestBuff), length(TKDT14DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT14DC_Test.BuildKDTreeM(False, length(TKDT14DC_Test.TestBuff), @TKDT14DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT14DC_Test.BuildKDTreeM(False, length(TKDT14DC_Test.TestBuff), TKDT14DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT14DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT14DC_Test.TestBuff));
  TKDT14DC_Test.Search(TKDT14DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT14DCDistance(TKDT14DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT14DC_Test.Clear;
  { kMean test }
  TKDT14DC_Test.BuildKDTreeWithCluster(TKDT14DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT14DC_Test.Search(TKDT14DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT14DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT14DC_Test);
end;

{$ENDIF DEBUG}


function KDT16DCVec(const s: string): TKDT16DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT16DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT16DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT16DCVec(const v: TKDT16DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT16DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT16DCPow(const v: TKDT16DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT16DCDistance(const v1, v2: TKDT16DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT16DC_AxisCount - 1 do
      Result := Result + KDT16DCPow(v2[i] - v1[i]);
end;

function KDT16DCCmpare(const v1, v2: TKDT16DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT16DC_Vec));
end;

function TKDT16DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DC_Node;
  function SortCompare(const p1, p2: PKDT16DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT16DC_SourceBuffer;
  dynBuff  : PKDT16DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT16DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DC.SearchStoreBuff(const StoreBuffPtr: PKDT16DCyanmicStoreBuffer; const Buff: TKDT16DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT16DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT16DC.GetData(const index: NativeInt): PKDT16DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT16DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DC.StoreBuffPtr: PKDT16DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT16DC.BuildKDTreeWithCluster(const inBuff: TKDT16DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT16DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT16DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT16DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DC.BuildKDTreeWithCluster(const inBuff: TKDT16DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DC_BuildCall);
var
  TempStoreBuff: TKDT16DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DC_BuildMethod);
var
  TempStoreBuff: TKDT16DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DC_BuildProc);
var
  TempStoreBuff: TKDT16DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT16DC.Search(const Buff: TKDT16DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DC_Node;

var
  NearestNeighbour: PKDT16DC_Node;

  function FindParentNode(const BuffPtr: PKDT16DC_Vec; NodePtr: PKDT16DC_Node): PKDT16DC_Node;
  var
    Next       : PKDT16DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT16DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DC_Node; const BuffPtr: PKDT16DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT16DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT16DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT16DC_Vec; const p1, p2: PKDT16DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT16DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT16DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT16DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT16DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT16DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DC_Node(NearestNodes[0]);
    end;
end;

function TKDT16DC.Search(const Buff: TKDT16DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DC.Search(const Buff: TKDT16DC_Vec; var SearchedDistanceMin: Double): PKDT16DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DC.Search(const Buff: TKDT16DC_Vec): PKDT16DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT16DC.Search(const inBuff: TKDT16DC_DynamicVecBuffer; var OutBuff: TKDT16DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DC_DynamicVecBuffer;
  outBuffPtr : PKDT16DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT16DC_Source));
end;

procedure TKDT16DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT16DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT16DC.PrintNodeTree(const NodePtr: PKDT16DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT16DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT16DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT16DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT16DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT16DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT16DC.Test;
var
  TKDT16DC_Test    : TKDT16DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT16DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT16DC_Test := TKDT16DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT16DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT16DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT16DC_AxisCount - 1 do
        TKDT16DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT16DC_Test.TestBuff), length(TKDT16DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT16DC_Test.BuildKDTreeM(False, length(TKDT16DC_Test.TestBuff), @TKDT16DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT16DC_Test.BuildKDTreeM(False, length(TKDT16DC_Test.TestBuff), TKDT16DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT16DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT16DC_Test.TestBuff));
  TKDT16DC_Test.Search(TKDT16DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT16DCDistance(TKDT16DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT16DC_Test.Clear;
  { kMean test }
  TKDT16DC_Test.BuildKDTreeWithCluster(TKDT16DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT16DC_Test.Search(TKDT16DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT16DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT16DC_Test);
end;

{$ENDIF DEBUG}


function KDT18DCVec(const s: string): TKDT18DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT18DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT18DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT18DCVec(const v: TKDT18DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT18DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT18DCPow(const v: TKDT18DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT18DCDistance(const v1, v2: TKDT18DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT18DC_AxisCount - 1 do
      Result := Result + KDT18DCPow(v2[i] - v1[i]);
end;

function KDT18DCCmpare(const v1, v2: TKDT18DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT18DC_Vec));
end;

function TKDT18DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DC_Node;
  function SortCompare(const p1, p2: PKDT18DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT18DC_SourceBuffer;
  dynBuff  : PKDT18DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT18DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DC.SearchStoreBuff(const StoreBuffPtr: PKDT18DCyanmicStoreBuffer; const Buff: TKDT18DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT18DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT18DC.GetData(const index: NativeInt): PKDT18DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT18DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DC.StoreBuffPtr: PKDT18DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT18DC.BuildKDTreeWithCluster(const inBuff: TKDT18DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT18DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT18DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT18DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DC.BuildKDTreeWithCluster(const inBuff: TKDT18DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DC_BuildCall);
var
  TempStoreBuff: TKDT18DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DC_BuildMethod);
var
  TempStoreBuff: TKDT18DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DC_BuildProc);
var
  TempStoreBuff: TKDT18DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT18DC.Search(const Buff: TKDT18DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DC_Node;

var
  NearestNeighbour: PKDT18DC_Node;

  function FindParentNode(const BuffPtr: PKDT18DC_Vec; NodePtr: PKDT18DC_Node): PKDT18DC_Node;
  var
    Next       : PKDT18DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT18DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DC_Node; const BuffPtr: PKDT18DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT18DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT18DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT18DC_Vec; const p1, p2: PKDT18DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT18DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT18DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT18DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT18DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT18DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DC_Node(NearestNodes[0]);
    end;
end;

function TKDT18DC.Search(const Buff: TKDT18DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DC.Search(const Buff: TKDT18DC_Vec; var SearchedDistanceMin: Double): PKDT18DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DC.Search(const Buff: TKDT18DC_Vec): PKDT18DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT18DC.Search(const inBuff: TKDT18DC_DynamicVecBuffer; var OutBuff: TKDT18DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DC_DynamicVecBuffer;
  outBuffPtr : PKDT18DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT18DC_Source));
end;

procedure TKDT18DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT18DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT18DC.PrintNodeTree(const NodePtr: PKDT18DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT18DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT18DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT18DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT18DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT18DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT18DC.Test;
var
  TKDT18DC_Test    : TKDT18DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT18DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT18DC_Test := TKDT18DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT18DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT18DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT18DC_AxisCount - 1 do
        TKDT18DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT18DC_Test.TestBuff), length(TKDT18DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT18DC_Test.BuildKDTreeM(False, length(TKDT18DC_Test.TestBuff), @TKDT18DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT18DC_Test.BuildKDTreeM(False, length(TKDT18DC_Test.TestBuff), TKDT18DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT18DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT18DC_Test.TestBuff));
  TKDT18DC_Test.Search(TKDT18DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT18DCDistance(TKDT18DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT18DC_Test.Clear;
  { kMean test }
  TKDT18DC_Test.BuildKDTreeWithCluster(TKDT18DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT18DC_Test.Search(TKDT18DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT18DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT18DC_Test);
end;

{$ENDIF DEBUG}


function KDT20DCVec(const s: string): TKDT20DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT20DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT20DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT20DCVec(const v: TKDT20DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT20DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT20DCPow(const v: TKDT20DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT20DCDistance(const v1, v2: TKDT20DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT20DC_AxisCount - 1 do
      Result := Result + KDT20DCPow(v2[i] - v1[i]);
end;

function KDT20DCCmpare(const v1, v2: TKDT20DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT20DC_Vec));
end;

function TKDT20DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DC_Node;
  function SortCompare(const p1, p2: PKDT20DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT20DC_SourceBuffer;
  dynBuff  : PKDT20DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT20DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DC.SearchStoreBuff(const StoreBuffPtr: PKDT20DCyanmicStoreBuffer; const Buff: TKDT20DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT20DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT20DC.GetData(const index: NativeInt): PKDT20DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT20DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DC.StoreBuffPtr: PKDT20DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT20DC.BuildKDTreeWithCluster(const inBuff: TKDT20DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT20DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT20DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT20DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DC.BuildKDTreeWithCluster(const inBuff: TKDT20DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DC_BuildCall);
var
  TempStoreBuff: TKDT20DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DC_BuildMethod);
var
  TempStoreBuff: TKDT20DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DC_BuildProc);
var
  TempStoreBuff: TKDT20DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT20DC.Search(const Buff: TKDT20DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DC_Node;

var
  NearestNeighbour: PKDT20DC_Node;

  function FindParentNode(const BuffPtr: PKDT20DC_Vec; NodePtr: PKDT20DC_Node): PKDT20DC_Node;
  var
    Next       : PKDT20DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT20DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DC_Node; const BuffPtr: PKDT20DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT20DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT20DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT20DC_Vec; const p1, p2: PKDT20DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT20DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT20DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT20DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT20DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT20DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DC_Node(NearestNodes[0]);
    end;
end;

function TKDT20DC.Search(const Buff: TKDT20DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DC.Search(const Buff: TKDT20DC_Vec; var SearchedDistanceMin: Double): PKDT20DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DC.Search(const Buff: TKDT20DC_Vec): PKDT20DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT20DC.Search(const inBuff: TKDT20DC_DynamicVecBuffer; var OutBuff: TKDT20DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DC_DynamicVecBuffer;
  outBuffPtr : PKDT20DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT20DC_Source));
end;

procedure TKDT20DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT20DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT20DC.PrintNodeTree(const NodePtr: PKDT20DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT20DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT20DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT20DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT20DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT20DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT20DC.Test;
var
  TKDT20DC_Test    : TKDT20DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT20DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT20DC_Test := TKDT20DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT20DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT20DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT20DC_AxisCount - 1 do
        TKDT20DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT20DC_Test.TestBuff), length(TKDT20DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT20DC_Test.BuildKDTreeM(False, length(TKDT20DC_Test.TestBuff), @TKDT20DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT20DC_Test.BuildKDTreeM(False, length(TKDT20DC_Test.TestBuff), TKDT20DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT20DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT20DC_Test.TestBuff));
  TKDT20DC_Test.Search(TKDT20DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT20DCDistance(TKDT20DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT20DC_Test.Clear;
  { kMean test }
  TKDT20DC_Test.BuildKDTreeWithCluster(TKDT20DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT20DC_Test.Search(TKDT20DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT20DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT20DC_Test);
end;

{$ENDIF DEBUG}


function KDT22DCVec(const s: string): TKDT22DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT22DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT22DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT22DCVec(const v: TKDT22DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT22DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT22DCPow(const v: TKDT22DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT22DCDistance(const v1, v2: TKDT22DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT22DC_AxisCount - 1 do
      Result := Result + KDT22DCPow(v2[i] - v1[i]);
end;

function KDT22DCCmpare(const v1, v2: TKDT22DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT22DC_Vec));
end;

function TKDT22DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DC_Node;
  function SortCompare(const p1, p2: PKDT22DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT22DC_SourceBuffer;
  dynBuff  : PKDT22DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT22DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DC.SearchStoreBuff(const StoreBuffPtr: PKDT22DCyanmicStoreBuffer; const Buff: TKDT22DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT22DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT22DC.GetData(const index: NativeInt): PKDT22DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT22DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DC.StoreBuffPtr: PKDT22DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT22DC.BuildKDTreeWithCluster(const inBuff: TKDT22DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT22DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT22DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT22DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DC.BuildKDTreeWithCluster(const inBuff: TKDT22DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DC_BuildCall);
var
  TempStoreBuff: TKDT22DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DC_BuildMethod);
var
  TempStoreBuff: TKDT22DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DC_BuildProc);
var
  TempStoreBuff: TKDT22DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT22DC.Search(const Buff: TKDT22DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DC_Node;

var
  NearestNeighbour: PKDT22DC_Node;

  function FindParentNode(const BuffPtr: PKDT22DC_Vec; NodePtr: PKDT22DC_Node): PKDT22DC_Node;
  var
    Next       : PKDT22DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT22DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DC_Node; const BuffPtr: PKDT22DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT22DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT22DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT22DC_Vec; const p1, p2: PKDT22DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT22DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT22DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT22DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT22DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT22DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DC_Node(NearestNodes[0]);
    end;
end;

function TKDT22DC.Search(const Buff: TKDT22DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DC.Search(const Buff: TKDT22DC_Vec; var SearchedDistanceMin: Double): PKDT22DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DC.Search(const Buff: TKDT22DC_Vec): PKDT22DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT22DC.Search(const inBuff: TKDT22DC_DynamicVecBuffer; var OutBuff: TKDT22DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DC_DynamicVecBuffer;
  outBuffPtr : PKDT22DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT22DC_Source));
end;

procedure TKDT22DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT22DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT22DC.PrintNodeTree(const NodePtr: PKDT22DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT22DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT22DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT22DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT22DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT22DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT22DC.Test;
var
  TKDT22DC_Test    : TKDT22DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT22DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT22DC_Test := TKDT22DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT22DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT22DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT22DC_AxisCount - 1 do
        TKDT22DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT22DC_Test.TestBuff), length(TKDT22DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT22DC_Test.BuildKDTreeM(False, length(TKDT22DC_Test.TestBuff), @TKDT22DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT22DC_Test.BuildKDTreeM(False, length(TKDT22DC_Test.TestBuff), TKDT22DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT22DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT22DC_Test.TestBuff));
  TKDT22DC_Test.Search(TKDT22DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT22DCDistance(TKDT22DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT22DC_Test.Clear;
  { kMean test }
  TKDT22DC_Test.BuildKDTreeWithCluster(TKDT22DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT22DC_Test.Search(TKDT22DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT22DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT22DC_Test);
end;

{$ENDIF DEBUG}


function KDT24DCVec(const s: string): TKDT24DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT24DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT24DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT24DCVec(const v: TKDT24DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT24DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT24DCPow(const v: TKDT24DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT24DCDistance(const v1, v2: TKDT24DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT24DC_AxisCount - 1 do
      Result := Result + KDT24DCPow(v2[i] - v1[i]);
end;

function KDT24DCCmpare(const v1, v2: TKDT24DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT24DC_Vec));
end;

function TKDT24DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DC_Node;
  function SortCompare(const p1, p2: PKDT24DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT24DC_SourceBuffer;
  dynBuff  : PKDT24DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT24DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DC.SearchStoreBuff(const StoreBuffPtr: PKDT24DCyanmicStoreBuffer; const Buff: TKDT24DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT24DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT24DC.GetData(const index: NativeInt): PKDT24DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT24DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DC.StoreBuffPtr: PKDT24DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT24DC.BuildKDTreeWithCluster(const inBuff: TKDT24DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT24DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT24DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT24DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DC.BuildKDTreeWithCluster(const inBuff: TKDT24DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DC_BuildCall);
var
  TempStoreBuff: TKDT24DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DC_BuildMethod);
var
  TempStoreBuff: TKDT24DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DC_BuildProc);
var
  TempStoreBuff: TKDT24DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT24DC.Search(const Buff: TKDT24DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DC_Node;

var
  NearestNeighbour: PKDT24DC_Node;

  function FindParentNode(const BuffPtr: PKDT24DC_Vec; NodePtr: PKDT24DC_Node): PKDT24DC_Node;
  var
    Next       : PKDT24DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT24DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DC_Node; const BuffPtr: PKDT24DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT24DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT24DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT24DC_Vec; const p1, p2: PKDT24DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT24DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT24DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT24DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT24DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT24DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DC_Node(NearestNodes[0]);
    end;
end;

function TKDT24DC.Search(const Buff: TKDT24DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DC.Search(const Buff: TKDT24DC_Vec; var SearchedDistanceMin: Double): PKDT24DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DC.Search(const Buff: TKDT24DC_Vec): PKDT24DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT24DC.Search(const inBuff: TKDT24DC_DynamicVecBuffer; var OutBuff: TKDT24DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DC_DynamicVecBuffer;
  outBuffPtr : PKDT24DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT24DC_Source));
end;

procedure TKDT24DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT24DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT24DC.PrintNodeTree(const NodePtr: PKDT24DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT24DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT24DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT24DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT24DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT24DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT24DC.Test;
var
  TKDT24DC_Test    : TKDT24DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT24DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT24DC_Test := TKDT24DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT24DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT24DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT24DC_AxisCount - 1 do
        TKDT24DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT24DC_Test.TestBuff), length(TKDT24DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT24DC_Test.BuildKDTreeM(False, length(TKDT24DC_Test.TestBuff), @TKDT24DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT24DC_Test.BuildKDTreeM(False, length(TKDT24DC_Test.TestBuff), TKDT24DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT24DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT24DC_Test.TestBuff));
  TKDT24DC_Test.Search(TKDT24DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT24DCDistance(TKDT24DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT24DC_Test.Clear;
  { kMean test }
  TKDT24DC_Test.BuildKDTreeWithCluster(TKDT24DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT24DC_Test.Search(TKDT24DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT24DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT24DC_Test);
end;

{$ENDIF DEBUG}


function KDT28DCVec(const s: string): TKDT28DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT28DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT28DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT28DCVec(const v: TKDT28DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT28DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT28DCPow(const v: TKDT28DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT28DCDistance(const v1, v2: TKDT28DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT28DC_AxisCount - 1 do
      Result := Result + KDT28DCPow(v2[i] - v1[i]);
end;

function KDT28DCCmpare(const v1, v2: TKDT28DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT28DC_Vec));
end;

function TKDT28DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DC_Node;
  function SortCompare(const p1, p2: PKDT28DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT28DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT28DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT28DC_SourceBuffer;
  dynBuff  : PKDT28DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT28DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT28DC.SearchStoreBuff(const StoreBuffPtr: PKDT28DCyanmicStoreBuffer; const Buff: TKDT28DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT28DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT28DC.GetData(const index: NativeInt): PKDT28DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT28DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT28DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT28DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT28DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT28DC.StoreBuffPtr: PKDT28DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT28DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT28DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT28DC.BuildKDTreeWithCluster(const inBuff: TKDT28DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT28DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT28DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT28DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT28DC.BuildKDTreeWithCluster(const inBuff: TKDT28DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DC_BuildCall);
var
  TempStoreBuff: TKDT28DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DC_BuildMethod);
var
  TempStoreBuff: TKDT28DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DC_BuildProc);
var
  TempStoreBuff: TKDT28DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT28DC.Search(const Buff: TKDT28DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DC_Node;

var
  NearestNeighbour: PKDT28DC_Node;

  function FindParentNode(const BuffPtr: PKDT28DC_Vec; NodePtr: PKDT28DC_Node): PKDT28DC_Node;
  var
    Next       : PKDT28DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT28DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT28DC_Node; const BuffPtr: PKDT28DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT28DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT28DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT28DC_Vec; const p1, p2: PKDT28DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT28DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT28DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT28DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT28DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT28DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT28DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT28DC_Node(NearestNodes[0]);
    end;
end;

function TKDT28DC.Search(const Buff: TKDT28DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT28DC.Search(const Buff: TKDT28DC_Vec; var SearchedDistanceMin: Double): PKDT28DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT28DC.Search(const Buff: TKDT28DC_Vec): PKDT28DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT28DC.Search(const inBuff: TKDT28DC_DynamicVecBuffer; var OutBuff: TKDT28DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DC_DynamicVecBuffer;
  outBuffPtr : PKDT28DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT28DC_Source));
end;

procedure TKDT28DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT28DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT28DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT28DC.PrintNodeTree(const NodePtr: PKDT28DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT28DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT28DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT28DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT28DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT28DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT28DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT28DC.Test;
var
  TKDT28DC_Test    : TKDT28DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT28DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT28DC_Test := TKDT28DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT28DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT28DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT28DC_AxisCount - 1 do
        TKDT28DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT28DC_Test.TestBuff), length(TKDT28DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT28DC_Test.BuildKDTreeM(False, length(TKDT28DC_Test.TestBuff), @TKDT28DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT28DC_Test.BuildKDTreeM(False, length(TKDT28DC_Test.TestBuff), TKDT28DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT28DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT28DC_Test.TestBuff));
  TKDT28DC_Test.Search(TKDT28DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT28DCDistance(TKDT28DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT28DC_Test.Clear;
  { kMean test }
  TKDT28DC_Test.BuildKDTreeWithCluster(TKDT28DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT28DC_Test.Search(TKDT28DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT28DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT28DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT28DC_Test);
end;

{$ENDIF DEBUG}


function KDT30DCVec(const s: string): TKDT30DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT30DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT30DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT30DCVec(const v: TKDT30DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT30DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT30DCPow(const v: TKDT30DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT30DCDistance(const v1, v2: TKDT30DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT30DC_AxisCount - 1 do
      Result := Result + KDT30DCPow(v2[i] - v1[i]);
end;

function KDT30DCCmpare(const v1, v2: TKDT30DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT30DC_Vec));
end;

function TKDT30DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DC_Node;
  function SortCompare(const p1, p2: PKDT30DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT30DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT30DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT30DC_SourceBuffer;
  dynBuff  : PKDT30DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT30DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT30DC.SearchStoreBuff(const StoreBuffPtr: PKDT30DCyanmicStoreBuffer; const Buff: TKDT30DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT30DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT30DC.GetData(const index: NativeInt): PKDT30DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT30DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT30DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT30DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT30DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT30DC.StoreBuffPtr: PKDT30DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT30DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT30DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT30DC.BuildKDTreeWithCluster(const inBuff: TKDT30DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT30DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT30DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT30DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT30DC.BuildKDTreeWithCluster(const inBuff: TKDT30DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DC_BuildCall);
var
  TempStoreBuff: TKDT30DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DC_BuildMethod);
var
  TempStoreBuff: TKDT30DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DC_BuildProc);
var
  TempStoreBuff: TKDT30DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT30DC.Search(const Buff: TKDT30DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DC_Node;

var
  NearestNeighbour: PKDT30DC_Node;

  function FindParentNode(const BuffPtr: PKDT30DC_Vec; NodePtr: PKDT30DC_Node): PKDT30DC_Node;
  var
    Next       : PKDT30DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT30DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT30DC_Node; const BuffPtr: PKDT30DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT30DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT30DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT30DC_Vec; const p1, p2: PKDT30DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT30DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT30DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT30DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT30DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT30DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT30DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT30DC_Node(NearestNodes[0]);
    end;
end;

function TKDT30DC.Search(const Buff: TKDT30DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT30DC.Search(const Buff: TKDT30DC_Vec; var SearchedDistanceMin: Double): PKDT30DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT30DC.Search(const Buff: TKDT30DC_Vec): PKDT30DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT30DC.Search(const inBuff: TKDT30DC_DynamicVecBuffer; var OutBuff: TKDT30DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DC_DynamicVecBuffer;
  outBuffPtr : PKDT30DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT30DC_Source));
end;

procedure TKDT30DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT30DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT30DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT30DC.PrintNodeTree(const NodePtr: PKDT30DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT30DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT30DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT30DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT30DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT30DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT30DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT30DC.Test;
var
  TKDT30DC_Test    : TKDT30DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT30DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT30DC_Test := TKDT30DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT30DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT30DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT30DC_AxisCount - 1 do
        TKDT30DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT30DC_Test.TestBuff), length(TKDT30DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT30DC_Test.BuildKDTreeM(False, length(TKDT30DC_Test.TestBuff), @TKDT30DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT30DC_Test.BuildKDTreeM(False, length(TKDT30DC_Test.TestBuff), TKDT30DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT30DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT30DC_Test.TestBuff));
  TKDT30DC_Test.Search(TKDT30DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT30DCDistance(TKDT30DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT30DC_Test.Clear;
  { kMean test }
  TKDT30DC_Test.BuildKDTreeWithCluster(TKDT30DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT30DC_Test.Search(TKDT30DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT30DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT30DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT30DC_Test);
end;

{$ENDIF DEBUG}


function KDT32DCVec(const s: string): TKDT32DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT32DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT32DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT32DCVec(const v: TKDT32DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT32DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT32DCPow(const v: TKDT32DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT32DCDistance(const v1, v2: TKDT32DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT32DC_AxisCount - 1 do
      Result := Result + KDT32DCPow(v2[i] - v1[i]);
end;

function KDT32DCCmpare(const v1, v2: TKDT32DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT32DC_Vec));
end;

function TKDT32DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DC_Node;
  function SortCompare(const p1, p2: PKDT32DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT32DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT32DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT32DC_SourceBuffer;
  dynBuff  : PKDT32DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT32DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT32DC.SearchStoreBuff(const StoreBuffPtr: PKDT32DCyanmicStoreBuffer; const Buff: TKDT32DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT32DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT32DC.GetData(const index: NativeInt): PKDT32DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT32DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT32DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT32DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT32DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT32DC.StoreBuffPtr: PKDT32DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT32DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT32DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT32DC.BuildKDTreeWithCluster(const inBuff: TKDT32DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT32DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT32DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT32DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT32DC.BuildKDTreeWithCluster(const inBuff: TKDT32DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DC_BuildCall);
var
  TempStoreBuff: TKDT32DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DC_BuildMethod);
var
  TempStoreBuff: TKDT32DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DC_BuildProc);
var
  TempStoreBuff: TKDT32DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT32DC.Search(const Buff: TKDT32DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DC_Node;

var
  NearestNeighbour: PKDT32DC_Node;

  function FindParentNode(const BuffPtr: PKDT32DC_Vec; NodePtr: PKDT32DC_Node): PKDT32DC_Node;
  var
    Next       : PKDT32DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT32DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT32DC_Node; const BuffPtr: PKDT32DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT32DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT32DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT32DC_Vec; const p1, p2: PKDT32DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT32DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT32DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT32DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT32DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT32DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT32DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT32DC_Node(NearestNodes[0]);
    end;
end;

function TKDT32DC.Search(const Buff: TKDT32DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT32DC.Search(const Buff: TKDT32DC_Vec; var SearchedDistanceMin: Double): PKDT32DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT32DC.Search(const Buff: TKDT32DC_Vec): PKDT32DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT32DC.Search(const inBuff: TKDT32DC_DynamicVecBuffer; var OutBuff: TKDT32DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DC_DynamicVecBuffer;
  outBuffPtr : PKDT32DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT32DC_Source));
end;

procedure TKDT32DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT32DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT32DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT32DC.PrintNodeTree(const NodePtr: PKDT32DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT32DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT32DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT32DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT32DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT32DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT32DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT32DC.Test;
var
  TKDT32DC_Test    : TKDT32DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT32DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT32DC_Test := TKDT32DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT32DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT32DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT32DC_AxisCount - 1 do
        TKDT32DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT32DC_Test.TestBuff), length(TKDT32DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT32DC_Test.BuildKDTreeM(False, length(TKDT32DC_Test.TestBuff), @TKDT32DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT32DC_Test.BuildKDTreeM(False, length(TKDT32DC_Test.TestBuff), TKDT32DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT32DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT32DC_Test.TestBuff));
  TKDT32DC_Test.Search(TKDT32DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT32DCDistance(TKDT32DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT32DC_Test.Clear;
  { kMean test }
  TKDT32DC_Test.BuildKDTreeWithCluster(TKDT32DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT32DC_Test.Search(TKDT32DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT32DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT32DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT32DC_Test);
end;

{$ENDIF DEBUG}


function KDT34DCVec(const s: string): TKDT34DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT34DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT34DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT34DCVec(const v: TKDT34DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT34DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT34DCPow(const v: TKDT34DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT34DCDistance(const v1, v2: TKDT34DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT34DC_AxisCount - 1 do
      Result := Result + KDT34DCPow(v2[i] - v1[i]);
end;

function KDT34DCCmpare(const v1, v2: TKDT34DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT34DC_Vec));
end;

function TKDT34DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DC_Node;
  function SortCompare(const p1, p2: PKDT34DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT34DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT34DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT34DC_SourceBuffer;
  dynBuff  : PKDT34DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT34DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT34DC.SearchStoreBuff(const StoreBuffPtr: PKDT34DCyanmicStoreBuffer; const Buff: TKDT34DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT34DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT34DC.GetData(const index: NativeInt): PKDT34DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT34DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT34DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT34DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT34DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT34DC.StoreBuffPtr: PKDT34DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT34DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT34DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT34DC.BuildKDTreeWithCluster(const inBuff: TKDT34DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT34DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT34DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT34DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT34DC.BuildKDTreeWithCluster(const inBuff: TKDT34DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DC_BuildCall);
var
  TempStoreBuff: TKDT34DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DC_BuildMethod);
var
  TempStoreBuff: TKDT34DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DC_BuildProc);
var
  TempStoreBuff: TKDT34DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT34DC.Search(const Buff: TKDT34DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DC_Node;

var
  NearestNeighbour: PKDT34DC_Node;

  function FindParentNode(const BuffPtr: PKDT34DC_Vec; NodePtr: PKDT34DC_Node): PKDT34DC_Node;
  var
    Next       : PKDT34DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT34DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT34DC_Node; const BuffPtr: PKDT34DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT34DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT34DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT34DC_Vec; const p1, p2: PKDT34DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT34DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT34DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT34DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT34DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT34DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT34DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT34DC_Node(NearestNodes[0]);
    end;
end;

function TKDT34DC.Search(const Buff: TKDT34DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT34DC.Search(const Buff: TKDT34DC_Vec; var SearchedDistanceMin: Double): PKDT34DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT34DC.Search(const Buff: TKDT34DC_Vec): PKDT34DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT34DC.Search(const inBuff: TKDT34DC_DynamicVecBuffer; var OutBuff: TKDT34DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DC_DynamicVecBuffer;
  outBuffPtr : PKDT34DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT34DC_Source));
end;

procedure TKDT34DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT34DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT34DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT34DC.PrintNodeTree(const NodePtr: PKDT34DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT34DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT34DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT34DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT34DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT34DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT34DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT34DC.Test;
var
  TKDT34DC_Test    : TKDT34DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT34DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT34DC_Test := TKDT34DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT34DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT34DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT34DC_AxisCount - 1 do
        TKDT34DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT34DC_Test.TestBuff), length(TKDT34DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT34DC_Test.BuildKDTreeM(False, length(TKDT34DC_Test.TestBuff), @TKDT34DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT34DC_Test.BuildKDTreeM(False, length(TKDT34DC_Test.TestBuff), TKDT34DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT34DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT34DC_Test.TestBuff));
  TKDT34DC_Test.Search(TKDT34DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT34DCDistance(TKDT34DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT34DC_Test.Clear;
  { kMean test }
  TKDT34DC_Test.BuildKDTreeWithCluster(TKDT34DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT34DC_Test.Search(TKDT34DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT34DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT34DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT34DC_Test);
end;

{$ENDIF DEBUG}


function KDT36DCVec(const s: string): TKDT36DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT36DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT36DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT36DCVec(const v: TKDT36DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT36DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT36DCPow(const v: TKDT36DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT36DCDistance(const v1, v2: TKDT36DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT36DC_AxisCount - 1 do
      Result := Result + KDT36DCPow(v2[i] - v1[i]);
end;

function KDT36DCCmpare(const v1, v2: TKDT36DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT36DC_Vec));
end;

function TKDT36DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DC_Node;
  function SortCompare(const p1, p2: PKDT36DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT36DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT36DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT36DC_SourceBuffer;
  dynBuff  : PKDT36DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT36DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT36DC.SearchStoreBuff(const StoreBuffPtr: PKDT36DCyanmicStoreBuffer; const Buff: TKDT36DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT36DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT36DC.GetData(const index: NativeInt): PKDT36DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT36DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT36DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT36DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT36DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT36DC.StoreBuffPtr: PKDT36DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT36DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT36DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT36DC.BuildKDTreeWithCluster(const inBuff: TKDT36DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT36DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT36DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT36DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT36DC.BuildKDTreeWithCluster(const inBuff: TKDT36DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DC_BuildCall);
var
  TempStoreBuff: TKDT36DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DC_BuildMethod);
var
  TempStoreBuff: TKDT36DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DC_BuildProc);
var
  TempStoreBuff: TKDT36DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT36DC.Search(const Buff: TKDT36DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DC_Node;

var
  NearestNeighbour: PKDT36DC_Node;

  function FindParentNode(const BuffPtr: PKDT36DC_Vec; NodePtr: PKDT36DC_Node): PKDT36DC_Node;
  var
    Next       : PKDT36DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT36DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT36DC_Node; const BuffPtr: PKDT36DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT36DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT36DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT36DC_Vec; const p1, p2: PKDT36DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT36DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT36DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT36DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT36DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT36DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT36DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT36DC_Node(NearestNodes[0]);
    end;
end;

function TKDT36DC.Search(const Buff: TKDT36DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT36DC.Search(const Buff: TKDT36DC_Vec; var SearchedDistanceMin: Double): PKDT36DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT36DC.Search(const Buff: TKDT36DC_Vec): PKDT36DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT36DC.Search(const inBuff: TKDT36DC_DynamicVecBuffer; var OutBuff: TKDT36DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DC_DynamicVecBuffer;
  outBuffPtr : PKDT36DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT36DC_Source));
end;

procedure TKDT36DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT36DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT36DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT36DC.PrintNodeTree(const NodePtr: PKDT36DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT36DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT36DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT36DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT36DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT36DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT36DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT36DC.Test;
var
  TKDT36DC_Test    : TKDT36DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT36DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT36DC_Test := TKDT36DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT36DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT36DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT36DC_AxisCount - 1 do
        TKDT36DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT36DC_Test.TestBuff), length(TKDT36DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT36DC_Test.BuildKDTreeM(False, length(TKDT36DC_Test.TestBuff), @TKDT36DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT36DC_Test.BuildKDTreeM(False, length(TKDT36DC_Test.TestBuff), TKDT36DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT36DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT36DC_Test.TestBuff));
  TKDT36DC_Test.Search(TKDT36DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT36DCDistance(TKDT36DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT36DC_Test.Clear;
  { kMean test }
  TKDT36DC_Test.BuildKDTreeWithCluster(TKDT36DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT36DC_Test.Search(TKDT36DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT36DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT36DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT36DC_Test);
end;

{$ENDIF DEBUG}


function KDT40DCVec(const s: string): TKDT40DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT40DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT40DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT40DCVec(const v: TKDT40DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT40DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT40DCPow(const v: TKDT40DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT40DCDistance(const v1, v2: TKDT40DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT40DC_AxisCount - 1 do
      Result := Result + KDT40DCPow(v2[i] - v1[i]);
end;

function KDT40DCCmpare(const v1, v2: TKDT40DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT40DC_Vec));
end;

function TKDT40DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DC_Node;
  function SortCompare(const p1, p2: PKDT40DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT40DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT40DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT40DC_SourceBuffer;
  dynBuff  : PKDT40DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT40DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT40DC.SearchStoreBuff(const StoreBuffPtr: PKDT40DCyanmicStoreBuffer; const Buff: TKDT40DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT40DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT40DC.GetData(const index: NativeInt): PKDT40DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT40DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT40DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT40DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT40DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT40DC.StoreBuffPtr: PKDT40DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT40DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT40DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT40DC.BuildKDTreeWithCluster(const inBuff: TKDT40DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT40DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT40DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT40DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT40DC.BuildKDTreeWithCluster(const inBuff: TKDT40DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DC_BuildCall);
var
  TempStoreBuff: TKDT40DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DC_BuildMethod);
var
  TempStoreBuff: TKDT40DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DC_BuildProc);
var
  TempStoreBuff: TKDT40DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT40DC.Search(const Buff: TKDT40DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DC_Node;

var
  NearestNeighbour: PKDT40DC_Node;

  function FindParentNode(const BuffPtr: PKDT40DC_Vec; NodePtr: PKDT40DC_Node): PKDT40DC_Node;
  var
    Next       : PKDT40DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT40DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT40DC_Node; const BuffPtr: PKDT40DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT40DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT40DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT40DC_Vec; const p1, p2: PKDT40DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT40DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT40DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT40DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT40DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT40DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT40DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT40DC_Node(NearestNodes[0]);
    end;
end;

function TKDT40DC.Search(const Buff: TKDT40DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT40DC.Search(const Buff: TKDT40DC_Vec; var SearchedDistanceMin: Double): PKDT40DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT40DC.Search(const Buff: TKDT40DC_Vec): PKDT40DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT40DC.Search(const inBuff: TKDT40DC_DynamicVecBuffer; var OutBuff: TKDT40DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DC_DynamicVecBuffer;
  outBuffPtr : PKDT40DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT40DC_Source));
end;

procedure TKDT40DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT40DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT40DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT40DC.PrintNodeTree(const NodePtr: PKDT40DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT40DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT40DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT40DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT40DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT40DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT40DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT40DC.Test;
var
  TKDT40DC_Test    : TKDT40DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT40DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT40DC_Test := TKDT40DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT40DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT40DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT40DC_AxisCount - 1 do
        TKDT40DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT40DC_Test.TestBuff), length(TKDT40DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT40DC_Test.BuildKDTreeM(False, length(TKDT40DC_Test.TestBuff), @TKDT40DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT40DC_Test.BuildKDTreeM(False, length(TKDT40DC_Test.TestBuff), TKDT40DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT40DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT40DC_Test.TestBuff));
  TKDT40DC_Test.Search(TKDT40DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT40DCDistance(TKDT40DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT40DC_Test.Clear;
  { kMean test }
  TKDT40DC_Test.BuildKDTreeWithCluster(TKDT40DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT40DC_Test.Search(TKDT40DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT40DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT40DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT40DC_Test);
end;

{$ENDIF DEBUG}


function KDT48DCVec(const s: string): TKDT48DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT48DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT48DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT48DCVec(const v: TKDT48DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT48DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT48DCPow(const v: TKDT48DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT48DCDistance(const v1, v2: TKDT48DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT48DC_AxisCount - 1 do
      Result := Result + KDT48DCPow(v2[i] - v1[i]);
end;

function KDT48DCCmpare(const v1, v2: TKDT48DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT48DC_Vec));
end;

function TKDT48DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DC_Node;
  function SortCompare(const p1, p2: PKDT48DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT48DC_SourceBuffer;
  dynBuff  : PKDT48DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT48DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DC.SearchStoreBuff(const StoreBuffPtr: PKDT48DCyanmicStoreBuffer; const Buff: TKDT48DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT48DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT48DC.GetData(const index: NativeInt): PKDT48DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT48DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DC.StoreBuffPtr: PKDT48DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT48DC.BuildKDTreeWithCluster(const inBuff: TKDT48DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT48DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT48DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT48DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DC.BuildKDTreeWithCluster(const inBuff: TKDT48DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DC_BuildCall);
var
  TempStoreBuff: TKDT48DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DC_BuildMethod);
var
  TempStoreBuff: TKDT48DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DC_BuildProc);
var
  TempStoreBuff: TKDT48DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT48DC.Search(const Buff: TKDT48DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DC_Node;

var
  NearestNeighbour: PKDT48DC_Node;

  function FindParentNode(const BuffPtr: PKDT48DC_Vec; NodePtr: PKDT48DC_Node): PKDT48DC_Node;
  var
    Next       : PKDT48DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT48DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DC_Node; const BuffPtr: PKDT48DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT48DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT48DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT48DC_Vec; const p1, p2: PKDT48DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT48DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT48DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT48DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT48DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT48DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DC_Node(NearestNodes[0]);
    end;
end;

function TKDT48DC.Search(const Buff: TKDT48DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DC.Search(const Buff: TKDT48DC_Vec; var SearchedDistanceMin: Double): PKDT48DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DC.Search(const Buff: TKDT48DC_Vec): PKDT48DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT48DC.Search(const inBuff: TKDT48DC_DynamicVecBuffer; var OutBuff: TKDT48DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DC_DynamicVecBuffer;
  outBuffPtr : PKDT48DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT48DC_Source));
end;

procedure TKDT48DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT48DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT48DC.PrintNodeTree(const NodePtr: PKDT48DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT48DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT48DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT48DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT48DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT48DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT48DC.Test;
var
  TKDT48DC_Test    : TKDT48DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT48DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT48DC_Test := TKDT48DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT48DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT48DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT48DC_AxisCount - 1 do
        TKDT48DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT48DC_Test.TestBuff), length(TKDT48DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT48DC_Test.BuildKDTreeM(False, length(TKDT48DC_Test.TestBuff), @TKDT48DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT48DC_Test.BuildKDTreeM(False, length(TKDT48DC_Test.TestBuff), TKDT48DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT48DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT48DC_Test.TestBuff));
  TKDT48DC_Test.Search(TKDT48DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT48DCDistance(TKDT48DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT48DC_Test.Clear;
  { kMean test }
  TKDT48DC_Test.BuildKDTreeWithCluster(TKDT48DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT48DC_Test.Search(TKDT48DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT48DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT48DC_Test);
end;

{$ENDIF DEBUG}


function KDT64DCVec(const s: string): TKDT64DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT64DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT64DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT64DCVec(const v: TKDT64DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT64DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT64DCPow(const v: TKDT64DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT64DCDistance(const v1, v2: TKDT64DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT64DC_AxisCount - 1 do
      Result := Result + KDT64DCPow(v2[i] - v1[i]);
end;

function KDT64DCCmpare(const v1, v2: TKDT64DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT64DC_Vec));
end;

function TKDT64DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DC_Node;
  function SortCompare(const p1, p2: PKDT64DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT64DC_SourceBuffer;
  dynBuff  : PKDT64DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT64DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DC.SearchStoreBuff(const StoreBuffPtr: PKDT64DCyanmicStoreBuffer; const Buff: TKDT64DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT64DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT64DC.GetData(const index: NativeInt): PKDT64DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT64DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DC.StoreBuffPtr: PKDT64DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT64DC.BuildKDTreeWithCluster(const inBuff: TKDT64DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT64DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT64DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT64DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DC.BuildKDTreeWithCluster(const inBuff: TKDT64DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DC_BuildCall);
var
  TempStoreBuff: TKDT64DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DC_BuildMethod);
var
  TempStoreBuff: TKDT64DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DC_BuildProc);
var
  TempStoreBuff: TKDT64DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT64DC.Search(const Buff: TKDT64DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DC_Node;

var
  NearestNeighbour: PKDT64DC_Node;

  function FindParentNode(const BuffPtr: PKDT64DC_Vec; NodePtr: PKDT64DC_Node): PKDT64DC_Node;
  var
    Next       : PKDT64DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT64DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DC_Node; const BuffPtr: PKDT64DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT64DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT64DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT64DC_Vec; const p1, p2: PKDT64DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT64DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT64DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT64DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT64DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT64DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DC_Node(NearestNodes[0]);
    end;
end;

function TKDT64DC.Search(const Buff: TKDT64DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DC.Search(const Buff: TKDT64DC_Vec; var SearchedDistanceMin: Double): PKDT64DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DC.Search(const Buff: TKDT64DC_Vec): PKDT64DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT64DC.Search(const inBuff: TKDT64DC_DynamicVecBuffer; var OutBuff: TKDT64DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DC_DynamicVecBuffer;
  outBuffPtr : PKDT64DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT64DC_Source));
end;

procedure TKDT64DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT64DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT64DC.PrintNodeTree(const NodePtr: PKDT64DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT64DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT64DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT64DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT64DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT64DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT64DC.Test;
var
  TKDT64DC_Test    : TKDT64DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT64DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT64DC_Test := TKDT64DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT64DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT64DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT64DC_AxisCount - 1 do
        TKDT64DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT64DC_Test.TestBuff), length(TKDT64DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT64DC_Test.BuildKDTreeM(False, length(TKDT64DC_Test.TestBuff), @TKDT64DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT64DC_Test.BuildKDTreeM(False, length(TKDT64DC_Test.TestBuff), TKDT64DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT64DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT64DC_Test.TestBuff));
  TKDT64DC_Test.Search(TKDT64DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT64DCDistance(TKDT64DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT64DC_Test.Clear;
  { kMean test }
  TKDT64DC_Test.BuildKDTreeWithCluster(TKDT64DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT64DC_Test.Search(TKDT64DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT64DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT64DC_Test);
end;

{$ENDIF DEBUG}


function KDT96DCVec(const s: string): TKDT96DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT96DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT96DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT96DCVec(const v: TKDT96DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT96DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT96DCPow(const v: TKDT96DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT96DCDistance(const v1, v2: TKDT96DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT96DC_AxisCount - 1 do
      Result := Result + KDT96DCPow(v2[i] - v1[i]);
end;

function KDT96DCCmpare(const v1, v2: TKDT96DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT96DC_Vec));
end;

function TKDT96DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DC_Node;
  function SortCompare(const p1, p2: PKDT96DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT96DC_SourceBuffer;
  dynBuff  : PKDT96DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT96DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DC.SearchStoreBuff(const StoreBuffPtr: PKDT96DCyanmicStoreBuffer; const Buff: TKDT96DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT96DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT96DC.GetData(const index: NativeInt): PKDT96DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT96DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DC.StoreBuffPtr: PKDT96DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT96DC.BuildKDTreeWithCluster(const inBuff: TKDT96DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT96DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT96DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT96DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DC.BuildKDTreeWithCluster(const inBuff: TKDT96DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DC_BuildCall);
var
  TempStoreBuff: TKDT96DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DC_BuildMethod);
var
  TempStoreBuff: TKDT96DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DC_BuildProc);
var
  TempStoreBuff: TKDT96DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT96DC.Search(const Buff: TKDT96DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DC_Node;

var
  NearestNeighbour: PKDT96DC_Node;

  function FindParentNode(const BuffPtr: PKDT96DC_Vec; NodePtr: PKDT96DC_Node): PKDT96DC_Node;
  var
    Next       : PKDT96DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT96DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DC_Node; const BuffPtr: PKDT96DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT96DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT96DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT96DC_Vec; const p1, p2: PKDT96DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT96DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT96DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT96DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT96DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT96DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DC_Node(NearestNodes[0]);
    end;
end;

function TKDT96DC.Search(const Buff: TKDT96DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DC.Search(const Buff: TKDT96DC_Vec; var SearchedDistanceMin: Double): PKDT96DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DC.Search(const Buff: TKDT96DC_Vec): PKDT96DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT96DC.Search(const inBuff: TKDT96DC_DynamicVecBuffer; var OutBuff: TKDT96DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DC_DynamicVecBuffer;
  outBuffPtr : PKDT96DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT96DC_Source));
end;

procedure TKDT96DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT96DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT96DC.PrintNodeTree(const NodePtr: PKDT96DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT96DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT96DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT96DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT96DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT96DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT96DC.Test;
var
  TKDT96DC_Test    : TKDT96DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT96DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT96DC_Test := TKDT96DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT96DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT96DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT96DC_AxisCount - 1 do
        TKDT96DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT96DC_Test.TestBuff), length(TKDT96DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT96DC_Test.BuildKDTreeM(False, length(TKDT96DC_Test.TestBuff), @TKDT96DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT96DC_Test.BuildKDTreeM(False, length(TKDT96DC_Test.TestBuff), TKDT96DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT96DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT96DC_Test.TestBuff));
  TKDT96DC_Test.Search(TKDT96DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT96DCDistance(TKDT96DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT96DC_Test.Clear;
  { kMean test }
  TKDT96DC_Test.BuildKDTreeWithCluster(TKDT96DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT96DC_Test.Search(TKDT96DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT96DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT96DC_Test);
end;

{$ENDIF DEBUG}


function KDT128DCVec(const s: string): TKDT128DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT128DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT128DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT128DCVec(const v: TKDT128DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT128DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT128DCPow(const v: TKDT128DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT128DCDistance(const v1, v2: TKDT128DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT128DC_AxisCount - 1 do
      Result := Result + KDT128DCPow(v2[i] - v1[i]);
end;

function KDT128DCCmpare(const v1, v2: TKDT128DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT128DC_Vec));
end;

function TKDT128DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DC_Node;
  function SortCompare(const p1, p2: PKDT128DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT128DC_SourceBuffer;
  dynBuff  : PKDT128DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT128DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DC.SearchStoreBuff(const StoreBuffPtr: PKDT128DCyanmicStoreBuffer; const Buff: TKDT128DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT128DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT128DC.GetData(const index: NativeInt): PKDT128DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT128DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DC.StoreBuffPtr: PKDT128DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT128DC.BuildKDTreeWithCluster(const inBuff: TKDT128DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT128DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT128DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT128DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DC.BuildKDTreeWithCluster(const inBuff: TKDT128DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DC_BuildCall);
var
  TempStoreBuff: TKDT128DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DC_BuildMethod);
var
  TempStoreBuff: TKDT128DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DC_BuildProc);
var
  TempStoreBuff: TKDT128DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT128DC.Search(const Buff: TKDT128DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DC_Node;

var
  NearestNeighbour: PKDT128DC_Node;

  function FindParentNode(const BuffPtr: PKDT128DC_Vec; NodePtr: PKDT128DC_Node): PKDT128DC_Node;
  var
    Next       : PKDT128DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT128DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DC_Node; const BuffPtr: PKDT128DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT128DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT128DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT128DC_Vec; const p1, p2: PKDT128DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT128DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT128DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT128DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT128DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT128DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DC_Node(NearestNodes[0]);
    end;
end;

function TKDT128DC.Search(const Buff: TKDT128DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DC.Search(const Buff: TKDT128DC_Vec; var SearchedDistanceMin: Double): PKDT128DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DC.Search(const Buff: TKDT128DC_Vec): PKDT128DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT128DC.Search(const inBuff: TKDT128DC_DynamicVecBuffer; var OutBuff: TKDT128DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DC_DynamicVecBuffer;
  outBuffPtr : PKDT128DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT128DC_Source));
end;

procedure TKDT128DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT128DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT128DC.PrintNodeTree(const NodePtr: PKDT128DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT128DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT128DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT128DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT128DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT128DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT128DC.Test;
var
  TKDT128DC_Test    : TKDT128DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT128DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT128DC_Test := TKDT128DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT128DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT128DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT128DC_AxisCount - 1 do
        TKDT128DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT128DC_Test.TestBuff), length(TKDT128DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT128DC_Test.BuildKDTreeM(False, length(TKDT128DC_Test.TestBuff), @TKDT128DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT128DC_Test.BuildKDTreeM(False, length(TKDT128DC_Test.TestBuff), TKDT128DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT128DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT128DC_Test.TestBuff));
  TKDT128DC_Test.Search(TKDT128DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT128DCDistance(TKDT128DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT128DC_Test.Clear;
  { kMean test }
  TKDT128DC_Test.BuildKDTreeWithCluster(TKDT128DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT128DC_Test.Search(TKDT128DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT128DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT128DC_Test);
end;

{$ENDIF DEBUG}


function KDT256DCVec(const s: string): TKDT256DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT256DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT256DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT256DCVec(const v: TKDT256DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT256DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT256DCPow(const v: TKDT256DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT256DCDistance(const v1, v2: TKDT256DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT256DC_AxisCount - 1 do
      Result := Result + KDT256DCPow(v2[i] - v1[i]);
end;

function KDT256DCCmpare(const v1, v2: TKDT256DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT256DC_Vec));
end;

function TKDT256DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DC_Node;
  function SortCompare(const p1, p2: PKDT256DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT256DC_SourceBuffer;
  dynBuff  : PKDT256DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT256DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DC.SearchStoreBuff(const StoreBuffPtr: PKDT256DCyanmicStoreBuffer; const Buff: TKDT256DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT256DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT256DC.GetData(const index: NativeInt): PKDT256DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT256DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DC.StoreBuffPtr: PKDT256DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT256DC.BuildKDTreeWithCluster(const inBuff: TKDT256DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT256DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT256DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT256DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DC.BuildKDTreeWithCluster(const inBuff: TKDT256DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DC_BuildCall);
var
  TempStoreBuff: TKDT256DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DC_BuildMethod);
var
  TempStoreBuff: TKDT256DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DC_BuildProc);
var
  TempStoreBuff: TKDT256DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT256DC.Search(const Buff: TKDT256DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DC_Node;

var
  NearestNeighbour: PKDT256DC_Node;

  function FindParentNode(const BuffPtr: PKDT256DC_Vec; NodePtr: PKDT256DC_Node): PKDT256DC_Node;
  var
    Next       : PKDT256DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT256DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DC_Node; const BuffPtr: PKDT256DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT256DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT256DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT256DC_Vec; const p1, p2: PKDT256DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT256DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT256DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT256DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT256DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT256DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DC_Node(NearestNodes[0]);
    end;
end;

function TKDT256DC.Search(const Buff: TKDT256DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DC.Search(const Buff: TKDT256DC_Vec; var SearchedDistanceMin: Double): PKDT256DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DC.Search(const Buff: TKDT256DC_Vec): PKDT256DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT256DC.Search(const inBuff: TKDT256DC_DynamicVecBuffer; var OutBuff: TKDT256DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DC_DynamicVecBuffer;
  outBuffPtr : PKDT256DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT256DC_Source));
end;

procedure TKDT256DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT256DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT256DC.PrintNodeTree(const NodePtr: PKDT256DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT256DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT256DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT256DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT256DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT256DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT256DC.Test;
var
  TKDT256DC_Test    : TKDT256DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT256DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT256DC_Test := TKDT256DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT256DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT256DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT256DC_AxisCount - 1 do
        TKDT256DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT256DC_Test.TestBuff), length(TKDT256DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT256DC_Test.BuildKDTreeM(False, length(TKDT256DC_Test.TestBuff), @TKDT256DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT256DC_Test.BuildKDTreeM(False, length(TKDT256DC_Test.TestBuff), TKDT256DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT256DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT256DC_Test.TestBuff));
  TKDT256DC_Test.Search(TKDT256DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT256DCDistance(TKDT256DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT256DC_Test.Clear;
  { kMean test }
  TKDT256DC_Test.BuildKDTreeWithCluster(TKDT256DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT256DC_Test.Search(TKDT256DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT256DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT256DC_Test);
end;

{$ENDIF DEBUG}


function KDT372DCVec(const s: string): TKDT372DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT372DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT372DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT372DCVec(const v: TKDT372DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT372DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT372DCPow(const v: TKDT372DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT372DCDistance(const v1, v2: TKDT372DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT372DC_AxisCount - 1 do
      Result := Result + KDT372DCPow(v2[i] - v1[i]);
end;

function KDT372DCCmpare(const v1, v2: TKDT372DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT372DC_Vec));
end;

function TKDT372DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DC_Node;
  function SortCompare(const p1, p2: PKDT372DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT372DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT372DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT372DC_SourceBuffer;
  dynBuff  : PKDT372DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT372DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT372DC.SearchStoreBuff(const StoreBuffPtr: PKDT372DCyanmicStoreBuffer; const Buff: TKDT372DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT372DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT372DC.GetData(const index: NativeInt): PKDT372DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT372DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT372DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT372DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT372DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT372DC.StoreBuffPtr: PKDT372DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT372DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT372DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT372DC.BuildKDTreeWithCluster(const inBuff: TKDT372DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT372DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT372DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT372DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT372DC.BuildKDTreeWithCluster(const inBuff: TKDT372DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DC_BuildCall);
var
  TempStoreBuff: TKDT372DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DC_BuildMethod);
var
  TempStoreBuff: TKDT372DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DC_BuildProc);
var
  TempStoreBuff: TKDT372DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT372DC.Search(const Buff: TKDT372DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DC_Node;

var
  NearestNeighbour: PKDT372DC_Node;

  function FindParentNode(const BuffPtr: PKDT372DC_Vec; NodePtr: PKDT372DC_Node): PKDT372DC_Node;
  var
    Next       : PKDT372DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT372DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT372DC_Node; const BuffPtr: PKDT372DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT372DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT372DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT372DC_Vec; const p1, p2: PKDT372DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT372DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT372DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT372DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT372DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT372DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT372DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT372DC_Node(NearestNodes[0]);
    end;
end;

function TKDT372DC.Search(const Buff: TKDT372DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT372DC.Search(const Buff: TKDT372DC_Vec; var SearchedDistanceMin: Double): PKDT372DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT372DC.Search(const Buff: TKDT372DC_Vec): PKDT372DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT372DC.Search(const inBuff: TKDT372DC_DynamicVecBuffer; var OutBuff: TKDT372DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DC_DynamicVecBuffer;
  outBuffPtr : PKDT372DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT372DC_Source));
end;

procedure TKDT372DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT372DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT372DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT372DC.PrintNodeTree(const NodePtr: PKDT372DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT372DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT372DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT372DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT372DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT372DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT372DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT372DC.Test;
var
  TKDT372DC_Test    : TKDT372DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT372DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT372DC_Test := TKDT372DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT372DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT372DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT372DC_AxisCount - 1 do
        TKDT372DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT372DC_Test.TestBuff), length(TKDT372DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT372DC_Test.BuildKDTreeM(False, length(TKDT372DC_Test.TestBuff), @TKDT372DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT372DC_Test.BuildKDTreeM(False, length(TKDT372DC_Test.TestBuff), TKDT372DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT372DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT372DC_Test.TestBuff));
  TKDT372DC_Test.Search(TKDT372DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT372DCDistance(TKDT372DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT372DC_Test.Clear;
  { kMean test }
  TKDT372DC_Test.BuildKDTreeWithCluster(TKDT372DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT372DC_Test.Search(TKDT372DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT372DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT372DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT372DC_Test);
end;

{$ENDIF DEBUG}


function KDT512DCVec(const s: string): TKDT512DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT512DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT512DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT512DCVec(const v: TKDT512DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT512DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT512DCPow(const v: TKDT512DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT512DCDistance(const v1, v2: TKDT512DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT512DC_AxisCount - 1 do
      Result := Result + KDT512DCPow(v2[i] - v1[i]);
end;

function KDT512DCCmpare(const v1, v2: TKDT512DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT512DC_Vec));
end;

function TKDT512DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DC_Node;
  function SortCompare(const p1, p2: PKDT512DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT512DC_SourceBuffer;
  dynBuff  : PKDT512DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT512DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DC.SearchStoreBuff(const StoreBuffPtr: PKDT512DCyanmicStoreBuffer; const Buff: TKDT512DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT512DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT512DC.GetData(const index: NativeInt): PKDT512DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT512DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DC.StoreBuffPtr: PKDT512DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT512DC.BuildKDTreeWithCluster(const inBuff: TKDT512DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT512DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT512DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT512DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DC.BuildKDTreeWithCluster(const inBuff: TKDT512DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DC_BuildCall);
var
  TempStoreBuff: TKDT512DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DC_BuildMethod);
var
  TempStoreBuff: TKDT512DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DC_BuildProc);
var
  TempStoreBuff: TKDT512DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT512DC.Search(const Buff: TKDT512DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DC_Node;

var
  NearestNeighbour: PKDT512DC_Node;

  function FindParentNode(const BuffPtr: PKDT512DC_Vec; NodePtr: PKDT512DC_Node): PKDT512DC_Node;
  var
    Next       : PKDT512DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT512DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DC_Node; const BuffPtr: PKDT512DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT512DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT512DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT512DC_Vec; const p1, p2: PKDT512DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT512DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT512DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT512DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT512DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT512DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DC_Node(NearestNodes[0]);
    end;
end;

function TKDT512DC.Search(const Buff: TKDT512DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DC.Search(const Buff: TKDT512DC_Vec; var SearchedDistanceMin: Double): PKDT512DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DC.Search(const Buff: TKDT512DC_Vec): PKDT512DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT512DC.Search(const inBuff: TKDT512DC_DynamicVecBuffer; var OutBuff: TKDT512DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DC_DynamicVecBuffer;
  outBuffPtr : PKDT512DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT512DC_Source));
end;

procedure TKDT512DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT512DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT512DC.PrintNodeTree(const NodePtr: PKDT512DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT512DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT512DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT512DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT512DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT512DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT512DC.Test;
var
  TKDT512DC_Test    : TKDT512DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT512DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT512DC_Test := TKDT512DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT512DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT512DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT512DC_AxisCount - 1 do
        TKDT512DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT512DC_Test.TestBuff), length(TKDT512DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT512DC_Test.BuildKDTreeM(False, length(TKDT512DC_Test.TestBuff), @TKDT512DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT512DC_Test.BuildKDTreeM(False, length(TKDT512DC_Test.TestBuff), TKDT512DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT512DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT512DC_Test.TestBuff));
  TKDT512DC_Test.Search(TKDT512DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT512DCDistance(TKDT512DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT512DC_Test.Clear;
  { kMean test }
  TKDT512DC_Test.BuildKDTreeWithCluster(TKDT512DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT512DC_Test.Search(TKDT512DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT512DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT512DC_Test);
end;

{$ENDIF DEBUG}


function KDT640DCVec(const s: string): TKDT640DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT640DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT640DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT640DCVec(const v: TKDT640DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT640DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT640DCPow(const v: TKDT640DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT640DCDistance(const v1, v2: TKDT640DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT640DC_AxisCount - 1 do
      Result := Result + KDT640DCPow(v2[i] - v1[i]);
end;

function KDT640DCCmpare(const v1, v2: TKDT640DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT640DC_Vec));
end;

function TKDT640DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT640DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT640DC_Node;
  function SortCompare(const p1, p2: PKDT640DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT640DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT640DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT640DC_SourceBuffer;
  dynBuff  : PKDT640DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT640DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT640DC.SearchStoreBuff(const StoreBuffPtr: PKDT640DCyanmicStoreBuffer; const Buff: TKDT640DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT640DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT640DC.GetData(const index: NativeInt): PKDT640DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT640DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT640DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT640DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT640DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT640DC.StoreBuffPtr: PKDT640DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT640DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT640DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT640DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT640DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT640DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT640DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT640DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT640DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT640DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT640DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT640DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT640DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT640DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT640DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT640DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT640DC.BuildKDTreeWithCluster(const inBuff: TKDT640DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT640DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT640DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT640DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT640DC.BuildKDTreeWithCluster(const inBuff: TKDT640DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT640DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DC_BuildCall);
var
  TempStoreBuff: TKDT640DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT640DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT640DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT640DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT640DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT640DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT640DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DC_BuildMethod);
var
  TempStoreBuff: TKDT640DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT640DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT640DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT640DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT640DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT640DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT640DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DC_BuildProc);
var
  TempStoreBuff: TKDT640DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT640DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT640DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT640DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT640DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT640DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT640DC.Search(const Buff: TKDT640DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT640DC_Node;

var
  NearestNeighbour: PKDT640DC_Node;

  function FindParentNode(const BuffPtr: PKDT640DC_Vec; NodePtr: PKDT640DC_Node): PKDT640DC_Node;
  var
    Next       : PKDT640DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT640DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT640DC_Node; const BuffPtr: PKDT640DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT640DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT640DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT640DC_Vec; const p1, p2: PKDT640DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT640DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT640DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT640DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT640DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT640DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT640DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT640DC_Node(NearestNodes[0]);
    end;
end;

function TKDT640DC.Search(const Buff: TKDT640DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT640DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT640DC.Search(const Buff: TKDT640DC_Vec; var SearchedDistanceMin: Double): PKDT640DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT640DC.Search(const Buff: TKDT640DC_Vec): PKDT640DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT640DC.Search(const inBuff: TKDT640DC_DynamicVecBuffer; var OutBuff: TKDT640DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT640DC_DynamicVecBuffer;
  outBuffPtr : PKDT640DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT640DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT640DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT640DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT640DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT640DC_Source));
end;

procedure TKDT640DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT640DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT640DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT640DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT640DC.PrintNodeTree(const NodePtr: PKDT640DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT640DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT640DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT640DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT640DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT640DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT640DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT640DC.Test;
var
  TKDT640DC_Test    : TKDT640DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT640DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT640DC_Test := TKDT640DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT640DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT640DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT640DC_AxisCount - 1 do
        TKDT640DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT640DC_Test.TestBuff), length(TKDT640DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT640DC_Test.BuildKDTreeM(False, length(TKDT640DC_Test.TestBuff), @TKDT640DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT640DC_Test.BuildKDTreeM(False, length(TKDT640DC_Test.TestBuff), TKDT640DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT640DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT640DC_Test.TestBuff));
  TKDT640DC_Test.Search(TKDT640DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT640DCDistance(TKDT640DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT640DC_Test.Clear;
  { kMean test }
  TKDT640DC_Test.BuildKDTreeWithCluster(TKDT640DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT640DC_Test.Search(TKDT640DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT640DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT640DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT640DC_Test);
end;

{$ENDIF DEBUG}


function KDT768DCVec(const s: string): TKDT768DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT768DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT768DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT768DCVec(const v: TKDT768DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT768DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT768DCPow(const v: TKDT768DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT768DCDistance(const v1, v2: TKDT768DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT768DC_AxisCount - 1 do
      Result := Result + KDT768DCPow(v2[i] - v1[i]);
end;

function KDT768DCCmpare(const v1, v2: TKDT768DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT768DC_Vec));
end;

function TKDT768DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DC_Node;
  function SortCompare(const p1, p2: PKDT768DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT768DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT768DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT768DC_SourceBuffer;
  dynBuff  : PKDT768DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT768DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT768DC.SearchStoreBuff(const StoreBuffPtr: PKDT768DCyanmicStoreBuffer; const Buff: TKDT768DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT768DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT768DC.GetData(const index: NativeInt): PKDT768DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT768DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT768DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT768DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT768DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT768DC.StoreBuffPtr: PKDT768DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT768DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT768DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT768DC.BuildKDTreeWithCluster(const inBuff: TKDT768DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT768DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT768DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT768DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT768DC.BuildKDTreeWithCluster(const inBuff: TKDT768DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DC_BuildCall);
var
  TempStoreBuff: TKDT768DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DC_BuildMethod);
var
  TempStoreBuff: TKDT768DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DC_BuildProc);
var
  TempStoreBuff: TKDT768DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT768DC.Search(const Buff: TKDT768DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DC_Node;

var
  NearestNeighbour: PKDT768DC_Node;

  function FindParentNode(const BuffPtr: PKDT768DC_Vec; NodePtr: PKDT768DC_Node): PKDT768DC_Node;
  var
    Next       : PKDT768DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT768DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT768DC_Node; const BuffPtr: PKDT768DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT768DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT768DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT768DC_Vec; const p1, p2: PKDT768DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT768DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT768DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT768DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT768DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT768DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT768DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT768DC_Node(NearestNodes[0]);
    end;
end;

function TKDT768DC.Search(const Buff: TKDT768DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT768DC.Search(const Buff: TKDT768DC_Vec; var SearchedDistanceMin: Double): PKDT768DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT768DC.Search(const Buff: TKDT768DC_Vec): PKDT768DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT768DC.Search(const inBuff: TKDT768DC_DynamicVecBuffer; var OutBuff: TKDT768DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DC_DynamicVecBuffer;
  outBuffPtr : PKDT768DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT768DC_Source));
end;

procedure TKDT768DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT768DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT768DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT768DC.PrintNodeTree(const NodePtr: PKDT768DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT768DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT768DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT768DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT768DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT768DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT768DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT768DC.Test;
var
  TKDT768DC_Test    : TKDT768DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT768DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT768DC_Test := TKDT768DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT768DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT768DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT768DC_AxisCount - 1 do
        TKDT768DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT768DC_Test.TestBuff), length(TKDT768DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT768DC_Test.BuildKDTreeM(False, length(TKDT768DC_Test.TestBuff), @TKDT768DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT768DC_Test.BuildKDTreeM(False, length(TKDT768DC_Test.TestBuff), TKDT768DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT768DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT768DC_Test.TestBuff));
  TKDT768DC_Test.Search(TKDT768DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT768DCDistance(TKDT768DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT768DC_Test.Clear;
  { kMean test }
  TKDT768DC_Test.BuildKDTreeWithCluster(TKDT768DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT768DC_Test.Search(TKDT768DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT768DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT768DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT768DC_Test);
end;

{$ENDIF DEBUG}


function KDT1024DCVec(const s: string): TKDT1024DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1024DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1024DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1024DCVec(const v: TKDT1024DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1024DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1024DCPow(const v: TKDT1024DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT1024DCDistance(const v1, v2: TKDT1024DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1024DC_AxisCount - 1 do
      Result := Result + KDT1024DCPow(v2[i] - v1[i]);
end;

function KDT1024DCCmpare(const v1, v2: TKDT1024DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1024DC_Vec));
end;

function TKDT1024DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DC_Node;
  function SortCompare(const p1, p2: PKDT1024DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1024DC_SourceBuffer;
  dynBuff  : PKDT1024DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1024DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DC.SearchStoreBuff(const StoreBuffPtr: PKDT1024DCyanmicStoreBuffer; const Buff: TKDT1024DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1024DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1024DC.GetData(const index: NativeInt): PKDT1024DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1024DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DC.StoreBuffPtr: PKDT1024DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1024DC.BuildKDTreeWithCluster(const inBuff: TKDT1024DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1024DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1024DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1024DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DC.BuildKDTreeWithCluster(const inBuff: TKDT1024DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DC_BuildCall);
var
  TempStoreBuff: TKDT1024DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DC_BuildMethod);
var
  TempStoreBuff: TKDT1024DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DC_BuildProc);
var
  TempStoreBuff: TKDT1024DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1024DC.Search(const Buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DC_Node;

var
  NearestNeighbour: PKDT1024DC_Node;

  function FindParentNode(const BuffPtr: PKDT1024DC_Vec; NodePtr: PKDT1024DC_Node): PKDT1024DC_Node;
  var
    Next       : PKDT1024DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1024DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DC_Node; const BuffPtr: PKDT1024DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1024DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1024DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1024DC_Vec; const p1, p2: PKDT1024DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1024DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1024DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1024DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1024DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1024DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DC_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DC.Search(const Buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DC.Search(const Buff: TKDT1024DC_Vec; var SearchedDistanceMin: Double): PKDT1024DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DC.Search(const Buff: TKDT1024DC_Vec): PKDT1024DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1024DC.Search(const inBuff: TKDT1024DC_DynamicVecBuffer; var OutBuff: TKDT1024DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DC_DynamicVecBuffer;
  outBuffPtr : PKDT1024DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1024DC_Source));
end;

procedure TKDT1024DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1024DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1024DC.PrintNodeTree(const NodePtr: PKDT1024DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1024DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1024DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1024DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1024DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1024DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1024DC.Test;
var
  TKDT1024DC_Test    : TKDT1024DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1024DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1024DC_Test := TKDT1024DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1024DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT1024DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT1024DC_AxisCount - 1 do
        TKDT1024DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1024DC_Test.TestBuff), length(TKDT1024DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1024DC_Test.BuildKDTreeM(False, length(TKDT1024DC_Test.TestBuff), @TKDT1024DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1024DC_Test.BuildKDTreeM(False, length(TKDT1024DC_Test.TestBuff), TKDT1024DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1024DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1024DC_Test.TestBuff));
  TKDT1024DC_Test.Search(TKDT1024DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1024DCDistance(TKDT1024DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1024DC_Test.Clear;
  { kMean test }
  TKDT1024DC_Test.BuildKDTreeWithCluster(TKDT1024DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1024DC_Test.Search(TKDT1024DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1024DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1024DC_Test);
end;

{$ENDIF DEBUG}


function KDT1080DCVec(const s: string): TKDT1080DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1080DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1080DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1080DCVec(const v: TKDT1080DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1080DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1080DCPow(const v: TKDT1080DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT1080DCDistance(const v1, v2: TKDT1080DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1080DC_AxisCount - 1 do
      Result := Result + KDT1080DCPow(v2[i] - v1[i]);
end;

function KDT1080DCCmpare(const v1, v2: TKDT1080DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1080DC_Vec));
end;

function TKDT1080DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1080DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1080DC_Node;
  function SortCompare(const p1, p2: PKDT1080DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1080DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1080DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1080DC_SourceBuffer;
  dynBuff  : PKDT1080DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1080DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1080DC.SearchStoreBuff(const StoreBuffPtr: PKDT1080DCyanmicStoreBuffer; const Buff: TKDT1080DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1080DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1080DC.GetData(const index: NativeInt): PKDT1080DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1080DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1080DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1080DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1080DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1080DC.StoreBuffPtr: PKDT1080DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1080DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1080DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1080DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1080DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1080DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1080DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1080DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1080DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1080DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1080DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1080DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1080DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1080DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1080DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1080DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1080DC.BuildKDTreeWithCluster(const inBuff: TKDT1080DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1080DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1080DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1080DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1080DC.BuildKDTreeWithCluster(const inBuff: TKDT1080DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1080DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DC_BuildCall);
var
  TempStoreBuff: TKDT1080DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1080DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1080DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1080DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1080DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1080DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1080DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DC_BuildMethod);
var
  TempStoreBuff: TKDT1080DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1080DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1080DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1080DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1080DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1080DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1080DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DC_BuildProc);
var
  TempStoreBuff: TKDT1080DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1080DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1080DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1080DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1080DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1080DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1080DC.Search(const Buff: TKDT1080DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1080DC_Node;

var
  NearestNeighbour: PKDT1080DC_Node;

  function FindParentNode(const BuffPtr: PKDT1080DC_Vec; NodePtr: PKDT1080DC_Node): PKDT1080DC_Node;
  var
    Next       : PKDT1080DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1080DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1080DC_Node; const BuffPtr: PKDT1080DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1080DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1080DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1080DC_Vec; const p1, p2: PKDT1080DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1080DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1080DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1080DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1080DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1080DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1080DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1080DC_Node(NearestNodes[0]);
    end;
end;

function TKDT1080DC.Search(const Buff: TKDT1080DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1080DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1080DC.Search(const Buff: TKDT1080DC_Vec; var SearchedDistanceMin: Double): PKDT1080DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1080DC.Search(const Buff: TKDT1080DC_Vec): PKDT1080DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1080DC.Search(const inBuff: TKDT1080DC_DynamicVecBuffer; var OutBuff: TKDT1080DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1080DC_DynamicVecBuffer;
  outBuffPtr : PKDT1080DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1080DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1080DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1080DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1080DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1080DC_Source));
end;

procedure TKDT1080DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1080DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1080DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1080DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1080DC.PrintNodeTree(const NodePtr: PKDT1080DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1080DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1080DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1080DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1080DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1080DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1080DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1080DC.Test;
var
  TKDT1080DC_Test    : TKDT1080DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1080DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1080DC_Test := TKDT1080DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1080DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT1080DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT1080DC_AxisCount - 1 do
        TKDT1080DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1080DC_Test.TestBuff), length(TKDT1080DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1080DC_Test.BuildKDTreeM(False, length(TKDT1080DC_Test.TestBuff), @TKDT1080DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1080DC_Test.BuildKDTreeM(False, length(TKDT1080DC_Test.TestBuff), TKDT1080DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1080DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1080DC_Test.TestBuff));
  TKDT1080DC_Test.Search(TKDT1080DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1080DCDistance(TKDT1080DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1080DC_Test.Clear;
  { kMean test }
  TKDT1080DC_Test.BuildKDTreeWithCluster(TKDT1080DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1080DC_Test.Search(TKDT1080DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1080DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1080DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1080DC_Test);
end;

{$ENDIF DEBUG}


function KDT1536DCVec(const s: string): TKDT1536DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1536DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1536DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1536DCVec(const v: TKDT1536DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1536DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1536DCPow(const v: TKDT1536DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT1536DCDistance(const v1, v2: TKDT1536DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1536DC_AxisCount - 1 do
      Result := Result + KDT1536DCPow(v2[i] - v1[i]);
end;

function KDT1536DCCmpare(const v1, v2: TKDT1536DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1536DC_Vec));
end;

function TKDT1536DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DC_Node;
  function SortCompare(const p1, p2: PKDT1536DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1536DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1536DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1536DC_SourceBuffer;
  dynBuff  : PKDT1536DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1536DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1536DC.SearchStoreBuff(const StoreBuffPtr: PKDT1536DCyanmicStoreBuffer; const Buff: TKDT1536DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1536DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1536DC.GetData(const index: NativeInt): PKDT1536DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1536DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1536DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1536DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1536DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1536DC.StoreBuffPtr: PKDT1536DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1536DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1536DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1536DC.BuildKDTreeWithCluster(const inBuff: TKDT1536DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1536DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1536DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1536DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1536DC.BuildKDTreeWithCluster(const inBuff: TKDT1536DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DC_BuildCall);
var
  TempStoreBuff: TKDT1536DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DC_BuildMethod);
var
  TempStoreBuff: TKDT1536DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DC_BuildProc);
var
  TempStoreBuff: TKDT1536DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1536DC.Search(const Buff: TKDT1536DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DC_Node;

var
  NearestNeighbour: PKDT1536DC_Node;

  function FindParentNode(const BuffPtr: PKDT1536DC_Vec; NodePtr: PKDT1536DC_Node): PKDT1536DC_Node;
  var
    Next       : PKDT1536DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1536DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1536DC_Node; const BuffPtr: PKDT1536DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1536DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1536DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1536DC_Vec; const p1, p2: PKDT1536DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1536DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1536DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1536DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1536DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1536DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1536DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1536DC_Node(NearestNodes[0]);
    end;
end;

function TKDT1536DC.Search(const Buff: TKDT1536DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1536DC.Search(const Buff: TKDT1536DC_Vec; var SearchedDistanceMin: Double): PKDT1536DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1536DC.Search(const Buff: TKDT1536DC_Vec): PKDT1536DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1536DC.Search(const inBuff: TKDT1536DC_DynamicVecBuffer; var OutBuff: TKDT1536DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DC_DynamicVecBuffer;
  outBuffPtr : PKDT1536DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1536DC_Source));
end;

procedure TKDT1536DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1536DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1536DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1536DC.PrintNodeTree(const NodePtr: PKDT1536DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1536DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1536DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1536DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1536DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1536DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1536DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1536DC.Test;
var
  TKDT1536DC_Test    : TKDT1536DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1536DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1536DC_Test := TKDT1536DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1536DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT1536DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT1536DC_AxisCount - 1 do
        TKDT1536DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1536DC_Test.TestBuff), length(TKDT1536DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1536DC_Test.BuildKDTreeM(False, length(TKDT1536DC_Test.TestBuff), @TKDT1536DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1536DC_Test.BuildKDTreeM(False, length(TKDT1536DC_Test.TestBuff), TKDT1536DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1536DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1536DC_Test.TestBuff));
  TKDT1536DC_Test.Search(TKDT1536DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1536DCDistance(TKDT1536DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1536DC_Test.Clear;
  { kMean test }
  TKDT1536DC_Test.BuildKDTreeWithCluster(TKDT1536DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1536DC_Test.Search(TKDT1536DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1536DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1536DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1536DC_Test);
end;

{$ENDIF DEBUG}


function KDT1920DCVec(const s: string): TKDT1920DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1920DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1920DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1920DCVec(const v: TKDT1920DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1920DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1920DCPow(const v: TKDT1920DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT1920DCDistance(const v1, v2: TKDT1920DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1920DC_AxisCount - 1 do
      Result := Result + KDT1920DCPow(v2[i] - v1[i]);
end;

function KDT1920DCCmpare(const v1, v2: TKDT1920DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1920DC_Vec));
end;

function TKDT1920DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DC_Node;
  function SortCompare(const p1, p2: PKDT1920DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1920DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1920DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1920DC_SourceBuffer;
  dynBuff  : PKDT1920DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1920DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1920DC.SearchStoreBuff(const StoreBuffPtr: PKDT1920DCyanmicStoreBuffer; const Buff: TKDT1920DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1920DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1920DC.GetData(const index: NativeInt): PKDT1920DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1920DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1920DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1920DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1920DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1920DC.StoreBuffPtr: PKDT1920DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1920DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1920DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1920DC.BuildKDTreeWithCluster(const inBuff: TKDT1920DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1920DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1920DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1920DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1920DC.BuildKDTreeWithCluster(const inBuff: TKDT1920DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DC_BuildCall);
var
  TempStoreBuff: TKDT1920DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DC_BuildMethod);
var
  TempStoreBuff: TKDT1920DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DC_BuildProc);
var
  TempStoreBuff: TKDT1920DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1920DC.Search(const Buff: TKDT1920DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DC_Node;

var
  NearestNeighbour: PKDT1920DC_Node;

  function FindParentNode(const BuffPtr: PKDT1920DC_Vec; NodePtr: PKDT1920DC_Node): PKDT1920DC_Node;
  var
    Next       : PKDT1920DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1920DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1920DC_Node; const BuffPtr: PKDT1920DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1920DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1920DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1920DC_Vec; const p1, p2: PKDT1920DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1920DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1920DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1920DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1920DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1920DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1920DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1920DC_Node(NearestNodes[0]);
    end;
end;

function TKDT1920DC.Search(const Buff: TKDT1920DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1920DC.Search(const Buff: TKDT1920DC_Vec; var SearchedDistanceMin: Double): PKDT1920DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1920DC.Search(const Buff: TKDT1920DC_Vec): PKDT1920DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1920DC.Search(const inBuff: TKDT1920DC_DynamicVecBuffer; var OutBuff: TKDT1920DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DC_DynamicVecBuffer;
  outBuffPtr : PKDT1920DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1920DC_Source));
end;

procedure TKDT1920DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1920DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1920DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1920DC.PrintNodeTree(const NodePtr: PKDT1920DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1920DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1920DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1920DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1920DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1920DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1920DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1920DC.Test;
var
  TKDT1920DC_Test    : TKDT1920DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1920DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1920DC_Test := TKDT1920DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1920DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT1920DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT1920DC_AxisCount - 1 do
        TKDT1920DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1920DC_Test.TestBuff), length(TKDT1920DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1920DC_Test.BuildKDTreeM(False, length(TKDT1920DC_Test.TestBuff), @TKDT1920DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1920DC_Test.BuildKDTreeM(False, length(TKDT1920DC_Test.TestBuff), TKDT1920DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1920DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1920DC_Test.TestBuff));
  TKDT1920DC_Test.Search(TKDT1920DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1920DCDistance(TKDT1920DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1920DC_Test.Clear;
  { kMean test }
  TKDT1920DC_Test.BuildKDTreeWithCluster(TKDT1920DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1920DC_Test.Search(TKDT1920DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1920DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1920DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1920DC_Test);
end;

{$ENDIF DEBUG}


function KDT2048DCVec(const s: string): TKDT2048DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT2048DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT2048DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT2048DCVec(const v: TKDT2048DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT2048DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT2048DCPow(const v: TKDT2048DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT2048DCDistance(const v1, v2: TKDT2048DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT2048DC_AxisCount - 1 do
      Result := Result + KDT2048DCPow(v2[i] - v1[i]);
end;

function KDT2048DCCmpare(const v1, v2: TKDT2048DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT2048DC_Vec));
end;

function TKDT2048DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DC_Node;
  function SortCompare(const p1, p2: PKDT2048DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2048DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2048DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2048DC_SourceBuffer;
  dynBuff  : PKDT2048DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT2048DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2048DC.SearchStoreBuff(const StoreBuffPtr: PKDT2048DCyanmicStoreBuffer; const Buff: TKDT2048DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT2048DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT2048DC.GetData(const index: NativeInt): PKDT2048DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2048DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2048DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2048DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2048DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2048DC.StoreBuffPtr: PKDT2048DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2048DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2048DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2048DC.BuildKDTreeWithCluster(const inBuff: TKDT2048DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT2048DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT2048DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT2048DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2048DC.BuildKDTreeWithCluster(const inBuff: TKDT2048DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DC_BuildCall);
var
  TempStoreBuff: TKDT2048DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DC_BuildMethod);
var
  TempStoreBuff: TKDT2048DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DC_BuildProc);
var
  TempStoreBuff: TKDT2048DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2048DC.Search(const Buff: TKDT2048DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DC_Node;

var
  NearestNeighbour: PKDT2048DC_Node;

  function FindParentNode(const BuffPtr: PKDT2048DC_Vec; NodePtr: PKDT2048DC_Node): PKDT2048DC_Node;
  var
    Next       : PKDT2048DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT2048DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2048DC_Node; const BuffPtr: PKDT2048DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2048DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT2048DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2048DC_Vec; const p1, p2: PKDT2048DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2048DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2048DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2048DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2048DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2048DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2048DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2048DC_Node(NearestNodes[0]);
    end;
end;

function TKDT2048DC.Search(const Buff: TKDT2048DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2048DC.Search(const Buff: TKDT2048DC_Vec; var SearchedDistanceMin: Double): PKDT2048DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2048DC.Search(const Buff: TKDT2048DC_Vec): PKDT2048DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2048DC.Search(const inBuff: TKDT2048DC_DynamicVecBuffer; var OutBuff: TKDT2048DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DC_DynamicVecBuffer;
  outBuffPtr : PKDT2048DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2048DC_Source));
end;

procedure TKDT2048DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2048DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2048DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT2048DC.PrintNodeTree(const NodePtr: PKDT2048DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2048DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2048DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2048DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2048DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT2048DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT2048DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2048DC.Test;
var
  TKDT2048DC_Test    : TKDT2048DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2048DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2048DC_Test := TKDT2048DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2048DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT2048DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT2048DC_AxisCount - 1 do
        TKDT2048DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2048DC_Test.TestBuff), length(TKDT2048DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2048DC_Test.BuildKDTreeM(False, length(TKDT2048DC_Test.TestBuff), @TKDT2048DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2048DC_Test.BuildKDTreeM(False, length(TKDT2048DC_Test.TestBuff), TKDT2048DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2048DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2048DC_Test.TestBuff));
  TKDT2048DC_Test.Search(TKDT2048DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2048DCDistance(TKDT2048DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2048DC_Test.Clear;
  { kMean test }
  TKDT2048DC_Test.BuildKDTreeWithCluster(TKDT2048DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2048DC_Test.Search(TKDT2048DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2048DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2048DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2048DC_Test);
end;

{$ENDIF DEBUG}


function KDT3072DCVec(const s: string): TKDT3072DC_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3072DC_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3072DC_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3072DCVec(const v: TKDT3072DC_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3072DC_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT3072DCPow(const v: TKDT3072DC_VecType): Double;
begin
  Result := v * v;
end;

function KDT3072DCDistance(const v1, v2: TKDT3072DC_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3072DC_AxisCount - 1 do
      Result := Result + KDT3072DCPow(v2[i] - v1[i]);
end;

function KDT3072DCCmpare(const v1, v2: TKDT3072DC_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3072DC_Vec));
end;

function TKDT3072DC.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DC_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DC_Node;
  function SortCompare(const p1, p2: PKDT3072DC_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3072DC_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3072DC_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3072DC_SourceBuffer;
  dynBuff  : PKDT3072DCyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3072DC_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3072DC.SearchStoreBuff(const StoreBuffPtr: PKDT3072DCyanmicStoreBuffer; const Buff: TKDT3072DC_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3072DCCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3072DC.GetData(const index: NativeInt): PKDT3072DC_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3072DC.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3072DC.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3072DC.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3072DC_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3072DC.StoreBuffPtr: PKDT3072DCyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3072DC.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DC_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3072DC.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DC_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DC.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DC_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DCyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DC_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DC_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DC_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3072DC.BuildKDTreeWithCluster(const inBuff: TKDT3072DC_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3072DC_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3072DC_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3072DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3072DC.BuildKDTreeWithCluster(const inBuff: TKDT3072DC_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DC_BuildCall);
var
  TempStoreBuff: TKDT3072DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DC.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DC_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DC_BuildMethod);
var
  TempStoreBuff: TKDT3072DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DC.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DC_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DC_BuildProc);
var
  TempStoreBuff: TKDT3072DCyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DC_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DC_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DC_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DC_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DC_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DC.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DC_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3072DC.Search(const Buff: TKDT3072DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DC_Node;

var
  NearestNeighbour: PKDT3072DC_Node;

  function FindParentNode(const BuffPtr: PKDT3072DC_Vec; NodePtr: PKDT3072DC_Node): PKDT3072DC_Node;
  var
    Next       : PKDT3072DC_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3072DC_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3072DC_Node; const BuffPtr: PKDT3072DC_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3072DCDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3072DC_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3072DC_Vec; const p1, p2: PKDT3072DC_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3072DCDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3072DCDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3072DC_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3072DC_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3072DC_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3072DCDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3072DC_Node(NearestNodes[0]);
    end;
end;

function TKDT3072DC.Search(const Buff: TKDT3072DC_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DC_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3072DC.Search(const Buff: TKDT3072DC_Vec; var SearchedDistanceMin: Double): PKDT3072DC_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3072DC.Search(const Buff: TKDT3072DC_Vec): PKDT3072DC_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3072DC.Search(const inBuff: TKDT3072DC_DynamicVecBuffer; var OutBuff: TKDT3072DC_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DC_DynamicVecBuffer;
  outBuffPtr : PKDT3072DC_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DC_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DC_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DC_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DC.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3072DC_Source));
end;

procedure TKDT3072DC.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3072DC_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3072DC.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DC.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3072DC.PrintNodeTree(const NodePtr: PKDT3072DC_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3072DC_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3072DCVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3072DC.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3072DCVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3072DC.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3072DC_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3072DC.Test;
var
  TKDT3072DC_Test    : TKDT3072DC;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3072DC_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3072DC_Test := TKDT3072DC.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3072DC_Test.TestBuff, 300);
  for i := 0 to length(TKDT3072DC_Test.TestBuff) - 1 do
    for j := 0 to TKDT3072DC_AxisCount - 1 do
        TKDT3072DC_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3072DC_Test.TestBuff), length(TKDT3072DC_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3072DC_Test.BuildKDTreeM(False, length(TKDT3072DC_Test.TestBuff), @TKDT3072DC_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3072DC_Test.BuildKDTreeM(False, length(TKDT3072DC_Test.TestBuff), TKDT3072DC_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3072DC_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3072DC_Test.TestBuff));
  TKDT3072DC_Test.Search(TKDT3072DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3072DCDistance(TKDT3072DC_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3072DC_Test.Clear;
  { kMean test }
  TKDT3072DC_Test.BuildKDTreeWithCluster(TKDT3072DC_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3072DC_Test.Search(TKDT3072DC_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3072DC_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3072DC_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3072DC_Test);
end;

{$ENDIF DEBUG}

{$IFDEF DEBUG}
procedure Test_All;
begin
  TKDT1DC.Test();
  TKDT2DC.Test();
  TKDT3DC.Test();
  TKDT4DC.Test();
  TKDT6DC.Test();
  TKDT8DC.Test();
  TKDT10DC.Test();
  TKDT12DC.Test();
  TKDT14DC.Test();
  TKDT16DC.Test();
  TKDT18DC.Test();
  TKDT20DC.Test();
  TKDT22DC.Test();
  TKDT24DC.Test();
  TKDT28DC.Test();
  TKDT30DC.Test();
  TKDT32DC.Test();
  TKDT34DC.Test();
  TKDT36DC.Test();
  TKDT40DC.Test();
  TKDT48DC.Test();
  TKDT64DC.Test();
  TKDT96DC.Test();
  TKDT128DC.Test();
  TKDT256DC.Test();
  TKDT372DC.Test();
  TKDT512DC.Test();
  TKDT640DC.Test();
  TKDT768DC.Test();
  TKDT1024DC.Test();
  TKDT1080DC.Test();
  TKDT1536DC.Test();
  TKDT1920DC.Test();
  TKDT2048DC.Test();
  TKDT3072DC.Test();
  DoStatus('All Test Finished');
end;
{$ENDIF}




initialization

finalization

end.

