{ Fast KDTree Integer type support                                               }
{ ****************************************************************************** }
{ * fast KDTree Support,writen by QQ 600585@qq.com                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ ****************************************************************************** }

unit FastKDTreeI32;

interface

uses CoreClasses, KM;

{$I zDefine.inc}

{$IFDEF FPC}
{$DEFINE DEBUG}
{$ENDIF FPC}

const

  // integer KDTree
  TKDT1DI32_AxisCount = 1;
  TKDT2DI32_AxisCount = 2;
  TKDT3DI32_AxisCount = 3;
  TKDT4DI32_AxisCount = 4;
  TKDT5DI32_AxisCount = 5;
  TKDT6DI32_AxisCount = 6;
  TKDT7DI32_AxisCount = 7;
  TKDT8DI32_AxisCount = 8;
  TKDT9DI32_AxisCount = 9;
  TKDT10DI32_AxisCount = 10;
  TKDT11DI32_AxisCount = 11;
  TKDT12DI32_AxisCount = 12;
  TKDT13DI32_AxisCount = 13;
  TKDT14DI32_AxisCount = 14;
  TKDT15DI32_AxisCount = 15;
  TKDT16DI32_AxisCount = 16;
  TKDT17DI32_AxisCount = 17;
  TKDT18DI32_AxisCount = 18;
  TKDT19DI32_AxisCount = 19;
  TKDT20DI32_AxisCount = 20;
  TKDT21DI32_AxisCount = 21;
  TKDT22DI32_AxisCount = 22;
  TKDT23DI32_AxisCount = 23;
  TKDT24DI32_AxisCount = 24;
  TKDT25DI32_AxisCount = 25;
  TKDT26DI32_AxisCount = 26;
  TKDT27DI32_AxisCount = 27;
  TKDT28DI32_AxisCount = 28;
  TKDT29DI32_AxisCount = 29;
  TKDT30DI32_AxisCount = 30;
  TKDT32DI32_AxisCount = 32;
  TKDT34DI32_AxisCount = 34;
  TKDT36DI32_AxisCount = 36;
  TKDT38DI32_AxisCount = 38;
  TKDT40DI32_AxisCount = 40;
  TKDT44DI32_AxisCount = 44;
  TKDT48DI32_AxisCount = 48;
  TKDT50DI32_AxisCount = 50;
  TKDT56DI32_AxisCount = 56;
  TKDT60DI32_AxisCount = 60;
  TKDT64DI32_AxisCount = 64;
  TKDT72DI32_AxisCount = 72;
  TKDT84DI32_AxisCount = 84;
  TKDT96DI32_AxisCount = 96;
  TKDT128DI32_AxisCount = 128;
  TKDT140DI32_AxisCount = 140;
  TKDT160DI32_AxisCount = 160;
  TKDT196DI32_AxisCount = 196;
  TKDT256DI32_AxisCount = 256;
  TKDT272DI32_AxisCount = 272;
  TKDT288DI32_AxisCount = 288;
  TKDT372DI32_AxisCount = 372;
  TKDT512DI32_AxisCount = 512;
  TKDT576DI32_AxisCount = 576;
  TKDT768DI32_AxisCount = 768;
  TKDT1024DI32_AxisCount = 1024;
  TKDT1040DI32_AxisCount = 1040;
  TKDT1056DI32_AxisCount = 1056;
  TKDT1536DI32_AxisCount = 1536;
  TKDT1920DI32_AxisCount = 1920;
  TKDT1980DI32_AxisCount = 1980;
  TKDT2048DI32_AxisCount = 2048;
  TKDT3072DI32_AxisCount = 3072;
  TKDT3088DI32_AxisCount = 3088;
  TKDT3104DI32_AxisCount = 3104;
  TKDT4096DI32_AxisCount = 4096;
  TKDT8192DI32_AxisCount = 8192;

type

  // integer: KDTree
  TKDT1DI32 = class;  TKDT1DI32_VecType = Single; // 1D
  TKDT2DI32 = class;  TKDT2DI32_VecType = Single; // 2D
  TKDT3DI32 = class;  TKDT3DI32_VecType = Single; // 3D
  TKDT4DI32 = class;  TKDT4DI32_VecType = Single; // 4D
  TKDT5DI32 = class;  TKDT5DI32_VecType = Single; // 5D
  TKDT6DI32 = class;  TKDT6DI32_VecType = Single; // 6D
  TKDT7DI32 = class;  TKDT7DI32_VecType = Single; // 7D
  TKDT8DI32 = class;  TKDT8DI32_VecType = Single; // 8D
  TKDT9DI32 = class;  TKDT9DI32_VecType = Single; // 9D
  TKDT10DI32 = class;  TKDT10DI32_VecType = Single; // 10D
  TKDT11DI32 = class;  TKDT11DI32_VecType = Single; // 11D
  TKDT12DI32 = class;  TKDT12DI32_VecType = Single; // 12D
  TKDT13DI32 = class;  TKDT13DI32_VecType = Single; // 13D
  TKDT14DI32 = class;  TKDT14DI32_VecType = Single; // 14D
  TKDT15DI32 = class;  TKDT15DI32_VecType = Single; // 15D
  TKDT16DI32 = class;  TKDT16DI32_VecType = Single; // 16D
  TKDT17DI32 = class;  TKDT17DI32_VecType = Single; // 17D
  TKDT18DI32 = class;  TKDT18DI32_VecType = Single; // 18D
  TKDT19DI32 = class;  TKDT19DI32_VecType = Single; // 19D
  TKDT20DI32 = class;  TKDT20DI32_VecType = Single; // 20D
  TKDT21DI32 = class;  TKDT21DI32_VecType = Single; // 21D
  TKDT22DI32 = class;  TKDT22DI32_VecType = Single; // 22D
  TKDT23DI32 = class;  TKDT23DI32_VecType = Single; // 23D
  TKDT24DI32 = class;  TKDT24DI32_VecType = Single; // 24D
  TKDT25DI32 = class;  TKDT25DI32_VecType = Single; // 25D
  TKDT26DI32 = class;  TKDT26DI32_VecType = Single; // 26D
  TKDT27DI32 = class;  TKDT27DI32_VecType = Single; // 27D
  TKDT28DI32 = class;  TKDT28DI32_VecType = Single; // 28D
  TKDT29DI32 = class;  TKDT29DI32_VecType = Single; // 29D
  TKDT30DI32 = class;  TKDT30DI32_VecType = Single; // 30D
  TKDT32DI32 = class;  TKDT32DI32_VecType = Single; // 32D
  TKDT34DI32 = class;  TKDT34DI32_VecType = Single; // 34D
  TKDT36DI32 = class;  TKDT36DI32_VecType = Single; // 36D
  TKDT38DI32 = class;  TKDT38DI32_VecType = Single; // 38D
  TKDT40DI32 = class;  TKDT40DI32_VecType = Single; // 40D
  TKDT44DI32 = class;  TKDT44DI32_VecType = Single; // 44D
  TKDT48DI32 = class;  TKDT48DI32_VecType = Single; // 48D
  TKDT50DI32 = class;  TKDT50DI32_VecType = Single; // 50D
  TKDT56DI32 = class;  TKDT56DI32_VecType = Single; // 56D
  TKDT60DI32 = class;  TKDT60DI32_VecType = Single; // 60D
  TKDT64DI32 = class;  TKDT64DI32_VecType = Single; // 64D
  TKDT72DI32 = class;  TKDT72DI32_VecType = Single; // 72D
  TKDT84DI32 = class;  TKDT84DI32_VecType = Single; // 84D
  TKDT96DI32 = class;  TKDT96DI32_VecType = Single; // 96D
  TKDT128DI32 = class;  TKDT128DI32_VecType = Single; // 128D
  TKDT140DI32 = class;  TKDT140DI32_VecType = Single; // 140D
  TKDT160DI32 = class;  TKDT160DI32_VecType = Single; // 160D
  TKDT196DI32 = class;  TKDT196DI32_VecType = Single; // 196D
  TKDT256DI32 = class;  TKDT256DI32_VecType = Single; // 256D
  TKDT272DI32 = class;  TKDT272DI32_VecType = Single; // 272D
  TKDT288DI32 = class;  TKDT288DI32_VecType = Single; // 288D
  TKDT372DI32 = class;  TKDT372DI32_VecType = Single; // 372D
  TKDT512DI32 = class;  TKDT512DI32_VecType = Single; // 512D
  TKDT576DI32 = class;  TKDT576DI32_VecType = Single; // 576D
  TKDT768DI32 = class;  TKDT768DI32_VecType = Single; // 768D
  TKDT1024DI32 = class;  TKDT1024DI32_VecType = Single; // 1024D
  TKDT1040DI32 = class;  TKDT1040DI32_VecType = Single; // 1040D
  TKDT1056DI32 = class;  TKDT1056DI32_VecType = Single; // 1056D
  TKDT1536DI32 = class;  TKDT1536DI32_VecType = Single; // 1536D
  TKDT1920DI32 = class;  TKDT1920DI32_VecType = Single; // 1920D
  TKDT1980DI32 = class;  TKDT1980DI32_VecType = Single; // 1980D
  TKDT2048DI32 = class;  TKDT2048DI32_VecType = Single; // 2048D
  TKDT3072DI32 = class;  TKDT3072DI32_VecType = Single; // 3072D
  TKDT3088DI32 = class;  TKDT3088DI32_VecType = Single; // 3088D
  TKDT3104DI32 = class;  TKDT3104DI32_VecType = Single; // 3104D
  TKDT4096DI32 = class;  TKDT4096DI32_VecType = Single; // 4096D
  TKDT8192DI32 = class;  TKDT8192DI32_VecType = Single; // 8192D










  // integer KDTree


  TKDT1DI32_Vec = array [0 .. TKDT1DI32_AxisCount - 1] of TKDT1DI32_VecType;
  PKDT1DI32_Vec = ^TKDT1DI32_Vec;

  TKDT1DI32_DynamicVecBuffer = array of TKDT1DI32_Vec;
  PKDT1DI32_DynamicVecBuffer = ^TKDT1DI32_DynamicVecBuffer;

  TKDT1DI32_Source = packed record
    Buff: TKDT1DI32_Vec;
    index: Int64;
  end;

  PKDT1DI32_Source       = ^TKDT1DI32_Source;
  TKDT1DI32_SourceBuffer = array [0 .. 0] of PKDT1DI32_Source;
  PKDT1DI32_SourceBuffer = ^TKDT1DI32_SourceBuffer;

  TKDT1DI32yanmicSourceBuffer = array of PKDT1DI32_Source;
  PKDT1DI32yanmicSourceBuffer = ^TKDT1DI32yanmicSourceBuffer;

  TKDT1DI32yanmicStoreBuffer = array of TKDT1DI32_Source;
  PKDT1DI32yanmicStoreBuffer = ^TKDT1DI32yanmicStoreBuffer;

  PKDT1DI32_Node = ^TKDT1DI32_Node;

  TKDT1DI32_Node = packed record
    Parent, Right, Left: PKDT1DI32_Node;
    vec: PKDT1DI32_Source;
  end;

  TKDT1DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1DI32_Source);
  TKDT1DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT1DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1DI32_Source);
  {$ENDIF}

  TKDT1DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1DI32yanmicStoreBuffer;
    KDBuff     : TKDT1DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1DI32yanmicStoreBuffer; const Buff: TKDT1DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DI32_Node; overload;
    function Search(const Buff: TKDT1DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DI32_Node; overload;
    function Search(const Buff: TKDT1DI32_Vec; var SearchedDistanceMin: Double): PKDT1DI32_Node; overload;
    function Search(const Buff: TKDT1DI32_Vec): PKDT1DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1DI32_DynamicVecBuffer; var OutBuff: TKDT1DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT2DI32_Vec = array [0 .. TKDT2DI32_AxisCount - 1] of TKDT2DI32_VecType;
  PKDT2DI32_Vec = ^TKDT2DI32_Vec;

  TKDT2DI32_DynamicVecBuffer = array of TKDT2DI32_Vec;
  PKDT2DI32_DynamicVecBuffer = ^TKDT2DI32_DynamicVecBuffer;

  TKDT2DI32_Source = packed record
    Buff: TKDT2DI32_Vec;
    index: Int64;
  end;

  PKDT2DI32_Source       = ^TKDT2DI32_Source;
  TKDT2DI32_SourceBuffer = array [0 .. 0] of PKDT2DI32_Source;
  PKDT2DI32_SourceBuffer = ^TKDT2DI32_SourceBuffer;

  TKDT2DI32yanmicSourceBuffer = array of PKDT2DI32_Source;
  PKDT2DI32yanmicSourceBuffer = ^TKDT2DI32yanmicSourceBuffer;

  TKDT2DI32yanmicStoreBuffer = array of TKDT2DI32_Source;
  PKDT2DI32yanmicStoreBuffer = ^TKDT2DI32yanmicStoreBuffer;

  PKDT2DI32_Node = ^TKDT2DI32_Node;

  TKDT2DI32_Node = packed record
    Parent, Right, Left: PKDT2DI32_Node;
    vec: PKDT2DI32_Source;
  end;

  TKDT2DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT2DI32_Source);
  TKDT2DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT2DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT2DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT2DI32_Source);
  {$ENDIF}

  TKDT2DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2DI32yanmicStoreBuffer;
    KDBuff     : TKDT2DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT2DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT2DI32yanmicStoreBuffer; const Buff: TKDT2DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT2DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DI32_Node; overload;
    function Search(const Buff: TKDT2DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DI32_Node; overload;
    function Search(const Buff: TKDT2DI32_Vec; var SearchedDistanceMin: Double): PKDT2DI32_Node; overload;
    function Search(const Buff: TKDT2DI32_Vec): PKDT2DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2DI32_DynamicVecBuffer; var OutBuff: TKDT2DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT2DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT2DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3DI32_Vec = array [0 .. TKDT3DI32_AxisCount - 1] of TKDT3DI32_VecType;
  PKDT3DI32_Vec = ^TKDT3DI32_Vec;

  TKDT3DI32_DynamicVecBuffer = array of TKDT3DI32_Vec;
  PKDT3DI32_DynamicVecBuffer = ^TKDT3DI32_DynamicVecBuffer;

  TKDT3DI32_Source = packed record
    Buff: TKDT3DI32_Vec;
    index: Int64;
  end;

  PKDT3DI32_Source       = ^TKDT3DI32_Source;
  TKDT3DI32_SourceBuffer = array [0 .. 0] of PKDT3DI32_Source;
  PKDT3DI32_SourceBuffer = ^TKDT3DI32_SourceBuffer;

  TKDT3DI32yanmicSourceBuffer = array of PKDT3DI32_Source;
  PKDT3DI32yanmicSourceBuffer = ^TKDT3DI32yanmicSourceBuffer;

  TKDT3DI32yanmicStoreBuffer = array of TKDT3DI32_Source;
  PKDT3DI32yanmicStoreBuffer = ^TKDT3DI32yanmicStoreBuffer;

  PKDT3DI32_Node = ^TKDT3DI32_Node;

  TKDT3DI32_Node = packed record
    Parent, Right, Left: PKDT3DI32_Node;
    vec: PKDT3DI32_Source;
  end;

  TKDT3DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3DI32_Source);
  TKDT3DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT3DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3DI32_Source);
  {$ENDIF}

  TKDT3DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3DI32yanmicStoreBuffer;
    KDBuff     : TKDT3DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3DI32yanmicStoreBuffer; const Buff: TKDT3DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DI32_Node; overload;
    function Search(const Buff: TKDT3DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DI32_Node; overload;
    function Search(const Buff: TKDT3DI32_Vec; var SearchedDistanceMin: Double): PKDT3DI32_Node; overload;
    function Search(const Buff: TKDT3DI32_Vec): PKDT3DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3DI32_DynamicVecBuffer; var OutBuff: TKDT3DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT4DI32_Vec = array [0 .. TKDT4DI32_AxisCount - 1] of TKDT4DI32_VecType;
  PKDT4DI32_Vec = ^TKDT4DI32_Vec;

  TKDT4DI32_DynamicVecBuffer = array of TKDT4DI32_Vec;
  PKDT4DI32_DynamicVecBuffer = ^TKDT4DI32_DynamicVecBuffer;

  TKDT4DI32_Source = packed record
    Buff: TKDT4DI32_Vec;
    index: Int64;
  end;

  PKDT4DI32_Source       = ^TKDT4DI32_Source;
  TKDT4DI32_SourceBuffer = array [0 .. 0] of PKDT4DI32_Source;
  PKDT4DI32_SourceBuffer = ^TKDT4DI32_SourceBuffer;

  TKDT4DI32yanmicSourceBuffer = array of PKDT4DI32_Source;
  PKDT4DI32yanmicSourceBuffer = ^TKDT4DI32yanmicSourceBuffer;

  TKDT4DI32yanmicStoreBuffer = array of TKDT4DI32_Source;
  PKDT4DI32yanmicStoreBuffer = ^TKDT4DI32yanmicStoreBuffer;

  PKDT4DI32_Node = ^TKDT4DI32_Node;

  TKDT4DI32_Node = packed record
    Parent, Right, Left: PKDT4DI32_Node;
    vec: PKDT4DI32_Source;
  end;

  TKDT4DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT4DI32_Source);
  TKDT4DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT4DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT4DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT4DI32_Source);
  {$ENDIF}

  TKDT4DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT4DI32yanmicStoreBuffer;
    KDBuff     : TKDT4DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT4DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT4DI32yanmicStoreBuffer; const Buff: TKDT4DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT4DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT4DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DI32_Node; overload;
    function Search(const Buff: TKDT4DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DI32_Node; overload;
    function Search(const Buff: TKDT4DI32_Vec; var SearchedDistanceMin: Double): PKDT4DI32_Node; overload;
    function Search(const Buff: TKDT4DI32_Vec): PKDT4DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4DI32_DynamicVecBuffer; var OutBuff: TKDT4DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT4DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT4DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT5DI32_Vec = array [0 .. TKDT5DI32_AxisCount - 1] of TKDT5DI32_VecType;
  PKDT5DI32_Vec = ^TKDT5DI32_Vec;

  TKDT5DI32_DynamicVecBuffer = array of TKDT5DI32_Vec;
  PKDT5DI32_DynamicVecBuffer = ^TKDT5DI32_DynamicVecBuffer;

  TKDT5DI32_Source = packed record
    Buff: TKDT5DI32_Vec;
    index: Int64;
  end;

  PKDT5DI32_Source       = ^TKDT5DI32_Source;
  TKDT5DI32_SourceBuffer = array [0 .. 0] of PKDT5DI32_Source;
  PKDT5DI32_SourceBuffer = ^TKDT5DI32_SourceBuffer;

  TKDT5DI32yanmicSourceBuffer = array of PKDT5DI32_Source;
  PKDT5DI32yanmicSourceBuffer = ^TKDT5DI32yanmicSourceBuffer;

  TKDT5DI32yanmicStoreBuffer = array of TKDT5DI32_Source;
  PKDT5DI32yanmicStoreBuffer = ^TKDT5DI32yanmicStoreBuffer;

  PKDT5DI32_Node = ^TKDT5DI32_Node;

  TKDT5DI32_Node = packed record
    Parent, Right, Left: PKDT5DI32_Node;
    vec: PKDT5DI32_Source;
  end;

  TKDT5DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT5DI32_Source);
  TKDT5DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT5DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT5DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT5DI32_Source);
  {$ENDIF}

  TKDT5DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT5DI32yanmicStoreBuffer;
    KDBuff     : TKDT5DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT5DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT5DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT5DI32yanmicStoreBuffer; const Buff: TKDT5DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT5DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT5DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT5DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT5DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT5DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DI32_Node; overload;
    function Search(const Buff: TKDT5DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DI32_Node; overload;
    function Search(const Buff: TKDT5DI32_Vec; var SearchedDistanceMin: Double): PKDT5DI32_Node; overload;
    function Search(const Buff: TKDT5DI32_Vec): PKDT5DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT5DI32_DynamicVecBuffer; var OutBuff: TKDT5DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT5DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT5DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT6DI32_Vec = array [0 .. TKDT6DI32_AxisCount - 1] of TKDT6DI32_VecType;
  PKDT6DI32_Vec = ^TKDT6DI32_Vec;

  TKDT6DI32_DynamicVecBuffer = array of TKDT6DI32_Vec;
  PKDT6DI32_DynamicVecBuffer = ^TKDT6DI32_DynamicVecBuffer;

  TKDT6DI32_Source = packed record
    Buff: TKDT6DI32_Vec;
    index: Int64;
  end;

  PKDT6DI32_Source       = ^TKDT6DI32_Source;
  TKDT6DI32_SourceBuffer = array [0 .. 0] of PKDT6DI32_Source;
  PKDT6DI32_SourceBuffer = ^TKDT6DI32_SourceBuffer;

  TKDT6DI32yanmicSourceBuffer = array of PKDT6DI32_Source;
  PKDT6DI32yanmicSourceBuffer = ^TKDT6DI32yanmicSourceBuffer;

  TKDT6DI32yanmicStoreBuffer = array of TKDT6DI32_Source;
  PKDT6DI32yanmicStoreBuffer = ^TKDT6DI32yanmicStoreBuffer;

  PKDT6DI32_Node = ^TKDT6DI32_Node;

  TKDT6DI32_Node = packed record
    Parent, Right, Left: PKDT6DI32_Node;
    vec: PKDT6DI32_Source;
  end;

  TKDT6DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT6DI32_Source);
  TKDT6DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT6DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT6DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT6DI32_Source);
  {$ENDIF}

  TKDT6DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT6DI32yanmicStoreBuffer;
    KDBuff     : TKDT6DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT6DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT6DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT6DI32yanmicStoreBuffer; const Buff: TKDT6DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT6DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT6DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT6DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT6DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DI32_Node; overload;
    function Search(const Buff: TKDT6DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DI32_Node; overload;
    function Search(const Buff: TKDT6DI32_Vec; var SearchedDistanceMin: Double): PKDT6DI32_Node; overload;
    function Search(const Buff: TKDT6DI32_Vec): PKDT6DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT6DI32_DynamicVecBuffer; var OutBuff: TKDT6DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT6DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT6DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT7DI32_Vec = array [0 .. TKDT7DI32_AxisCount - 1] of TKDT7DI32_VecType;
  PKDT7DI32_Vec = ^TKDT7DI32_Vec;

  TKDT7DI32_DynamicVecBuffer = array of TKDT7DI32_Vec;
  PKDT7DI32_DynamicVecBuffer = ^TKDT7DI32_DynamicVecBuffer;

  TKDT7DI32_Source = packed record
    Buff: TKDT7DI32_Vec;
    index: Int64;
  end;

  PKDT7DI32_Source       = ^TKDT7DI32_Source;
  TKDT7DI32_SourceBuffer = array [0 .. 0] of PKDT7DI32_Source;
  PKDT7DI32_SourceBuffer = ^TKDT7DI32_SourceBuffer;

  TKDT7DI32yanmicSourceBuffer = array of PKDT7DI32_Source;
  PKDT7DI32yanmicSourceBuffer = ^TKDT7DI32yanmicSourceBuffer;

  TKDT7DI32yanmicStoreBuffer = array of TKDT7DI32_Source;
  PKDT7DI32yanmicStoreBuffer = ^TKDT7DI32yanmicStoreBuffer;

  PKDT7DI32_Node = ^TKDT7DI32_Node;

  TKDT7DI32_Node = packed record
    Parent, Right, Left: PKDT7DI32_Node;
    vec: PKDT7DI32_Source;
  end;

  TKDT7DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT7DI32_Source);
  TKDT7DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT7DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT7DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT7DI32_Source);
  {$ENDIF}

  TKDT7DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT7DI32yanmicStoreBuffer;
    KDBuff     : TKDT7DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT7DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT7DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT7DI32yanmicStoreBuffer; const Buff: TKDT7DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT7DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT7DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT7DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT7DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT7DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DI32_Node; overload;
    function Search(const Buff: TKDT7DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DI32_Node; overload;
    function Search(const Buff: TKDT7DI32_Vec; var SearchedDistanceMin: Double): PKDT7DI32_Node; overload;
    function Search(const Buff: TKDT7DI32_Vec): PKDT7DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT7DI32_DynamicVecBuffer; var OutBuff: TKDT7DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT7DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT7DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT8DI32_Vec = array [0 .. TKDT8DI32_AxisCount - 1] of TKDT8DI32_VecType;
  PKDT8DI32_Vec = ^TKDT8DI32_Vec;

  TKDT8DI32_DynamicVecBuffer = array of TKDT8DI32_Vec;
  PKDT8DI32_DynamicVecBuffer = ^TKDT8DI32_DynamicVecBuffer;

  TKDT8DI32_Source = packed record
    Buff: TKDT8DI32_Vec;
    index: Int64;
  end;

  PKDT8DI32_Source       = ^TKDT8DI32_Source;
  TKDT8DI32_SourceBuffer = array [0 .. 0] of PKDT8DI32_Source;
  PKDT8DI32_SourceBuffer = ^TKDT8DI32_SourceBuffer;

  TKDT8DI32yanmicSourceBuffer = array of PKDT8DI32_Source;
  PKDT8DI32yanmicSourceBuffer = ^TKDT8DI32yanmicSourceBuffer;

  TKDT8DI32yanmicStoreBuffer = array of TKDT8DI32_Source;
  PKDT8DI32yanmicStoreBuffer = ^TKDT8DI32yanmicStoreBuffer;

  PKDT8DI32_Node = ^TKDT8DI32_Node;

  TKDT8DI32_Node = packed record
    Parent, Right, Left: PKDT8DI32_Node;
    vec: PKDT8DI32_Source;
  end;

  TKDT8DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT8DI32_Source);
  TKDT8DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT8DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT8DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT8DI32_Source);
  {$ENDIF}

  TKDT8DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT8DI32yanmicStoreBuffer;
    KDBuff     : TKDT8DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT8DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT8DI32yanmicStoreBuffer; const Buff: TKDT8DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT8DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT8DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DI32_Node; overload;
    function Search(const Buff: TKDT8DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DI32_Node; overload;
    function Search(const Buff: TKDT8DI32_Vec; var SearchedDistanceMin: Double): PKDT8DI32_Node; overload;
    function Search(const Buff: TKDT8DI32_Vec): PKDT8DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8DI32_DynamicVecBuffer; var OutBuff: TKDT8DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT8DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT8DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT9DI32_Vec = array [0 .. TKDT9DI32_AxisCount - 1] of TKDT9DI32_VecType;
  PKDT9DI32_Vec = ^TKDT9DI32_Vec;

  TKDT9DI32_DynamicVecBuffer = array of TKDT9DI32_Vec;
  PKDT9DI32_DynamicVecBuffer = ^TKDT9DI32_DynamicVecBuffer;

  TKDT9DI32_Source = packed record
    Buff: TKDT9DI32_Vec;
    index: Int64;
  end;

  PKDT9DI32_Source       = ^TKDT9DI32_Source;
  TKDT9DI32_SourceBuffer = array [0 .. 0] of PKDT9DI32_Source;
  PKDT9DI32_SourceBuffer = ^TKDT9DI32_SourceBuffer;

  TKDT9DI32yanmicSourceBuffer = array of PKDT9DI32_Source;
  PKDT9DI32yanmicSourceBuffer = ^TKDT9DI32yanmicSourceBuffer;

  TKDT9DI32yanmicStoreBuffer = array of TKDT9DI32_Source;
  PKDT9DI32yanmicStoreBuffer = ^TKDT9DI32yanmicStoreBuffer;

  PKDT9DI32_Node = ^TKDT9DI32_Node;

  TKDT9DI32_Node = packed record
    Parent, Right, Left: PKDT9DI32_Node;
    vec: PKDT9DI32_Source;
  end;

  TKDT9DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT9DI32_Source);
  TKDT9DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT9DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT9DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT9DI32_Source);
  {$ENDIF}

  TKDT9DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT9DI32yanmicStoreBuffer;
    KDBuff     : TKDT9DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT9DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT9DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT9DI32yanmicStoreBuffer; const Buff: TKDT9DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT9DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT9DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT9DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT9DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT9DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DI32_Node; overload;
    function Search(const Buff: TKDT9DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DI32_Node; overload;
    function Search(const Buff: TKDT9DI32_Vec; var SearchedDistanceMin: Double): PKDT9DI32_Node; overload;
    function Search(const Buff: TKDT9DI32_Vec): PKDT9DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT9DI32_DynamicVecBuffer; var OutBuff: TKDT9DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT9DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT9DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT10DI32_Vec = array [0 .. TKDT10DI32_AxisCount - 1] of TKDT10DI32_VecType;
  PKDT10DI32_Vec = ^TKDT10DI32_Vec;

  TKDT10DI32_DynamicVecBuffer = array of TKDT10DI32_Vec;
  PKDT10DI32_DynamicVecBuffer = ^TKDT10DI32_DynamicVecBuffer;

  TKDT10DI32_Source = packed record
    Buff: TKDT10DI32_Vec;
    index: Int64;
  end;

  PKDT10DI32_Source       = ^TKDT10DI32_Source;
  TKDT10DI32_SourceBuffer = array [0 .. 0] of PKDT10DI32_Source;
  PKDT10DI32_SourceBuffer = ^TKDT10DI32_SourceBuffer;

  TKDT10DI32yanmicSourceBuffer = array of PKDT10DI32_Source;
  PKDT10DI32yanmicSourceBuffer = ^TKDT10DI32yanmicSourceBuffer;

  TKDT10DI32yanmicStoreBuffer = array of TKDT10DI32_Source;
  PKDT10DI32yanmicStoreBuffer = ^TKDT10DI32yanmicStoreBuffer;

  PKDT10DI32_Node = ^TKDT10DI32_Node;

  TKDT10DI32_Node = packed record
    Parent, Right, Left: PKDT10DI32_Node;
    vec: PKDT10DI32_Source;
  end;

  TKDT10DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT10DI32_Source);
  TKDT10DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT10DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT10DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT10DI32_Source);
  {$ENDIF}

  TKDT10DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT10DI32yanmicStoreBuffer;
    KDBuff     : TKDT10DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT10DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT10DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT10DI32yanmicStoreBuffer; const Buff: TKDT10DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT10DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT10DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT10DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT10DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DI32_Node; overload;
    function Search(const Buff: TKDT10DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DI32_Node; overload;
    function Search(const Buff: TKDT10DI32_Vec; var SearchedDistanceMin: Double): PKDT10DI32_Node; overload;
    function Search(const Buff: TKDT10DI32_Vec): PKDT10DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT10DI32_DynamicVecBuffer; var OutBuff: TKDT10DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT10DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT10DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT11DI32_Vec = array [0 .. TKDT11DI32_AxisCount - 1] of TKDT11DI32_VecType;
  PKDT11DI32_Vec = ^TKDT11DI32_Vec;

  TKDT11DI32_DynamicVecBuffer = array of TKDT11DI32_Vec;
  PKDT11DI32_DynamicVecBuffer = ^TKDT11DI32_DynamicVecBuffer;

  TKDT11DI32_Source = packed record
    Buff: TKDT11DI32_Vec;
    index: Int64;
  end;

  PKDT11DI32_Source       = ^TKDT11DI32_Source;
  TKDT11DI32_SourceBuffer = array [0 .. 0] of PKDT11DI32_Source;
  PKDT11DI32_SourceBuffer = ^TKDT11DI32_SourceBuffer;

  TKDT11DI32yanmicSourceBuffer = array of PKDT11DI32_Source;
  PKDT11DI32yanmicSourceBuffer = ^TKDT11DI32yanmicSourceBuffer;

  TKDT11DI32yanmicStoreBuffer = array of TKDT11DI32_Source;
  PKDT11DI32yanmicStoreBuffer = ^TKDT11DI32yanmicStoreBuffer;

  PKDT11DI32_Node = ^TKDT11DI32_Node;

  TKDT11DI32_Node = packed record
    Parent, Right, Left: PKDT11DI32_Node;
    vec: PKDT11DI32_Source;
  end;

  TKDT11DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT11DI32_Source);
  TKDT11DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT11DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT11DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT11DI32_Source);
  {$ENDIF}

  TKDT11DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT11DI32yanmicStoreBuffer;
    KDBuff     : TKDT11DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT11DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT11DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT11DI32yanmicStoreBuffer; const Buff: TKDT11DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT11DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT11DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT11DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT11DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT11DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DI32_Node; overload;
    function Search(const Buff: TKDT11DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DI32_Node; overload;
    function Search(const Buff: TKDT11DI32_Vec; var SearchedDistanceMin: Double): PKDT11DI32_Node; overload;
    function Search(const Buff: TKDT11DI32_Vec): PKDT11DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT11DI32_DynamicVecBuffer; var OutBuff: TKDT11DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT11DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT11DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT12DI32_Vec = array [0 .. TKDT12DI32_AxisCount - 1] of TKDT12DI32_VecType;
  PKDT12DI32_Vec = ^TKDT12DI32_Vec;

  TKDT12DI32_DynamicVecBuffer = array of TKDT12DI32_Vec;
  PKDT12DI32_DynamicVecBuffer = ^TKDT12DI32_DynamicVecBuffer;

  TKDT12DI32_Source = packed record
    Buff: TKDT12DI32_Vec;
    index: Int64;
  end;

  PKDT12DI32_Source       = ^TKDT12DI32_Source;
  TKDT12DI32_SourceBuffer = array [0 .. 0] of PKDT12DI32_Source;
  PKDT12DI32_SourceBuffer = ^TKDT12DI32_SourceBuffer;

  TKDT12DI32yanmicSourceBuffer = array of PKDT12DI32_Source;
  PKDT12DI32yanmicSourceBuffer = ^TKDT12DI32yanmicSourceBuffer;

  TKDT12DI32yanmicStoreBuffer = array of TKDT12DI32_Source;
  PKDT12DI32yanmicStoreBuffer = ^TKDT12DI32yanmicStoreBuffer;

  PKDT12DI32_Node = ^TKDT12DI32_Node;

  TKDT12DI32_Node = packed record
    Parent, Right, Left: PKDT12DI32_Node;
    vec: PKDT12DI32_Source;
  end;

  TKDT12DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT12DI32_Source);
  TKDT12DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT12DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT12DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT12DI32_Source);
  {$ENDIF}

  TKDT12DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT12DI32yanmicStoreBuffer;
    KDBuff     : TKDT12DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT12DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT12DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT12DI32yanmicStoreBuffer; const Buff: TKDT12DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT12DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT12DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT12DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT12DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DI32_Node; overload;
    function Search(const Buff: TKDT12DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DI32_Node; overload;
    function Search(const Buff: TKDT12DI32_Vec; var SearchedDistanceMin: Double): PKDT12DI32_Node; overload;
    function Search(const Buff: TKDT12DI32_Vec): PKDT12DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT12DI32_DynamicVecBuffer; var OutBuff: TKDT12DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT12DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT12DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT13DI32_Vec = array [0 .. TKDT13DI32_AxisCount - 1] of TKDT13DI32_VecType;
  PKDT13DI32_Vec = ^TKDT13DI32_Vec;

  TKDT13DI32_DynamicVecBuffer = array of TKDT13DI32_Vec;
  PKDT13DI32_DynamicVecBuffer = ^TKDT13DI32_DynamicVecBuffer;

  TKDT13DI32_Source = packed record
    Buff: TKDT13DI32_Vec;
    index: Int64;
  end;

  PKDT13DI32_Source       = ^TKDT13DI32_Source;
  TKDT13DI32_SourceBuffer = array [0 .. 0] of PKDT13DI32_Source;
  PKDT13DI32_SourceBuffer = ^TKDT13DI32_SourceBuffer;

  TKDT13DI32yanmicSourceBuffer = array of PKDT13DI32_Source;
  PKDT13DI32yanmicSourceBuffer = ^TKDT13DI32yanmicSourceBuffer;

  TKDT13DI32yanmicStoreBuffer = array of TKDT13DI32_Source;
  PKDT13DI32yanmicStoreBuffer = ^TKDT13DI32yanmicStoreBuffer;

  PKDT13DI32_Node = ^TKDT13DI32_Node;

  TKDT13DI32_Node = packed record
    Parent, Right, Left: PKDT13DI32_Node;
    vec: PKDT13DI32_Source;
  end;

  TKDT13DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT13DI32_Source);
  TKDT13DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT13DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT13DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT13DI32_Source);
  {$ENDIF}

  TKDT13DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT13DI32yanmicStoreBuffer;
    KDBuff     : TKDT13DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT13DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT13DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT13DI32yanmicStoreBuffer; const Buff: TKDT13DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT13DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT13DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT13DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT13DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT13DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DI32_Node; overload;
    function Search(const Buff: TKDT13DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DI32_Node; overload;
    function Search(const Buff: TKDT13DI32_Vec; var SearchedDistanceMin: Double): PKDT13DI32_Node; overload;
    function Search(const Buff: TKDT13DI32_Vec): PKDT13DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT13DI32_DynamicVecBuffer; var OutBuff: TKDT13DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT13DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT13DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT14DI32_Vec = array [0 .. TKDT14DI32_AxisCount - 1] of TKDT14DI32_VecType;
  PKDT14DI32_Vec = ^TKDT14DI32_Vec;

  TKDT14DI32_DynamicVecBuffer = array of TKDT14DI32_Vec;
  PKDT14DI32_DynamicVecBuffer = ^TKDT14DI32_DynamicVecBuffer;

  TKDT14DI32_Source = packed record
    Buff: TKDT14DI32_Vec;
    index: Int64;
  end;

  PKDT14DI32_Source       = ^TKDT14DI32_Source;
  TKDT14DI32_SourceBuffer = array [0 .. 0] of PKDT14DI32_Source;
  PKDT14DI32_SourceBuffer = ^TKDT14DI32_SourceBuffer;

  TKDT14DI32yanmicSourceBuffer = array of PKDT14DI32_Source;
  PKDT14DI32yanmicSourceBuffer = ^TKDT14DI32yanmicSourceBuffer;

  TKDT14DI32yanmicStoreBuffer = array of TKDT14DI32_Source;
  PKDT14DI32yanmicStoreBuffer = ^TKDT14DI32yanmicStoreBuffer;

  PKDT14DI32_Node = ^TKDT14DI32_Node;

  TKDT14DI32_Node = packed record
    Parent, Right, Left: PKDT14DI32_Node;
    vec: PKDT14DI32_Source;
  end;

  TKDT14DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT14DI32_Source);
  TKDT14DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT14DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT14DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT14DI32_Source);
  {$ENDIF}

  TKDT14DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT14DI32yanmicStoreBuffer;
    KDBuff     : TKDT14DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT14DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT14DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT14DI32yanmicStoreBuffer; const Buff: TKDT14DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT14DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT14DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT14DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT14DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DI32_Node; overload;
    function Search(const Buff: TKDT14DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DI32_Node; overload;
    function Search(const Buff: TKDT14DI32_Vec; var SearchedDistanceMin: Double): PKDT14DI32_Node; overload;
    function Search(const Buff: TKDT14DI32_Vec): PKDT14DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT14DI32_DynamicVecBuffer; var OutBuff: TKDT14DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT14DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT14DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT15DI32_Vec = array [0 .. TKDT15DI32_AxisCount - 1] of TKDT15DI32_VecType;
  PKDT15DI32_Vec = ^TKDT15DI32_Vec;

  TKDT15DI32_DynamicVecBuffer = array of TKDT15DI32_Vec;
  PKDT15DI32_DynamicVecBuffer = ^TKDT15DI32_DynamicVecBuffer;

  TKDT15DI32_Source = packed record
    Buff: TKDT15DI32_Vec;
    index: Int64;
  end;

  PKDT15DI32_Source       = ^TKDT15DI32_Source;
  TKDT15DI32_SourceBuffer = array [0 .. 0] of PKDT15DI32_Source;
  PKDT15DI32_SourceBuffer = ^TKDT15DI32_SourceBuffer;

  TKDT15DI32yanmicSourceBuffer = array of PKDT15DI32_Source;
  PKDT15DI32yanmicSourceBuffer = ^TKDT15DI32yanmicSourceBuffer;

  TKDT15DI32yanmicStoreBuffer = array of TKDT15DI32_Source;
  PKDT15DI32yanmicStoreBuffer = ^TKDT15DI32yanmicStoreBuffer;

  PKDT15DI32_Node = ^TKDT15DI32_Node;

  TKDT15DI32_Node = packed record
    Parent, Right, Left: PKDT15DI32_Node;
    vec: PKDT15DI32_Source;
  end;

  TKDT15DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT15DI32_Source);
  TKDT15DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT15DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT15DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT15DI32_Source);
  {$ENDIF}

  TKDT15DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT15DI32yanmicStoreBuffer;
    KDBuff     : TKDT15DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT15DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT15DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT15DI32yanmicStoreBuffer; const Buff: TKDT15DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT15DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT15DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT15DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT15DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT15DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DI32_Node; overload;
    function Search(const Buff: TKDT15DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DI32_Node; overload;
    function Search(const Buff: TKDT15DI32_Vec; var SearchedDistanceMin: Double): PKDT15DI32_Node; overload;
    function Search(const Buff: TKDT15DI32_Vec): PKDT15DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT15DI32_DynamicVecBuffer; var OutBuff: TKDT15DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT15DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT15DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT16DI32_Vec = array [0 .. TKDT16DI32_AxisCount - 1] of TKDT16DI32_VecType;
  PKDT16DI32_Vec = ^TKDT16DI32_Vec;

  TKDT16DI32_DynamicVecBuffer = array of TKDT16DI32_Vec;
  PKDT16DI32_DynamicVecBuffer = ^TKDT16DI32_DynamicVecBuffer;

  TKDT16DI32_Source = packed record
    Buff: TKDT16DI32_Vec;
    index: Int64;
  end;

  PKDT16DI32_Source       = ^TKDT16DI32_Source;
  TKDT16DI32_SourceBuffer = array [0 .. 0] of PKDT16DI32_Source;
  PKDT16DI32_SourceBuffer = ^TKDT16DI32_SourceBuffer;

  TKDT16DI32yanmicSourceBuffer = array of PKDT16DI32_Source;
  PKDT16DI32yanmicSourceBuffer = ^TKDT16DI32yanmicSourceBuffer;

  TKDT16DI32yanmicStoreBuffer = array of TKDT16DI32_Source;
  PKDT16DI32yanmicStoreBuffer = ^TKDT16DI32yanmicStoreBuffer;

  PKDT16DI32_Node = ^TKDT16DI32_Node;

  TKDT16DI32_Node = packed record
    Parent, Right, Left: PKDT16DI32_Node;
    vec: PKDT16DI32_Source;
  end;

  TKDT16DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT16DI32_Source);
  TKDT16DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT16DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT16DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT16DI32_Source);
  {$ENDIF}

  TKDT16DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT16DI32yanmicStoreBuffer;
    KDBuff     : TKDT16DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT16DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT16DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT16DI32yanmicStoreBuffer; const Buff: TKDT16DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT16DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT16DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT16DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT16DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DI32_Node; overload;
    function Search(const Buff: TKDT16DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DI32_Node; overload;
    function Search(const Buff: TKDT16DI32_Vec; var SearchedDistanceMin: Double): PKDT16DI32_Node; overload;
    function Search(const Buff: TKDT16DI32_Vec): PKDT16DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT16DI32_DynamicVecBuffer; var OutBuff: TKDT16DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT16DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT16DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT17DI32_Vec = array [0 .. TKDT17DI32_AxisCount - 1] of TKDT17DI32_VecType;
  PKDT17DI32_Vec = ^TKDT17DI32_Vec;

  TKDT17DI32_DynamicVecBuffer = array of TKDT17DI32_Vec;
  PKDT17DI32_DynamicVecBuffer = ^TKDT17DI32_DynamicVecBuffer;

  TKDT17DI32_Source = packed record
    Buff: TKDT17DI32_Vec;
    index: Int64;
  end;

  PKDT17DI32_Source       = ^TKDT17DI32_Source;
  TKDT17DI32_SourceBuffer = array [0 .. 0] of PKDT17DI32_Source;
  PKDT17DI32_SourceBuffer = ^TKDT17DI32_SourceBuffer;

  TKDT17DI32yanmicSourceBuffer = array of PKDT17DI32_Source;
  PKDT17DI32yanmicSourceBuffer = ^TKDT17DI32yanmicSourceBuffer;

  TKDT17DI32yanmicStoreBuffer = array of TKDT17DI32_Source;
  PKDT17DI32yanmicStoreBuffer = ^TKDT17DI32yanmicStoreBuffer;

  PKDT17DI32_Node = ^TKDT17DI32_Node;

  TKDT17DI32_Node = packed record
    Parent, Right, Left: PKDT17DI32_Node;
    vec: PKDT17DI32_Source;
  end;

  TKDT17DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT17DI32_Source);
  TKDT17DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT17DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT17DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT17DI32_Source);
  {$ENDIF}

  TKDT17DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT17DI32yanmicStoreBuffer;
    KDBuff     : TKDT17DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT17DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT17DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT17DI32yanmicStoreBuffer; const Buff: TKDT17DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT17DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT17DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT17DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT17DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT17DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DI32_Node; overload;
    function Search(const Buff: TKDT17DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DI32_Node; overload;
    function Search(const Buff: TKDT17DI32_Vec; var SearchedDistanceMin: Double): PKDT17DI32_Node; overload;
    function Search(const Buff: TKDT17DI32_Vec): PKDT17DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT17DI32_DynamicVecBuffer; var OutBuff: TKDT17DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT17DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT17DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT18DI32_Vec = array [0 .. TKDT18DI32_AxisCount - 1] of TKDT18DI32_VecType;
  PKDT18DI32_Vec = ^TKDT18DI32_Vec;

  TKDT18DI32_DynamicVecBuffer = array of TKDT18DI32_Vec;
  PKDT18DI32_DynamicVecBuffer = ^TKDT18DI32_DynamicVecBuffer;

  TKDT18DI32_Source = packed record
    Buff: TKDT18DI32_Vec;
    index: Int64;
  end;

  PKDT18DI32_Source       = ^TKDT18DI32_Source;
  TKDT18DI32_SourceBuffer = array [0 .. 0] of PKDT18DI32_Source;
  PKDT18DI32_SourceBuffer = ^TKDT18DI32_SourceBuffer;

  TKDT18DI32yanmicSourceBuffer = array of PKDT18DI32_Source;
  PKDT18DI32yanmicSourceBuffer = ^TKDT18DI32yanmicSourceBuffer;

  TKDT18DI32yanmicStoreBuffer = array of TKDT18DI32_Source;
  PKDT18DI32yanmicStoreBuffer = ^TKDT18DI32yanmicStoreBuffer;

  PKDT18DI32_Node = ^TKDT18DI32_Node;

  TKDT18DI32_Node = packed record
    Parent, Right, Left: PKDT18DI32_Node;
    vec: PKDT18DI32_Source;
  end;

  TKDT18DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT18DI32_Source);
  TKDT18DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT18DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT18DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT18DI32_Source);
  {$ENDIF}

  TKDT18DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT18DI32yanmicStoreBuffer;
    KDBuff     : TKDT18DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT18DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT18DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT18DI32yanmicStoreBuffer; const Buff: TKDT18DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT18DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT18DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT18DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT18DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DI32_Node; overload;
    function Search(const Buff: TKDT18DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DI32_Node; overload;
    function Search(const Buff: TKDT18DI32_Vec; var SearchedDistanceMin: Double): PKDT18DI32_Node; overload;
    function Search(const Buff: TKDT18DI32_Vec): PKDT18DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT18DI32_DynamicVecBuffer; var OutBuff: TKDT18DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT18DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT18DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT19DI32_Vec = array [0 .. TKDT19DI32_AxisCount - 1] of TKDT19DI32_VecType;
  PKDT19DI32_Vec = ^TKDT19DI32_Vec;

  TKDT19DI32_DynamicVecBuffer = array of TKDT19DI32_Vec;
  PKDT19DI32_DynamicVecBuffer = ^TKDT19DI32_DynamicVecBuffer;

  TKDT19DI32_Source = packed record
    Buff: TKDT19DI32_Vec;
    index: Int64;
  end;

  PKDT19DI32_Source       = ^TKDT19DI32_Source;
  TKDT19DI32_SourceBuffer = array [0 .. 0] of PKDT19DI32_Source;
  PKDT19DI32_SourceBuffer = ^TKDT19DI32_SourceBuffer;

  TKDT19DI32yanmicSourceBuffer = array of PKDT19DI32_Source;
  PKDT19DI32yanmicSourceBuffer = ^TKDT19DI32yanmicSourceBuffer;

  TKDT19DI32yanmicStoreBuffer = array of TKDT19DI32_Source;
  PKDT19DI32yanmicStoreBuffer = ^TKDT19DI32yanmicStoreBuffer;

  PKDT19DI32_Node = ^TKDT19DI32_Node;

  TKDT19DI32_Node = packed record
    Parent, Right, Left: PKDT19DI32_Node;
    vec: PKDT19DI32_Source;
  end;

  TKDT19DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT19DI32_Source);
  TKDT19DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT19DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT19DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT19DI32_Source);
  {$ENDIF}

  TKDT19DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT19DI32yanmicStoreBuffer;
    KDBuff     : TKDT19DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT19DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT19DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT19DI32yanmicStoreBuffer; const Buff: TKDT19DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT19DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT19DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT19DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT19DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT19DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DI32_Node; overload;
    function Search(const Buff: TKDT19DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DI32_Node; overload;
    function Search(const Buff: TKDT19DI32_Vec; var SearchedDistanceMin: Double): PKDT19DI32_Node; overload;
    function Search(const Buff: TKDT19DI32_Vec): PKDT19DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT19DI32_DynamicVecBuffer; var OutBuff: TKDT19DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT19DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT19DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT20DI32_Vec = array [0 .. TKDT20DI32_AxisCount - 1] of TKDT20DI32_VecType;
  PKDT20DI32_Vec = ^TKDT20DI32_Vec;

  TKDT20DI32_DynamicVecBuffer = array of TKDT20DI32_Vec;
  PKDT20DI32_DynamicVecBuffer = ^TKDT20DI32_DynamicVecBuffer;

  TKDT20DI32_Source = packed record
    Buff: TKDT20DI32_Vec;
    index: Int64;
  end;

  PKDT20DI32_Source       = ^TKDT20DI32_Source;
  TKDT20DI32_SourceBuffer = array [0 .. 0] of PKDT20DI32_Source;
  PKDT20DI32_SourceBuffer = ^TKDT20DI32_SourceBuffer;

  TKDT20DI32yanmicSourceBuffer = array of PKDT20DI32_Source;
  PKDT20DI32yanmicSourceBuffer = ^TKDT20DI32yanmicSourceBuffer;

  TKDT20DI32yanmicStoreBuffer = array of TKDT20DI32_Source;
  PKDT20DI32yanmicStoreBuffer = ^TKDT20DI32yanmicStoreBuffer;

  PKDT20DI32_Node = ^TKDT20DI32_Node;

  TKDT20DI32_Node = packed record
    Parent, Right, Left: PKDT20DI32_Node;
    vec: PKDT20DI32_Source;
  end;

  TKDT20DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT20DI32_Source);
  TKDT20DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT20DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT20DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT20DI32_Source);
  {$ENDIF}

  TKDT20DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT20DI32yanmicStoreBuffer;
    KDBuff     : TKDT20DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT20DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT20DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT20DI32yanmicStoreBuffer; const Buff: TKDT20DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT20DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT20DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT20DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT20DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DI32_Node; overload;
    function Search(const Buff: TKDT20DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DI32_Node; overload;
    function Search(const Buff: TKDT20DI32_Vec; var SearchedDistanceMin: Double): PKDT20DI32_Node; overload;
    function Search(const Buff: TKDT20DI32_Vec): PKDT20DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT20DI32_DynamicVecBuffer; var OutBuff: TKDT20DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT20DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT20DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT21DI32_Vec = array [0 .. TKDT21DI32_AxisCount - 1] of TKDT21DI32_VecType;
  PKDT21DI32_Vec = ^TKDT21DI32_Vec;

  TKDT21DI32_DynamicVecBuffer = array of TKDT21DI32_Vec;
  PKDT21DI32_DynamicVecBuffer = ^TKDT21DI32_DynamicVecBuffer;

  TKDT21DI32_Source = packed record
    Buff: TKDT21DI32_Vec;
    index: Int64;
  end;

  PKDT21DI32_Source       = ^TKDT21DI32_Source;
  TKDT21DI32_SourceBuffer = array [0 .. 0] of PKDT21DI32_Source;
  PKDT21DI32_SourceBuffer = ^TKDT21DI32_SourceBuffer;

  TKDT21DI32yanmicSourceBuffer = array of PKDT21DI32_Source;
  PKDT21DI32yanmicSourceBuffer = ^TKDT21DI32yanmicSourceBuffer;

  TKDT21DI32yanmicStoreBuffer = array of TKDT21DI32_Source;
  PKDT21DI32yanmicStoreBuffer = ^TKDT21DI32yanmicStoreBuffer;

  PKDT21DI32_Node = ^TKDT21DI32_Node;

  TKDT21DI32_Node = packed record
    Parent, Right, Left: PKDT21DI32_Node;
    vec: PKDT21DI32_Source;
  end;

  TKDT21DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT21DI32_Source);
  TKDT21DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT21DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT21DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT21DI32_Source);
  {$ENDIF}

  TKDT21DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT21DI32yanmicStoreBuffer;
    KDBuff     : TKDT21DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT21DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT21DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT21DI32yanmicStoreBuffer; const Buff: TKDT21DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT21DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT21DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT21DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT21DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT21DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DI32_Node; overload;
    function Search(const Buff: TKDT21DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DI32_Node; overload;
    function Search(const Buff: TKDT21DI32_Vec; var SearchedDistanceMin: Double): PKDT21DI32_Node; overload;
    function Search(const Buff: TKDT21DI32_Vec): PKDT21DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT21DI32_DynamicVecBuffer; var OutBuff: TKDT21DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT21DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT21DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT22DI32_Vec = array [0 .. TKDT22DI32_AxisCount - 1] of TKDT22DI32_VecType;
  PKDT22DI32_Vec = ^TKDT22DI32_Vec;

  TKDT22DI32_DynamicVecBuffer = array of TKDT22DI32_Vec;
  PKDT22DI32_DynamicVecBuffer = ^TKDT22DI32_DynamicVecBuffer;

  TKDT22DI32_Source = packed record
    Buff: TKDT22DI32_Vec;
    index: Int64;
  end;

  PKDT22DI32_Source       = ^TKDT22DI32_Source;
  TKDT22DI32_SourceBuffer = array [0 .. 0] of PKDT22DI32_Source;
  PKDT22DI32_SourceBuffer = ^TKDT22DI32_SourceBuffer;

  TKDT22DI32yanmicSourceBuffer = array of PKDT22DI32_Source;
  PKDT22DI32yanmicSourceBuffer = ^TKDT22DI32yanmicSourceBuffer;

  TKDT22DI32yanmicStoreBuffer = array of TKDT22DI32_Source;
  PKDT22DI32yanmicStoreBuffer = ^TKDT22DI32yanmicStoreBuffer;

  PKDT22DI32_Node = ^TKDT22DI32_Node;

  TKDT22DI32_Node = packed record
    Parent, Right, Left: PKDT22DI32_Node;
    vec: PKDT22DI32_Source;
  end;

  TKDT22DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT22DI32_Source);
  TKDT22DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT22DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT22DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT22DI32_Source);
  {$ENDIF}

  TKDT22DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT22DI32yanmicStoreBuffer;
    KDBuff     : TKDT22DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT22DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT22DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT22DI32yanmicStoreBuffer; const Buff: TKDT22DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT22DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT22DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT22DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT22DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DI32_Node; overload;
    function Search(const Buff: TKDT22DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DI32_Node; overload;
    function Search(const Buff: TKDT22DI32_Vec; var SearchedDistanceMin: Double): PKDT22DI32_Node; overload;
    function Search(const Buff: TKDT22DI32_Vec): PKDT22DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT22DI32_DynamicVecBuffer; var OutBuff: TKDT22DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT22DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT22DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT23DI32_Vec = array [0 .. TKDT23DI32_AxisCount - 1] of TKDT23DI32_VecType;
  PKDT23DI32_Vec = ^TKDT23DI32_Vec;

  TKDT23DI32_DynamicVecBuffer = array of TKDT23DI32_Vec;
  PKDT23DI32_DynamicVecBuffer = ^TKDT23DI32_DynamicVecBuffer;

  TKDT23DI32_Source = packed record
    Buff: TKDT23DI32_Vec;
    index: Int64;
  end;

  PKDT23DI32_Source       = ^TKDT23DI32_Source;
  TKDT23DI32_SourceBuffer = array [0 .. 0] of PKDT23DI32_Source;
  PKDT23DI32_SourceBuffer = ^TKDT23DI32_SourceBuffer;

  TKDT23DI32yanmicSourceBuffer = array of PKDT23DI32_Source;
  PKDT23DI32yanmicSourceBuffer = ^TKDT23DI32yanmicSourceBuffer;

  TKDT23DI32yanmicStoreBuffer = array of TKDT23DI32_Source;
  PKDT23DI32yanmicStoreBuffer = ^TKDT23DI32yanmicStoreBuffer;

  PKDT23DI32_Node = ^TKDT23DI32_Node;

  TKDT23DI32_Node = packed record
    Parent, Right, Left: PKDT23DI32_Node;
    vec: PKDT23DI32_Source;
  end;

  TKDT23DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT23DI32_Source);
  TKDT23DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT23DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT23DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT23DI32_Source);
  {$ENDIF}

  TKDT23DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT23DI32yanmicStoreBuffer;
    KDBuff     : TKDT23DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT23DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT23DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT23DI32yanmicStoreBuffer; const Buff: TKDT23DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT23DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT23DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT23DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT23DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT23DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DI32_Node; overload;
    function Search(const Buff: TKDT23DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DI32_Node; overload;
    function Search(const Buff: TKDT23DI32_Vec; var SearchedDistanceMin: Double): PKDT23DI32_Node; overload;
    function Search(const Buff: TKDT23DI32_Vec): PKDT23DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT23DI32_DynamicVecBuffer; var OutBuff: TKDT23DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT23DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT23DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT24DI32_Vec = array [0 .. TKDT24DI32_AxisCount - 1] of TKDT24DI32_VecType;
  PKDT24DI32_Vec = ^TKDT24DI32_Vec;

  TKDT24DI32_DynamicVecBuffer = array of TKDT24DI32_Vec;
  PKDT24DI32_DynamicVecBuffer = ^TKDT24DI32_DynamicVecBuffer;

  TKDT24DI32_Source = packed record
    Buff: TKDT24DI32_Vec;
    index: Int64;
  end;

  PKDT24DI32_Source       = ^TKDT24DI32_Source;
  TKDT24DI32_SourceBuffer = array [0 .. 0] of PKDT24DI32_Source;
  PKDT24DI32_SourceBuffer = ^TKDT24DI32_SourceBuffer;

  TKDT24DI32yanmicSourceBuffer = array of PKDT24DI32_Source;
  PKDT24DI32yanmicSourceBuffer = ^TKDT24DI32yanmicSourceBuffer;

  TKDT24DI32yanmicStoreBuffer = array of TKDT24DI32_Source;
  PKDT24DI32yanmicStoreBuffer = ^TKDT24DI32yanmicStoreBuffer;

  PKDT24DI32_Node = ^TKDT24DI32_Node;

  TKDT24DI32_Node = packed record
    Parent, Right, Left: PKDT24DI32_Node;
    vec: PKDT24DI32_Source;
  end;

  TKDT24DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT24DI32_Source);
  TKDT24DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT24DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT24DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT24DI32_Source);
  {$ENDIF}

  TKDT24DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT24DI32yanmicStoreBuffer;
    KDBuff     : TKDT24DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT24DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT24DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT24DI32yanmicStoreBuffer; const Buff: TKDT24DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT24DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT24DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT24DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT24DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DI32_Node; overload;
    function Search(const Buff: TKDT24DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DI32_Node; overload;
    function Search(const Buff: TKDT24DI32_Vec; var SearchedDistanceMin: Double): PKDT24DI32_Node; overload;
    function Search(const Buff: TKDT24DI32_Vec): PKDT24DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT24DI32_DynamicVecBuffer; var OutBuff: TKDT24DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT24DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT24DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT25DI32_Vec = array [0 .. TKDT25DI32_AxisCount - 1] of TKDT25DI32_VecType;
  PKDT25DI32_Vec = ^TKDT25DI32_Vec;

  TKDT25DI32_DynamicVecBuffer = array of TKDT25DI32_Vec;
  PKDT25DI32_DynamicVecBuffer = ^TKDT25DI32_DynamicVecBuffer;

  TKDT25DI32_Source = packed record
    Buff: TKDT25DI32_Vec;
    index: Int64;
  end;

  PKDT25DI32_Source       = ^TKDT25DI32_Source;
  TKDT25DI32_SourceBuffer = array [0 .. 0] of PKDT25DI32_Source;
  PKDT25DI32_SourceBuffer = ^TKDT25DI32_SourceBuffer;

  TKDT25DI32yanmicSourceBuffer = array of PKDT25DI32_Source;
  PKDT25DI32yanmicSourceBuffer = ^TKDT25DI32yanmicSourceBuffer;

  TKDT25DI32yanmicStoreBuffer = array of TKDT25DI32_Source;
  PKDT25DI32yanmicStoreBuffer = ^TKDT25DI32yanmicStoreBuffer;

  PKDT25DI32_Node = ^TKDT25DI32_Node;

  TKDT25DI32_Node = packed record
    Parent, Right, Left: PKDT25DI32_Node;
    vec: PKDT25DI32_Source;
  end;

  TKDT25DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT25DI32_Source);
  TKDT25DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT25DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT25DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT25DI32_Source);
  {$ENDIF}

  TKDT25DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT25DI32yanmicStoreBuffer;
    KDBuff     : TKDT25DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT25DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT25DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT25DI32yanmicStoreBuffer; const Buff: TKDT25DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT25DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT25DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT25DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT25DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT25DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DI32_Node; overload;
    function Search(const Buff: TKDT25DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DI32_Node; overload;
    function Search(const Buff: TKDT25DI32_Vec; var SearchedDistanceMin: Double): PKDT25DI32_Node; overload;
    function Search(const Buff: TKDT25DI32_Vec): PKDT25DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT25DI32_DynamicVecBuffer; var OutBuff: TKDT25DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT25DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT25DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT26DI32_Vec = array [0 .. TKDT26DI32_AxisCount - 1] of TKDT26DI32_VecType;
  PKDT26DI32_Vec = ^TKDT26DI32_Vec;

  TKDT26DI32_DynamicVecBuffer = array of TKDT26DI32_Vec;
  PKDT26DI32_DynamicVecBuffer = ^TKDT26DI32_DynamicVecBuffer;

  TKDT26DI32_Source = packed record
    Buff: TKDT26DI32_Vec;
    index: Int64;
  end;

  PKDT26DI32_Source       = ^TKDT26DI32_Source;
  TKDT26DI32_SourceBuffer = array [0 .. 0] of PKDT26DI32_Source;
  PKDT26DI32_SourceBuffer = ^TKDT26DI32_SourceBuffer;

  TKDT26DI32yanmicSourceBuffer = array of PKDT26DI32_Source;
  PKDT26DI32yanmicSourceBuffer = ^TKDT26DI32yanmicSourceBuffer;

  TKDT26DI32yanmicStoreBuffer = array of TKDT26DI32_Source;
  PKDT26DI32yanmicStoreBuffer = ^TKDT26DI32yanmicStoreBuffer;

  PKDT26DI32_Node = ^TKDT26DI32_Node;

  TKDT26DI32_Node = packed record
    Parent, Right, Left: PKDT26DI32_Node;
    vec: PKDT26DI32_Source;
  end;

  TKDT26DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT26DI32_Source);
  TKDT26DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT26DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT26DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT26DI32_Source);
  {$ENDIF}

  TKDT26DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT26DI32yanmicStoreBuffer;
    KDBuff     : TKDT26DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT26DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT26DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT26DI32yanmicStoreBuffer; const Buff: TKDT26DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT26DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT26DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT26DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT26DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT26DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DI32_Node; overload;
    function Search(const Buff: TKDT26DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DI32_Node; overload;
    function Search(const Buff: TKDT26DI32_Vec; var SearchedDistanceMin: Double): PKDT26DI32_Node; overload;
    function Search(const Buff: TKDT26DI32_Vec): PKDT26DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT26DI32_DynamicVecBuffer; var OutBuff: TKDT26DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT26DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT26DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT27DI32_Vec = array [0 .. TKDT27DI32_AxisCount - 1] of TKDT27DI32_VecType;
  PKDT27DI32_Vec = ^TKDT27DI32_Vec;

  TKDT27DI32_DynamicVecBuffer = array of TKDT27DI32_Vec;
  PKDT27DI32_DynamicVecBuffer = ^TKDT27DI32_DynamicVecBuffer;

  TKDT27DI32_Source = packed record
    Buff: TKDT27DI32_Vec;
    index: Int64;
  end;

  PKDT27DI32_Source       = ^TKDT27DI32_Source;
  TKDT27DI32_SourceBuffer = array [0 .. 0] of PKDT27DI32_Source;
  PKDT27DI32_SourceBuffer = ^TKDT27DI32_SourceBuffer;

  TKDT27DI32yanmicSourceBuffer = array of PKDT27DI32_Source;
  PKDT27DI32yanmicSourceBuffer = ^TKDT27DI32yanmicSourceBuffer;

  TKDT27DI32yanmicStoreBuffer = array of TKDT27DI32_Source;
  PKDT27DI32yanmicStoreBuffer = ^TKDT27DI32yanmicStoreBuffer;

  PKDT27DI32_Node = ^TKDT27DI32_Node;

  TKDT27DI32_Node = packed record
    Parent, Right, Left: PKDT27DI32_Node;
    vec: PKDT27DI32_Source;
  end;

  TKDT27DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT27DI32_Source);
  TKDT27DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT27DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT27DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT27DI32_Source);
  {$ENDIF}

  TKDT27DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT27DI32yanmicStoreBuffer;
    KDBuff     : TKDT27DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT27DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT27DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT27DI32yanmicStoreBuffer; const Buff: TKDT27DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT27DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT27DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT27DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT27DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT27DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DI32_Node; overload;
    function Search(const Buff: TKDT27DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DI32_Node; overload;
    function Search(const Buff: TKDT27DI32_Vec; var SearchedDistanceMin: Double): PKDT27DI32_Node; overload;
    function Search(const Buff: TKDT27DI32_Vec): PKDT27DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT27DI32_DynamicVecBuffer; var OutBuff: TKDT27DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT27DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT27DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT28DI32_Vec = array [0 .. TKDT28DI32_AxisCount - 1] of TKDT28DI32_VecType;
  PKDT28DI32_Vec = ^TKDT28DI32_Vec;

  TKDT28DI32_DynamicVecBuffer = array of TKDT28DI32_Vec;
  PKDT28DI32_DynamicVecBuffer = ^TKDT28DI32_DynamicVecBuffer;

  TKDT28DI32_Source = packed record
    Buff: TKDT28DI32_Vec;
    index: Int64;
  end;

  PKDT28DI32_Source       = ^TKDT28DI32_Source;
  TKDT28DI32_SourceBuffer = array [0 .. 0] of PKDT28DI32_Source;
  PKDT28DI32_SourceBuffer = ^TKDT28DI32_SourceBuffer;

  TKDT28DI32yanmicSourceBuffer = array of PKDT28DI32_Source;
  PKDT28DI32yanmicSourceBuffer = ^TKDT28DI32yanmicSourceBuffer;

  TKDT28DI32yanmicStoreBuffer = array of TKDT28DI32_Source;
  PKDT28DI32yanmicStoreBuffer = ^TKDT28DI32yanmicStoreBuffer;

  PKDT28DI32_Node = ^TKDT28DI32_Node;

  TKDT28DI32_Node = packed record
    Parent, Right, Left: PKDT28DI32_Node;
    vec: PKDT28DI32_Source;
  end;

  TKDT28DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT28DI32_Source);
  TKDT28DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT28DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT28DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT28DI32_Source);
  {$ENDIF}

  TKDT28DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT28DI32yanmicStoreBuffer;
    KDBuff     : TKDT28DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT28DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT28DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT28DI32yanmicStoreBuffer; const Buff: TKDT28DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT28DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT28DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT28DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT28DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT28DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DI32_Node; overload;
    function Search(const Buff: TKDT28DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DI32_Node; overload;
    function Search(const Buff: TKDT28DI32_Vec; var SearchedDistanceMin: Double): PKDT28DI32_Node; overload;
    function Search(const Buff: TKDT28DI32_Vec): PKDT28DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT28DI32_DynamicVecBuffer; var OutBuff: TKDT28DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT28DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT28DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT29DI32_Vec = array [0 .. TKDT29DI32_AxisCount - 1] of TKDT29DI32_VecType;
  PKDT29DI32_Vec = ^TKDT29DI32_Vec;

  TKDT29DI32_DynamicVecBuffer = array of TKDT29DI32_Vec;
  PKDT29DI32_DynamicVecBuffer = ^TKDT29DI32_DynamicVecBuffer;

  TKDT29DI32_Source = packed record
    Buff: TKDT29DI32_Vec;
    index: Int64;
  end;

  PKDT29DI32_Source       = ^TKDT29DI32_Source;
  TKDT29DI32_SourceBuffer = array [0 .. 0] of PKDT29DI32_Source;
  PKDT29DI32_SourceBuffer = ^TKDT29DI32_SourceBuffer;

  TKDT29DI32yanmicSourceBuffer = array of PKDT29DI32_Source;
  PKDT29DI32yanmicSourceBuffer = ^TKDT29DI32yanmicSourceBuffer;

  TKDT29DI32yanmicStoreBuffer = array of TKDT29DI32_Source;
  PKDT29DI32yanmicStoreBuffer = ^TKDT29DI32yanmicStoreBuffer;

  PKDT29DI32_Node = ^TKDT29DI32_Node;

  TKDT29DI32_Node = packed record
    Parent, Right, Left: PKDT29DI32_Node;
    vec: PKDT29DI32_Source;
  end;

  TKDT29DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT29DI32_Source);
  TKDT29DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT29DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT29DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT29DI32_Source);
  {$ENDIF}

  TKDT29DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT29DI32yanmicStoreBuffer;
    KDBuff     : TKDT29DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT29DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT29DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT29DI32yanmicStoreBuffer; const Buff: TKDT29DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT29DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT29DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT29DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT29DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT29DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DI32_Node; overload;
    function Search(const Buff: TKDT29DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DI32_Node; overload;
    function Search(const Buff: TKDT29DI32_Vec; var SearchedDistanceMin: Double): PKDT29DI32_Node; overload;
    function Search(const Buff: TKDT29DI32_Vec): PKDT29DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT29DI32_DynamicVecBuffer; var OutBuff: TKDT29DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT29DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT29DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT30DI32_Vec = array [0 .. TKDT30DI32_AxisCount - 1] of TKDT30DI32_VecType;
  PKDT30DI32_Vec = ^TKDT30DI32_Vec;

  TKDT30DI32_DynamicVecBuffer = array of TKDT30DI32_Vec;
  PKDT30DI32_DynamicVecBuffer = ^TKDT30DI32_DynamicVecBuffer;

  TKDT30DI32_Source = packed record
    Buff: TKDT30DI32_Vec;
    index: Int64;
  end;

  PKDT30DI32_Source       = ^TKDT30DI32_Source;
  TKDT30DI32_SourceBuffer = array [0 .. 0] of PKDT30DI32_Source;
  PKDT30DI32_SourceBuffer = ^TKDT30DI32_SourceBuffer;

  TKDT30DI32yanmicSourceBuffer = array of PKDT30DI32_Source;
  PKDT30DI32yanmicSourceBuffer = ^TKDT30DI32yanmicSourceBuffer;

  TKDT30DI32yanmicStoreBuffer = array of TKDT30DI32_Source;
  PKDT30DI32yanmicStoreBuffer = ^TKDT30DI32yanmicStoreBuffer;

  PKDT30DI32_Node = ^TKDT30DI32_Node;

  TKDT30DI32_Node = packed record
    Parent, Right, Left: PKDT30DI32_Node;
    vec: PKDT30DI32_Source;
  end;

  TKDT30DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT30DI32_Source);
  TKDT30DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT30DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT30DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT30DI32_Source);
  {$ENDIF}

  TKDT30DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT30DI32yanmicStoreBuffer;
    KDBuff     : TKDT30DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT30DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT30DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT30DI32yanmicStoreBuffer; const Buff: TKDT30DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT30DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT30DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT30DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT30DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT30DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DI32_Node; overload;
    function Search(const Buff: TKDT30DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DI32_Node; overload;
    function Search(const Buff: TKDT30DI32_Vec; var SearchedDistanceMin: Double): PKDT30DI32_Node; overload;
    function Search(const Buff: TKDT30DI32_Vec): PKDT30DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT30DI32_DynamicVecBuffer; var OutBuff: TKDT30DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT30DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT30DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT32DI32_Vec = array [0 .. TKDT32DI32_AxisCount - 1] of TKDT32DI32_VecType;
  PKDT32DI32_Vec = ^TKDT32DI32_Vec;

  TKDT32DI32_DynamicVecBuffer = array of TKDT32DI32_Vec;
  PKDT32DI32_DynamicVecBuffer = ^TKDT32DI32_DynamicVecBuffer;

  TKDT32DI32_Source = packed record
    Buff: TKDT32DI32_Vec;
    index: Int64;
  end;

  PKDT32DI32_Source       = ^TKDT32DI32_Source;
  TKDT32DI32_SourceBuffer = array [0 .. 0] of PKDT32DI32_Source;
  PKDT32DI32_SourceBuffer = ^TKDT32DI32_SourceBuffer;

  TKDT32DI32yanmicSourceBuffer = array of PKDT32DI32_Source;
  PKDT32DI32yanmicSourceBuffer = ^TKDT32DI32yanmicSourceBuffer;

  TKDT32DI32yanmicStoreBuffer = array of TKDT32DI32_Source;
  PKDT32DI32yanmicStoreBuffer = ^TKDT32DI32yanmicStoreBuffer;

  PKDT32DI32_Node = ^TKDT32DI32_Node;

  TKDT32DI32_Node = packed record
    Parent, Right, Left: PKDT32DI32_Node;
    vec: PKDT32DI32_Source;
  end;

  TKDT32DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT32DI32_Source);
  TKDT32DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT32DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT32DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT32DI32_Source);
  {$ENDIF}

  TKDT32DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT32DI32yanmicStoreBuffer;
    KDBuff     : TKDT32DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT32DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT32DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT32DI32yanmicStoreBuffer; const Buff: TKDT32DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT32DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT32DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT32DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT32DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT32DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DI32_Node; overload;
    function Search(const Buff: TKDT32DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DI32_Node; overload;
    function Search(const Buff: TKDT32DI32_Vec; var SearchedDistanceMin: Double): PKDT32DI32_Node; overload;
    function Search(const Buff: TKDT32DI32_Vec): PKDT32DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT32DI32_DynamicVecBuffer; var OutBuff: TKDT32DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT32DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT32DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT34DI32_Vec = array [0 .. TKDT34DI32_AxisCount - 1] of TKDT34DI32_VecType;
  PKDT34DI32_Vec = ^TKDT34DI32_Vec;

  TKDT34DI32_DynamicVecBuffer = array of TKDT34DI32_Vec;
  PKDT34DI32_DynamicVecBuffer = ^TKDT34DI32_DynamicVecBuffer;

  TKDT34DI32_Source = packed record
    Buff: TKDT34DI32_Vec;
    index: Int64;
  end;

  PKDT34DI32_Source       = ^TKDT34DI32_Source;
  TKDT34DI32_SourceBuffer = array [0 .. 0] of PKDT34DI32_Source;
  PKDT34DI32_SourceBuffer = ^TKDT34DI32_SourceBuffer;

  TKDT34DI32yanmicSourceBuffer = array of PKDT34DI32_Source;
  PKDT34DI32yanmicSourceBuffer = ^TKDT34DI32yanmicSourceBuffer;

  TKDT34DI32yanmicStoreBuffer = array of TKDT34DI32_Source;
  PKDT34DI32yanmicStoreBuffer = ^TKDT34DI32yanmicStoreBuffer;

  PKDT34DI32_Node = ^TKDT34DI32_Node;

  TKDT34DI32_Node = packed record
    Parent, Right, Left: PKDT34DI32_Node;
    vec: PKDT34DI32_Source;
  end;

  TKDT34DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT34DI32_Source);
  TKDT34DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT34DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT34DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT34DI32_Source);
  {$ENDIF}

  TKDT34DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT34DI32yanmicStoreBuffer;
    KDBuff     : TKDT34DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT34DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT34DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT34DI32yanmicStoreBuffer; const Buff: TKDT34DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT34DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT34DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT34DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT34DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT34DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DI32_Node; overload;
    function Search(const Buff: TKDT34DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DI32_Node; overload;
    function Search(const Buff: TKDT34DI32_Vec; var SearchedDistanceMin: Double): PKDT34DI32_Node; overload;
    function Search(const Buff: TKDT34DI32_Vec): PKDT34DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT34DI32_DynamicVecBuffer; var OutBuff: TKDT34DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT34DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT34DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT36DI32_Vec = array [0 .. TKDT36DI32_AxisCount - 1] of TKDT36DI32_VecType;
  PKDT36DI32_Vec = ^TKDT36DI32_Vec;

  TKDT36DI32_DynamicVecBuffer = array of TKDT36DI32_Vec;
  PKDT36DI32_DynamicVecBuffer = ^TKDT36DI32_DynamicVecBuffer;

  TKDT36DI32_Source = packed record
    Buff: TKDT36DI32_Vec;
    index: Int64;
  end;

  PKDT36DI32_Source       = ^TKDT36DI32_Source;
  TKDT36DI32_SourceBuffer = array [0 .. 0] of PKDT36DI32_Source;
  PKDT36DI32_SourceBuffer = ^TKDT36DI32_SourceBuffer;

  TKDT36DI32yanmicSourceBuffer = array of PKDT36DI32_Source;
  PKDT36DI32yanmicSourceBuffer = ^TKDT36DI32yanmicSourceBuffer;

  TKDT36DI32yanmicStoreBuffer = array of TKDT36DI32_Source;
  PKDT36DI32yanmicStoreBuffer = ^TKDT36DI32yanmicStoreBuffer;

  PKDT36DI32_Node = ^TKDT36DI32_Node;

  TKDT36DI32_Node = packed record
    Parent, Right, Left: PKDT36DI32_Node;
    vec: PKDT36DI32_Source;
  end;

  TKDT36DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT36DI32_Source);
  TKDT36DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT36DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT36DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT36DI32_Source);
  {$ENDIF}

  TKDT36DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT36DI32yanmicStoreBuffer;
    KDBuff     : TKDT36DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT36DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT36DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT36DI32yanmicStoreBuffer; const Buff: TKDT36DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT36DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT36DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT36DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT36DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT36DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DI32_Node; overload;
    function Search(const Buff: TKDT36DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DI32_Node; overload;
    function Search(const Buff: TKDT36DI32_Vec; var SearchedDistanceMin: Double): PKDT36DI32_Node; overload;
    function Search(const Buff: TKDT36DI32_Vec): PKDT36DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT36DI32_DynamicVecBuffer; var OutBuff: TKDT36DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT36DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT36DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT38DI32_Vec = array [0 .. TKDT38DI32_AxisCount - 1] of TKDT38DI32_VecType;
  PKDT38DI32_Vec = ^TKDT38DI32_Vec;

  TKDT38DI32_DynamicVecBuffer = array of TKDT38DI32_Vec;
  PKDT38DI32_DynamicVecBuffer = ^TKDT38DI32_DynamicVecBuffer;

  TKDT38DI32_Source = packed record
    Buff: TKDT38DI32_Vec;
    index: Int64;
  end;

  PKDT38DI32_Source       = ^TKDT38DI32_Source;
  TKDT38DI32_SourceBuffer = array [0 .. 0] of PKDT38DI32_Source;
  PKDT38DI32_SourceBuffer = ^TKDT38DI32_SourceBuffer;

  TKDT38DI32yanmicSourceBuffer = array of PKDT38DI32_Source;
  PKDT38DI32yanmicSourceBuffer = ^TKDT38DI32yanmicSourceBuffer;

  TKDT38DI32yanmicStoreBuffer = array of TKDT38DI32_Source;
  PKDT38DI32yanmicStoreBuffer = ^TKDT38DI32yanmicStoreBuffer;

  PKDT38DI32_Node = ^TKDT38DI32_Node;

  TKDT38DI32_Node = packed record
    Parent, Right, Left: PKDT38DI32_Node;
    vec: PKDT38DI32_Source;
  end;

  TKDT38DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT38DI32_Source);
  TKDT38DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT38DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT38DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT38DI32_Source);
  {$ENDIF}

  TKDT38DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT38DI32yanmicStoreBuffer;
    KDBuff     : TKDT38DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT38DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT38DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT38DI32yanmicStoreBuffer; const Buff: TKDT38DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT38DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT38DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT38DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT38DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT38DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DI32_Node; overload;
    function Search(const Buff: TKDT38DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DI32_Node; overload;
    function Search(const Buff: TKDT38DI32_Vec; var SearchedDistanceMin: Double): PKDT38DI32_Node; overload;
    function Search(const Buff: TKDT38DI32_Vec): PKDT38DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT38DI32_DynamicVecBuffer; var OutBuff: TKDT38DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT38DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT38DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT40DI32_Vec = array [0 .. TKDT40DI32_AxisCount - 1] of TKDT40DI32_VecType;
  PKDT40DI32_Vec = ^TKDT40DI32_Vec;

  TKDT40DI32_DynamicVecBuffer = array of TKDT40DI32_Vec;
  PKDT40DI32_DynamicVecBuffer = ^TKDT40DI32_DynamicVecBuffer;

  TKDT40DI32_Source = packed record
    Buff: TKDT40DI32_Vec;
    index: Int64;
  end;

  PKDT40DI32_Source       = ^TKDT40DI32_Source;
  TKDT40DI32_SourceBuffer = array [0 .. 0] of PKDT40DI32_Source;
  PKDT40DI32_SourceBuffer = ^TKDT40DI32_SourceBuffer;

  TKDT40DI32yanmicSourceBuffer = array of PKDT40DI32_Source;
  PKDT40DI32yanmicSourceBuffer = ^TKDT40DI32yanmicSourceBuffer;

  TKDT40DI32yanmicStoreBuffer = array of TKDT40DI32_Source;
  PKDT40DI32yanmicStoreBuffer = ^TKDT40DI32yanmicStoreBuffer;

  PKDT40DI32_Node = ^TKDT40DI32_Node;

  TKDT40DI32_Node = packed record
    Parent, Right, Left: PKDT40DI32_Node;
    vec: PKDT40DI32_Source;
  end;

  TKDT40DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT40DI32_Source);
  TKDT40DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT40DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT40DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT40DI32_Source);
  {$ENDIF}

  TKDT40DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT40DI32yanmicStoreBuffer;
    KDBuff     : TKDT40DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT40DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT40DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT40DI32yanmicStoreBuffer; const Buff: TKDT40DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT40DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT40DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT40DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT40DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT40DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DI32_Node; overload;
    function Search(const Buff: TKDT40DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DI32_Node; overload;
    function Search(const Buff: TKDT40DI32_Vec; var SearchedDistanceMin: Double): PKDT40DI32_Node; overload;
    function Search(const Buff: TKDT40DI32_Vec): PKDT40DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT40DI32_DynamicVecBuffer; var OutBuff: TKDT40DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT40DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT40DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT44DI32_Vec = array [0 .. TKDT44DI32_AxisCount - 1] of TKDT44DI32_VecType;
  PKDT44DI32_Vec = ^TKDT44DI32_Vec;

  TKDT44DI32_DynamicVecBuffer = array of TKDT44DI32_Vec;
  PKDT44DI32_DynamicVecBuffer = ^TKDT44DI32_DynamicVecBuffer;

  TKDT44DI32_Source = packed record
    Buff: TKDT44DI32_Vec;
    index: Int64;
  end;

  PKDT44DI32_Source       = ^TKDT44DI32_Source;
  TKDT44DI32_SourceBuffer = array [0 .. 0] of PKDT44DI32_Source;
  PKDT44DI32_SourceBuffer = ^TKDT44DI32_SourceBuffer;

  TKDT44DI32yanmicSourceBuffer = array of PKDT44DI32_Source;
  PKDT44DI32yanmicSourceBuffer = ^TKDT44DI32yanmicSourceBuffer;

  TKDT44DI32yanmicStoreBuffer = array of TKDT44DI32_Source;
  PKDT44DI32yanmicStoreBuffer = ^TKDT44DI32yanmicStoreBuffer;

  PKDT44DI32_Node = ^TKDT44DI32_Node;

  TKDT44DI32_Node = packed record
    Parent, Right, Left: PKDT44DI32_Node;
    vec: PKDT44DI32_Source;
  end;

  TKDT44DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT44DI32_Source);
  TKDT44DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT44DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT44DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT44DI32_Source);
  {$ENDIF}

  TKDT44DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT44DI32yanmicStoreBuffer;
    KDBuff     : TKDT44DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT44DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT44DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT44DI32yanmicStoreBuffer; const Buff: TKDT44DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT44DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT44DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT44DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT44DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT44DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DI32_Node; overload;
    function Search(const Buff: TKDT44DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DI32_Node; overload;
    function Search(const Buff: TKDT44DI32_Vec; var SearchedDistanceMin: Double): PKDT44DI32_Node; overload;
    function Search(const Buff: TKDT44DI32_Vec): PKDT44DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT44DI32_DynamicVecBuffer; var OutBuff: TKDT44DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT44DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT44DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT48DI32_Vec = array [0 .. TKDT48DI32_AxisCount - 1] of TKDT48DI32_VecType;
  PKDT48DI32_Vec = ^TKDT48DI32_Vec;

  TKDT48DI32_DynamicVecBuffer = array of TKDT48DI32_Vec;
  PKDT48DI32_DynamicVecBuffer = ^TKDT48DI32_DynamicVecBuffer;

  TKDT48DI32_Source = packed record
    Buff: TKDT48DI32_Vec;
    index: Int64;
  end;

  PKDT48DI32_Source       = ^TKDT48DI32_Source;
  TKDT48DI32_SourceBuffer = array [0 .. 0] of PKDT48DI32_Source;
  PKDT48DI32_SourceBuffer = ^TKDT48DI32_SourceBuffer;

  TKDT48DI32yanmicSourceBuffer = array of PKDT48DI32_Source;
  PKDT48DI32yanmicSourceBuffer = ^TKDT48DI32yanmicSourceBuffer;

  TKDT48DI32yanmicStoreBuffer = array of TKDT48DI32_Source;
  PKDT48DI32yanmicStoreBuffer = ^TKDT48DI32yanmicStoreBuffer;

  PKDT48DI32_Node = ^TKDT48DI32_Node;

  TKDT48DI32_Node = packed record
    Parent, Right, Left: PKDT48DI32_Node;
    vec: PKDT48DI32_Source;
  end;

  TKDT48DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT48DI32_Source);
  TKDT48DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT48DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT48DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT48DI32_Source);
  {$ENDIF}

  TKDT48DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT48DI32yanmicStoreBuffer;
    KDBuff     : TKDT48DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT48DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT48DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT48DI32yanmicStoreBuffer; const Buff: TKDT48DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT48DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT48DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT48DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT48DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DI32_Node; overload;
    function Search(const Buff: TKDT48DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DI32_Node; overload;
    function Search(const Buff: TKDT48DI32_Vec; var SearchedDistanceMin: Double): PKDT48DI32_Node; overload;
    function Search(const Buff: TKDT48DI32_Vec): PKDT48DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT48DI32_DynamicVecBuffer; var OutBuff: TKDT48DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT48DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT48DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT50DI32_Vec = array [0 .. TKDT50DI32_AxisCount - 1] of TKDT50DI32_VecType;
  PKDT50DI32_Vec = ^TKDT50DI32_Vec;

  TKDT50DI32_DynamicVecBuffer = array of TKDT50DI32_Vec;
  PKDT50DI32_DynamicVecBuffer = ^TKDT50DI32_DynamicVecBuffer;

  TKDT50DI32_Source = packed record
    Buff: TKDT50DI32_Vec;
    index: Int64;
  end;

  PKDT50DI32_Source       = ^TKDT50DI32_Source;
  TKDT50DI32_SourceBuffer = array [0 .. 0] of PKDT50DI32_Source;
  PKDT50DI32_SourceBuffer = ^TKDT50DI32_SourceBuffer;

  TKDT50DI32yanmicSourceBuffer = array of PKDT50DI32_Source;
  PKDT50DI32yanmicSourceBuffer = ^TKDT50DI32yanmicSourceBuffer;

  TKDT50DI32yanmicStoreBuffer = array of TKDT50DI32_Source;
  PKDT50DI32yanmicStoreBuffer = ^TKDT50DI32yanmicStoreBuffer;

  PKDT50DI32_Node = ^TKDT50DI32_Node;

  TKDT50DI32_Node = packed record
    Parent, Right, Left: PKDT50DI32_Node;
    vec: PKDT50DI32_Source;
  end;

  TKDT50DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT50DI32_Source);
  TKDT50DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT50DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT50DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT50DI32_Source);
  {$ENDIF}

  TKDT50DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT50DI32yanmicStoreBuffer;
    KDBuff     : TKDT50DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT50DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT50DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT50DI32yanmicStoreBuffer; const Buff: TKDT50DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT50DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT50DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT50DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT50DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT50DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DI32_Node; overload;
    function Search(const Buff: TKDT50DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DI32_Node; overload;
    function Search(const Buff: TKDT50DI32_Vec; var SearchedDistanceMin: Double): PKDT50DI32_Node; overload;
    function Search(const Buff: TKDT50DI32_Vec): PKDT50DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT50DI32_DynamicVecBuffer; var OutBuff: TKDT50DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT50DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT50DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT56DI32_Vec = array [0 .. TKDT56DI32_AxisCount - 1] of TKDT56DI32_VecType;
  PKDT56DI32_Vec = ^TKDT56DI32_Vec;

  TKDT56DI32_DynamicVecBuffer = array of TKDT56DI32_Vec;
  PKDT56DI32_DynamicVecBuffer = ^TKDT56DI32_DynamicVecBuffer;

  TKDT56DI32_Source = packed record
    Buff: TKDT56DI32_Vec;
    index: Int64;
  end;

  PKDT56DI32_Source       = ^TKDT56DI32_Source;
  TKDT56DI32_SourceBuffer = array [0 .. 0] of PKDT56DI32_Source;
  PKDT56DI32_SourceBuffer = ^TKDT56DI32_SourceBuffer;

  TKDT56DI32yanmicSourceBuffer = array of PKDT56DI32_Source;
  PKDT56DI32yanmicSourceBuffer = ^TKDT56DI32yanmicSourceBuffer;

  TKDT56DI32yanmicStoreBuffer = array of TKDT56DI32_Source;
  PKDT56DI32yanmicStoreBuffer = ^TKDT56DI32yanmicStoreBuffer;

  PKDT56DI32_Node = ^TKDT56DI32_Node;

  TKDT56DI32_Node = packed record
    Parent, Right, Left: PKDT56DI32_Node;
    vec: PKDT56DI32_Source;
  end;

  TKDT56DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT56DI32_Source);
  TKDT56DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT56DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT56DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT56DI32_Source);
  {$ENDIF}

  TKDT56DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT56DI32yanmicStoreBuffer;
    KDBuff     : TKDT56DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT56DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT56DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT56DI32yanmicStoreBuffer; const Buff: TKDT56DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT56DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT56DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT56DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT56DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT56DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DI32_Node; overload;
    function Search(const Buff: TKDT56DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DI32_Node; overload;
    function Search(const Buff: TKDT56DI32_Vec; var SearchedDistanceMin: Double): PKDT56DI32_Node; overload;
    function Search(const Buff: TKDT56DI32_Vec): PKDT56DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT56DI32_DynamicVecBuffer; var OutBuff: TKDT56DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT56DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT56DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT60DI32_Vec = array [0 .. TKDT60DI32_AxisCount - 1] of TKDT60DI32_VecType;
  PKDT60DI32_Vec = ^TKDT60DI32_Vec;

  TKDT60DI32_DynamicVecBuffer = array of TKDT60DI32_Vec;
  PKDT60DI32_DynamicVecBuffer = ^TKDT60DI32_DynamicVecBuffer;

  TKDT60DI32_Source = packed record
    Buff: TKDT60DI32_Vec;
    index: Int64;
  end;

  PKDT60DI32_Source       = ^TKDT60DI32_Source;
  TKDT60DI32_SourceBuffer = array [0 .. 0] of PKDT60DI32_Source;
  PKDT60DI32_SourceBuffer = ^TKDT60DI32_SourceBuffer;

  TKDT60DI32yanmicSourceBuffer = array of PKDT60DI32_Source;
  PKDT60DI32yanmicSourceBuffer = ^TKDT60DI32yanmicSourceBuffer;

  TKDT60DI32yanmicStoreBuffer = array of TKDT60DI32_Source;
  PKDT60DI32yanmicStoreBuffer = ^TKDT60DI32yanmicStoreBuffer;

  PKDT60DI32_Node = ^TKDT60DI32_Node;

  TKDT60DI32_Node = packed record
    Parent, Right, Left: PKDT60DI32_Node;
    vec: PKDT60DI32_Source;
  end;

  TKDT60DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT60DI32_Source);
  TKDT60DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT60DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT60DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT60DI32_Source);
  {$ENDIF}

  TKDT60DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT60DI32yanmicStoreBuffer;
    KDBuff     : TKDT60DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT60DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT60DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT60DI32yanmicStoreBuffer; const Buff: TKDT60DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT60DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT60DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT60DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT60DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT60DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DI32_Node; overload;
    function Search(const Buff: TKDT60DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DI32_Node; overload;
    function Search(const Buff: TKDT60DI32_Vec; var SearchedDistanceMin: Double): PKDT60DI32_Node; overload;
    function Search(const Buff: TKDT60DI32_Vec): PKDT60DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT60DI32_DynamicVecBuffer; var OutBuff: TKDT60DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT60DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT60DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT64DI32_Vec = array [0 .. TKDT64DI32_AxisCount - 1] of TKDT64DI32_VecType;
  PKDT64DI32_Vec = ^TKDT64DI32_Vec;

  TKDT64DI32_DynamicVecBuffer = array of TKDT64DI32_Vec;
  PKDT64DI32_DynamicVecBuffer = ^TKDT64DI32_DynamicVecBuffer;

  TKDT64DI32_Source = packed record
    Buff: TKDT64DI32_Vec;
    index: Int64;
  end;

  PKDT64DI32_Source       = ^TKDT64DI32_Source;
  TKDT64DI32_SourceBuffer = array [0 .. 0] of PKDT64DI32_Source;
  PKDT64DI32_SourceBuffer = ^TKDT64DI32_SourceBuffer;

  TKDT64DI32yanmicSourceBuffer = array of PKDT64DI32_Source;
  PKDT64DI32yanmicSourceBuffer = ^TKDT64DI32yanmicSourceBuffer;

  TKDT64DI32yanmicStoreBuffer = array of TKDT64DI32_Source;
  PKDT64DI32yanmicStoreBuffer = ^TKDT64DI32yanmicStoreBuffer;

  PKDT64DI32_Node = ^TKDT64DI32_Node;

  TKDT64DI32_Node = packed record
    Parent, Right, Left: PKDT64DI32_Node;
    vec: PKDT64DI32_Source;
  end;

  TKDT64DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT64DI32_Source);
  TKDT64DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT64DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT64DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT64DI32_Source);
  {$ENDIF}

  TKDT64DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT64DI32yanmicStoreBuffer;
    KDBuff     : TKDT64DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT64DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT64DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT64DI32yanmicStoreBuffer; const Buff: TKDT64DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT64DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT64DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT64DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT64DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DI32_Node; overload;
    function Search(const Buff: TKDT64DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DI32_Node; overload;
    function Search(const Buff: TKDT64DI32_Vec; var SearchedDistanceMin: Double): PKDT64DI32_Node; overload;
    function Search(const Buff: TKDT64DI32_Vec): PKDT64DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT64DI32_DynamicVecBuffer; var OutBuff: TKDT64DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT64DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT64DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT72DI32_Vec = array [0 .. TKDT72DI32_AxisCount - 1] of TKDT72DI32_VecType;
  PKDT72DI32_Vec = ^TKDT72DI32_Vec;

  TKDT72DI32_DynamicVecBuffer = array of TKDT72DI32_Vec;
  PKDT72DI32_DynamicVecBuffer = ^TKDT72DI32_DynamicVecBuffer;

  TKDT72DI32_Source = packed record
    Buff: TKDT72DI32_Vec;
    index: Int64;
  end;

  PKDT72DI32_Source       = ^TKDT72DI32_Source;
  TKDT72DI32_SourceBuffer = array [0 .. 0] of PKDT72DI32_Source;
  PKDT72DI32_SourceBuffer = ^TKDT72DI32_SourceBuffer;

  TKDT72DI32yanmicSourceBuffer = array of PKDT72DI32_Source;
  PKDT72DI32yanmicSourceBuffer = ^TKDT72DI32yanmicSourceBuffer;

  TKDT72DI32yanmicStoreBuffer = array of TKDT72DI32_Source;
  PKDT72DI32yanmicStoreBuffer = ^TKDT72DI32yanmicStoreBuffer;

  PKDT72DI32_Node = ^TKDT72DI32_Node;

  TKDT72DI32_Node = packed record
    Parent, Right, Left: PKDT72DI32_Node;
    vec: PKDT72DI32_Source;
  end;

  TKDT72DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT72DI32_Source);
  TKDT72DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT72DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT72DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT72DI32_Source);
  {$ENDIF}

  TKDT72DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT72DI32yanmicStoreBuffer;
    KDBuff     : TKDT72DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT72DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT72DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT72DI32yanmicStoreBuffer; const Buff: TKDT72DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT72DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT72DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT72DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT72DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT72DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DI32_Node; overload;
    function Search(const Buff: TKDT72DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DI32_Node; overload;
    function Search(const Buff: TKDT72DI32_Vec; var SearchedDistanceMin: Double): PKDT72DI32_Node; overload;
    function Search(const Buff: TKDT72DI32_Vec): PKDT72DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT72DI32_DynamicVecBuffer; var OutBuff: TKDT72DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT72DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT72DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT84DI32_Vec = array [0 .. TKDT84DI32_AxisCount - 1] of TKDT84DI32_VecType;
  PKDT84DI32_Vec = ^TKDT84DI32_Vec;

  TKDT84DI32_DynamicVecBuffer = array of TKDT84DI32_Vec;
  PKDT84DI32_DynamicVecBuffer = ^TKDT84DI32_DynamicVecBuffer;

  TKDT84DI32_Source = packed record
    Buff: TKDT84DI32_Vec;
    index: Int64;
  end;

  PKDT84DI32_Source       = ^TKDT84DI32_Source;
  TKDT84DI32_SourceBuffer = array [0 .. 0] of PKDT84DI32_Source;
  PKDT84DI32_SourceBuffer = ^TKDT84DI32_SourceBuffer;

  TKDT84DI32yanmicSourceBuffer = array of PKDT84DI32_Source;
  PKDT84DI32yanmicSourceBuffer = ^TKDT84DI32yanmicSourceBuffer;

  TKDT84DI32yanmicStoreBuffer = array of TKDT84DI32_Source;
  PKDT84DI32yanmicStoreBuffer = ^TKDT84DI32yanmicStoreBuffer;

  PKDT84DI32_Node = ^TKDT84DI32_Node;

  TKDT84DI32_Node = packed record
    Parent, Right, Left: PKDT84DI32_Node;
    vec: PKDT84DI32_Source;
  end;

  TKDT84DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT84DI32_Source);
  TKDT84DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT84DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT84DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT84DI32_Source);
  {$ENDIF}

  TKDT84DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT84DI32yanmicStoreBuffer;
    KDBuff     : TKDT84DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT84DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT84DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT84DI32yanmicStoreBuffer; const Buff: TKDT84DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT84DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT84DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT84DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT84DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT84DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DI32_Node; overload;
    function Search(const Buff: TKDT84DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DI32_Node; overload;
    function Search(const Buff: TKDT84DI32_Vec; var SearchedDistanceMin: Double): PKDT84DI32_Node; overload;
    function Search(const Buff: TKDT84DI32_Vec): PKDT84DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT84DI32_DynamicVecBuffer; var OutBuff: TKDT84DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT84DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT84DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT96DI32_Vec = array [0 .. TKDT96DI32_AxisCount - 1] of TKDT96DI32_VecType;
  PKDT96DI32_Vec = ^TKDT96DI32_Vec;

  TKDT96DI32_DynamicVecBuffer = array of TKDT96DI32_Vec;
  PKDT96DI32_DynamicVecBuffer = ^TKDT96DI32_DynamicVecBuffer;

  TKDT96DI32_Source = packed record
    Buff: TKDT96DI32_Vec;
    index: Int64;
  end;

  PKDT96DI32_Source       = ^TKDT96DI32_Source;
  TKDT96DI32_SourceBuffer = array [0 .. 0] of PKDT96DI32_Source;
  PKDT96DI32_SourceBuffer = ^TKDT96DI32_SourceBuffer;

  TKDT96DI32yanmicSourceBuffer = array of PKDT96DI32_Source;
  PKDT96DI32yanmicSourceBuffer = ^TKDT96DI32yanmicSourceBuffer;

  TKDT96DI32yanmicStoreBuffer = array of TKDT96DI32_Source;
  PKDT96DI32yanmicStoreBuffer = ^TKDT96DI32yanmicStoreBuffer;

  PKDT96DI32_Node = ^TKDT96DI32_Node;

  TKDT96DI32_Node = packed record
    Parent, Right, Left: PKDT96DI32_Node;
    vec: PKDT96DI32_Source;
  end;

  TKDT96DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT96DI32_Source);
  TKDT96DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT96DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT96DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT96DI32_Source);
  {$ENDIF}

  TKDT96DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT96DI32yanmicStoreBuffer;
    KDBuff     : TKDT96DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT96DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT96DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT96DI32yanmicStoreBuffer; const Buff: TKDT96DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT96DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT96DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT96DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT96DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DI32_Node; overload;
    function Search(const Buff: TKDT96DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DI32_Node; overload;
    function Search(const Buff: TKDT96DI32_Vec; var SearchedDistanceMin: Double): PKDT96DI32_Node; overload;
    function Search(const Buff: TKDT96DI32_Vec): PKDT96DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT96DI32_DynamicVecBuffer; var OutBuff: TKDT96DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT96DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT96DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT128DI32_Vec = array [0 .. TKDT128DI32_AxisCount - 1] of TKDT128DI32_VecType;
  PKDT128DI32_Vec = ^TKDT128DI32_Vec;

  TKDT128DI32_DynamicVecBuffer = array of TKDT128DI32_Vec;
  PKDT128DI32_DynamicVecBuffer = ^TKDT128DI32_DynamicVecBuffer;

  TKDT128DI32_Source = packed record
    Buff: TKDT128DI32_Vec;
    index: Int64;
  end;

  PKDT128DI32_Source       = ^TKDT128DI32_Source;
  TKDT128DI32_SourceBuffer = array [0 .. 0] of PKDT128DI32_Source;
  PKDT128DI32_SourceBuffer = ^TKDT128DI32_SourceBuffer;

  TKDT128DI32yanmicSourceBuffer = array of PKDT128DI32_Source;
  PKDT128DI32yanmicSourceBuffer = ^TKDT128DI32yanmicSourceBuffer;

  TKDT128DI32yanmicStoreBuffer = array of TKDT128DI32_Source;
  PKDT128DI32yanmicStoreBuffer = ^TKDT128DI32yanmicStoreBuffer;

  PKDT128DI32_Node = ^TKDT128DI32_Node;

  TKDT128DI32_Node = packed record
    Parent, Right, Left: PKDT128DI32_Node;
    vec: PKDT128DI32_Source;
  end;

  TKDT128DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT128DI32_Source);
  TKDT128DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT128DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT128DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT128DI32_Source);
  {$ENDIF}

  TKDT128DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT128DI32yanmicStoreBuffer;
    KDBuff     : TKDT128DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT128DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT128DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT128DI32yanmicStoreBuffer; const Buff: TKDT128DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT128DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT128DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT128DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT128DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DI32_Node; overload;
    function Search(const Buff: TKDT128DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DI32_Node; overload;
    function Search(const Buff: TKDT128DI32_Vec; var SearchedDistanceMin: Double): PKDT128DI32_Node; overload;
    function Search(const Buff: TKDT128DI32_Vec): PKDT128DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT128DI32_DynamicVecBuffer; var OutBuff: TKDT128DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT128DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT128DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT140DI32_Vec = array [0 .. TKDT140DI32_AxisCount - 1] of TKDT140DI32_VecType;
  PKDT140DI32_Vec = ^TKDT140DI32_Vec;

  TKDT140DI32_DynamicVecBuffer = array of TKDT140DI32_Vec;
  PKDT140DI32_DynamicVecBuffer = ^TKDT140DI32_DynamicVecBuffer;

  TKDT140DI32_Source = packed record
    Buff: TKDT140DI32_Vec;
    index: Int64;
  end;

  PKDT140DI32_Source       = ^TKDT140DI32_Source;
  TKDT140DI32_SourceBuffer = array [0 .. 0] of PKDT140DI32_Source;
  PKDT140DI32_SourceBuffer = ^TKDT140DI32_SourceBuffer;

  TKDT140DI32yanmicSourceBuffer = array of PKDT140DI32_Source;
  PKDT140DI32yanmicSourceBuffer = ^TKDT140DI32yanmicSourceBuffer;

  TKDT140DI32yanmicStoreBuffer = array of TKDT140DI32_Source;
  PKDT140DI32yanmicStoreBuffer = ^TKDT140DI32yanmicStoreBuffer;

  PKDT140DI32_Node = ^TKDT140DI32_Node;

  TKDT140DI32_Node = packed record
    Parent, Right, Left: PKDT140DI32_Node;
    vec: PKDT140DI32_Source;
  end;

  TKDT140DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT140DI32_Source);
  TKDT140DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT140DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT140DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT140DI32_Source);
  {$ENDIF}

  TKDT140DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT140DI32yanmicStoreBuffer;
    KDBuff     : TKDT140DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT140DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT140DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT140DI32yanmicStoreBuffer; const Buff: TKDT140DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT140DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT140DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT140DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT140DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT140DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DI32_Node; overload;
    function Search(const Buff: TKDT140DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DI32_Node; overload;
    function Search(const Buff: TKDT140DI32_Vec; var SearchedDistanceMin: Double): PKDT140DI32_Node; overload;
    function Search(const Buff: TKDT140DI32_Vec): PKDT140DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT140DI32_DynamicVecBuffer; var OutBuff: TKDT140DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT140DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT140DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT160DI32_Vec = array [0 .. TKDT160DI32_AxisCount - 1] of TKDT160DI32_VecType;
  PKDT160DI32_Vec = ^TKDT160DI32_Vec;

  TKDT160DI32_DynamicVecBuffer = array of TKDT160DI32_Vec;
  PKDT160DI32_DynamicVecBuffer = ^TKDT160DI32_DynamicVecBuffer;

  TKDT160DI32_Source = packed record
    Buff: TKDT160DI32_Vec;
    index: Int64;
  end;

  PKDT160DI32_Source       = ^TKDT160DI32_Source;
  TKDT160DI32_SourceBuffer = array [0 .. 0] of PKDT160DI32_Source;
  PKDT160DI32_SourceBuffer = ^TKDT160DI32_SourceBuffer;

  TKDT160DI32yanmicSourceBuffer = array of PKDT160DI32_Source;
  PKDT160DI32yanmicSourceBuffer = ^TKDT160DI32yanmicSourceBuffer;

  TKDT160DI32yanmicStoreBuffer = array of TKDT160DI32_Source;
  PKDT160DI32yanmicStoreBuffer = ^TKDT160DI32yanmicStoreBuffer;

  PKDT160DI32_Node = ^TKDT160DI32_Node;

  TKDT160DI32_Node = packed record
    Parent, Right, Left: PKDT160DI32_Node;
    vec: PKDT160DI32_Source;
  end;

  TKDT160DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT160DI32_Source);
  TKDT160DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT160DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT160DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT160DI32_Source);
  {$ENDIF}

  TKDT160DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT160DI32yanmicStoreBuffer;
    KDBuff     : TKDT160DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT160DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT160DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT160DI32yanmicStoreBuffer; const Buff: TKDT160DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT160DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT160DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT160DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT160DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT160DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DI32_Node; overload;
    function Search(const Buff: TKDT160DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DI32_Node; overload;
    function Search(const Buff: TKDT160DI32_Vec; var SearchedDistanceMin: Double): PKDT160DI32_Node; overload;
    function Search(const Buff: TKDT160DI32_Vec): PKDT160DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT160DI32_DynamicVecBuffer; var OutBuff: TKDT160DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT160DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT160DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT196DI32_Vec = array [0 .. TKDT196DI32_AxisCount - 1] of TKDT196DI32_VecType;
  PKDT196DI32_Vec = ^TKDT196DI32_Vec;

  TKDT196DI32_DynamicVecBuffer = array of TKDT196DI32_Vec;
  PKDT196DI32_DynamicVecBuffer = ^TKDT196DI32_DynamicVecBuffer;

  TKDT196DI32_Source = packed record
    Buff: TKDT196DI32_Vec;
    index: Int64;
  end;

  PKDT196DI32_Source       = ^TKDT196DI32_Source;
  TKDT196DI32_SourceBuffer = array [0 .. 0] of PKDT196DI32_Source;
  PKDT196DI32_SourceBuffer = ^TKDT196DI32_SourceBuffer;

  TKDT196DI32yanmicSourceBuffer = array of PKDT196DI32_Source;
  PKDT196DI32yanmicSourceBuffer = ^TKDT196DI32yanmicSourceBuffer;

  TKDT196DI32yanmicStoreBuffer = array of TKDT196DI32_Source;
  PKDT196DI32yanmicStoreBuffer = ^TKDT196DI32yanmicStoreBuffer;

  PKDT196DI32_Node = ^TKDT196DI32_Node;

  TKDT196DI32_Node = packed record
    Parent, Right, Left: PKDT196DI32_Node;
    vec: PKDT196DI32_Source;
  end;

  TKDT196DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT196DI32_Source);
  TKDT196DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT196DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT196DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT196DI32_Source);
  {$ENDIF}

  TKDT196DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT196DI32yanmicStoreBuffer;
    KDBuff     : TKDT196DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT196DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT196DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT196DI32yanmicStoreBuffer; const Buff: TKDT196DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT196DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT196DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT196DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT196DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT196DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DI32_Node; overload;
    function Search(const Buff: TKDT196DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DI32_Node; overload;
    function Search(const Buff: TKDT196DI32_Vec; var SearchedDistanceMin: Double): PKDT196DI32_Node; overload;
    function Search(const Buff: TKDT196DI32_Vec): PKDT196DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT196DI32_DynamicVecBuffer; var OutBuff: TKDT196DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT196DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT196DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT256DI32_Vec = array [0 .. TKDT256DI32_AxisCount - 1] of TKDT256DI32_VecType;
  PKDT256DI32_Vec = ^TKDT256DI32_Vec;

  TKDT256DI32_DynamicVecBuffer = array of TKDT256DI32_Vec;
  PKDT256DI32_DynamicVecBuffer = ^TKDT256DI32_DynamicVecBuffer;

  TKDT256DI32_Source = packed record
    Buff: TKDT256DI32_Vec;
    index: Int64;
  end;

  PKDT256DI32_Source       = ^TKDT256DI32_Source;
  TKDT256DI32_SourceBuffer = array [0 .. 0] of PKDT256DI32_Source;
  PKDT256DI32_SourceBuffer = ^TKDT256DI32_SourceBuffer;

  TKDT256DI32yanmicSourceBuffer = array of PKDT256DI32_Source;
  PKDT256DI32yanmicSourceBuffer = ^TKDT256DI32yanmicSourceBuffer;

  TKDT256DI32yanmicStoreBuffer = array of TKDT256DI32_Source;
  PKDT256DI32yanmicStoreBuffer = ^TKDT256DI32yanmicStoreBuffer;

  PKDT256DI32_Node = ^TKDT256DI32_Node;

  TKDT256DI32_Node = packed record
    Parent, Right, Left: PKDT256DI32_Node;
    vec: PKDT256DI32_Source;
  end;

  TKDT256DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT256DI32_Source);
  TKDT256DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT256DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT256DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT256DI32_Source);
  {$ENDIF}

  TKDT256DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT256DI32yanmicStoreBuffer;
    KDBuff     : TKDT256DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT256DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT256DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT256DI32yanmicStoreBuffer; const Buff: TKDT256DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT256DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT256DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT256DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT256DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DI32_Node; overload;
    function Search(const Buff: TKDT256DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DI32_Node; overload;
    function Search(const Buff: TKDT256DI32_Vec; var SearchedDistanceMin: Double): PKDT256DI32_Node; overload;
    function Search(const Buff: TKDT256DI32_Vec): PKDT256DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT256DI32_DynamicVecBuffer; var OutBuff: TKDT256DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT256DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT256DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT272DI32_Vec = array [0 .. TKDT272DI32_AxisCount - 1] of TKDT272DI32_VecType;
  PKDT272DI32_Vec = ^TKDT272DI32_Vec;

  TKDT272DI32_DynamicVecBuffer = array of TKDT272DI32_Vec;
  PKDT272DI32_DynamicVecBuffer = ^TKDT272DI32_DynamicVecBuffer;

  TKDT272DI32_Source = packed record
    Buff: TKDT272DI32_Vec;
    index: Int64;
  end;

  PKDT272DI32_Source       = ^TKDT272DI32_Source;
  TKDT272DI32_SourceBuffer = array [0 .. 0] of PKDT272DI32_Source;
  PKDT272DI32_SourceBuffer = ^TKDT272DI32_SourceBuffer;

  TKDT272DI32yanmicSourceBuffer = array of PKDT272DI32_Source;
  PKDT272DI32yanmicSourceBuffer = ^TKDT272DI32yanmicSourceBuffer;

  TKDT272DI32yanmicStoreBuffer = array of TKDT272DI32_Source;
  PKDT272DI32yanmicStoreBuffer = ^TKDT272DI32yanmicStoreBuffer;

  PKDT272DI32_Node = ^TKDT272DI32_Node;

  TKDT272DI32_Node = packed record
    Parent, Right, Left: PKDT272DI32_Node;
    vec: PKDT272DI32_Source;
  end;

  TKDT272DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT272DI32_Source);
  TKDT272DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT272DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT272DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT272DI32_Source);
  {$ENDIF}

  TKDT272DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT272DI32yanmicStoreBuffer;
    KDBuff     : TKDT272DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT272DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT272DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT272DI32yanmicStoreBuffer; const Buff: TKDT272DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT272DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT272DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT272DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT272DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT272DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DI32_Node; overload;
    function Search(const Buff: TKDT272DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DI32_Node; overload;
    function Search(const Buff: TKDT272DI32_Vec; var SearchedDistanceMin: Double): PKDT272DI32_Node; overload;
    function Search(const Buff: TKDT272DI32_Vec): PKDT272DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT272DI32_DynamicVecBuffer; var OutBuff: TKDT272DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT272DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT272DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT288DI32_Vec = array [0 .. TKDT288DI32_AxisCount - 1] of TKDT288DI32_VecType;
  PKDT288DI32_Vec = ^TKDT288DI32_Vec;

  TKDT288DI32_DynamicVecBuffer = array of TKDT288DI32_Vec;
  PKDT288DI32_DynamicVecBuffer = ^TKDT288DI32_DynamicVecBuffer;

  TKDT288DI32_Source = packed record
    Buff: TKDT288DI32_Vec;
    index: Int64;
  end;

  PKDT288DI32_Source       = ^TKDT288DI32_Source;
  TKDT288DI32_SourceBuffer = array [0 .. 0] of PKDT288DI32_Source;
  PKDT288DI32_SourceBuffer = ^TKDT288DI32_SourceBuffer;

  TKDT288DI32yanmicSourceBuffer = array of PKDT288DI32_Source;
  PKDT288DI32yanmicSourceBuffer = ^TKDT288DI32yanmicSourceBuffer;

  TKDT288DI32yanmicStoreBuffer = array of TKDT288DI32_Source;
  PKDT288DI32yanmicStoreBuffer = ^TKDT288DI32yanmicStoreBuffer;

  PKDT288DI32_Node = ^TKDT288DI32_Node;

  TKDT288DI32_Node = packed record
    Parent, Right, Left: PKDT288DI32_Node;
    vec: PKDT288DI32_Source;
  end;

  TKDT288DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT288DI32_Source);
  TKDT288DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT288DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT288DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT288DI32_Source);
  {$ENDIF}

  TKDT288DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT288DI32yanmicStoreBuffer;
    KDBuff     : TKDT288DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT288DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT288DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT288DI32yanmicStoreBuffer; const Buff: TKDT288DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT288DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT288DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT288DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT288DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT288DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DI32_Node; overload;
    function Search(const Buff: TKDT288DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DI32_Node; overload;
    function Search(const Buff: TKDT288DI32_Vec; var SearchedDistanceMin: Double): PKDT288DI32_Node; overload;
    function Search(const Buff: TKDT288DI32_Vec): PKDT288DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT288DI32_DynamicVecBuffer; var OutBuff: TKDT288DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT288DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT288DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT372DI32_Vec = array [0 .. TKDT372DI32_AxisCount - 1] of TKDT372DI32_VecType;
  PKDT372DI32_Vec = ^TKDT372DI32_Vec;

  TKDT372DI32_DynamicVecBuffer = array of TKDT372DI32_Vec;
  PKDT372DI32_DynamicVecBuffer = ^TKDT372DI32_DynamicVecBuffer;

  TKDT372DI32_Source = packed record
    Buff: TKDT372DI32_Vec;
    index: Int64;
  end;

  PKDT372DI32_Source       = ^TKDT372DI32_Source;
  TKDT372DI32_SourceBuffer = array [0 .. 0] of PKDT372DI32_Source;
  PKDT372DI32_SourceBuffer = ^TKDT372DI32_SourceBuffer;

  TKDT372DI32yanmicSourceBuffer = array of PKDT372DI32_Source;
  PKDT372DI32yanmicSourceBuffer = ^TKDT372DI32yanmicSourceBuffer;

  TKDT372DI32yanmicStoreBuffer = array of TKDT372DI32_Source;
  PKDT372DI32yanmicStoreBuffer = ^TKDT372DI32yanmicStoreBuffer;

  PKDT372DI32_Node = ^TKDT372DI32_Node;

  TKDT372DI32_Node = packed record
    Parent, Right, Left: PKDT372DI32_Node;
    vec: PKDT372DI32_Source;
  end;

  TKDT372DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT372DI32_Source);
  TKDT372DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT372DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT372DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT372DI32_Source);
  {$ENDIF}

  TKDT372DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT372DI32yanmicStoreBuffer;
    KDBuff     : TKDT372DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT372DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT372DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT372DI32yanmicStoreBuffer; const Buff: TKDT372DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT372DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT372DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT372DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT372DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT372DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DI32_Node; overload;
    function Search(const Buff: TKDT372DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DI32_Node; overload;
    function Search(const Buff: TKDT372DI32_Vec; var SearchedDistanceMin: Double): PKDT372DI32_Node; overload;
    function Search(const Buff: TKDT372DI32_Vec): PKDT372DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT372DI32_DynamicVecBuffer; var OutBuff: TKDT372DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT372DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT372DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT512DI32_Vec = array [0 .. TKDT512DI32_AxisCount - 1] of TKDT512DI32_VecType;
  PKDT512DI32_Vec = ^TKDT512DI32_Vec;

  TKDT512DI32_DynamicVecBuffer = array of TKDT512DI32_Vec;
  PKDT512DI32_DynamicVecBuffer = ^TKDT512DI32_DynamicVecBuffer;

  TKDT512DI32_Source = packed record
    Buff: TKDT512DI32_Vec;
    index: Int64;
  end;

  PKDT512DI32_Source       = ^TKDT512DI32_Source;
  TKDT512DI32_SourceBuffer = array [0 .. 0] of PKDT512DI32_Source;
  PKDT512DI32_SourceBuffer = ^TKDT512DI32_SourceBuffer;

  TKDT512DI32yanmicSourceBuffer = array of PKDT512DI32_Source;
  PKDT512DI32yanmicSourceBuffer = ^TKDT512DI32yanmicSourceBuffer;

  TKDT512DI32yanmicStoreBuffer = array of TKDT512DI32_Source;
  PKDT512DI32yanmicStoreBuffer = ^TKDT512DI32yanmicStoreBuffer;

  PKDT512DI32_Node = ^TKDT512DI32_Node;

  TKDT512DI32_Node = packed record
    Parent, Right, Left: PKDT512DI32_Node;
    vec: PKDT512DI32_Source;
  end;

  TKDT512DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT512DI32_Source);
  TKDT512DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT512DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT512DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT512DI32_Source);
  {$ENDIF}

  TKDT512DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT512DI32yanmicStoreBuffer;
    KDBuff     : TKDT512DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT512DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT512DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT512DI32yanmicStoreBuffer; const Buff: TKDT512DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT512DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT512DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT512DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT512DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DI32_Node; overload;
    function Search(const Buff: TKDT512DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DI32_Node; overload;
    function Search(const Buff: TKDT512DI32_Vec; var SearchedDistanceMin: Double): PKDT512DI32_Node; overload;
    function Search(const Buff: TKDT512DI32_Vec): PKDT512DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT512DI32_DynamicVecBuffer; var OutBuff: TKDT512DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT512DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT512DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT576DI32_Vec = array [0 .. TKDT576DI32_AxisCount - 1] of TKDT576DI32_VecType;
  PKDT576DI32_Vec = ^TKDT576DI32_Vec;

  TKDT576DI32_DynamicVecBuffer = array of TKDT576DI32_Vec;
  PKDT576DI32_DynamicVecBuffer = ^TKDT576DI32_DynamicVecBuffer;

  TKDT576DI32_Source = packed record
    Buff: TKDT576DI32_Vec;
    index: Int64;
  end;

  PKDT576DI32_Source       = ^TKDT576DI32_Source;
  TKDT576DI32_SourceBuffer = array [0 .. 0] of PKDT576DI32_Source;
  PKDT576DI32_SourceBuffer = ^TKDT576DI32_SourceBuffer;

  TKDT576DI32yanmicSourceBuffer = array of PKDT576DI32_Source;
  PKDT576DI32yanmicSourceBuffer = ^TKDT576DI32yanmicSourceBuffer;

  TKDT576DI32yanmicStoreBuffer = array of TKDT576DI32_Source;
  PKDT576DI32yanmicStoreBuffer = ^TKDT576DI32yanmicStoreBuffer;

  PKDT576DI32_Node = ^TKDT576DI32_Node;

  TKDT576DI32_Node = packed record
    Parent, Right, Left: PKDT576DI32_Node;
    vec: PKDT576DI32_Source;
  end;

  TKDT576DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT576DI32_Source);
  TKDT576DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT576DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT576DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT576DI32_Source);
  {$ENDIF}

  TKDT576DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT576DI32yanmicStoreBuffer;
    KDBuff     : TKDT576DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT576DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT576DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT576DI32yanmicStoreBuffer; const Buff: TKDT576DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT576DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT576DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT576DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT576DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT576DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DI32_Node; overload;
    function Search(const Buff: TKDT576DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DI32_Node; overload;
    function Search(const Buff: TKDT576DI32_Vec; var SearchedDistanceMin: Double): PKDT576DI32_Node; overload;
    function Search(const Buff: TKDT576DI32_Vec): PKDT576DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT576DI32_DynamicVecBuffer; var OutBuff: TKDT576DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT576DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT576DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT768DI32_Vec = array [0 .. TKDT768DI32_AxisCount - 1] of TKDT768DI32_VecType;
  PKDT768DI32_Vec = ^TKDT768DI32_Vec;

  TKDT768DI32_DynamicVecBuffer = array of TKDT768DI32_Vec;
  PKDT768DI32_DynamicVecBuffer = ^TKDT768DI32_DynamicVecBuffer;

  TKDT768DI32_Source = packed record
    Buff: TKDT768DI32_Vec;
    index: Int64;
  end;

  PKDT768DI32_Source       = ^TKDT768DI32_Source;
  TKDT768DI32_SourceBuffer = array [0 .. 0] of PKDT768DI32_Source;
  PKDT768DI32_SourceBuffer = ^TKDT768DI32_SourceBuffer;

  TKDT768DI32yanmicSourceBuffer = array of PKDT768DI32_Source;
  PKDT768DI32yanmicSourceBuffer = ^TKDT768DI32yanmicSourceBuffer;

  TKDT768DI32yanmicStoreBuffer = array of TKDT768DI32_Source;
  PKDT768DI32yanmicStoreBuffer = ^TKDT768DI32yanmicStoreBuffer;

  PKDT768DI32_Node = ^TKDT768DI32_Node;

  TKDT768DI32_Node = packed record
    Parent, Right, Left: PKDT768DI32_Node;
    vec: PKDT768DI32_Source;
  end;

  TKDT768DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT768DI32_Source);
  TKDT768DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT768DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT768DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT768DI32_Source);
  {$ENDIF}

  TKDT768DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT768DI32yanmicStoreBuffer;
    KDBuff     : TKDT768DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT768DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT768DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT768DI32yanmicStoreBuffer; const Buff: TKDT768DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT768DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT768DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT768DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT768DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT768DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DI32_Node; overload;
    function Search(const Buff: TKDT768DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DI32_Node; overload;
    function Search(const Buff: TKDT768DI32_Vec; var SearchedDistanceMin: Double): PKDT768DI32_Node; overload;
    function Search(const Buff: TKDT768DI32_Vec): PKDT768DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT768DI32_DynamicVecBuffer; var OutBuff: TKDT768DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT768DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT768DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1024DI32_Vec = array [0 .. TKDT1024DI32_AxisCount - 1] of TKDT1024DI32_VecType;
  PKDT1024DI32_Vec = ^TKDT1024DI32_Vec;

  TKDT1024DI32_DynamicVecBuffer = array of TKDT1024DI32_Vec;
  PKDT1024DI32_DynamicVecBuffer = ^TKDT1024DI32_DynamicVecBuffer;

  TKDT1024DI32_Source = packed record
    Buff: TKDT1024DI32_Vec;
    index: Int64;
  end;

  PKDT1024DI32_Source       = ^TKDT1024DI32_Source;
  TKDT1024DI32_SourceBuffer = array [0 .. 0] of PKDT1024DI32_Source;
  PKDT1024DI32_SourceBuffer = ^TKDT1024DI32_SourceBuffer;

  TKDT1024DI32yanmicSourceBuffer = array of PKDT1024DI32_Source;
  PKDT1024DI32yanmicSourceBuffer = ^TKDT1024DI32yanmicSourceBuffer;

  TKDT1024DI32yanmicStoreBuffer = array of TKDT1024DI32_Source;
  PKDT1024DI32yanmicStoreBuffer = ^TKDT1024DI32yanmicStoreBuffer;

  PKDT1024DI32_Node = ^TKDT1024DI32_Node;

  TKDT1024DI32_Node = packed record
    Parent, Right, Left: PKDT1024DI32_Node;
    vec: PKDT1024DI32_Source;
  end;

  TKDT1024DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1024DI32_Source);
  TKDT1024DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1024DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT1024DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1024DI32_Source);
  {$ENDIF}

  TKDT1024DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1024DI32yanmicStoreBuffer;
    KDBuff     : TKDT1024DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1024DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1024DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1024DI32yanmicStoreBuffer; const Buff: TKDT1024DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1024DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1024DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1024DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1024DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DI32_Node; overload;
    function Search(const Buff: TKDT1024DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DI32_Node; overload;
    function Search(const Buff: TKDT1024DI32_Vec; var SearchedDistanceMin: Double): PKDT1024DI32_Node; overload;
    function Search(const Buff: TKDT1024DI32_Vec): PKDT1024DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1024DI32_DynamicVecBuffer; var OutBuff: TKDT1024DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1024DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1024DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1040DI32_Vec = array [0 .. TKDT1040DI32_AxisCount - 1] of TKDT1040DI32_VecType;
  PKDT1040DI32_Vec = ^TKDT1040DI32_Vec;

  TKDT1040DI32_DynamicVecBuffer = array of TKDT1040DI32_Vec;
  PKDT1040DI32_DynamicVecBuffer = ^TKDT1040DI32_DynamicVecBuffer;

  TKDT1040DI32_Source = packed record
    Buff: TKDT1040DI32_Vec;
    index: Int64;
  end;

  PKDT1040DI32_Source       = ^TKDT1040DI32_Source;
  TKDT1040DI32_SourceBuffer = array [0 .. 0] of PKDT1040DI32_Source;
  PKDT1040DI32_SourceBuffer = ^TKDT1040DI32_SourceBuffer;

  TKDT1040DI32yanmicSourceBuffer = array of PKDT1040DI32_Source;
  PKDT1040DI32yanmicSourceBuffer = ^TKDT1040DI32yanmicSourceBuffer;

  TKDT1040DI32yanmicStoreBuffer = array of TKDT1040DI32_Source;
  PKDT1040DI32yanmicStoreBuffer = ^TKDT1040DI32yanmicStoreBuffer;

  PKDT1040DI32_Node = ^TKDT1040DI32_Node;

  TKDT1040DI32_Node = packed record
    Parent, Right, Left: PKDT1040DI32_Node;
    vec: PKDT1040DI32_Source;
  end;

  TKDT1040DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1040DI32_Source);
  TKDT1040DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1040DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT1040DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1040DI32_Source);
  {$ENDIF}

  TKDT1040DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1040DI32yanmicStoreBuffer;
    KDBuff     : TKDT1040DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1040DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1040DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1040DI32yanmicStoreBuffer; const Buff: TKDT1040DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1040DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1040DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1040DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1040DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1040DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DI32_Node; overload;
    function Search(const Buff: TKDT1040DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DI32_Node; overload;
    function Search(const Buff: TKDT1040DI32_Vec; var SearchedDistanceMin: Double): PKDT1040DI32_Node; overload;
    function Search(const Buff: TKDT1040DI32_Vec): PKDT1040DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1040DI32_DynamicVecBuffer; var OutBuff: TKDT1040DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1040DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1040DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1056DI32_Vec = array [0 .. TKDT1056DI32_AxisCount - 1] of TKDT1056DI32_VecType;
  PKDT1056DI32_Vec = ^TKDT1056DI32_Vec;

  TKDT1056DI32_DynamicVecBuffer = array of TKDT1056DI32_Vec;
  PKDT1056DI32_DynamicVecBuffer = ^TKDT1056DI32_DynamicVecBuffer;

  TKDT1056DI32_Source = packed record
    Buff: TKDT1056DI32_Vec;
    index: Int64;
  end;

  PKDT1056DI32_Source       = ^TKDT1056DI32_Source;
  TKDT1056DI32_SourceBuffer = array [0 .. 0] of PKDT1056DI32_Source;
  PKDT1056DI32_SourceBuffer = ^TKDT1056DI32_SourceBuffer;

  TKDT1056DI32yanmicSourceBuffer = array of PKDT1056DI32_Source;
  PKDT1056DI32yanmicSourceBuffer = ^TKDT1056DI32yanmicSourceBuffer;

  TKDT1056DI32yanmicStoreBuffer = array of TKDT1056DI32_Source;
  PKDT1056DI32yanmicStoreBuffer = ^TKDT1056DI32yanmicStoreBuffer;

  PKDT1056DI32_Node = ^TKDT1056DI32_Node;

  TKDT1056DI32_Node = packed record
    Parent, Right, Left: PKDT1056DI32_Node;
    vec: PKDT1056DI32_Source;
  end;

  TKDT1056DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1056DI32_Source);
  TKDT1056DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1056DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT1056DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1056DI32_Source);
  {$ENDIF}

  TKDT1056DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1056DI32yanmicStoreBuffer;
    KDBuff     : TKDT1056DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1056DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1056DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1056DI32yanmicStoreBuffer; const Buff: TKDT1056DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1056DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1056DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1056DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1056DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1056DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DI32_Node; overload;
    function Search(const Buff: TKDT1056DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DI32_Node; overload;
    function Search(const Buff: TKDT1056DI32_Vec; var SearchedDistanceMin: Double): PKDT1056DI32_Node; overload;
    function Search(const Buff: TKDT1056DI32_Vec): PKDT1056DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1056DI32_DynamicVecBuffer; var OutBuff: TKDT1056DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1056DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1056DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1536DI32_Vec = array [0 .. TKDT1536DI32_AxisCount - 1] of TKDT1536DI32_VecType;
  PKDT1536DI32_Vec = ^TKDT1536DI32_Vec;

  TKDT1536DI32_DynamicVecBuffer = array of TKDT1536DI32_Vec;
  PKDT1536DI32_DynamicVecBuffer = ^TKDT1536DI32_DynamicVecBuffer;

  TKDT1536DI32_Source = packed record
    Buff: TKDT1536DI32_Vec;
    index: Int64;
  end;

  PKDT1536DI32_Source       = ^TKDT1536DI32_Source;
  TKDT1536DI32_SourceBuffer = array [0 .. 0] of PKDT1536DI32_Source;
  PKDT1536DI32_SourceBuffer = ^TKDT1536DI32_SourceBuffer;

  TKDT1536DI32yanmicSourceBuffer = array of PKDT1536DI32_Source;
  PKDT1536DI32yanmicSourceBuffer = ^TKDT1536DI32yanmicSourceBuffer;

  TKDT1536DI32yanmicStoreBuffer = array of TKDT1536DI32_Source;
  PKDT1536DI32yanmicStoreBuffer = ^TKDT1536DI32yanmicStoreBuffer;

  PKDT1536DI32_Node = ^TKDT1536DI32_Node;

  TKDT1536DI32_Node = packed record
    Parent, Right, Left: PKDT1536DI32_Node;
    vec: PKDT1536DI32_Source;
  end;

  TKDT1536DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1536DI32_Source);
  TKDT1536DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1536DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT1536DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1536DI32_Source);
  {$ENDIF}

  TKDT1536DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1536DI32yanmicStoreBuffer;
    KDBuff     : TKDT1536DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1536DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1536DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1536DI32yanmicStoreBuffer; const Buff: TKDT1536DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1536DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1536DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1536DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1536DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1536DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DI32_Node; overload;
    function Search(const Buff: TKDT1536DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DI32_Node; overload;
    function Search(const Buff: TKDT1536DI32_Vec; var SearchedDistanceMin: Double): PKDT1536DI32_Node; overload;
    function Search(const Buff: TKDT1536DI32_Vec): PKDT1536DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1536DI32_DynamicVecBuffer; var OutBuff: TKDT1536DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1536DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1536DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1920DI32_Vec = array [0 .. TKDT1920DI32_AxisCount - 1] of TKDT1920DI32_VecType;
  PKDT1920DI32_Vec = ^TKDT1920DI32_Vec;

  TKDT1920DI32_DynamicVecBuffer = array of TKDT1920DI32_Vec;
  PKDT1920DI32_DynamicVecBuffer = ^TKDT1920DI32_DynamicVecBuffer;

  TKDT1920DI32_Source = packed record
    Buff: TKDT1920DI32_Vec;
    index: Int64;
  end;

  PKDT1920DI32_Source       = ^TKDT1920DI32_Source;
  TKDT1920DI32_SourceBuffer = array [0 .. 0] of PKDT1920DI32_Source;
  PKDT1920DI32_SourceBuffer = ^TKDT1920DI32_SourceBuffer;

  TKDT1920DI32yanmicSourceBuffer = array of PKDT1920DI32_Source;
  PKDT1920DI32yanmicSourceBuffer = ^TKDT1920DI32yanmicSourceBuffer;

  TKDT1920DI32yanmicStoreBuffer = array of TKDT1920DI32_Source;
  PKDT1920DI32yanmicStoreBuffer = ^TKDT1920DI32yanmicStoreBuffer;

  PKDT1920DI32_Node = ^TKDT1920DI32_Node;

  TKDT1920DI32_Node = packed record
    Parent, Right, Left: PKDT1920DI32_Node;
    vec: PKDT1920DI32_Source;
  end;

  TKDT1920DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1920DI32_Source);
  TKDT1920DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1920DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT1920DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1920DI32_Source);
  {$ENDIF}

  TKDT1920DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1920DI32yanmicStoreBuffer;
    KDBuff     : TKDT1920DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1920DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1920DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1920DI32yanmicStoreBuffer; const Buff: TKDT1920DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1920DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1920DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1920DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1920DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1920DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DI32_Node; overload;
    function Search(const Buff: TKDT1920DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DI32_Node; overload;
    function Search(const Buff: TKDT1920DI32_Vec; var SearchedDistanceMin: Double): PKDT1920DI32_Node; overload;
    function Search(const Buff: TKDT1920DI32_Vec): PKDT1920DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1920DI32_DynamicVecBuffer; var OutBuff: TKDT1920DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1920DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1920DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1980DI32_Vec = array [0 .. TKDT1980DI32_AxisCount - 1] of TKDT1980DI32_VecType;
  PKDT1980DI32_Vec = ^TKDT1980DI32_Vec;

  TKDT1980DI32_DynamicVecBuffer = array of TKDT1980DI32_Vec;
  PKDT1980DI32_DynamicVecBuffer = ^TKDT1980DI32_DynamicVecBuffer;

  TKDT1980DI32_Source = packed record
    Buff: TKDT1980DI32_Vec;
    index: Int64;
  end;

  PKDT1980DI32_Source       = ^TKDT1980DI32_Source;
  TKDT1980DI32_SourceBuffer = array [0 .. 0] of PKDT1980DI32_Source;
  PKDT1980DI32_SourceBuffer = ^TKDT1980DI32_SourceBuffer;

  TKDT1980DI32yanmicSourceBuffer = array of PKDT1980DI32_Source;
  PKDT1980DI32yanmicSourceBuffer = ^TKDT1980DI32yanmicSourceBuffer;

  TKDT1980DI32yanmicStoreBuffer = array of TKDT1980DI32_Source;
  PKDT1980DI32yanmicStoreBuffer = ^TKDT1980DI32yanmicStoreBuffer;

  PKDT1980DI32_Node = ^TKDT1980DI32_Node;

  TKDT1980DI32_Node = packed record
    Parent, Right, Left: PKDT1980DI32_Node;
    vec: PKDT1980DI32_Source;
  end;

  TKDT1980DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1980DI32_Source);
  TKDT1980DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1980DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT1980DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1980DI32_Source);
  {$ENDIF}

  TKDT1980DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1980DI32yanmicStoreBuffer;
    KDBuff     : TKDT1980DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1980DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1980DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1980DI32yanmicStoreBuffer; const Buff: TKDT1980DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1980DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1980DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1980DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1980DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1980DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DI32_Node; overload;
    function Search(const Buff: TKDT1980DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DI32_Node; overload;
    function Search(const Buff: TKDT1980DI32_Vec; var SearchedDistanceMin: Double): PKDT1980DI32_Node; overload;
    function Search(const Buff: TKDT1980DI32_Vec): PKDT1980DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1980DI32_DynamicVecBuffer; var OutBuff: TKDT1980DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1980DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1980DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT2048DI32_Vec = array [0 .. TKDT2048DI32_AxisCount - 1] of TKDT2048DI32_VecType;
  PKDT2048DI32_Vec = ^TKDT2048DI32_Vec;

  TKDT2048DI32_DynamicVecBuffer = array of TKDT2048DI32_Vec;
  PKDT2048DI32_DynamicVecBuffer = ^TKDT2048DI32_DynamicVecBuffer;

  TKDT2048DI32_Source = packed record
    Buff: TKDT2048DI32_Vec;
    index: Int64;
  end;

  PKDT2048DI32_Source       = ^TKDT2048DI32_Source;
  TKDT2048DI32_SourceBuffer = array [0 .. 0] of PKDT2048DI32_Source;
  PKDT2048DI32_SourceBuffer = ^TKDT2048DI32_SourceBuffer;

  TKDT2048DI32yanmicSourceBuffer = array of PKDT2048DI32_Source;
  PKDT2048DI32yanmicSourceBuffer = ^TKDT2048DI32yanmicSourceBuffer;

  TKDT2048DI32yanmicStoreBuffer = array of TKDT2048DI32_Source;
  PKDT2048DI32yanmicStoreBuffer = ^TKDT2048DI32yanmicStoreBuffer;

  PKDT2048DI32_Node = ^TKDT2048DI32_Node;

  TKDT2048DI32_Node = packed record
    Parent, Right, Left: PKDT2048DI32_Node;
    vec: PKDT2048DI32_Source;
  end;

  TKDT2048DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT2048DI32_Source);
  TKDT2048DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT2048DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT2048DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT2048DI32_Source);
  {$ENDIF}

  TKDT2048DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2048DI32yanmicStoreBuffer;
    KDBuff     : TKDT2048DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2048DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT2048DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT2048DI32yanmicStoreBuffer; const Buff: TKDT2048DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT2048DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2048DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2048DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2048DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2048DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DI32_Node; overload;
    function Search(const Buff: TKDT2048DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DI32_Node; overload;
    function Search(const Buff: TKDT2048DI32_Vec; var SearchedDistanceMin: Double): PKDT2048DI32_Node; overload;
    function Search(const Buff: TKDT2048DI32_Vec): PKDT2048DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2048DI32_DynamicVecBuffer; var OutBuff: TKDT2048DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT2048DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT2048DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3072DI32_Vec = array [0 .. TKDT3072DI32_AxisCount - 1] of TKDT3072DI32_VecType;
  PKDT3072DI32_Vec = ^TKDT3072DI32_Vec;

  TKDT3072DI32_DynamicVecBuffer = array of TKDT3072DI32_Vec;
  PKDT3072DI32_DynamicVecBuffer = ^TKDT3072DI32_DynamicVecBuffer;

  TKDT3072DI32_Source = packed record
    Buff: TKDT3072DI32_Vec;
    index: Int64;
  end;

  PKDT3072DI32_Source       = ^TKDT3072DI32_Source;
  TKDT3072DI32_SourceBuffer = array [0 .. 0] of PKDT3072DI32_Source;
  PKDT3072DI32_SourceBuffer = ^TKDT3072DI32_SourceBuffer;

  TKDT3072DI32yanmicSourceBuffer = array of PKDT3072DI32_Source;
  PKDT3072DI32yanmicSourceBuffer = ^TKDT3072DI32yanmicSourceBuffer;

  TKDT3072DI32yanmicStoreBuffer = array of TKDT3072DI32_Source;
  PKDT3072DI32yanmicStoreBuffer = ^TKDT3072DI32yanmicStoreBuffer;

  PKDT3072DI32_Node = ^TKDT3072DI32_Node;

  TKDT3072DI32_Node = packed record
    Parent, Right, Left: PKDT3072DI32_Node;
    vec: PKDT3072DI32_Source;
  end;

  TKDT3072DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3072DI32_Source);
  TKDT3072DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3072DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT3072DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3072DI32_Source);
  {$ENDIF}

  TKDT3072DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3072DI32yanmicStoreBuffer;
    KDBuff     : TKDT3072DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3072DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3072DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3072DI32yanmicStoreBuffer; const Buff: TKDT3072DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3072DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3072DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3072DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3072DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3072DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DI32_Node; overload;
    function Search(const Buff: TKDT3072DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DI32_Node; overload;
    function Search(const Buff: TKDT3072DI32_Vec; var SearchedDistanceMin: Double): PKDT3072DI32_Node; overload;
    function Search(const Buff: TKDT3072DI32_Vec): PKDT3072DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3072DI32_DynamicVecBuffer; var OutBuff: TKDT3072DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3072DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3072DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3088DI32_Vec = array [0 .. TKDT3088DI32_AxisCount - 1] of TKDT3088DI32_VecType;
  PKDT3088DI32_Vec = ^TKDT3088DI32_Vec;

  TKDT3088DI32_DynamicVecBuffer = array of TKDT3088DI32_Vec;
  PKDT3088DI32_DynamicVecBuffer = ^TKDT3088DI32_DynamicVecBuffer;

  TKDT3088DI32_Source = packed record
    Buff: TKDT3088DI32_Vec;
    index: Int64;
  end;

  PKDT3088DI32_Source       = ^TKDT3088DI32_Source;
  TKDT3088DI32_SourceBuffer = array [0 .. 0] of PKDT3088DI32_Source;
  PKDT3088DI32_SourceBuffer = ^TKDT3088DI32_SourceBuffer;

  TKDT3088DI32yanmicSourceBuffer = array of PKDT3088DI32_Source;
  PKDT3088DI32yanmicSourceBuffer = ^TKDT3088DI32yanmicSourceBuffer;

  TKDT3088DI32yanmicStoreBuffer = array of TKDT3088DI32_Source;
  PKDT3088DI32yanmicStoreBuffer = ^TKDT3088DI32yanmicStoreBuffer;

  PKDT3088DI32_Node = ^TKDT3088DI32_Node;

  TKDT3088DI32_Node = packed record
    Parent, Right, Left: PKDT3088DI32_Node;
    vec: PKDT3088DI32_Source;
  end;

  TKDT3088DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3088DI32_Source);
  TKDT3088DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3088DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT3088DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3088DI32_Source);
  {$ENDIF}

  TKDT3088DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3088DI32yanmicStoreBuffer;
    KDBuff     : TKDT3088DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3088DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3088DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3088DI32yanmicStoreBuffer; const Buff: TKDT3088DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3088DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3088DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3088DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3088DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3088DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DI32_Node; overload;
    function Search(const Buff: TKDT3088DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DI32_Node; overload;
    function Search(const Buff: TKDT3088DI32_Vec; var SearchedDistanceMin: Double): PKDT3088DI32_Node; overload;
    function Search(const Buff: TKDT3088DI32_Vec): PKDT3088DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3088DI32_DynamicVecBuffer; var OutBuff: TKDT3088DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3088DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3088DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3104DI32_Vec = array [0 .. TKDT3104DI32_AxisCount - 1] of TKDT3104DI32_VecType;
  PKDT3104DI32_Vec = ^TKDT3104DI32_Vec;

  TKDT3104DI32_DynamicVecBuffer = array of TKDT3104DI32_Vec;
  PKDT3104DI32_DynamicVecBuffer = ^TKDT3104DI32_DynamicVecBuffer;

  TKDT3104DI32_Source = packed record
    Buff: TKDT3104DI32_Vec;
    index: Int64;
  end;

  PKDT3104DI32_Source       = ^TKDT3104DI32_Source;
  TKDT3104DI32_SourceBuffer = array [0 .. 0] of PKDT3104DI32_Source;
  PKDT3104DI32_SourceBuffer = ^TKDT3104DI32_SourceBuffer;

  TKDT3104DI32yanmicSourceBuffer = array of PKDT3104DI32_Source;
  PKDT3104DI32yanmicSourceBuffer = ^TKDT3104DI32yanmicSourceBuffer;

  TKDT3104DI32yanmicStoreBuffer = array of TKDT3104DI32_Source;
  PKDT3104DI32yanmicStoreBuffer = ^TKDT3104DI32yanmicStoreBuffer;

  PKDT3104DI32_Node = ^TKDT3104DI32_Node;

  TKDT3104DI32_Node = packed record
    Parent, Right, Left: PKDT3104DI32_Node;
    vec: PKDT3104DI32_Source;
  end;

  TKDT3104DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3104DI32_Source);
  TKDT3104DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3104DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT3104DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3104DI32_Source);
  {$ENDIF}

  TKDT3104DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3104DI32yanmicStoreBuffer;
    KDBuff     : TKDT3104DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3104DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3104DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3104DI32yanmicStoreBuffer; const Buff: TKDT3104DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3104DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3104DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3104DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3104DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3104DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DI32_Node; overload;
    function Search(const Buff: TKDT3104DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DI32_Node; overload;
    function Search(const Buff: TKDT3104DI32_Vec; var SearchedDistanceMin: Double): PKDT3104DI32_Node; overload;
    function Search(const Buff: TKDT3104DI32_Vec): PKDT3104DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3104DI32_DynamicVecBuffer; var OutBuff: TKDT3104DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3104DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3104DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT4096DI32_Vec = array [0 .. TKDT4096DI32_AxisCount - 1] of TKDT4096DI32_VecType;
  PKDT4096DI32_Vec = ^TKDT4096DI32_Vec;

  TKDT4096DI32_DynamicVecBuffer = array of TKDT4096DI32_Vec;
  PKDT4096DI32_DynamicVecBuffer = ^TKDT4096DI32_DynamicVecBuffer;

  TKDT4096DI32_Source = packed record
    Buff: TKDT4096DI32_Vec;
    index: Int64;
  end;

  PKDT4096DI32_Source       = ^TKDT4096DI32_Source;
  TKDT4096DI32_SourceBuffer = array [0 .. 0] of PKDT4096DI32_Source;
  PKDT4096DI32_SourceBuffer = ^TKDT4096DI32_SourceBuffer;

  TKDT4096DI32yanmicSourceBuffer = array of PKDT4096DI32_Source;
  PKDT4096DI32yanmicSourceBuffer = ^TKDT4096DI32yanmicSourceBuffer;

  TKDT4096DI32yanmicStoreBuffer = array of TKDT4096DI32_Source;
  PKDT4096DI32yanmicStoreBuffer = ^TKDT4096DI32yanmicStoreBuffer;

  PKDT4096DI32_Node = ^TKDT4096DI32_Node;

  TKDT4096DI32_Node = packed record
    Parent, Right, Left: PKDT4096DI32_Node;
    vec: PKDT4096DI32_Source;
  end;

  TKDT4096DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT4096DI32_Source);
  TKDT4096DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT4096DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT4096DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT4096DI32_Source);
  {$ENDIF}

  TKDT4096DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT4096DI32yanmicStoreBuffer;
    KDBuff     : TKDT4096DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4096DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT4096DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT4096DI32yanmicStoreBuffer; const Buff: TKDT4096DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT4096DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4096DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4096DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT4096DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4096DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DI32_Node; overload;
    function Search(const Buff: TKDT4096DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DI32_Node; overload;
    function Search(const Buff: TKDT4096DI32_Vec; var SearchedDistanceMin: Double): PKDT4096DI32_Node; overload;
    function Search(const Buff: TKDT4096DI32_Vec): PKDT4096DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4096DI32_DynamicVecBuffer; var OutBuff: TKDT4096DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT4096DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT4096DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT8192DI32_Vec = array [0 .. TKDT8192DI32_AxisCount - 1] of TKDT8192DI32_VecType;
  PKDT8192DI32_Vec = ^TKDT8192DI32_Vec;

  TKDT8192DI32_DynamicVecBuffer = array of TKDT8192DI32_Vec;
  PKDT8192DI32_DynamicVecBuffer = ^TKDT8192DI32_DynamicVecBuffer;

  TKDT8192DI32_Source = packed record
    Buff: TKDT8192DI32_Vec;
    index: Int64;
  end;

  PKDT8192DI32_Source       = ^TKDT8192DI32_Source;
  TKDT8192DI32_SourceBuffer = array [0 .. 0] of PKDT8192DI32_Source;
  PKDT8192DI32_SourceBuffer = ^TKDT8192DI32_SourceBuffer;

  TKDT8192DI32yanmicSourceBuffer = array of PKDT8192DI32_Source;
  PKDT8192DI32yanmicSourceBuffer = ^TKDT8192DI32yanmicSourceBuffer;

  TKDT8192DI32yanmicStoreBuffer = array of TKDT8192DI32_Source;
  PKDT8192DI32yanmicStoreBuffer = ^TKDT8192DI32yanmicStoreBuffer;

  PKDT8192DI32_Node = ^TKDT8192DI32_Node;

  TKDT8192DI32_Node = packed record
    Parent, Right, Left: PKDT8192DI32_Node;
    vec: PKDT8192DI32_Source;
  end;

  TKDT8192DI32_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT8192DI32_Source);
  TKDT8192DI32_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT8192DI32_Source) of object;
  {$IFNDEF FPC}
  TKDT8192DI32_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT8192DI32_Source);
  {$ENDIF}

  TKDT8192DI32 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT8192DI32yanmicStoreBuffer;
    KDBuff     : TKDT8192DI32yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8192DI32_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT8192DI32_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DI32_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT8192DI32yanmicStoreBuffer; const Buff: TKDT8192DI32_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT8192DI32_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8192DI32_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8192DI32yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT8192DI32_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DI32_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DI32_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DI32_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DI32_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI32_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI32_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI32_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI32_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI32_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8192DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DI32_Node; overload;
    function Search(const Buff: TKDT8192DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DI32_Node; overload;
    function Search(const Buff: TKDT8192DI32_Vec; var SearchedDistanceMin: Double): PKDT8192DI32_Node; overload;
    function Search(const Buff: TKDT8192DI32_Vec): PKDT8192DI32_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8192DI32_DynamicVecBuffer; var OutBuff: TKDT8192DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT8192DI32_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT8192DI32_Source);
    class procedure Test;
    {$ENDIF}
  end;






  // integer KDTree
function KDT1DI32Vec(const s: string): TKDT1DI32_Vec; overload;
function KDT1DI32Vec(const v: TKDT1DI32_Vec): string; overload;
function KDT1DI32Pow(const v: TKDT1DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1DI32Distance(const v1, v2: TKDT1DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1DI32Cmpare(const v1, v2: TKDT1DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT2DI32Vec(const s: string): TKDT2DI32_Vec; overload;
function KDT2DI32Vec(const v: TKDT2DI32_Vec): string; overload;
function KDT2DI32Pow(const v: TKDT2DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2DI32Distance(const v1, v2: TKDT2DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2DI32Cmpare(const v1, v2: TKDT2DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3DI32Vec(const s: string): TKDT3DI32_Vec; overload;
function KDT3DI32Vec(const v: TKDT3DI32_Vec): string; overload;
function KDT3DI32Pow(const v: TKDT3DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3DI32Distance(const v1, v2: TKDT3DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3DI32Cmpare(const v1, v2: TKDT3DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT4DI32Vec(const s: string): TKDT4DI32_Vec; overload;
function KDT4DI32Vec(const v: TKDT4DI32_Vec): string; overload;
function KDT4DI32Pow(const v: TKDT4DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4DI32Distance(const v1, v2: TKDT4DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4DI32Cmpare(const v1, v2: TKDT4DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT5DI32Vec(const s: string): TKDT5DI32_Vec; overload;
function KDT5DI32Vec(const v: TKDT5DI32_Vec): string; overload;
function KDT5DI32Pow(const v: TKDT5DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT5DI32Distance(const v1, v2: TKDT5DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT5DI32Cmpare(const v1, v2: TKDT5DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT6DI32Vec(const s: string): TKDT6DI32_Vec; overload;
function KDT6DI32Vec(const v: TKDT6DI32_Vec): string; overload;
function KDT6DI32Pow(const v: TKDT6DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT6DI32Distance(const v1, v2: TKDT6DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT6DI32Cmpare(const v1, v2: TKDT6DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT7DI32Vec(const s: string): TKDT7DI32_Vec; overload;
function KDT7DI32Vec(const v: TKDT7DI32_Vec): string; overload;
function KDT7DI32Pow(const v: TKDT7DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT7DI32Distance(const v1, v2: TKDT7DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT7DI32Cmpare(const v1, v2: TKDT7DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT8DI32Vec(const s: string): TKDT8DI32_Vec; overload;
function KDT8DI32Vec(const v: TKDT8DI32_Vec): string; overload;
function KDT8DI32Pow(const v: TKDT8DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8DI32Distance(const v1, v2: TKDT8DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8DI32Cmpare(const v1, v2: TKDT8DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT9DI32Vec(const s: string): TKDT9DI32_Vec; overload;
function KDT9DI32Vec(const v: TKDT9DI32_Vec): string; overload;
function KDT9DI32Pow(const v: TKDT9DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT9DI32Distance(const v1, v2: TKDT9DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT9DI32Cmpare(const v1, v2: TKDT9DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT10DI32Vec(const s: string): TKDT10DI32_Vec; overload;
function KDT10DI32Vec(const v: TKDT10DI32_Vec): string; overload;
function KDT10DI32Pow(const v: TKDT10DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT10DI32Distance(const v1, v2: TKDT10DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT10DI32Cmpare(const v1, v2: TKDT10DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT11DI32Vec(const s: string): TKDT11DI32_Vec; overload;
function KDT11DI32Vec(const v: TKDT11DI32_Vec): string; overload;
function KDT11DI32Pow(const v: TKDT11DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT11DI32Distance(const v1, v2: TKDT11DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT11DI32Cmpare(const v1, v2: TKDT11DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT12DI32Vec(const s: string): TKDT12DI32_Vec; overload;
function KDT12DI32Vec(const v: TKDT12DI32_Vec): string; overload;
function KDT12DI32Pow(const v: TKDT12DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT12DI32Distance(const v1, v2: TKDT12DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT12DI32Cmpare(const v1, v2: TKDT12DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT13DI32Vec(const s: string): TKDT13DI32_Vec; overload;
function KDT13DI32Vec(const v: TKDT13DI32_Vec): string; overload;
function KDT13DI32Pow(const v: TKDT13DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT13DI32Distance(const v1, v2: TKDT13DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT13DI32Cmpare(const v1, v2: TKDT13DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT14DI32Vec(const s: string): TKDT14DI32_Vec; overload;
function KDT14DI32Vec(const v: TKDT14DI32_Vec): string; overload;
function KDT14DI32Pow(const v: TKDT14DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT14DI32Distance(const v1, v2: TKDT14DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT14DI32Cmpare(const v1, v2: TKDT14DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT15DI32Vec(const s: string): TKDT15DI32_Vec; overload;
function KDT15DI32Vec(const v: TKDT15DI32_Vec): string; overload;
function KDT15DI32Pow(const v: TKDT15DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT15DI32Distance(const v1, v2: TKDT15DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT15DI32Cmpare(const v1, v2: TKDT15DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT16DI32Vec(const s: string): TKDT16DI32_Vec; overload;
function KDT16DI32Vec(const v: TKDT16DI32_Vec): string; overload;
function KDT16DI32Pow(const v: TKDT16DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT16DI32Distance(const v1, v2: TKDT16DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT16DI32Cmpare(const v1, v2: TKDT16DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT17DI32Vec(const s: string): TKDT17DI32_Vec; overload;
function KDT17DI32Vec(const v: TKDT17DI32_Vec): string; overload;
function KDT17DI32Pow(const v: TKDT17DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT17DI32Distance(const v1, v2: TKDT17DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT17DI32Cmpare(const v1, v2: TKDT17DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT18DI32Vec(const s: string): TKDT18DI32_Vec; overload;
function KDT18DI32Vec(const v: TKDT18DI32_Vec): string; overload;
function KDT18DI32Pow(const v: TKDT18DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT18DI32Distance(const v1, v2: TKDT18DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT18DI32Cmpare(const v1, v2: TKDT18DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT19DI32Vec(const s: string): TKDT19DI32_Vec; overload;
function KDT19DI32Vec(const v: TKDT19DI32_Vec): string; overload;
function KDT19DI32Pow(const v: TKDT19DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT19DI32Distance(const v1, v2: TKDT19DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT19DI32Cmpare(const v1, v2: TKDT19DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT20DI32Vec(const s: string): TKDT20DI32_Vec; overload;
function KDT20DI32Vec(const v: TKDT20DI32_Vec): string; overload;
function KDT20DI32Pow(const v: TKDT20DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT20DI32Distance(const v1, v2: TKDT20DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT20DI32Cmpare(const v1, v2: TKDT20DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT21DI32Vec(const s: string): TKDT21DI32_Vec; overload;
function KDT21DI32Vec(const v: TKDT21DI32_Vec): string; overload;
function KDT21DI32Pow(const v: TKDT21DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT21DI32Distance(const v1, v2: TKDT21DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT21DI32Cmpare(const v1, v2: TKDT21DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT22DI32Vec(const s: string): TKDT22DI32_Vec; overload;
function KDT22DI32Vec(const v: TKDT22DI32_Vec): string; overload;
function KDT22DI32Pow(const v: TKDT22DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT22DI32Distance(const v1, v2: TKDT22DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT22DI32Cmpare(const v1, v2: TKDT22DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT23DI32Vec(const s: string): TKDT23DI32_Vec; overload;
function KDT23DI32Vec(const v: TKDT23DI32_Vec): string; overload;
function KDT23DI32Pow(const v: TKDT23DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT23DI32Distance(const v1, v2: TKDT23DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT23DI32Cmpare(const v1, v2: TKDT23DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT24DI32Vec(const s: string): TKDT24DI32_Vec; overload;
function KDT24DI32Vec(const v: TKDT24DI32_Vec): string; overload;
function KDT24DI32Pow(const v: TKDT24DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT24DI32Distance(const v1, v2: TKDT24DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT24DI32Cmpare(const v1, v2: TKDT24DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT25DI32Vec(const s: string): TKDT25DI32_Vec; overload;
function KDT25DI32Vec(const v: TKDT25DI32_Vec): string; overload;
function KDT25DI32Pow(const v: TKDT25DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT25DI32Distance(const v1, v2: TKDT25DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT25DI32Cmpare(const v1, v2: TKDT25DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT26DI32Vec(const s: string): TKDT26DI32_Vec; overload;
function KDT26DI32Vec(const v: TKDT26DI32_Vec): string; overload;
function KDT26DI32Pow(const v: TKDT26DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT26DI32Distance(const v1, v2: TKDT26DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT26DI32Cmpare(const v1, v2: TKDT26DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT27DI32Vec(const s: string): TKDT27DI32_Vec; overload;
function KDT27DI32Vec(const v: TKDT27DI32_Vec): string; overload;
function KDT27DI32Pow(const v: TKDT27DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT27DI32Distance(const v1, v2: TKDT27DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT27DI32Cmpare(const v1, v2: TKDT27DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT28DI32Vec(const s: string): TKDT28DI32_Vec; overload;
function KDT28DI32Vec(const v: TKDT28DI32_Vec): string; overload;
function KDT28DI32Pow(const v: TKDT28DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT28DI32Distance(const v1, v2: TKDT28DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT28DI32Cmpare(const v1, v2: TKDT28DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT29DI32Vec(const s: string): TKDT29DI32_Vec; overload;
function KDT29DI32Vec(const v: TKDT29DI32_Vec): string; overload;
function KDT29DI32Pow(const v: TKDT29DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT29DI32Distance(const v1, v2: TKDT29DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT29DI32Cmpare(const v1, v2: TKDT29DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT30DI32Vec(const s: string): TKDT30DI32_Vec; overload;
function KDT30DI32Vec(const v: TKDT30DI32_Vec): string; overload;
function KDT30DI32Pow(const v: TKDT30DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT30DI32Distance(const v1, v2: TKDT30DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT30DI32Cmpare(const v1, v2: TKDT30DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT32DI32Vec(const s: string): TKDT32DI32_Vec; overload;
function KDT32DI32Vec(const v: TKDT32DI32_Vec): string; overload;
function KDT32DI32Pow(const v: TKDT32DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT32DI32Distance(const v1, v2: TKDT32DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT32DI32Cmpare(const v1, v2: TKDT32DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT34DI32Vec(const s: string): TKDT34DI32_Vec; overload;
function KDT34DI32Vec(const v: TKDT34DI32_Vec): string; overload;
function KDT34DI32Pow(const v: TKDT34DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT34DI32Distance(const v1, v2: TKDT34DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT34DI32Cmpare(const v1, v2: TKDT34DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT36DI32Vec(const s: string): TKDT36DI32_Vec; overload;
function KDT36DI32Vec(const v: TKDT36DI32_Vec): string; overload;
function KDT36DI32Pow(const v: TKDT36DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT36DI32Distance(const v1, v2: TKDT36DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT36DI32Cmpare(const v1, v2: TKDT36DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT38DI32Vec(const s: string): TKDT38DI32_Vec; overload;
function KDT38DI32Vec(const v: TKDT38DI32_Vec): string; overload;
function KDT38DI32Pow(const v: TKDT38DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT38DI32Distance(const v1, v2: TKDT38DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT38DI32Cmpare(const v1, v2: TKDT38DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT40DI32Vec(const s: string): TKDT40DI32_Vec; overload;
function KDT40DI32Vec(const v: TKDT40DI32_Vec): string; overload;
function KDT40DI32Pow(const v: TKDT40DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT40DI32Distance(const v1, v2: TKDT40DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT40DI32Cmpare(const v1, v2: TKDT40DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT44DI32Vec(const s: string): TKDT44DI32_Vec; overload;
function KDT44DI32Vec(const v: TKDT44DI32_Vec): string; overload;
function KDT44DI32Pow(const v: TKDT44DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT44DI32Distance(const v1, v2: TKDT44DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT44DI32Cmpare(const v1, v2: TKDT44DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT48DI32Vec(const s: string): TKDT48DI32_Vec; overload;
function KDT48DI32Vec(const v: TKDT48DI32_Vec): string; overload;
function KDT48DI32Pow(const v: TKDT48DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT48DI32Distance(const v1, v2: TKDT48DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT48DI32Cmpare(const v1, v2: TKDT48DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT50DI32Vec(const s: string): TKDT50DI32_Vec; overload;
function KDT50DI32Vec(const v: TKDT50DI32_Vec): string; overload;
function KDT50DI32Pow(const v: TKDT50DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT50DI32Distance(const v1, v2: TKDT50DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT50DI32Cmpare(const v1, v2: TKDT50DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT56DI32Vec(const s: string): TKDT56DI32_Vec; overload;
function KDT56DI32Vec(const v: TKDT56DI32_Vec): string; overload;
function KDT56DI32Pow(const v: TKDT56DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT56DI32Distance(const v1, v2: TKDT56DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT56DI32Cmpare(const v1, v2: TKDT56DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT60DI32Vec(const s: string): TKDT60DI32_Vec; overload;
function KDT60DI32Vec(const v: TKDT60DI32_Vec): string; overload;
function KDT60DI32Pow(const v: TKDT60DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT60DI32Distance(const v1, v2: TKDT60DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT60DI32Cmpare(const v1, v2: TKDT60DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT64DI32Vec(const s: string): TKDT64DI32_Vec; overload;
function KDT64DI32Vec(const v: TKDT64DI32_Vec): string; overload;
function KDT64DI32Pow(const v: TKDT64DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT64DI32Distance(const v1, v2: TKDT64DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT64DI32Cmpare(const v1, v2: TKDT64DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT72DI32Vec(const s: string): TKDT72DI32_Vec; overload;
function KDT72DI32Vec(const v: TKDT72DI32_Vec): string; overload;
function KDT72DI32Pow(const v: TKDT72DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT72DI32Distance(const v1, v2: TKDT72DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT72DI32Cmpare(const v1, v2: TKDT72DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT84DI32Vec(const s: string): TKDT84DI32_Vec; overload;
function KDT84DI32Vec(const v: TKDT84DI32_Vec): string; overload;
function KDT84DI32Pow(const v: TKDT84DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT84DI32Distance(const v1, v2: TKDT84DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT84DI32Cmpare(const v1, v2: TKDT84DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT96DI32Vec(const s: string): TKDT96DI32_Vec; overload;
function KDT96DI32Vec(const v: TKDT96DI32_Vec): string; overload;
function KDT96DI32Pow(const v: TKDT96DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT96DI32Distance(const v1, v2: TKDT96DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT96DI32Cmpare(const v1, v2: TKDT96DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT128DI32Vec(const s: string): TKDT128DI32_Vec; overload;
function KDT128DI32Vec(const v: TKDT128DI32_Vec): string; overload;
function KDT128DI32Pow(const v: TKDT128DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT128DI32Distance(const v1, v2: TKDT128DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT128DI32Cmpare(const v1, v2: TKDT128DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT140DI32Vec(const s: string): TKDT140DI32_Vec; overload;
function KDT140DI32Vec(const v: TKDT140DI32_Vec): string; overload;
function KDT140DI32Pow(const v: TKDT140DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT140DI32Distance(const v1, v2: TKDT140DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT140DI32Cmpare(const v1, v2: TKDT140DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT160DI32Vec(const s: string): TKDT160DI32_Vec; overload;
function KDT160DI32Vec(const v: TKDT160DI32_Vec): string; overload;
function KDT160DI32Pow(const v: TKDT160DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT160DI32Distance(const v1, v2: TKDT160DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT160DI32Cmpare(const v1, v2: TKDT160DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT196DI32Vec(const s: string): TKDT196DI32_Vec; overload;
function KDT196DI32Vec(const v: TKDT196DI32_Vec): string; overload;
function KDT196DI32Pow(const v: TKDT196DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT196DI32Distance(const v1, v2: TKDT196DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT196DI32Cmpare(const v1, v2: TKDT196DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT256DI32Vec(const s: string): TKDT256DI32_Vec; overload;
function KDT256DI32Vec(const v: TKDT256DI32_Vec): string; overload;
function KDT256DI32Pow(const v: TKDT256DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT256DI32Distance(const v1, v2: TKDT256DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT256DI32Cmpare(const v1, v2: TKDT256DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT272DI32Vec(const s: string): TKDT272DI32_Vec; overload;
function KDT272DI32Vec(const v: TKDT272DI32_Vec): string; overload;
function KDT272DI32Pow(const v: TKDT272DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT272DI32Distance(const v1, v2: TKDT272DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT272DI32Cmpare(const v1, v2: TKDT272DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT288DI32Vec(const s: string): TKDT288DI32_Vec; overload;
function KDT288DI32Vec(const v: TKDT288DI32_Vec): string; overload;
function KDT288DI32Pow(const v: TKDT288DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT288DI32Distance(const v1, v2: TKDT288DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT288DI32Cmpare(const v1, v2: TKDT288DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT372DI32Vec(const s: string): TKDT372DI32_Vec; overload;
function KDT372DI32Vec(const v: TKDT372DI32_Vec): string; overload;
function KDT372DI32Pow(const v: TKDT372DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT372DI32Distance(const v1, v2: TKDT372DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT372DI32Cmpare(const v1, v2: TKDT372DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT512DI32Vec(const s: string): TKDT512DI32_Vec; overload;
function KDT512DI32Vec(const v: TKDT512DI32_Vec): string; overload;
function KDT512DI32Pow(const v: TKDT512DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT512DI32Distance(const v1, v2: TKDT512DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT512DI32Cmpare(const v1, v2: TKDT512DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT576DI32Vec(const s: string): TKDT576DI32_Vec; overload;
function KDT576DI32Vec(const v: TKDT576DI32_Vec): string; overload;
function KDT576DI32Pow(const v: TKDT576DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT576DI32Distance(const v1, v2: TKDT576DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT576DI32Cmpare(const v1, v2: TKDT576DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT768DI32Vec(const s: string): TKDT768DI32_Vec; overload;
function KDT768DI32Vec(const v: TKDT768DI32_Vec): string; overload;
function KDT768DI32Pow(const v: TKDT768DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT768DI32Distance(const v1, v2: TKDT768DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT768DI32Cmpare(const v1, v2: TKDT768DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1024DI32Vec(const s: string): TKDT1024DI32_Vec; overload;
function KDT1024DI32Vec(const v: TKDT1024DI32_Vec): string; overload;
function KDT1024DI32Pow(const v: TKDT1024DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1024DI32Distance(const v1, v2: TKDT1024DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1024DI32Cmpare(const v1, v2: TKDT1024DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1040DI32Vec(const s: string): TKDT1040DI32_Vec; overload;
function KDT1040DI32Vec(const v: TKDT1040DI32_Vec): string; overload;
function KDT1040DI32Pow(const v: TKDT1040DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1040DI32Distance(const v1, v2: TKDT1040DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1040DI32Cmpare(const v1, v2: TKDT1040DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1056DI32Vec(const s: string): TKDT1056DI32_Vec; overload;
function KDT1056DI32Vec(const v: TKDT1056DI32_Vec): string; overload;
function KDT1056DI32Pow(const v: TKDT1056DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1056DI32Distance(const v1, v2: TKDT1056DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1056DI32Cmpare(const v1, v2: TKDT1056DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1536DI32Vec(const s: string): TKDT1536DI32_Vec; overload;
function KDT1536DI32Vec(const v: TKDT1536DI32_Vec): string; overload;
function KDT1536DI32Pow(const v: TKDT1536DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1536DI32Distance(const v1, v2: TKDT1536DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1536DI32Cmpare(const v1, v2: TKDT1536DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1920DI32Vec(const s: string): TKDT1920DI32_Vec; overload;
function KDT1920DI32Vec(const v: TKDT1920DI32_Vec): string; overload;
function KDT1920DI32Pow(const v: TKDT1920DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1920DI32Distance(const v1, v2: TKDT1920DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1920DI32Cmpare(const v1, v2: TKDT1920DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1980DI32Vec(const s: string): TKDT1980DI32_Vec; overload;
function KDT1980DI32Vec(const v: TKDT1980DI32_Vec): string; overload;
function KDT1980DI32Pow(const v: TKDT1980DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1980DI32Distance(const v1, v2: TKDT1980DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1980DI32Cmpare(const v1, v2: TKDT1980DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT2048DI32Vec(const s: string): TKDT2048DI32_Vec; overload;
function KDT2048DI32Vec(const v: TKDT2048DI32_Vec): string; overload;
function KDT2048DI32Pow(const v: TKDT2048DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2048DI32Distance(const v1, v2: TKDT2048DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2048DI32Cmpare(const v1, v2: TKDT2048DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3072DI32Vec(const s: string): TKDT3072DI32_Vec; overload;
function KDT3072DI32Vec(const v: TKDT3072DI32_Vec): string; overload;
function KDT3072DI32Pow(const v: TKDT3072DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3072DI32Distance(const v1, v2: TKDT3072DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3072DI32Cmpare(const v1, v2: TKDT3072DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3088DI32Vec(const s: string): TKDT3088DI32_Vec; overload;
function KDT3088DI32Vec(const v: TKDT3088DI32_Vec): string; overload;
function KDT3088DI32Pow(const v: TKDT3088DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3088DI32Distance(const v1, v2: TKDT3088DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3088DI32Cmpare(const v1, v2: TKDT3088DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3104DI32Vec(const s: string): TKDT3104DI32_Vec; overload;
function KDT3104DI32Vec(const v: TKDT3104DI32_Vec): string; overload;
function KDT3104DI32Pow(const v: TKDT3104DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3104DI32Distance(const v1, v2: TKDT3104DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3104DI32Cmpare(const v1, v2: TKDT3104DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT4096DI32Vec(const s: string): TKDT4096DI32_Vec; overload;
function KDT4096DI32Vec(const v: TKDT4096DI32_Vec): string; overload;
function KDT4096DI32Pow(const v: TKDT4096DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4096DI32Distance(const v1, v2: TKDT4096DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4096DI32Cmpare(const v1, v2: TKDT4096DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT8192DI32Vec(const s: string): TKDT8192DI32_Vec; overload;
function KDT8192DI32Vec(const v: TKDT8192DI32_Vec): string; overload;
function KDT8192DI32Pow(const v: TKDT8192DI32_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8192DI32Distance(const v1, v2: TKDT8192DI32_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8192DI32Cmpare(const v1, v2: TKDT8192DI32_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

{$IFDEF DEBUG}
procedure Test_All;
{$ENDIF}


implementation

uses
  {$IFDEF FPC}
  mtprocs,
  {$ELSE FPC}
  Threading,
  {$ENDIF FPC}
  PascalStrings, TextParsing, UnicodeMixedLib, DoStatusIO;






function KDT1DI32Vec(const s: string): TKDT1DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1DI32Vec(const v: TKDT1DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1DI32Pow(const v: TKDT1DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT1DI32Distance(const v1, v2: TKDT1DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1DI32_AxisCount - 1 do
      Result := Result + KDT1DI32Pow(v2[i] - v1[i]);
end;

function KDT1DI32Cmpare(const v1, v2: TKDT1DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1DI32_Vec));
end;

function TKDT1DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DI32_Node;
  function SortCompare(const p1, p2: PKDT1DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1DI32_SourceBuffer;
  dynBuff  : PKDT1DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DI32.SearchStoreBuff(const StoreBuffPtr: PKDT1DI32yanmicStoreBuffer; const Buff: TKDT1DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1DI32.GetData(const index: NativeInt): PKDT1DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DI32.StoreBuffPtr: PKDT1DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1DI32.BuildKDTreeWithCluster(const inBuff: TKDT1DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DI32.BuildKDTreeWithCluster(const inBuff: TKDT1DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI32_BuildCall);
var
  TempStoreBuff: TKDT1DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI32_BuildMethod);
var
  TempStoreBuff: TKDT1DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI32_BuildProc);
var
  TempStoreBuff: TKDT1DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1DI32.Search(const Buff: TKDT1DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DI32_Node;

var
  NearestNeighbour: PKDT1DI32_Node;

  function FindParentNode(const BuffPtr: PKDT1DI32_Vec; NodePtr: PKDT1DI32_Node): PKDT1DI32_Node;
  var
    Next       : PKDT1DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DI32_Node; const BuffPtr: PKDT1DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1DI32_Vec; const p1, p2: PKDT1DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT1DI32.Search(const Buff: TKDT1DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DI32.Search(const Buff: TKDT1DI32_Vec; var SearchedDistanceMin: Double): PKDT1DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DI32.Search(const Buff: TKDT1DI32_Vec): PKDT1DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1DI32.Search(const inBuff: TKDT1DI32_DynamicVecBuffer; var OutBuff: TKDT1DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DI32_DynamicVecBuffer;
  outBuffPtr : PKDT1DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1DI32_Source));
end;

procedure TKDT1DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1DI32.PrintNodeTree(const NodePtr: PKDT1DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1DI32.Test;
var
  TKDT1DI32_Test    : TKDT1DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1DI32_Test := TKDT1DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT1DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT1DI32_AxisCount - 1 do
        TKDT1DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1DI32_Test.TestBuff), length(TKDT1DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1DI32_Test.BuildKDTreeM(False, length(TKDT1DI32_Test.TestBuff), @TKDT1DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1DI32_Test.BuildKDTreeM(False, length(TKDT1DI32_Test.TestBuff), TKDT1DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1DI32_Test.TestBuff));
  TKDT1DI32_Test.Search(TKDT1DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1DI32Distance(TKDT1DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1DI32_Test.Clear;
  { kMean test }
  TKDT1DI32_Test.BuildKDTreeWithCluster(TKDT1DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1DI32_Test.Search(TKDT1DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1DI32_Test);
end;

{$ENDIF DEBUG}


function KDT2DI32Vec(const s: string): TKDT2DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT2DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT2DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT2DI32Vec(const v: TKDT2DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT2DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT2DI32Pow(const v: TKDT2DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT2DI32Distance(const v1, v2: TKDT2DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT2DI32_AxisCount - 1 do
      Result := Result + KDT2DI32Pow(v2[i] - v1[i]);
end;

function KDT2DI32Cmpare(const v1, v2: TKDT2DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT2DI32_Vec));
end;

function TKDT2DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DI32_Node;
  function SortCompare(const p1, p2: PKDT2DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2DI32_SourceBuffer;
  dynBuff  : PKDT2DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT2DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DI32.SearchStoreBuff(const StoreBuffPtr: PKDT2DI32yanmicStoreBuffer; const Buff: TKDT2DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT2DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT2DI32.GetData(const index: NativeInt): PKDT2DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DI32.StoreBuffPtr: PKDT2DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2DI32.BuildKDTreeWithCluster(const inBuff: TKDT2DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT2DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT2DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT2DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DI32.BuildKDTreeWithCluster(const inBuff: TKDT2DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI32_BuildCall);
var
  TempStoreBuff: TKDT2DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI32_BuildMethod);
var
  TempStoreBuff: TKDT2DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI32_BuildProc);
var
  TempStoreBuff: TKDT2DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2DI32.Search(const Buff: TKDT2DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DI32_Node;

var
  NearestNeighbour: PKDT2DI32_Node;

  function FindParentNode(const BuffPtr: PKDT2DI32_Vec; NodePtr: PKDT2DI32_Node): PKDT2DI32_Node;
  var
    Next       : PKDT2DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT2DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DI32_Node; const BuffPtr: PKDT2DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT2DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2DI32_Vec; const p1, p2: PKDT2DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT2DI32.Search(const Buff: TKDT2DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DI32.Search(const Buff: TKDT2DI32_Vec; var SearchedDistanceMin: Double): PKDT2DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DI32.Search(const Buff: TKDT2DI32_Vec): PKDT2DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2DI32.Search(const inBuff: TKDT2DI32_DynamicVecBuffer; var OutBuff: TKDT2DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DI32_DynamicVecBuffer;
  outBuffPtr : PKDT2DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2DI32_Source));
end;

procedure TKDT2DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT2DI32.PrintNodeTree(const NodePtr: PKDT2DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT2DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT2DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2DI32.Test;
var
  TKDT2DI32_Test    : TKDT2DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2DI32_Test := TKDT2DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT2DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT2DI32_AxisCount - 1 do
        TKDT2DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT2DI32_Test.TestBuff), length(TKDT2DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2DI32_Test.BuildKDTreeM(False, length(TKDT2DI32_Test.TestBuff), @TKDT2DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2DI32_Test.BuildKDTreeM(False, length(TKDT2DI32_Test.TestBuff), TKDT2DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2DI32_Test.TestBuff));
  TKDT2DI32_Test.Search(TKDT2DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2DI32Distance(TKDT2DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2DI32_Test.Clear;
  { kMean test }
  TKDT2DI32_Test.BuildKDTreeWithCluster(TKDT2DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2DI32_Test.Search(TKDT2DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2DI32_Test);
end;

{$ENDIF DEBUG}


function KDT3DI32Vec(const s: string): TKDT3DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3DI32Vec(const v: TKDT3DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT3DI32Pow(const v: TKDT3DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT3DI32Distance(const v1, v2: TKDT3DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3DI32_AxisCount - 1 do
      Result := Result + KDT3DI32Pow(v2[i] - v1[i]);
end;

function KDT3DI32Cmpare(const v1, v2: TKDT3DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3DI32_Vec));
end;

function TKDT3DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DI32_Node;
  function SortCompare(const p1, p2: PKDT3DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3DI32_SourceBuffer;
  dynBuff  : PKDT3DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DI32.SearchStoreBuff(const StoreBuffPtr: PKDT3DI32yanmicStoreBuffer; const Buff: TKDT3DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3DI32.GetData(const index: NativeInt): PKDT3DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DI32.StoreBuffPtr: PKDT3DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3DI32.BuildKDTreeWithCluster(const inBuff: TKDT3DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DI32.BuildKDTreeWithCluster(const inBuff: TKDT3DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI32_BuildCall);
var
  TempStoreBuff: TKDT3DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI32_BuildMethod);
var
  TempStoreBuff: TKDT3DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI32_BuildProc);
var
  TempStoreBuff: TKDT3DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3DI32.Search(const Buff: TKDT3DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DI32_Node;

var
  NearestNeighbour: PKDT3DI32_Node;

  function FindParentNode(const BuffPtr: PKDT3DI32_Vec; NodePtr: PKDT3DI32_Node): PKDT3DI32_Node;
  var
    Next       : PKDT3DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DI32_Node; const BuffPtr: PKDT3DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3DI32_Vec; const p1, p2: PKDT3DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT3DI32.Search(const Buff: TKDT3DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DI32.Search(const Buff: TKDT3DI32_Vec; var SearchedDistanceMin: Double): PKDT3DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DI32.Search(const Buff: TKDT3DI32_Vec): PKDT3DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3DI32.Search(const inBuff: TKDT3DI32_DynamicVecBuffer; var OutBuff: TKDT3DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DI32_DynamicVecBuffer;
  outBuffPtr : PKDT3DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3DI32_Source));
end;

procedure TKDT3DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3DI32.PrintNodeTree(const NodePtr: PKDT3DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3DI32.Test;
var
  TKDT3DI32_Test    : TKDT3DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3DI32_Test := TKDT3DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT3DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT3DI32_AxisCount - 1 do
        TKDT3DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT3DI32_Test.TestBuff), length(TKDT3DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3DI32_Test.BuildKDTreeM(False, length(TKDT3DI32_Test.TestBuff), @TKDT3DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3DI32_Test.BuildKDTreeM(False, length(TKDT3DI32_Test.TestBuff), TKDT3DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3DI32_Test.TestBuff));
  TKDT3DI32_Test.Search(TKDT3DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3DI32Distance(TKDT3DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3DI32_Test.Clear;
  { kMean test }
  TKDT3DI32_Test.BuildKDTreeWithCluster(TKDT3DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3DI32_Test.Search(TKDT3DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3DI32_Test);
end;

{$ENDIF DEBUG}


function KDT4DI32Vec(const s: string): TKDT4DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT4DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT4DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT4DI32Vec(const v: TKDT4DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT4DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT4DI32Pow(const v: TKDT4DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT4DI32Distance(const v1, v2: TKDT4DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT4DI32_AxisCount - 1 do
      Result := Result + KDT4DI32Pow(v2[i] - v1[i]);
end;

function KDT4DI32Cmpare(const v1, v2: TKDT4DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT4DI32_Vec));
end;

function TKDT4DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DI32_Node;
  function SortCompare(const p1, p2: PKDT4DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4DI32_SourceBuffer;
  dynBuff  : PKDT4DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT4DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DI32.SearchStoreBuff(const StoreBuffPtr: PKDT4DI32yanmicStoreBuffer; const Buff: TKDT4DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT4DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT4DI32.GetData(const index: NativeInt): PKDT4DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DI32.StoreBuffPtr: PKDT4DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4DI32.BuildKDTreeWithCluster(const inBuff: TKDT4DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT4DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT4DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT4DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DI32.BuildKDTreeWithCluster(const inBuff: TKDT4DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI32_BuildCall);
var
  TempStoreBuff: TKDT4DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI32_BuildMethod);
var
  TempStoreBuff: TKDT4DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI32_BuildProc);
var
  TempStoreBuff: TKDT4DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT4DI32.Search(const Buff: TKDT4DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DI32_Node;

var
  NearestNeighbour: PKDT4DI32_Node;

  function FindParentNode(const BuffPtr: PKDT4DI32_Vec; NodePtr: PKDT4DI32_Node): PKDT4DI32_Node;
  var
    Next       : PKDT4DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT4DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DI32_Node; const BuffPtr: PKDT4DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT4DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4DI32_Vec; const p1, p2: PKDT4DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT4DI32.Search(const Buff: TKDT4DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DI32.Search(const Buff: TKDT4DI32_Vec; var SearchedDistanceMin: Double): PKDT4DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DI32.Search(const Buff: TKDT4DI32_Vec): PKDT4DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4DI32.Search(const inBuff: TKDT4DI32_DynamicVecBuffer; var OutBuff: TKDT4DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DI32_DynamicVecBuffer;
  outBuffPtr : PKDT4DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4DI32_Source));
end;

procedure TKDT4DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT4DI32.PrintNodeTree(const NodePtr: PKDT4DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT4DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT4DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4DI32.Test;
var
  TKDT4DI32_Test    : TKDT4DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4DI32_Test := TKDT4DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT4DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT4DI32_AxisCount - 1 do
        TKDT4DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT4DI32_Test.TestBuff), length(TKDT4DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4DI32_Test.BuildKDTreeM(False, length(TKDT4DI32_Test.TestBuff), @TKDT4DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4DI32_Test.BuildKDTreeM(False, length(TKDT4DI32_Test.TestBuff), TKDT4DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4DI32_Test.TestBuff));
  TKDT4DI32_Test.Search(TKDT4DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4DI32Distance(TKDT4DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4DI32_Test.Clear;
  { kMean test }
  TKDT4DI32_Test.BuildKDTreeWithCluster(TKDT4DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4DI32_Test.Search(TKDT4DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4DI32_Test);
end;

{$ENDIF DEBUG}


function KDT5DI32Vec(const s: string): TKDT5DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT5DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT5DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT5DI32Vec(const v: TKDT5DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT5DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT5DI32Pow(const v: TKDT5DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT5DI32Distance(const v1, v2: TKDT5DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT5DI32_AxisCount - 1 do
      Result := Result + KDT5DI32Pow(v2[i] - v1[i]);
end;

function KDT5DI32Cmpare(const v1, v2: TKDT5DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT5DI32_Vec));
end;

function TKDT5DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DI32_Node;
  function SortCompare(const p1, p2: PKDT5DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT5DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT5DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT5DI32_SourceBuffer;
  dynBuff  : PKDT5DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT5DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT5DI32.SearchStoreBuff(const StoreBuffPtr: PKDT5DI32yanmicStoreBuffer; const Buff: TKDT5DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT5DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT5DI32.GetData(const index: NativeInt): PKDT5DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT5DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT5DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT5DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT5DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT5DI32.StoreBuffPtr: PKDT5DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT5DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT5DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT5DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT5DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT5DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT5DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT5DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT5DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT5DI32.BuildKDTreeWithCluster(const inBuff: TKDT5DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT5DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT5DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT5DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT5DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT5DI32.BuildKDTreeWithCluster(const inBuff: TKDT5DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI32_BuildCall);
var
  TempStoreBuff: TKDT5DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT5DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT5DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT5DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT5DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI32_BuildMethod);
var
  TempStoreBuff: TKDT5DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT5DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT5DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT5DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT5DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI32_BuildProc);
var
  TempStoreBuff: TKDT5DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT5DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT5DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT5DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT5DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT5DI32.Search(const Buff: TKDT5DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DI32_Node;

var
  NearestNeighbour: PKDT5DI32_Node;

  function FindParentNode(const BuffPtr: PKDT5DI32_Vec; NodePtr: PKDT5DI32_Node): PKDT5DI32_Node;
  var
    Next       : PKDT5DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT5DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT5DI32_Node; const BuffPtr: PKDT5DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT5DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT5DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT5DI32_Vec; const p1, p2: PKDT5DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT5DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT5DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT5DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT5DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT5DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT5DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT5DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT5DI32.Search(const Buff: TKDT5DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT5DI32.Search(const Buff: TKDT5DI32_Vec; var SearchedDistanceMin: Double): PKDT5DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT5DI32.Search(const Buff: TKDT5DI32_Vec): PKDT5DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT5DI32.Search(const inBuff: TKDT5DI32_DynamicVecBuffer; var OutBuff: TKDT5DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT5DI32_DynamicVecBuffer;
  outBuffPtr : PKDT5DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT5DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT5DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT5DI32_Source));
end;

procedure TKDT5DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT5DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT5DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT5DI32.PrintNodeTree(const NodePtr: PKDT5DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT5DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT5DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT5DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT5DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT5DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT5DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT5DI32.Test;
var
  TKDT5DI32_Test    : TKDT5DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT5DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT5DI32_Test := TKDT5DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT5DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT5DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT5DI32_AxisCount - 1 do
        TKDT5DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT5DI32_Test.TestBuff), length(TKDT5DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT5DI32_Test.BuildKDTreeM(False, length(TKDT5DI32_Test.TestBuff), @TKDT5DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT5DI32_Test.BuildKDTreeM(False, length(TKDT5DI32_Test.TestBuff), TKDT5DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT5DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT5DI32_Test.TestBuff));
  TKDT5DI32_Test.Search(TKDT5DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT5DI32Distance(TKDT5DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT5DI32_Test.Clear;
  { kMean test }
  TKDT5DI32_Test.BuildKDTreeWithCluster(TKDT5DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT5DI32_Test.Search(TKDT5DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT5DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT5DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT5DI32_Test);
end;

{$ENDIF DEBUG}


function KDT6DI32Vec(const s: string): TKDT6DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT6DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT6DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT6DI32Vec(const v: TKDT6DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT6DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT6DI32Pow(const v: TKDT6DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT6DI32Distance(const v1, v2: TKDT6DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT6DI32_AxisCount - 1 do
      Result := Result + KDT6DI32Pow(v2[i] - v1[i]);
end;

function KDT6DI32Cmpare(const v1, v2: TKDT6DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT6DI32_Vec));
end;

function TKDT6DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DI32_Node;
  function SortCompare(const p1, p2: PKDT6DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT6DI32_SourceBuffer;
  dynBuff  : PKDT6DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT6DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DI32.SearchStoreBuff(const StoreBuffPtr: PKDT6DI32yanmicStoreBuffer; const Buff: TKDT6DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT6DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT6DI32.GetData(const index: NativeInt): PKDT6DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT6DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DI32.StoreBuffPtr: PKDT6DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT6DI32.BuildKDTreeWithCluster(const inBuff: TKDT6DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT6DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT6DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT6DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DI32.BuildKDTreeWithCluster(const inBuff: TKDT6DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI32_BuildCall);
var
  TempStoreBuff: TKDT6DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI32_BuildMethod);
var
  TempStoreBuff: TKDT6DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI32_BuildProc);
var
  TempStoreBuff: TKDT6DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT6DI32.Search(const Buff: TKDT6DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DI32_Node;

var
  NearestNeighbour: PKDT6DI32_Node;

  function FindParentNode(const BuffPtr: PKDT6DI32_Vec; NodePtr: PKDT6DI32_Node): PKDT6DI32_Node;
  var
    Next       : PKDT6DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT6DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DI32_Node; const BuffPtr: PKDT6DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT6DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT6DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT6DI32_Vec; const p1, p2: PKDT6DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT6DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT6DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT6DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT6DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT6DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT6DI32.Search(const Buff: TKDT6DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DI32.Search(const Buff: TKDT6DI32_Vec; var SearchedDistanceMin: Double): PKDT6DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DI32.Search(const Buff: TKDT6DI32_Vec): PKDT6DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT6DI32.Search(const inBuff: TKDT6DI32_DynamicVecBuffer; var OutBuff: TKDT6DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DI32_DynamicVecBuffer;
  outBuffPtr : PKDT6DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT6DI32_Source));
end;

procedure TKDT6DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT6DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT6DI32.PrintNodeTree(const NodePtr: PKDT6DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT6DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT6DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT6DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT6DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT6DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT6DI32.Test;
var
  TKDT6DI32_Test    : TKDT6DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT6DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT6DI32_Test := TKDT6DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT6DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT6DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT6DI32_AxisCount - 1 do
        TKDT6DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT6DI32_Test.TestBuff), length(TKDT6DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT6DI32_Test.BuildKDTreeM(False, length(TKDT6DI32_Test.TestBuff), @TKDT6DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT6DI32_Test.BuildKDTreeM(False, length(TKDT6DI32_Test.TestBuff), TKDT6DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT6DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT6DI32_Test.TestBuff));
  TKDT6DI32_Test.Search(TKDT6DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT6DI32Distance(TKDT6DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT6DI32_Test.Clear;
  { kMean test }
  TKDT6DI32_Test.BuildKDTreeWithCluster(TKDT6DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT6DI32_Test.Search(TKDT6DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT6DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT6DI32_Test);
end;

{$ENDIF DEBUG}


function KDT7DI32Vec(const s: string): TKDT7DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT7DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT7DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT7DI32Vec(const v: TKDT7DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT7DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT7DI32Pow(const v: TKDT7DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT7DI32Distance(const v1, v2: TKDT7DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT7DI32_AxisCount - 1 do
      Result := Result + KDT7DI32Pow(v2[i] - v1[i]);
end;

function KDT7DI32Cmpare(const v1, v2: TKDT7DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT7DI32_Vec));
end;

function TKDT7DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DI32_Node;
  function SortCompare(const p1, p2: PKDT7DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT7DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT7DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT7DI32_SourceBuffer;
  dynBuff  : PKDT7DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT7DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT7DI32.SearchStoreBuff(const StoreBuffPtr: PKDT7DI32yanmicStoreBuffer; const Buff: TKDT7DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT7DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT7DI32.GetData(const index: NativeInt): PKDT7DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT7DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT7DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT7DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT7DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT7DI32.StoreBuffPtr: PKDT7DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT7DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT7DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT7DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT7DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT7DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT7DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT7DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT7DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT7DI32.BuildKDTreeWithCluster(const inBuff: TKDT7DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT7DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT7DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT7DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT7DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT7DI32.BuildKDTreeWithCluster(const inBuff: TKDT7DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI32_BuildCall);
var
  TempStoreBuff: TKDT7DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT7DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT7DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT7DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT7DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI32_BuildMethod);
var
  TempStoreBuff: TKDT7DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT7DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT7DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT7DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT7DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI32_BuildProc);
var
  TempStoreBuff: TKDT7DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT7DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT7DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT7DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT7DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT7DI32.Search(const Buff: TKDT7DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DI32_Node;

var
  NearestNeighbour: PKDT7DI32_Node;

  function FindParentNode(const BuffPtr: PKDT7DI32_Vec; NodePtr: PKDT7DI32_Node): PKDT7DI32_Node;
  var
    Next       : PKDT7DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT7DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT7DI32_Node; const BuffPtr: PKDT7DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT7DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT7DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT7DI32_Vec; const p1, p2: PKDT7DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT7DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT7DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT7DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT7DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT7DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT7DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT7DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT7DI32.Search(const Buff: TKDT7DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT7DI32.Search(const Buff: TKDT7DI32_Vec; var SearchedDistanceMin: Double): PKDT7DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT7DI32.Search(const Buff: TKDT7DI32_Vec): PKDT7DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT7DI32.Search(const inBuff: TKDT7DI32_DynamicVecBuffer; var OutBuff: TKDT7DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT7DI32_DynamicVecBuffer;
  outBuffPtr : PKDT7DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT7DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT7DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT7DI32_Source));
end;

procedure TKDT7DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT7DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT7DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT7DI32.PrintNodeTree(const NodePtr: PKDT7DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT7DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT7DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT7DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT7DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT7DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT7DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT7DI32.Test;
var
  TKDT7DI32_Test    : TKDT7DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT7DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT7DI32_Test := TKDT7DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT7DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT7DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT7DI32_AxisCount - 1 do
        TKDT7DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT7DI32_Test.TestBuff), length(TKDT7DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT7DI32_Test.BuildKDTreeM(False, length(TKDT7DI32_Test.TestBuff), @TKDT7DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT7DI32_Test.BuildKDTreeM(False, length(TKDT7DI32_Test.TestBuff), TKDT7DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT7DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT7DI32_Test.TestBuff));
  TKDT7DI32_Test.Search(TKDT7DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT7DI32Distance(TKDT7DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT7DI32_Test.Clear;
  { kMean test }
  TKDT7DI32_Test.BuildKDTreeWithCluster(TKDT7DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT7DI32_Test.Search(TKDT7DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT7DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT7DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT7DI32_Test);
end;

{$ENDIF DEBUG}


function KDT8DI32Vec(const s: string): TKDT8DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT8DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT8DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT8DI32Vec(const v: TKDT8DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT8DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT8DI32Pow(const v: TKDT8DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT8DI32Distance(const v1, v2: TKDT8DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT8DI32_AxisCount - 1 do
      Result := Result + KDT8DI32Pow(v2[i] - v1[i]);
end;

function KDT8DI32Cmpare(const v1, v2: TKDT8DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT8DI32_Vec));
end;

function TKDT8DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DI32_Node;
  function SortCompare(const p1, p2: PKDT8DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8DI32_SourceBuffer;
  dynBuff  : PKDT8DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT8DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DI32.SearchStoreBuff(const StoreBuffPtr: PKDT8DI32yanmicStoreBuffer; const Buff: TKDT8DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT8DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT8DI32.GetData(const index: NativeInt): PKDT8DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DI32.StoreBuffPtr: PKDT8DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8DI32.BuildKDTreeWithCluster(const inBuff: TKDT8DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT8DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT8DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT8DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DI32.BuildKDTreeWithCluster(const inBuff: TKDT8DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI32_BuildCall);
var
  TempStoreBuff: TKDT8DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI32_BuildMethod);
var
  TempStoreBuff: TKDT8DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI32_BuildProc);
var
  TempStoreBuff: TKDT8DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT8DI32.Search(const Buff: TKDT8DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DI32_Node;

var
  NearestNeighbour: PKDT8DI32_Node;

  function FindParentNode(const BuffPtr: PKDT8DI32_Vec; NodePtr: PKDT8DI32_Node): PKDT8DI32_Node;
  var
    Next       : PKDT8DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT8DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DI32_Node; const BuffPtr: PKDT8DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT8DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8DI32_Vec; const p1, p2: PKDT8DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT8DI32.Search(const Buff: TKDT8DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DI32.Search(const Buff: TKDT8DI32_Vec; var SearchedDistanceMin: Double): PKDT8DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DI32.Search(const Buff: TKDT8DI32_Vec): PKDT8DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8DI32.Search(const inBuff: TKDT8DI32_DynamicVecBuffer; var OutBuff: TKDT8DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DI32_DynamicVecBuffer;
  outBuffPtr : PKDT8DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8DI32_Source));
end;

procedure TKDT8DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT8DI32.PrintNodeTree(const NodePtr: PKDT8DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT8DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT8DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8DI32.Test;
var
  TKDT8DI32_Test    : TKDT8DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8DI32_Test := TKDT8DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT8DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT8DI32_AxisCount - 1 do
        TKDT8DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT8DI32_Test.TestBuff), length(TKDT8DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8DI32_Test.BuildKDTreeM(False, length(TKDT8DI32_Test.TestBuff), @TKDT8DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8DI32_Test.BuildKDTreeM(False, length(TKDT8DI32_Test.TestBuff), TKDT8DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8DI32_Test.TestBuff));
  TKDT8DI32_Test.Search(TKDT8DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8DI32Distance(TKDT8DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8DI32_Test.Clear;
  { kMean test }
  TKDT8DI32_Test.BuildKDTreeWithCluster(TKDT8DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8DI32_Test.Search(TKDT8DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8DI32_Test);
end;

{$ENDIF DEBUG}


function KDT9DI32Vec(const s: string): TKDT9DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT9DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT9DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT9DI32Vec(const v: TKDT9DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT9DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT9DI32Pow(const v: TKDT9DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT9DI32Distance(const v1, v2: TKDT9DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT9DI32_AxisCount - 1 do
      Result := Result + KDT9DI32Pow(v2[i] - v1[i]);
end;

function KDT9DI32Cmpare(const v1, v2: TKDT9DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT9DI32_Vec));
end;

function TKDT9DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DI32_Node;
  function SortCompare(const p1, p2: PKDT9DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT9DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT9DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT9DI32_SourceBuffer;
  dynBuff  : PKDT9DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT9DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT9DI32.SearchStoreBuff(const StoreBuffPtr: PKDT9DI32yanmicStoreBuffer; const Buff: TKDT9DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT9DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT9DI32.GetData(const index: NativeInt): PKDT9DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT9DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT9DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT9DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT9DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT9DI32.StoreBuffPtr: PKDT9DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT9DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT9DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT9DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT9DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT9DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT9DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT9DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT9DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT9DI32.BuildKDTreeWithCluster(const inBuff: TKDT9DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT9DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT9DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT9DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT9DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT9DI32.BuildKDTreeWithCluster(const inBuff: TKDT9DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI32_BuildCall);
var
  TempStoreBuff: TKDT9DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT9DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT9DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT9DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT9DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI32_BuildMethod);
var
  TempStoreBuff: TKDT9DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT9DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT9DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT9DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT9DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI32_BuildProc);
var
  TempStoreBuff: TKDT9DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT9DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT9DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT9DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT9DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT9DI32.Search(const Buff: TKDT9DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DI32_Node;

var
  NearestNeighbour: PKDT9DI32_Node;

  function FindParentNode(const BuffPtr: PKDT9DI32_Vec; NodePtr: PKDT9DI32_Node): PKDT9DI32_Node;
  var
    Next       : PKDT9DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT9DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT9DI32_Node; const BuffPtr: PKDT9DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT9DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT9DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT9DI32_Vec; const p1, p2: PKDT9DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT9DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT9DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT9DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT9DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT9DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT9DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT9DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT9DI32.Search(const Buff: TKDT9DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT9DI32.Search(const Buff: TKDT9DI32_Vec; var SearchedDistanceMin: Double): PKDT9DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT9DI32.Search(const Buff: TKDT9DI32_Vec): PKDT9DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT9DI32.Search(const inBuff: TKDT9DI32_DynamicVecBuffer; var OutBuff: TKDT9DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT9DI32_DynamicVecBuffer;
  outBuffPtr : PKDT9DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT9DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT9DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT9DI32_Source));
end;

procedure TKDT9DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT9DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT9DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT9DI32.PrintNodeTree(const NodePtr: PKDT9DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT9DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT9DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT9DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT9DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT9DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT9DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT9DI32.Test;
var
  TKDT9DI32_Test    : TKDT9DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT9DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT9DI32_Test := TKDT9DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT9DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT9DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT9DI32_AxisCount - 1 do
        TKDT9DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT9DI32_Test.TestBuff), length(TKDT9DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT9DI32_Test.BuildKDTreeM(False, length(TKDT9DI32_Test.TestBuff), @TKDT9DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT9DI32_Test.BuildKDTreeM(False, length(TKDT9DI32_Test.TestBuff), TKDT9DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT9DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT9DI32_Test.TestBuff));
  TKDT9DI32_Test.Search(TKDT9DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT9DI32Distance(TKDT9DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT9DI32_Test.Clear;
  { kMean test }
  TKDT9DI32_Test.BuildKDTreeWithCluster(TKDT9DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT9DI32_Test.Search(TKDT9DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT9DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT9DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT9DI32_Test);
end;

{$ENDIF DEBUG}


function KDT10DI32Vec(const s: string): TKDT10DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT10DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT10DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT10DI32Vec(const v: TKDT10DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT10DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT10DI32Pow(const v: TKDT10DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT10DI32Distance(const v1, v2: TKDT10DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT10DI32_AxisCount - 1 do
      Result := Result + KDT10DI32Pow(v2[i] - v1[i]);
end;

function KDT10DI32Cmpare(const v1, v2: TKDT10DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT10DI32_Vec));
end;

function TKDT10DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DI32_Node;
  function SortCompare(const p1, p2: PKDT10DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT10DI32_SourceBuffer;
  dynBuff  : PKDT10DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT10DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DI32.SearchStoreBuff(const StoreBuffPtr: PKDT10DI32yanmicStoreBuffer; const Buff: TKDT10DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT10DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT10DI32.GetData(const index: NativeInt): PKDT10DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT10DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DI32.StoreBuffPtr: PKDT10DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT10DI32.BuildKDTreeWithCluster(const inBuff: TKDT10DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT10DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT10DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT10DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DI32.BuildKDTreeWithCluster(const inBuff: TKDT10DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI32_BuildCall);
var
  TempStoreBuff: TKDT10DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI32_BuildMethod);
var
  TempStoreBuff: TKDT10DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI32_BuildProc);
var
  TempStoreBuff: TKDT10DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT10DI32.Search(const Buff: TKDT10DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DI32_Node;

var
  NearestNeighbour: PKDT10DI32_Node;

  function FindParentNode(const BuffPtr: PKDT10DI32_Vec; NodePtr: PKDT10DI32_Node): PKDT10DI32_Node;
  var
    Next       : PKDT10DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT10DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DI32_Node; const BuffPtr: PKDT10DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT10DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT10DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT10DI32_Vec; const p1, p2: PKDT10DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT10DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT10DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT10DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT10DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT10DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT10DI32.Search(const Buff: TKDT10DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DI32.Search(const Buff: TKDT10DI32_Vec; var SearchedDistanceMin: Double): PKDT10DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DI32.Search(const Buff: TKDT10DI32_Vec): PKDT10DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT10DI32.Search(const inBuff: TKDT10DI32_DynamicVecBuffer; var OutBuff: TKDT10DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DI32_DynamicVecBuffer;
  outBuffPtr : PKDT10DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT10DI32_Source));
end;

procedure TKDT10DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT10DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT10DI32.PrintNodeTree(const NodePtr: PKDT10DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT10DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT10DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT10DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT10DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT10DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT10DI32.Test;
var
  TKDT10DI32_Test    : TKDT10DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT10DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT10DI32_Test := TKDT10DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT10DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT10DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT10DI32_AxisCount - 1 do
        TKDT10DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT10DI32_Test.TestBuff), length(TKDT10DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT10DI32_Test.BuildKDTreeM(False, length(TKDT10DI32_Test.TestBuff), @TKDT10DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT10DI32_Test.BuildKDTreeM(False, length(TKDT10DI32_Test.TestBuff), TKDT10DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT10DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT10DI32_Test.TestBuff));
  TKDT10DI32_Test.Search(TKDT10DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT10DI32Distance(TKDT10DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT10DI32_Test.Clear;
  { kMean test }
  TKDT10DI32_Test.BuildKDTreeWithCluster(TKDT10DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT10DI32_Test.Search(TKDT10DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT10DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT10DI32_Test);
end;

{$ENDIF DEBUG}


function KDT11DI32Vec(const s: string): TKDT11DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT11DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT11DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT11DI32Vec(const v: TKDT11DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT11DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT11DI32Pow(const v: TKDT11DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT11DI32Distance(const v1, v2: TKDT11DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT11DI32_AxisCount - 1 do
      Result := Result + KDT11DI32Pow(v2[i] - v1[i]);
end;

function KDT11DI32Cmpare(const v1, v2: TKDT11DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT11DI32_Vec));
end;

function TKDT11DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DI32_Node;
  function SortCompare(const p1, p2: PKDT11DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT11DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT11DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT11DI32_SourceBuffer;
  dynBuff  : PKDT11DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT11DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT11DI32.SearchStoreBuff(const StoreBuffPtr: PKDT11DI32yanmicStoreBuffer; const Buff: TKDT11DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT11DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT11DI32.GetData(const index: NativeInt): PKDT11DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT11DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT11DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT11DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT11DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT11DI32.StoreBuffPtr: PKDT11DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT11DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT11DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT11DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT11DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT11DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT11DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT11DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT11DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT11DI32.BuildKDTreeWithCluster(const inBuff: TKDT11DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT11DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT11DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT11DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT11DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT11DI32.BuildKDTreeWithCluster(const inBuff: TKDT11DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI32_BuildCall);
var
  TempStoreBuff: TKDT11DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT11DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT11DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT11DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT11DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI32_BuildMethod);
var
  TempStoreBuff: TKDT11DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT11DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT11DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT11DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT11DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI32_BuildProc);
var
  TempStoreBuff: TKDT11DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT11DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT11DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT11DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT11DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT11DI32.Search(const Buff: TKDT11DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DI32_Node;

var
  NearestNeighbour: PKDT11DI32_Node;

  function FindParentNode(const BuffPtr: PKDT11DI32_Vec; NodePtr: PKDT11DI32_Node): PKDT11DI32_Node;
  var
    Next       : PKDT11DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT11DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT11DI32_Node; const BuffPtr: PKDT11DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT11DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT11DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT11DI32_Vec; const p1, p2: PKDT11DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT11DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT11DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT11DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT11DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT11DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT11DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT11DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT11DI32.Search(const Buff: TKDT11DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT11DI32.Search(const Buff: TKDT11DI32_Vec; var SearchedDistanceMin: Double): PKDT11DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT11DI32.Search(const Buff: TKDT11DI32_Vec): PKDT11DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT11DI32.Search(const inBuff: TKDT11DI32_DynamicVecBuffer; var OutBuff: TKDT11DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT11DI32_DynamicVecBuffer;
  outBuffPtr : PKDT11DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT11DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT11DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT11DI32_Source));
end;

procedure TKDT11DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT11DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT11DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT11DI32.PrintNodeTree(const NodePtr: PKDT11DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT11DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT11DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT11DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT11DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT11DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT11DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT11DI32.Test;
var
  TKDT11DI32_Test    : TKDT11DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT11DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT11DI32_Test := TKDT11DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT11DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT11DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT11DI32_AxisCount - 1 do
        TKDT11DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT11DI32_Test.TestBuff), length(TKDT11DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT11DI32_Test.BuildKDTreeM(False, length(TKDT11DI32_Test.TestBuff), @TKDT11DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT11DI32_Test.BuildKDTreeM(False, length(TKDT11DI32_Test.TestBuff), TKDT11DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT11DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT11DI32_Test.TestBuff));
  TKDT11DI32_Test.Search(TKDT11DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT11DI32Distance(TKDT11DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT11DI32_Test.Clear;
  { kMean test }
  TKDT11DI32_Test.BuildKDTreeWithCluster(TKDT11DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT11DI32_Test.Search(TKDT11DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT11DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT11DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT11DI32_Test);
end;

{$ENDIF DEBUG}


function KDT12DI32Vec(const s: string): TKDT12DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT12DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT12DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT12DI32Vec(const v: TKDT12DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT12DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT12DI32Pow(const v: TKDT12DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT12DI32Distance(const v1, v2: TKDT12DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT12DI32_AxisCount - 1 do
      Result := Result + KDT12DI32Pow(v2[i] - v1[i]);
end;

function KDT12DI32Cmpare(const v1, v2: TKDT12DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT12DI32_Vec));
end;

function TKDT12DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DI32_Node;
  function SortCompare(const p1, p2: PKDT12DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT12DI32_SourceBuffer;
  dynBuff  : PKDT12DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT12DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DI32.SearchStoreBuff(const StoreBuffPtr: PKDT12DI32yanmicStoreBuffer; const Buff: TKDT12DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT12DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT12DI32.GetData(const index: NativeInt): PKDT12DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT12DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DI32.StoreBuffPtr: PKDT12DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT12DI32.BuildKDTreeWithCluster(const inBuff: TKDT12DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT12DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT12DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT12DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DI32.BuildKDTreeWithCluster(const inBuff: TKDT12DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI32_BuildCall);
var
  TempStoreBuff: TKDT12DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI32_BuildMethod);
var
  TempStoreBuff: TKDT12DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI32_BuildProc);
var
  TempStoreBuff: TKDT12DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT12DI32.Search(const Buff: TKDT12DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DI32_Node;

var
  NearestNeighbour: PKDT12DI32_Node;

  function FindParentNode(const BuffPtr: PKDT12DI32_Vec; NodePtr: PKDT12DI32_Node): PKDT12DI32_Node;
  var
    Next       : PKDT12DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT12DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DI32_Node; const BuffPtr: PKDT12DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT12DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT12DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT12DI32_Vec; const p1, p2: PKDT12DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT12DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT12DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT12DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT12DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT12DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT12DI32.Search(const Buff: TKDT12DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DI32.Search(const Buff: TKDT12DI32_Vec; var SearchedDistanceMin: Double): PKDT12DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DI32.Search(const Buff: TKDT12DI32_Vec): PKDT12DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT12DI32.Search(const inBuff: TKDT12DI32_DynamicVecBuffer; var OutBuff: TKDT12DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DI32_DynamicVecBuffer;
  outBuffPtr : PKDT12DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT12DI32_Source));
end;

procedure TKDT12DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT12DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT12DI32.PrintNodeTree(const NodePtr: PKDT12DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT12DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT12DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT12DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT12DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT12DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT12DI32.Test;
var
  TKDT12DI32_Test    : TKDT12DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT12DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT12DI32_Test := TKDT12DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT12DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT12DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT12DI32_AxisCount - 1 do
        TKDT12DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT12DI32_Test.TestBuff), length(TKDT12DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT12DI32_Test.BuildKDTreeM(False, length(TKDT12DI32_Test.TestBuff), @TKDT12DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT12DI32_Test.BuildKDTreeM(False, length(TKDT12DI32_Test.TestBuff), TKDT12DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT12DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT12DI32_Test.TestBuff));
  TKDT12DI32_Test.Search(TKDT12DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT12DI32Distance(TKDT12DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT12DI32_Test.Clear;
  { kMean test }
  TKDT12DI32_Test.BuildKDTreeWithCluster(TKDT12DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT12DI32_Test.Search(TKDT12DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT12DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT12DI32_Test);
end;

{$ENDIF DEBUG}


function KDT13DI32Vec(const s: string): TKDT13DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT13DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT13DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT13DI32Vec(const v: TKDT13DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT13DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT13DI32Pow(const v: TKDT13DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT13DI32Distance(const v1, v2: TKDT13DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT13DI32_AxisCount - 1 do
      Result := Result + KDT13DI32Pow(v2[i] - v1[i]);
end;

function KDT13DI32Cmpare(const v1, v2: TKDT13DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT13DI32_Vec));
end;

function TKDT13DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DI32_Node;
  function SortCompare(const p1, p2: PKDT13DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT13DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT13DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT13DI32_SourceBuffer;
  dynBuff  : PKDT13DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT13DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT13DI32.SearchStoreBuff(const StoreBuffPtr: PKDT13DI32yanmicStoreBuffer; const Buff: TKDT13DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT13DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT13DI32.GetData(const index: NativeInt): PKDT13DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT13DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT13DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT13DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT13DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT13DI32.StoreBuffPtr: PKDT13DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT13DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT13DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT13DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT13DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT13DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT13DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT13DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT13DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT13DI32.BuildKDTreeWithCluster(const inBuff: TKDT13DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT13DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT13DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT13DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT13DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT13DI32.BuildKDTreeWithCluster(const inBuff: TKDT13DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI32_BuildCall);
var
  TempStoreBuff: TKDT13DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT13DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT13DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT13DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT13DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI32_BuildMethod);
var
  TempStoreBuff: TKDT13DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT13DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT13DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT13DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT13DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI32_BuildProc);
var
  TempStoreBuff: TKDT13DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT13DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT13DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT13DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT13DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT13DI32.Search(const Buff: TKDT13DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DI32_Node;

var
  NearestNeighbour: PKDT13DI32_Node;

  function FindParentNode(const BuffPtr: PKDT13DI32_Vec; NodePtr: PKDT13DI32_Node): PKDT13DI32_Node;
  var
    Next       : PKDT13DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT13DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT13DI32_Node; const BuffPtr: PKDT13DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT13DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT13DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT13DI32_Vec; const p1, p2: PKDT13DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT13DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT13DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT13DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT13DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT13DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT13DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT13DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT13DI32.Search(const Buff: TKDT13DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT13DI32.Search(const Buff: TKDT13DI32_Vec; var SearchedDistanceMin: Double): PKDT13DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT13DI32.Search(const Buff: TKDT13DI32_Vec): PKDT13DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT13DI32.Search(const inBuff: TKDT13DI32_DynamicVecBuffer; var OutBuff: TKDT13DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT13DI32_DynamicVecBuffer;
  outBuffPtr : PKDT13DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT13DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT13DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT13DI32_Source));
end;

procedure TKDT13DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT13DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT13DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT13DI32.PrintNodeTree(const NodePtr: PKDT13DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT13DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT13DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT13DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT13DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT13DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT13DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT13DI32.Test;
var
  TKDT13DI32_Test    : TKDT13DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT13DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT13DI32_Test := TKDT13DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT13DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT13DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT13DI32_AxisCount - 1 do
        TKDT13DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT13DI32_Test.TestBuff), length(TKDT13DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT13DI32_Test.BuildKDTreeM(False, length(TKDT13DI32_Test.TestBuff), @TKDT13DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT13DI32_Test.BuildKDTreeM(False, length(TKDT13DI32_Test.TestBuff), TKDT13DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT13DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT13DI32_Test.TestBuff));
  TKDT13DI32_Test.Search(TKDT13DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT13DI32Distance(TKDT13DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT13DI32_Test.Clear;
  { kMean test }
  TKDT13DI32_Test.BuildKDTreeWithCluster(TKDT13DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT13DI32_Test.Search(TKDT13DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT13DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT13DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT13DI32_Test);
end;

{$ENDIF DEBUG}


function KDT14DI32Vec(const s: string): TKDT14DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT14DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT14DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT14DI32Vec(const v: TKDT14DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT14DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT14DI32Pow(const v: TKDT14DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT14DI32Distance(const v1, v2: TKDT14DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT14DI32_AxisCount - 1 do
      Result := Result + KDT14DI32Pow(v2[i] - v1[i]);
end;

function KDT14DI32Cmpare(const v1, v2: TKDT14DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT14DI32_Vec));
end;

function TKDT14DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DI32_Node;
  function SortCompare(const p1, p2: PKDT14DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT14DI32_SourceBuffer;
  dynBuff  : PKDT14DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT14DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DI32.SearchStoreBuff(const StoreBuffPtr: PKDT14DI32yanmicStoreBuffer; const Buff: TKDT14DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT14DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT14DI32.GetData(const index: NativeInt): PKDT14DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT14DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DI32.StoreBuffPtr: PKDT14DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT14DI32.BuildKDTreeWithCluster(const inBuff: TKDT14DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT14DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT14DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT14DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DI32.BuildKDTreeWithCluster(const inBuff: TKDT14DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI32_BuildCall);
var
  TempStoreBuff: TKDT14DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI32_BuildMethod);
var
  TempStoreBuff: TKDT14DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI32_BuildProc);
var
  TempStoreBuff: TKDT14DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT14DI32.Search(const Buff: TKDT14DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DI32_Node;

var
  NearestNeighbour: PKDT14DI32_Node;

  function FindParentNode(const BuffPtr: PKDT14DI32_Vec; NodePtr: PKDT14DI32_Node): PKDT14DI32_Node;
  var
    Next       : PKDT14DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT14DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DI32_Node; const BuffPtr: PKDT14DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT14DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT14DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT14DI32_Vec; const p1, p2: PKDT14DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT14DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT14DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT14DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT14DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT14DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT14DI32.Search(const Buff: TKDT14DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DI32.Search(const Buff: TKDT14DI32_Vec; var SearchedDistanceMin: Double): PKDT14DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DI32.Search(const Buff: TKDT14DI32_Vec): PKDT14DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT14DI32.Search(const inBuff: TKDT14DI32_DynamicVecBuffer; var OutBuff: TKDT14DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DI32_DynamicVecBuffer;
  outBuffPtr : PKDT14DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT14DI32_Source));
end;

procedure TKDT14DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT14DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT14DI32.PrintNodeTree(const NodePtr: PKDT14DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT14DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT14DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT14DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT14DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT14DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT14DI32.Test;
var
  TKDT14DI32_Test    : TKDT14DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT14DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT14DI32_Test := TKDT14DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT14DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT14DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT14DI32_AxisCount - 1 do
        TKDT14DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT14DI32_Test.TestBuff), length(TKDT14DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT14DI32_Test.BuildKDTreeM(False, length(TKDT14DI32_Test.TestBuff), @TKDT14DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT14DI32_Test.BuildKDTreeM(False, length(TKDT14DI32_Test.TestBuff), TKDT14DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT14DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT14DI32_Test.TestBuff));
  TKDT14DI32_Test.Search(TKDT14DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT14DI32Distance(TKDT14DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT14DI32_Test.Clear;
  { kMean test }
  TKDT14DI32_Test.BuildKDTreeWithCluster(TKDT14DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT14DI32_Test.Search(TKDT14DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT14DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT14DI32_Test);
end;

{$ENDIF DEBUG}


function KDT15DI32Vec(const s: string): TKDT15DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT15DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT15DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT15DI32Vec(const v: TKDT15DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT15DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT15DI32Pow(const v: TKDT15DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT15DI32Distance(const v1, v2: TKDT15DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT15DI32_AxisCount - 1 do
      Result := Result + KDT15DI32Pow(v2[i] - v1[i]);
end;

function KDT15DI32Cmpare(const v1, v2: TKDT15DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT15DI32_Vec));
end;

function TKDT15DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DI32_Node;
  function SortCompare(const p1, p2: PKDT15DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT15DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT15DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT15DI32_SourceBuffer;
  dynBuff  : PKDT15DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT15DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT15DI32.SearchStoreBuff(const StoreBuffPtr: PKDT15DI32yanmicStoreBuffer; const Buff: TKDT15DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT15DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT15DI32.GetData(const index: NativeInt): PKDT15DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT15DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT15DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT15DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT15DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT15DI32.StoreBuffPtr: PKDT15DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT15DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT15DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT15DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT15DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT15DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT15DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT15DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT15DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT15DI32.BuildKDTreeWithCluster(const inBuff: TKDT15DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT15DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT15DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT15DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT15DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT15DI32.BuildKDTreeWithCluster(const inBuff: TKDT15DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI32_BuildCall);
var
  TempStoreBuff: TKDT15DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT15DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT15DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT15DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT15DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI32_BuildMethod);
var
  TempStoreBuff: TKDT15DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT15DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT15DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT15DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT15DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI32_BuildProc);
var
  TempStoreBuff: TKDT15DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT15DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT15DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT15DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT15DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT15DI32.Search(const Buff: TKDT15DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DI32_Node;

var
  NearestNeighbour: PKDT15DI32_Node;

  function FindParentNode(const BuffPtr: PKDT15DI32_Vec; NodePtr: PKDT15DI32_Node): PKDT15DI32_Node;
  var
    Next       : PKDT15DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT15DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT15DI32_Node; const BuffPtr: PKDT15DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT15DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT15DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT15DI32_Vec; const p1, p2: PKDT15DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT15DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT15DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT15DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT15DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT15DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT15DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT15DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT15DI32.Search(const Buff: TKDT15DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT15DI32.Search(const Buff: TKDT15DI32_Vec; var SearchedDistanceMin: Double): PKDT15DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT15DI32.Search(const Buff: TKDT15DI32_Vec): PKDT15DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT15DI32.Search(const inBuff: TKDT15DI32_DynamicVecBuffer; var OutBuff: TKDT15DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT15DI32_DynamicVecBuffer;
  outBuffPtr : PKDT15DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT15DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT15DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT15DI32_Source));
end;

procedure TKDT15DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT15DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT15DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT15DI32.PrintNodeTree(const NodePtr: PKDT15DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT15DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT15DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT15DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT15DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT15DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT15DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT15DI32.Test;
var
  TKDT15DI32_Test    : TKDT15DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT15DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT15DI32_Test := TKDT15DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT15DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT15DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT15DI32_AxisCount - 1 do
        TKDT15DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT15DI32_Test.TestBuff), length(TKDT15DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT15DI32_Test.BuildKDTreeM(False, length(TKDT15DI32_Test.TestBuff), @TKDT15DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT15DI32_Test.BuildKDTreeM(False, length(TKDT15DI32_Test.TestBuff), TKDT15DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT15DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT15DI32_Test.TestBuff));
  TKDT15DI32_Test.Search(TKDT15DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT15DI32Distance(TKDT15DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT15DI32_Test.Clear;
  { kMean test }
  TKDT15DI32_Test.BuildKDTreeWithCluster(TKDT15DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT15DI32_Test.Search(TKDT15DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT15DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT15DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT15DI32_Test);
end;

{$ENDIF DEBUG}


function KDT16DI32Vec(const s: string): TKDT16DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT16DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT16DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT16DI32Vec(const v: TKDT16DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT16DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT16DI32Pow(const v: TKDT16DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT16DI32Distance(const v1, v2: TKDT16DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT16DI32_AxisCount - 1 do
      Result := Result + KDT16DI32Pow(v2[i] - v1[i]);
end;

function KDT16DI32Cmpare(const v1, v2: TKDT16DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT16DI32_Vec));
end;

function TKDT16DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DI32_Node;
  function SortCompare(const p1, p2: PKDT16DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT16DI32_SourceBuffer;
  dynBuff  : PKDT16DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT16DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DI32.SearchStoreBuff(const StoreBuffPtr: PKDT16DI32yanmicStoreBuffer; const Buff: TKDT16DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT16DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT16DI32.GetData(const index: NativeInt): PKDT16DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT16DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DI32.StoreBuffPtr: PKDT16DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT16DI32.BuildKDTreeWithCluster(const inBuff: TKDT16DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT16DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT16DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT16DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DI32.BuildKDTreeWithCluster(const inBuff: TKDT16DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI32_BuildCall);
var
  TempStoreBuff: TKDT16DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI32_BuildMethod);
var
  TempStoreBuff: TKDT16DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI32_BuildProc);
var
  TempStoreBuff: TKDT16DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT16DI32.Search(const Buff: TKDT16DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DI32_Node;

var
  NearestNeighbour: PKDT16DI32_Node;

  function FindParentNode(const BuffPtr: PKDT16DI32_Vec; NodePtr: PKDT16DI32_Node): PKDT16DI32_Node;
  var
    Next       : PKDT16DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT16DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DI32_Node; const BuffPtr: PKDT16DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT16DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT16DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT16DI32_Vec; const p1, p2: PKDT16DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT16DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT16DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT16DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT16DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT16DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT16DI32.Search(const Buff: TKDT16DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DI32.Search(const Buff: TKDT16DI32_Vec; var SearchedDistanceMin: Double): PKDT16DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DI32.Search(const Buff: TKDT16DI32_Vec): PKDT16DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT16DI32.Search(const inBuff: TKDT16DI32_DynamicVecBuffer; var OutBuff: TKDT16DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DI32_DynamicVecBuffer;
  outBuffPtr : PKDT16DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT16DI32_Source));
end;

procedure TKDT16DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT16DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT16DI32.PrintNodeTree(const NodePtr: PKDT16DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT16DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT16DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT16DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT16DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT16DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT16DI32.Test;
var
  TKDT16DI32_Test    : TKDT16DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT16DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT16DI32_Test := TKDT16DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT16DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT16DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT16DI32_AxisCount - 1 do
        TKDT16DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT16DI32_Test.TestBuff), length(TKDT16DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT16DI32_Test.BuildKDTreeM(False, length(TKDT16DI32_Test.TestBuff), @TKDT16DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT16DI32_Test.BuildKDTreeM(False, length(TKDT16DI32_Test.TestBuff), TKDT16DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT16DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT16DI32_Test.TestBuff));
  TKDT16DI32_Test.Search(TKDT16DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT16DI32Distance(TKDT16DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT16DI32_Test.Clear;
  { kMean test }
  TKDT16DI32_Test.BuildKDTreeWithCluster(TKDT16DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT16DI32_Test.Search(TKDT16DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT16DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT16DI32_Test);
end;

{$ENDIF DEBUG}


function KDT17DI32Vec(const s: string): TKDT17DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT17DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT17DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT17DI32Vec(const v: TKDT17DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT17DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT17DI32Pow(const v: TKDT17DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT17DI32Distance(const v1, v2: TKDT17DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT17DI32_AxisCount - 1 do
      Result := Result + KDT17DI32Pow(v2[i] - v1[i]);
end;

function KDT17DI32Cmpare(const v1, v2: TKDT17DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT17DI32_Vec));
end;

function TKDT17DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DI32_Node;
  function SortCompare(const p1, p2: PKDT17DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT17DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT17DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT17DI32_SourceBuffer;
  dynBuff  : PKDT17DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT17DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT17DI32.SearchStoreBuff(const StoreBuffPtr: PKDT17DI32yanmicStoreBuffer; const Buff: TKDT17DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT17DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT17DI32.GetData(const index: NativeInt): PKDT17DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT17DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT17DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT17DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT17DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT17DI32.StoreBuffPtr: PKDT17DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT17DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT17DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT17DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT17DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT17DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT17DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT17DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT17DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT17DI32.BuildKDTreeWithCluster(const inBuff: TKDT17DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT17DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT17DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT17DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT17DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT17DI32.BuildKDTreeWithCluster(const inBuff: TKDT17DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI32_BuildCall);
var
  TempStoreBuff: TKDT17DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT17DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT17DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT17DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT17DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI32_BuildMethod);
var
  TempStoreBuff: TKDT17DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT17DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT17DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT17DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT17DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI32_BuildProc);
var
  TempStoreBuff: TKDT17DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT17DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT17DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT17DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT17DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT17DI32.Search(const Buff: TKDT17DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DI32_Node;

var
  NearestNeighbour: PKDT17DI32_Node;

  function FindParentNode(const BuffPtr: PKDT17DI32_Vec; NodePtr: PKDT17DI32_Node): PKDT17DI32_Node;
  var
    Next       : PKDT17DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT17DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT17DI32_Node; const BuffPtr: PKDT17DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT17DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT17DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT17DI32_Vec; const p1, p2: PKDT17DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT17DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT17DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT17DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT17DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT17DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT17DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT17DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT17DI32.Search(const Buff: TKDT17DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT17DI32.Search(const Buff: TKDT17DI32_Vec; var SearchedDistanceMin: Double): PKDT17DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT17DI32.Search(const Buff: TKDT17DI32_Vec): PKDT17DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT17DI32.Search(const inBuff: TKDT17DI32_DynamicVecBuffer; var OutBuff: TKDT17DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT17DI32_DynamicVecBuffer;
  outBuffPtr : PKDT17DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT17DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT17DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT17DI32_Source));
end;

procedure TKDT17DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT17DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT17DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT17DI32.PrintNodeTree(const NodePtr: PKDT17DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT17DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT17DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT17DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT17DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT17DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT17DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT17DI32.Test;
var
  TKDT17DI32_Test    : TKDT17DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT17DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT17DI32_Test := TKDT17DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT17DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT17DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT17DI32_AxisCount - 1 do
        TKDT17DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT17DI32_Test.TestBuff), length(TKDT17DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT17DI32_Test.BuildKDTreeM(False, length(TKDT17DI32_Test.TestBuff), @TKDT17DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT17DI32_Test.BuildKDTreeM(False, length(TKDT17DI32_Test.TestBuff), TKDT17DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT17DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT17DI32_Test.TestBuff));
  TKDT17DI32_Test.Search(TKDT17DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT17DI32Distance(TKDT17DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT17DI32_Test.Clear;
  { kMean test }
  TKDT17DI32_Test.BuildKDTreeWithCluster(TKDT17DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT17DI32_Test.Search(TKDT17DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT17DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT17DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT17DI32_Test);
end;

{$ENDIF DEBUG}


function KDT18DI32Vec(const s: string): TKDT18DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT18DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT18DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT18DI32Vec(const v: TKDT18DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT18DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT18DI32Pow(const v: TKDT18DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT18DI32Distance(const v1, v2: TKDT18DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT18DI32_AxisCount - 1 do
      Result := Result + KDT18DI32Pow(v2[i] - v1[i]);
end;

function KDT18DI32Cmpare(const v1, v2: TKDT18DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT18DI32_Vec));
end;

function TKDT18DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DI32_Node;
  function SortCompare(const p1, p2: PKDT18DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT18DI32_SourceBuffer;
  dynBuff  : PKDT18DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT18DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DI32.SearchStoreBuff(const StoreBuffPtr: PKDT18DI32yanmicStoreBuffer; const Buff: TKDT18DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT18DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT18DI32.GetData(const index: NativeInt): PKDT18DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT18DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DI32.StoreBuffPtr: PKDT18DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT18DI32.BuildKDTreeWithCluster(const inBuff: TKDT18DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT18DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT18DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT18DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DI32.BuildKDTreeWithCluster(const inBuff: TKDT18DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI32_BuildCall);
var
  TempStoreBuff: TKDT18DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI32_BuildMethod);
var
  TempStoreBuff: TKDT18DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI32_BuildProc);
var
  TempStoreBuff: TKDT18DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT18DI32.Search(const Buff: TKDT18DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DI32_Node;

var
  NearestNeighbour: PKDT18DI32_Node;

  function FindParentNode(const BuffPtr: PKDT18DI32_Vec; NodePtr: PKDT18DI32_Node): PKDT18DI32_Node;
  var
    Next       : PKDT18DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT18DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DI32_Node; const BuffPtr: PKDT18DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT18DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT18DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT18DI32_Vec; const p1, p2: PKDT18DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT18DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT18DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT18DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT18DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT18DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT18DI32.Search(const Buff: TKDT18DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DI32.Search(const Buff: TKDT18DI32_Vec; var SearchedDistanceMin: Double): PKDT18DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DI32.Search(const Buff: TKDT18DI32_Vec): PKDT18DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT18DI32.Search(const inBuff: TKDT18DI32_DynamicVecBuffer; var OutBuff: TKDT18DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DI32_DynamicVecBuffer;
  outBuffPtr : PKDT18DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT18DI32_Source));
end;

procedure TKDT18DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT18DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT18DI32.PrintNodeTree(const NodePtr: PKDT18DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT18DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT18DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT18DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT18DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT18DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT18DI32.Test;
var
  TKDT18DI32_Test    : TKDT18DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT18DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT18DI32_Test := TKDT18DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT18DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT18DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT18DI32_AxisCount - 1 do
        TKDT18DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT18DI32_Test.TestBuff), length(TKDT18DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT18DI32_Test.BuildKDTreeM(False, length(TKDT18DI32_Test.TestBuff), @TKDT18DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT18DI32_Test.BuildKDTreeM(False, length(TKDT18DI32_Test.TestBuff), TKDT18DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT18DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT18DI32_Test.TestBuff));
  TKDT18DI32_Test.Search(TKDT18DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT18DI32Distance(TKDT18DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT18DI32_Test.Clear;
  { kMean test }
  TKDT18DI32_Test.BuildKDTreeWithCluster(TKDT18DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT18DI32_Test.Search(TKDT18DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT18DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT18DI32_Test);
end;

{$ENDIF DEBUG}


function KDT19DI32Vec(const s: string): TKDT19DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT19DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT19DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT19DI32Vec(const v: TKDT19DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT19DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT19DI32Pow(const v: TKDT19DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT19DI32Distance(const v1, v2: TKDT19DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT19DI32_AxisCount - 1 do
      Result := Result + KDT19DI32Pow(v2[i] - v1[i]);
end;

function KDT19DI32Cmpare(const v1, v2: TKDT19DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT19DI32_Vec));
end;

function TKDT19DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DI32_Node;
  function SortCompare(const p1, p2: PKDT19DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT19DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT19DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT19DI32_SourceBuffer;
  dynBuff  : PKDT19DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT19DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT19DI32.SearchStoreBuff(const StoreBuffPtr: PKDT19DI32yanmicStoreBuffer; const Buff: TKDT19DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT19DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT19DI32.GetData(const index: NativeInt): PKDT19DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT19DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT19DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT19DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT19DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT19DI32.StoreBuffPtr: PKDT19DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT19DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT19DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT19DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT19DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT19DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT19DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT19DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT19DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT19DI32.BuildKDTreeWithCluster(const inBuff: TKDT19DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT19DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT19DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT19DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT19DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT19DI32.BuildKDTreeWithCluster(const inBuff: TKDT19DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI32_BuildCall);
var
  TempStoreBuff: TKDT19DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT19DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT19DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT19DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT19DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI32_BuildMethod);
var
  TempStoreBuff: TKDT19DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT19DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT19DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT19DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT19DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI32_BuildProc);
var
  TempStoreBuff: TKDT19DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT19DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT19DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT19DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT19DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT19DI32.Search(const Buff: TKDT19DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DI32_Node;

var
  NearestNeighbour: PKDT19DI32_Node;

  function FindParentNode(const BuffPtr: PKDT19DI32_Vec; NodePtr: PKDT19DI32_Node): PKDT19DI32_Node;
  var
    Next       : PKDT19DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT19DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT19DI32_Node; const BuffPtr: PKDT19DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT19DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT19DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT19DI32_Vec; const p1, p2: PKDT19DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT19DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT19DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT19DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT19DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT19DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT19DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT19DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT19DI32.Search(const Buff: TKDT19DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT19DI32.Search(const Buff: TKDT19DI32_Vec; var SearchedDistanceMin: Double): PKDT19DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT19DI32.Search(const Buff: TKDT19DI32_Vec): PKDT19DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT19DI32.Search(const inBuff: TKDT19DI32_DynamicVecBuffer; var OutBuff: TKDT19DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT19DI32_DynamicVecBuffer;
  outBuffPtr : PKDT19DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT19DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT19DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT19DI32_Source));
end;

procedure TKDT19DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT19DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT19DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT19DI32.PrintNodeTree(const NodePtr: PKDT19DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT19DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT19DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT19DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT19DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT19DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT19DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT19DI32.Test;
var
  TKDT19DI32_Test    : TKDT19DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT19DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT19DI32_Test := TKDT19DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT19DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT19DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT19DI32_AxisCount - 1 do
        TKDT19DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT19DI32_Test.TestBuff), length(TKDT19DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT19DI32_Test.BuildKDTreeM(False, length(TKDT19DI32_Test.TestBuff), @TKDT19DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT19DI32_Test.BuildKDTreeM(False, length(TKDT19DI32_Test.TestBuff), TKDT19DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT19DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT19DI32_Test.TestBuff));
  TKDT19DI32_Test.Search(TKDT19DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT19DI32Distance(TKDT19DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT19DI32_Test.Clear;
  { kMean test }
  TKDT19DI32_Test.BuildKDTreeWithCluster(TKDT19DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT19DI32_Test.Search(TKDT19DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT19DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT19DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT19DI32_Test);
end;

{$ENDIF DEBUG}


function KDT20DI32Vec(const s: string): TKDT20DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT20DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT20DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT20DI32Vec(const v: TKDT20DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT20DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT20DI32Pow(const v: TKDT20DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT20DI32Distance(const v1, v2: TKDT20DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT20DI32_AxisCount - 1 do
      Result := Result + KDT20DI32Pow(v2[i] - v1[i]);
end;

function KDT20DI32Cmpare(const v1, v2: TKDT20DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT20DI32_Vec));
end;

function TKDT20DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DI32_Node;
  function SortCompare(const p1, p2: PKDT20DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT20DI32_SourceBuffer;
  dynBuff  : PKDT20DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT20DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DI32.SearchStoreBuff(const StoreBuffPtr: PKDT20DI32yanmicStoreBuffer; const Buff: TKDT20DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT20DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT20DI32.GetData(const index: NativeInt): PKDT20DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT20DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DI32.StoreBuffPtr: PKDT20DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT20DI32.BuildKDTreeWithCluster(const inBuff: TKDT20DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT20DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT20DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT20DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DI32.BuildKDTreeWithCluster(const inBuff: TKDT20DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI32_BuildCall);
var
  TempStoreBuff: TKDT20DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI32_BuildMethod);
var
  TempStoreBuff: TKDT20DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI32_BuildProc);
var
  TempStoreBuff: TKDT20DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT20DI32.Search(const Buff: TKDT20DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DI32_Node;

var
  NearestNeighbour: PKDT20DI32_Node;

  function FindParentNode(const BuffPtr: PKDT20DI32_Vec; NodePtr: PKDT20DI32_Node): PKDT20DI32_Node;
  var
    Next       : PKDT20DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT20DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DI32_Node; const BuffPtr: PKDT20DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT20DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT20DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT20DI32_Vec; const p1, p2: PKDT20DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT20DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT20DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT20DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT20DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT20DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT20DI32.Search(const Buff: TKDT20DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DI32.Search(const Buff: TKDT20DI32_Vec; var SearchedDistanceMin: Double): PKDT20DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DI32.Search(const Buff: TKDT20DI32_Vec): PKDT20DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT20DI32.Search(const inBuff: TKDT20DI32_DynamicVecBuffer; var OutBuff: TKDT20DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DI32_DynamicVecBuffer;
  outBuffPtr : PKDT20DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT20DI32_Source));
end;

procedure TKDT20DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT20DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT20DI32.PrintNodeTree(const NodePtr: PKDT20DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT20DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT20DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT20DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT20DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT20DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT20DI32.Test;
var
  TKDT20DI32_Test    : TKDT20DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT20DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT20DI32_Test := TKDT20DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT20DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT20DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT20DI32_AxisCount - 1 do
        TKDT20DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT20DI32_Test.TestBuff), length(TKDT20DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT20DI32_Test.BuildKDTreeM(False, length(TKDT20DI32_Test.TestBuff), @TKDT20DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT20DI32_Test.BuildKDTreeM(False, length(TKDT20DI32_Test.TestBuff), TKDT20DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT20DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT20DI32_Test.TestBuff));
  TKDT20DI32_Test.Search(TKDT20DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT20DI32Distance(TKDT20DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT20DI32_Test.Clear;
  { kMean test }
  TKDT20DI32_Test.BuildKDTreeWithCluster(TKDT20DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT20DI32_Test.Search(TKDT20DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT20DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT20DI32_Test);
end;

{$ENDIF DEBUG}


function KDT21DI32Vec(const s: string): TKDT21DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT21DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT21DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT21DI32Vec(const v: TKDT21DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT21DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT21DI32Pow(const v: TKDT21DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT21DI32Distance(const v1, v2: TKDT21DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT21DI32_AxisCount - 1 do
      Result := Result + KDT21DI32Pow(v2[i] - v1[i]);
end;

function KDT21DI32Cmpare(const v1, v2: TKDT21DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT21DI32_Vec));
end;

function TKDT21DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DI32_Node;
  function SortCompare(const p1, p2: PKDT21DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT21DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT21DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT21DI32_SourceBuffer;
  dynBuff  : PKDT21DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT21DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT21DI32.SearchStoreBuff(const StoreBuffPtr: PKDT21DI32yanmicStoreBuffer; const Buff: TKDT21DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT21DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT21DI32.GetData(const index: NativeInt): PKDT21DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT21DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT21DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT21DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT21DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT21DI32.StoreBuffPtr: PKDT21DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT21DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT21DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT21DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT21DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT21DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT21DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT21DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT21DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT21DI32.BuildKDTreeWithCluster(const inBuff: TKDT21DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT21DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT21DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT21DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT21DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT21DI32.BuildKDTreeWithCluster(const inBuff: TKDT21DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI32_BuildCall);
var
  TempStoreBuff: TKDT21DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT21DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT21DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT21DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT21DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI32_BuildMethod);
var
  TempStoreBuff: TKDT21DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT21DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT21DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT21DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT21DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI32_BuildProc);
var
  TempStoreBuff: TKDT21DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT21DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT21DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT21DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT21DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT21DI32.Search(const Buff: TKDT21DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DI32_Node;

var
  NearestNeighbour: PKDT21DI32_Node;

  function FindParentNode(const BuffPtr: PKDT21DI32_Vec; NodePtr: PKDT21DI32_Node): PKDT21DI32_Node;
  var
    Next       : PKDT21DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT21DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT21DI32_Node; const BuffPtr: PKDT21DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT21DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT21DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT21DI32_Vec; const p1, p2: PKDT21DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT21DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT21DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT21DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT21DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT21DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT21DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT21DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT21DI32.Search(const Buff: TKDT21DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT21DI32.Search(const Buff: TKDT21DI32_Vec; var SearchedDistanceMin: Double): PKDT21DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT21DI32.Search(const Buff: TKDT21DI32_Vec): PKDT21DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT21DI32.Search(const inBuff: TKDT21DI32_DynamicVecBuffer; var OutBuff: TKDT21DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT21DI32_DynamicVecBuffer;
  outBuffPtr : PKDT21DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT21DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT21DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT21DI32_Source));
end;

procedure TKDT21DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT21DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT21DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT21DI32.PrintNodeTree(const NodePtr: PKDT21DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT21DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT21DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT21DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT21DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT21DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT21DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT21DI32.Test;
var
  TKDT21DI32_Test    : TKDT21DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT21DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT21DI32_Test := TKDT21DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT21DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT21DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT21DI32_AxisCount - 1 do
        TKDT21DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT21DI32_Test.TestBuff), length(TKDT21DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT21DI32_Test.BuildKDTreeM(False, length(TKDT21DI32_Test.TestBuff), @TKDT21DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT21DI32_Test.BuildKDTreeM(False, length(TKDT21DI32_Test.TestBuff), TKDT21DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT21DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT21DI32_Test.TestBuff));
  TKDT21DI32_Test.Search(TKDT21DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT21DI32Distance(TKDT21DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT21DI32_Test.Clear;
  { kMean test }
  TKDT21DI32_Test.BuildKDTreeWithCluster(TKDT21DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT21DI32_Test.Search(TKDT21DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT21DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT21DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT21DI32_Test);
end;

{$ENDIF DEBUG}


function KDT22DI32Vec(const s: string): TKDT22DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT22DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT22DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT22DI32Vec(const v: TKDT22DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT22DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT22DI32Pow(const v: TKDT22DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT22DI32Distance(const v1, v2: TKDT22DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT22DI32_AxisCount - 1 do
      Result := Result + KDT22DI32Pow(v2[i] - v1[i]);
end;

function KDT22DI32Cmpare(const v1, v2: TKDT22DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT22DI32_Vec));
end;

function TKDT22DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DI32_Node;
  function SortCompare(const p1, p2: PKDT22DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT22DI32_SourceBuffer;
  dynBuff  : PKDT22DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT22DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DI32.SearchStoreBuff(const StoreBuffPtr: PKDT22DI32yanmicStoreBuffer; const Buff: TKDT22DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT22DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT22DI32.GetData(const index: NativeInt): PKDT22DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT22DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DI32.StoreBuffPtr: PKDT22DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT22DI32.BuildKDTreeWithCluster(const inBuff: TKDT22DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT22DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT22DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT22DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DI32.BuildKDTreeWithCluster(const inBuff: TKDT22DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI32_BuildCall);
var
  TempStoreBuff: TKDT22DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI32_BuildMethod);
var
  TempStoreBuff: TKDT22DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI32_BuildProc);
var
  TempStoreBuff: TKDT22DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT22DI32.Search(const Buff: TKDT22DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DI32_Node;

var
  NearestNeighbour: PKDT22DI32_Node;

  function FindParentNode(const BuffPtr: PKDT22DI32_Vec; NodePtr: PKDT22DI32_Node): PKDT22DI32_Node;
  var
    Next       : PKDT22DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT22DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DI32_Node; const BuffPtr: PKDT22DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT22DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT22DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT22DI32_Vec; const p1, p2: PKDT22DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT22DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT22DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT22DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT22DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT22DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT22DI32.Search(const Buff: TKDT22DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DI32.Search(const Buff: TKDT22DI32_Vec; var SearchedDistanceMin: Double): PKDT22DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DI32.Search(const Buff: TKDT22DI32_Vec): PKDT22DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT22DI32.Search(const inBuff: TKDT22DI32_DynamicVecBuffer; var OutBuff: TKDT22DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DI32_DynamicVecBuffer;
  outBuffPtr : PKDT22DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT22DI32_Source));
end;

procedure TKDT22DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT22DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT22DI32.PrintNodeTree(const NodePtr: PKDT22DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT22DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT22DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT22DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT22DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT22DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT22DI32.Test;
var
  TKDT22DI32_Test    : TKDT22DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT22DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT22DI32_Test := TKDT22DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT22DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT22DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT22DI32_AxisCount - 1 do
        TKDT22DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT22DI32_Test.TestBuff), length(TKDT22DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT22DI32_Test.BuildKDTreeM(False, length(TKDT22DI32_Test.TestBuff), @TKDT22DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT22DI32_Test.BuildKDTreeM(False, length(TKDT22DI32_Test.TestBuff), TKDT22DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT22DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT22DI32_Test.TestBuff));
  TKDT22DI32_Test.Search(TKDT22DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT22DI32Distance(TKDT22DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT22DI32_Test.Clear;
  { kMean test }
  TKDT22DI32_Test.BuildKDTreeWithCluster(TKDT22DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT22DI32_Test.Search(TKDT22DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT22DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT22DI32_Test);
end;

{$ENDIF DEBUG}


function KDT23DI32Vec(const s: string): TKDT23DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT23DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT23DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT23DI32Vec(const v: TKDT23DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT23DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT23DI32Pow(const v: TKDT23DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT23DI32Distance(const v1, v2: TKDT23DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT23DI32_AxisCount - 1 do
      Result := Result + KDT23DI32Pow(v2[i] - v1[i]);
end;

function KDT23DI32Cmpare(const v1, v2: TKDT23DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT23DI32_Vec));
end;

function TKDT23DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DI32_Node;
  function SortCompare(const p1, p2: PKDT23DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT23DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT23DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT23DI32_SourceBuffer;
  dynBuff  : PKDT23DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT23DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT23DI32.SearchStoreBuff(const StoreBuffPtr: PKDT23DI32yanmicStoreBuffer; const Buff: TKDT23DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT23DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT23DI32.GetData(const index: NativeInt): PKDT23DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT23DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT23DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT23DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT23DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT23DI32.StoreBuffPtr: PKDT23DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT23DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT23DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT23DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT23DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT23DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT23DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT23DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT23DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT23DI32.BuildKDTreeWithCluster(const inBuff: TKDT23DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT23DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT23DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT23DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT23DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT23DI32.BuildKDTreeWithCluster(const inBuff: TKDT23DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI32_BuildCall);
var
  TempStoreBuff: TKDT23DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT23DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT23DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT23DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT23DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI32_BuildMethod);
var
  TempStoreBuff: TKDT23DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT23DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT23DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT23DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT23DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI32_BuildProc);
var
  TempStoreBuff: TKDT23DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT23DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT23DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT23DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT23DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT23DI32.Search(const Buff: TKDT23DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DI32_Node;

var
  NearestNeighbour: PKDT23DI32_Node;

  function FindParentNode(const BuffPtr: PKDT23DI32_Vec; NodePtr: PKDT23DI32_Node): PKDT23DI32_Node;
  var
    Next       : PKDT23DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT23DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT23DI32_Node; const BuffPtr: PKDT23DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT23DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT23DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT23DI32_Vec; const p1, p2: PKDT23DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT23DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT23DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT23DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT23DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT23DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT23DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT23DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT23DI32.Search(const Buff: TKDT23DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT23DI32.Search(const Buff: TKDT23DI32_Vec; var SearchedDistanceMin: Double): PKDT23DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT23DI32.Search(const Buff: TKDT23DI32_Vec): PKDT23DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT23DI32.Search(const inBuff: TKDT23DI32_DynamicVecBuffer; var OutBuff: TKDT23DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT23DI32_DynamicVecBuffer;
  outBuffPtr : PKDT23DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT23DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT23DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT23DI32_Source));
end;

procedure TKDT23DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT23DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT23DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT23DI32.PrintNodeTree(const NodePtr: PKDT23DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT23DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT23DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT23DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT23DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT23DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT23DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT23DI32.Test;
var
  TKDT23DI32_Test    : TKDT23DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT23DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT23DI32_Test := TKDT23DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT23DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT23DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT23DI32_AxisCount - 1 do
        TKDT23DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT23DI32_Test.TestBuff), length(TKDT23DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT23DI32_Test.BuildKDTreeM(False, length(TKDT23DI32_Test.TestBuff), @TKDT23DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT23DI32_Test.BuildKDTreeM(False, length(TKDT23DI32_Test.TestBuff), TKDT23DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT23DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT23DI32_Test.TestBuff));
  TKDT23DI32_Test.Search(TKDT23DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT23DI32Distance(TKDT23DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT23DI32_Test.Clear;
  { kMean test }
  TKDT23DI32_Test.BuildKDTreeWithCluster(TKDT23DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT23DI32_Test.Search(TKDT23DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT23DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT23DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT23DI32_Test);
end;

{$ENDIF DEBUG}


function KDT24DI32Vec(const s: string): TKDT24DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT24DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT24DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT24DI32Vec(const v: TKDT24DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT24DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT24DI32Pow(const v: TKDT24DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT24DI32Distance(const v1, v2: TKDT24DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT24DI32_AxisCount - 1 do
      Result := Result + KDT24DI32Pow(v2[i] - v1[i]);
end;

function KDT24DI32Cmpare(const v1, v2: TKDT24DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT24DI32_Vec));
end;

function TKDT24DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DI32_Node;
  function SortCompare(const p1, p2: PKDT24DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT24DI32_SourceBuffer;
  dynBuff  : PKDT24DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT24DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DI32.SearchStoreBuff(const StoreBuffPtr: PKDT24DI32yanmicStoreBuffer; const Buff: TKDT24DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT24DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT24DI32.GetData(const index: NativeInt): PKDT24DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT24DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DI32.StoreBuffPtr: PKDT24DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT24DI32.BuildKDTreeWithCluster(const inBuff: TKDT24DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT24DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT24DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT24DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DI32.BuildKDTreeWithCluster(const inBuff: TKDT24DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI32_BuildCall);
var
  TempStoreBuff: TKDT24DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI32_BuildMethod);
var
  TempStoreBuff: TKDT24DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI32_BuildProc);
var
  TempStoreBuff: TKDT24DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT24DI32.Search(const Buff: TKDT24DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DI32_Node;

var
  NearestNeighbour: PKDT24DI32_Node;

  function FindParentNode(const BuffPtr: PKDT24DI32_Vec; NodePtr: PKDT24DI32_Node): PKDT24DI32_Node;
  var
    Next       : PKDT24DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT24DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DI32_Node; const BuffPtr: PKDT24DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT24DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT24DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT24DI32_Vec; const p1, p2: PKDT24DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT24DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT24DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT24DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT24DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT24DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT24DI32.Search(const Buff: TKDT24DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DI32.Search(const Buff: TKDT24DI32_Vec; var SearchedDistanceMin: Double): PKDT24DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DI32.Search(const Buff: TKDT24DI32_Vec): PKDT24DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT24DI32.Search(const inBuff: TKDT24DI32_DynamicVecBuffer; var OutBuff: TKDT24DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DI32_DynamicVecBuffer;
  outBuffPtr : PKDT24DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT24DI32_Source));
end;

procedure TKDT24DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT24DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT24DI32.PrintNodeTree(const NodePtr: PKDT24DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT24DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT24DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT24DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT24DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT24DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT24DI32.Test;
var
  TKDT24DI32_Test    : TKDT24DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT24DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT24DI32_Test := TKDT24DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT24DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT24DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT24DI32_AxisCount - 1 do
        TKDT24DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT24DI32_Test.TestBuff), length(TKDT24DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT24DI32_Test.BuildKDTreeM(False, length(TKDT24DI32_Test.TestBuff), @TKDT24DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT24DI32_Test.BuildKDTreeM(False, length(TKDT24DI32_Test.TestBuff), TKDT24DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT24DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT24DI32_Test.TestBuff));
  TKDT24DI32_Test.Search(TKDT24DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT24DI32Distance(TKDT24DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT24DI32_Test.Clear;
  { kMean test }
  TKDT24DI32_Test.BuildKDTreeWithCluster(TKDT24DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT24DI32_Test.Search(TKDT24DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT24DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT24DI32_Test);
end;

{$ENDIF DEBUG}


function KDT25DI32Vec(const s: string): TKDT25DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT25DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT25DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT25DI32Vec(const v: TKDT25DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT25DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT25DI32Pow(const v: TKDT25DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT25DI32Distance(const v1, v2: TKDT25DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT25DI32_AxisCount - 1 do
      Result := Result + KDT25DI32Pow(v2[i] - v1[i]);
end;

function KDT25DI32Cmpare(const v1, v2: TKDT25DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT25DI32_Vec));
end;

function TKDT25DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DI32_Node;
  function SortCompare(const p1, p2: PKDT25DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT25DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT25DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT25DI32_SourceBuffer;
  dynBuff  : PKDT25DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT25DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT25DI32.SearchStoreBuff(const StoreBuffPtr: PKDT25DI32yanmicStoreBuffer; const Buff: TKDT25DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT25DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT25DI32.GetData(const index: NativeInt): PKDT25DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT25DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT25DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT25DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT25DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT25DI32.StoreBuffPtr: PKDT25DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT25DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT25DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT25DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT25DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT25DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT25DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT25DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT25DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT25DI32.BuildKDTreeWithCluster(const inBuff: TKDT25DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT25DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT25DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT25DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT25DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT25DI32.BuildKDTreeWithCluster(const inBuff: TKDT25DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT25DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI32_BuildCall);
var
  TempStoreBuff: TKDT25DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT25DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT25DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT25DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT25DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT25DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI32_BuildMethod);
var
  TempStoreBuff: TKDT25DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT25DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT25DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT25DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT25DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI32_BuildProc);
var
  TempStoreBuff: TKDT25DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT25DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT25DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT25DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT25DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT25DI32.Search(const Buff: TKDT25DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DI32_Node;

var
  NearestNeighbour: PKDT25DI32_Node;

  function FindParentNode(const BuffPtr: PKDT25DI32_Vec; NodePtr: PKDT25DI32_Node): PKDT25DI32_Node;
  var
    Next       : PKDT25DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT25DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT25DI32_Node; const BuffPtr: PKDT25DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT25DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT25DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT25DI32_Vec; const p1, p2: PKDT25DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT25DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT25DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT25DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT25DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT25DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT25DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT25DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT25DI32.Search(const Buff: TKDT25DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT25DI32.Search(const Buff: TKDT25DI32_Vec; var SearchedDistanceMin: Double): PKDT25DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT25DI32.Search(const Buff: TKDT25DI32_Vec): PKDT25DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT25DI32.Search(const inBuff: TKDT25DI32_DynamicVecBuffer; var OutBuff: TKDT25DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT25DI32_DynamicVecBuffer;
  outBuffPtr : PKDT25DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT25DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT25DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT25DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT25DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT25DI32_Source));
end;

procedure TKDT25DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT25DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT25DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT25DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT25DI32.PrintNodeTree(const NodePtr: PKDT25DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT25DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT25DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT25DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT25DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT25DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT25DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT25DI32.Test;
var
  TKDT25DI32_Test    : TKDT25DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT25DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT25DI32_Test := TKDT25DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT25DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT25DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT25DI32_AxisCount - 1 do
        TKDT25DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT25DI32_Test.TestBuff), length(TKDT25DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT25DI32_Test.BuildKDTreeM(False, length(TKDT25DI32_Test.TestBuff), @TKDT25DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT25DI32_Test.BuildKDTreeM(False, length(TKDT25DI32_Test.TestBuff), TKDT25DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT25DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT25DI32_Test.TestBuff));
  TKDT25DI32_Test.Search(TKDT25DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT25DI32Distance(TKDT25DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT25DI32_Test.Clear;
  { kMean test }
  TKDT25DI32_Test.BuildKDTreeWithCluster(TKDT25DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT25DI32_Test.Search(TKDT25DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT25DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT25DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT25DI32_Test);
end;

{$ENDIF DEBUG}


function KDT26DI32Vec(const s: string): TKDT26DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT26DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT26DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT26DI32Vec(const v: TKDT26DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT26DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT26DI32Pow(const v: TKDT26DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT26DI32Distance(const v1, v2: TKDT26DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT26DI32_AxisCount - 1 do
      Result := Result + KDT26DI32Pow(v2[i] - v1[i]);
end;

function KDT26DI32Cmpare(const v1, v2: TKDT26DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT26DI32_Vec));
end;

function TKDT26DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DI32_Node;
  function SortCompare(const p1, p2: PKDT26DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT26DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT26DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT26DI32_SourceBuffer;
  dynBuff  : PKDT26DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT26DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT26DI32.SearchStoreBuff(const StoreBuffPtr: PKDT26DI32yanmicStoreBuffer; const Buff: TKDT26DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT26DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT26DI32.GetData(const index: NativeInt): PKDT26DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT26DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT26DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT26DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT26DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT26DI32.StoreBuffPtr: PKDT26DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT26DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT26DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT26DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT26DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT26DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT26DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT26DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT26DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT26DI32.BuildKDTreeWithCluster(const inBuff: TKDT26DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT26DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT26DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT26DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT26DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT26DI32.BuildKDTreeWithCluster(const inBuff: TKDT26DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT26DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI32_BuildCall);
var
  TempStoreBuff: TKDT26DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT26DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT26DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT26DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT26DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT26DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI32_BuildMethod);
var
  TempStoreBuff: TKDT26DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT26DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT26DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT26DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT26DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI32_BuildProc);
var
  TempStoreBuff: TKDT26DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT26DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT26DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT26DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT26DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT26DI32.Search(const Buff: TKDT26DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DI32_Node;

var
  NearestNeighbour: PKDT26DI32_Node;

  function FindParentNode(const BuffPtr: PKDT26DI32_Vec; NodePtr: PKDT26DI32_Node): PKDT26DI32_Node;
  var
    Next       : PKDT26DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT26DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT26DI32_Node; const BuffPtr: PKDT26DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT26DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT26DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT26DI32_Vec; const p1, p2: PKDT26DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT26DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT26DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT26DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT26DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT26DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT26DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT26DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT26DI32.Search(const Buff: TKDT26DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT26DI32.Search(const Buff: TKDT26DI32_Vec; var SearchedDistanceMin: Double): PKDT26DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT26DI32.Search(const Buff: TKDT26DI32_Vec): PKDT26DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT26DI32.Search(const inBuff: TKDT26DI32_DynamicVecBuffer; var OutBuff: TKDT26DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT26DI32_DynamicVecBuffer;
  outBuffPtr : PKDT26DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT26DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT26DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT26DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT26DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT26DI32_Source));
end;

procedure TKDT26DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT26DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT26DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT26DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT26DI32.PrintNodeTree(const NodePtr: PKDT26DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT26DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT26DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT26DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT26DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT26DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT26DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT26DI32.Test;
var
  TKDT26DI32_Test    : TKDT26DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT26DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT26DI32_Test := TKDT26DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT26DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT26DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT26DI32_AxisCount - 1 do
        TKDT26DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT26DI32_Test.TestBuff), length(TKDT26DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT26DI32_Test.BuildKDTreeM(False, length(TKDT26DI32_Test.TestBuff), @TKDT26DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT26DI32_Test.BuildKDTreeM(False, length(TKDT26DI32_Test.TestBuff), TKDT26DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT26DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT26DI32_Test.TestBuff));
  TKDT26DI32_Test.Search(TKDT26DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT26DI32Distance(TKDT26DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT26DI32_Test.Clear;
  { kMean test }
  TKDT26DI32_Test.BuildKDTreeWithCluster(TKDT26DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT26DI32_Test.Search(TKDT26DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT26DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT26DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT26DI32_Test);
end;

{$ENDIF DEBUG}


function KDT27DI32Vec(const s: string): TKDT27DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT27DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT27DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT27DI32Vec(const v: TKDT27DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT27DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT27DI32Pow(const v: TKDT27DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT27DI32Distance(const v1, v2: TKDT27DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT27DI32_AxisCount - 1 do
      Result := Result + KDT27DI32Pow(v2[i] - v1[i]);
end;

function KDT27DI32Cmpare(const v1, v2: TKDT27DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT27DI32_Vec));
end;

function TKDT27DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DI32_Node;
  function SortCompare(const p1, p2: PKDT27DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT27DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT27DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT27DI32_SourceBuffer;
  dynBuff  : PKDT27DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT27DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT27DI32.SearchStoreBuff(const StoreBuffPtr: PKDT27DI32yanmicStoreBuffer; const Buff: TKDT27DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT27DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT27DI32.GetData(const index: NativeInt): PKDT27DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT27DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT27DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT27DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT27DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT27DI32.StoreBuffPtr: PKDT27DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT27DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT27DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT27DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT27DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT27DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT27DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT27DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT27DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT27DI32.BuildKDTreeWithCluster(const inBuff: TKDT27DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT27DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT27DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT27DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT27DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT27DI32.BuildKDTreeWithCluster(const inBuff: TKDT27DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT27DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI32_BuildCall);
var
  TempStoreBuff: TKDT27DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT27DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT27DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT27DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT27DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT27DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI32_BuildMethod);
var
  TempStoreBuff: TKDT27DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT27DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT27DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT27DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT27DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI32_BuildProc);
var
  TempStoreBuff: TKDT27DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT27DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT27DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT27DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT27DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT27DI32.Search(const Buff: TKDT27DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DI32_Node;

var
  NearestNeighbour: PKDT27DI32_Node;

  function FindParentNode(const BuffPtr: PKDT27DI32_Vec; NodePtr: PKDT27DI32_Node): PKDT27DI32_Node;
  var
    Next       : PKDT27DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT27DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT27DI32_Node; const BuffPtr: PKDT27DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT27DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT27DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT27DI32_Vec; const p1, p2: PKDT27DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT27DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT27DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT27DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT27DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT27DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT27DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT27DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT27DI32.Search(const Buff: TKDT27DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT27DI32.Search(const Buff: TKDT27DI32_Vec; var SearchedDistanceMin: Double): PKDT27DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT27DI32.Search(const Buff: TKDT27DI32_Vec): PKDT27DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT27DI32.Search(const inBuff: TKDT27DI32_DynamicVecBuffer; var OutBuff: TKDT27DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT27DI32_DynamicVecBuffer;
  outBuffPtr : PKDT27DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT27DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT27DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT27DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT27DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT27DI32_Source));
end;

procedure TKDT27DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT27DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT27DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT27DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT27DI32.PrintNodeTree(const NodePtr: PKDT27DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT27DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT27DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT27DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT27DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT27DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT27DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT27DI32.Test;
var
  TKDT27DI32_Test    : TKDT27DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT27DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT27DI32_Test := TKDT27DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT27DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT27DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT27DI32_AxisCount - 1 do
        TKDT27DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT27DI32_Test.TestBuff), length(TKDT27DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT27DI32_Test.BuildKDTreeM(False, length(TKDT27DI32_Test.TestBuff), @TKDT27DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT27DI32_Test.BuildKDTreeM(False, length(TKDT27DI32_Test.TestBuff), TKDT27DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT27DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT27DI32_Test.TestBuff));
  TKDT27DI32_Test.Search(TKDT27DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT27DI32Distance(TKDT27DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT27DI32_Test.Clear;
  { kMean test }
  TKDT27DI32_Test.BuildKDTreeWithCluster(TKDT27DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT27DI32_Test.Search(TKDT27DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT27DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT27DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT27DI32_Test);
end;

{$ENDIF DEBUG}


function KDT28DI32Vec(const s: string): TKDT28DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT28DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT28DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT28DI32Vec(const v: TKDT28DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT28DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT28DI32Pow(const v: TKDT28DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT28DI32Distance(const v1, v2: TKDT28DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT28DI32_AxisCount - 1 do
      Result := Result + KDT28DI32Pow(v2[i] - v1[i]);
end;

function KDT28DI32Cmpare(const v1, v2: TKDT28DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT28DI32_Vec));
end;

function TKDT28DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DI32_Node;
  function SortCompare(const p1, p2: PKDT28DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT28DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT28DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT28DI32_SourceBuffer;
  dynBuff  : PKDT28DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT28DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT28DI32.SearchStoreBuff(const StoreBuffPtr: PKDT28DI32yanmicStoreBuffer; const Buff: TKDT28DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT28DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT28DI32.GetData(const index: NativeInt): PKDT28DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT28DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT28DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT28DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT28DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT28DI32.StoreBuffPtr: PKDT28DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT28DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT28DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT28DI32.BuildKDTreeWithCluster(const inBuff: TKDT28DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT28DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT28DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT28DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT28DI32.BuildKDTreeWithCluster(const inBuff: TKDT28DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI32_BuildCall);
var
  TempStoreBuff: TKDT28DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI32_BuildMethod);
var
  TempStoreBuff: TKDT28DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI32_BuildProc);
var
  TempStoreBuff: TKDT28DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT28DI32.Search(const Buff: TKDT28DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DI32_Node;

var
  NearestNeighbour: PKDT28DI32_Node;

  function FindParentNode(const BuffPtr: PKDT28DI32_Vec; NodePtr: PKDT28DI32_Node): PKDT28DI32_Node;
  var
    Next       : PKDT28DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT28DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT28DI32_Node; const BuffPtr: PKDT28DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT28DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT28DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT28DI32_Vec; const p1, p2: PKDT28DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT28DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT28DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT28DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT28DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT28DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT28DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT28DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT28DI32.Search(const Buff: TKDT28DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT28DI32.Search(const Buff: TKDT28DI32_Vec; var SearchedDistanceMin: Double): PKDT28DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT28DI32.Search(const Buff: TKDT28DI32_Vec): PKDT28DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT28DI32.Search(const inBuff: TKDT28DI32_DynamicVecBuffer; var OutBuff: TKDT28DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DI32_DynamicVecBuffer;
  outBuffPtr : PKDT28DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT28DI32_Source));
end;

procedure TKDT28DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT28DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT28DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT28DI32.PrintNodeTree(const NodePtr: PKDT28DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT28DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT28DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT28DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT28DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT28DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT28DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT28DI32.Test;
var
  TKDT28DI32_Test    : TKDT28DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT28DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT28DI32_Test := TKDT28DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT28DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT28DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT28DI32_AxisCount - 1 do
        TKDT28DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT28DI32_Test.TestBuff), length(TKDT28DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT28DI32_Test.BuildKDTreeM(False, length(TKDT28DI32_Test.TestBuff), @TKDT28DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT28DI32_Test.BuildKDTreeM(False, length(TKDT28DI32_Test.TestBuff), TKDT28DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT28DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT28DI32_Test.TestBuff));
  TKDT28DI32_Test.Search(TKDT28DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT28DI32Distance(TKDT28DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT28DI32_Test.Clear;
  { kMean test }
  TKDT28DI32_Test.BuildKDTreeWithCluster(TKDT28DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT28DI32_Test.Search(TKDT28DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT28DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT28DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT28DI32_Test);
end;

{$ENDIF DEBUG}


function KDT29DI32Vec(const s: string): TKDT29DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT29DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT29DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT29DI32Vec(const v: TKDT29DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT29DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT29DI32Pow(const v: TKDT29DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT29DI32Distance(const v1, v2: TKDT29DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT29DI32_AxisCount - 1 do
      Result := Result + KDT29DI32Pow(v2[i] - v1[i]);
end;

function KDT29DI32Cmpare(const v1, v2: TKDT29DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT29DI32_Vec));
end;

function TKDT29DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DI32_Node;
  function SortCompare(const p1, p2: PKDT29DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT29DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT29DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT29DI32_SourceBuffer;
  dynBuff  : PKDT29DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT29DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT29DI32.SearchStoreBuff(const StoreBuffPtr: PKDT29DI32yanmicStoreBuffer; const Buff: TKDT29DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT29DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT29DI32.GetData(const index: NativeInt): PKDT29DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT29DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT29DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT29DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT29DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT29DI32.StoreBuffPtr: PKDT29DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT29DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT29DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT29DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT29DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT29DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT29DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT29DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT29DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT29DI32.BuildKDTreeWithCluster(const inBuff: TKDT29DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT29DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT29DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT29DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT29DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT29DI32.BuildKDTreeWithCluster(const inBuff: TKDT29DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT29DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI32_BuildCall);
var
  TempStoreBuff: TKDT29DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT29DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT29DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT29DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT29DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT29DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI32_BuildMethod);
var
  TempStoreBuff: TKDT29DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT29DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT29DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT29DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT29DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI32_BuildProc);
var
  TempStoreBuff: TKDT29DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT29DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT29DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT29DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT29DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT29DI32.Search(const Buff: TKDT29DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DI32_Node;

var
  NearestNeighbour: PKDT29DI32_Node;

  function FindParentNode(const BuffPtr: PKDT29DI32_Vec; NodePtr: PKDT29DI32_Node): PKDT29DI32_Node;
  var
    Next       : PKDT29DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT29DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT29DI32_Node; const BuffPtr: PKDT29DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT29DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT29DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT29DI32_Vec; const p1, p2: PKDT29DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT29DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT29DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT29DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT29DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT29DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT29DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT29DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT29DI32.Search(const Buff: TKDT29DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT29DI32.Search(const Buff: TKDT29DI32_Vec; var SearchedDistanceMin: Double): PKDT29DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT29DI32.Search(const Buff: TKDT29DI32_Vec): PKDT29DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT29DI32.Search(const inBuff: TKDT29DI32_DynamicVecBuffer; var OutBuff: TKDT29DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT29DI32_DynamicVecBuffer;
  outBuffPtr : PKDT29DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT29DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT29DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT29DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT29DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT29DI32_Source));
end;

procedure TKDT29DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT29DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT29DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT29DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT29DI32.PrintNodeTree(const NodePtr: PKDT29DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT29DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT29DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT29DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT29DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT29DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT29DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT29DI32.Test;
var
  TKDT29DI32_Test    : TKDT29DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT29DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT29DI32_Test := TKDT29DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT29DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT29DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT29DI32_AxisCount - 1 do
        TKDT29DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT29DI32_Test.TestBuff), length(TKDT29DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT29DI32_Test.BuildKDTreeM(False, length(TKDT29DI32_Test.TestBuff), @TKDT29DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT29DI32_Test.BuildKDTreeM(False, length(TKDT29DI32_Test.TestBuff), TKDT29DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT29DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT29DI32_Test.TestBuff));
  TKDT29DI32_Test.Search(TKDT29DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT29DI32Distance(TKDT29DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT29DI32_Test.Clear;
  { kMean test }
  TKDT29DI32_Test.BuildKDTreeWithCluster(TKDT29DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT29DI32_Test.Search(TKDT29DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT29DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT29DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT29DI32_Test);
end;

{$ENDIF DEBUG}


function KDT30DI32Vec(const s: string): TKDT30DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT30DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT30DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT30DI32Vec(const v: TKDT30DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT30DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT30DI32Pow(const v: TKDT30DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT30DI32Distance(const v1, v2: TKDT30DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT30DI32_AxisCount - 1 do
      Result := Result + KDT30DI32Pow(v2[i] - v1[i]);
end;

function KDT30DI32Cmpare(const v1, v2: TKDT30DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT30DI32_Vec));
end;

function TKDT30DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DI32_Node;
  function SortCompare(const p1, p2: PKDT30DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT30DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT30DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT30DI32_SourceBuffer;
  dynBuff  : PKDT30DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT30DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT30DI32.SearchStoreBuff(const StoreBuffPtr: PKDT30DI32yanmicStoreBuffer; const Buff: TKDT30DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT30DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT30DI32.GetData(const index: NativeInt): PKDT30DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT30DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT30DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT30DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT30DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT30DI32.StoreBuffPtr: PKDT30DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT30DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT30DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT30DI32.BuildKDTreeWithCluster(const inBuff: TKDT30DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT30DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT30DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT30DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT30DI32.BuildKDTreeWithCluster(const inBuff: TKDT30DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI32_BuildCall);
var
  TempStoreBuff: TKDT30DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI32_BuildMethod);
var
  TempStoreBuff: TKDT30DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI32_BuildProc);
var
  TempStoreBuff: TKDT30DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT30DI32.Search(const Buff: TKDT30DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DI32_Node;

var
  NearestNeighbour: PKDT30DI32_Node;

  function FindParentNode(const BuffPtr: PKDT30DI32_Vec; NodePtr: PKDT30DI32_Node): PKDT30DI32_Node;
  var
    Next       : PKDT30DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT30DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT30DI32_Node; const BuffPtr: PKDT30DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT30DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT30DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT30DI32_Vec; const p1, p2: PKDT30DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT30DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT30DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT30DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT30DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT30DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT30DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT30DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT30DI32.Search(const Buff: TKDT30DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT30DI32.Search(const Buff: TKDT30DI32_Vec; var SearchedDistanceMin: Double): PKDT30DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT30DI32.Search(const Buff: TKDT30DI32_Vec): PKDT30DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT30DI32.Search(const inBuff: TKDT30DI32_DynamicVecBuffer; var OutBuff: TKDT30DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DI32_DynamicVecBuffer;
  outBuffPtr : PKDT30DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT30DI32_Source));
end;

procedure TKDT30DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT30DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT30DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT30DI32.PrintNodeTree(const NodePtr: PKDT30DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT30DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT30DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT30DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT30DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT30DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT30DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT30DI32.Test;
var
  TKDT30DI32_Test    : TKDT30DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT30DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT30DI32_Test := TKDT30DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT30DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT30DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT30DI32_AxisCount - 1 do
        TKDT30DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT30DI32_Test.TestBuff), length(TKDT30DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT30DI32_Test.BuildKDTreeM(False, length(TKDT30DI32_Test.TestBuff), @TKDT30DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT30DI32_Test.BuildKDTreeM(False, length(TKDT30DI32_Test.TestBuff), TKDT30DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT30DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT30DI32_Test.TestBuff));
  TKDT30DI32_Test.Search(TKDT30DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT30DI32Distance(TKDT30DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT30DI32_Test.Clear;
  { kMean test }
  TKDT30DI32_Test.BuildKDTreeWithCluster(TKDT30DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT30DI32_Test.Search(TKDT30DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT30DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT30DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT30DI32_Test);
end;

{$ENDIF DEBUG}


function KDT32DI32Vec(const s: string): TKDT32DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT32DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT32DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT32DI32Vec(const v: TKDT32DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT32DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT32DI32Pow(const v: TKDT32DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT32DI32Distance(const v1, v2: TKDT32DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT32DI32_AxisCount - 1 do
      Result := Result + KDT32DI32Pow(v2[i] - v1[i]);
end;

function KDT32DI32Cmpare(const v1, v2: TKDT32DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT32DI32_Vec));
end;

function TKDT32DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DI32_Node;
  function SortCompare(const p1, p2: PKDT32DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT32DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT32DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT32DI32_SourceBuffer;
  dynBuff  : PKDT32DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT32DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT32DI32.SearchStoreBuff(const StoreBuffPtr: PKDT32DI32yanmicStoreBuffer; const Buff: TKDT32DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT32DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT32DI32.GetData(const index: NativeInt): PKDT32DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT32DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT32DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT32DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT32DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT32DI32.StoreBuffPtr: PKDT32DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT32DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT32DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT32DI32.BuildKDTreeWithCluster(const inBuff: TKDT32DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT32DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT32DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT32DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT32DI32.BuildKDTreeWithCluster(const inBuff: TKDT32DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI32_BuildCall);
var
  TempStoreBuff: TKDT32DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI32_BuildMethod);
var
  TempStoreBuff: TKDT32DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI32_BuildProc);
var
  TempStoreBuff: TKDT32DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT32DI32.Search(const Buff: TKDT32DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DI32_Node;

var
  NearestNeighbour: PKDT32DI32_Node;

  function FindParentNode(const BuffPtr: PKDT32DI32_Vec; NodePtr: PKDT32DI32_Node): PKDT32DI32_Node;
  var
    Next       : PKDT32DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT32DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT32DI32_Node; const BuffPtr: PKDT32DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT32DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT32DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT32DI32_Vec; const p1, p2: PKDT32DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT32DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT32DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT32DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT32DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT32DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT32DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT32DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT32DI32.Search(const Buff: TKDT32DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT32DI32.Search(const Buff: TKDT32DI32_Vec; var SearchedDistanceMin: Double): PKDT32DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT32DI32.Search(const Buff: TKDT32DI32_Vec): PKDT32DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT32DI32.Search(const inBuff: TKDT32DI32_DynamicVecBuffer; var OutBuff: TKDT32DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DI32_DynamicVecBuffer;
  outBuffPtr : PKDT32DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT32DI32_Source));
end;

procedure TKDT32DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT32DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT32DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT32DI32.PrintNodeTree(const NodePtr: PKDT32DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT32DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT32DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT32DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT32DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT32DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT32DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT32DI32.Test;
var
  TKDT32DI32_Test    : TKDT32DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT32DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT32DI32_Test := TKDT32DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT32DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT32DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT32DI32_AxisCount - 1 do
        TKDT32DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT32DI32_Test.TestBuff), length(TKDT32DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT32DI32_Test.BuildKDTreeM(False, length(TKDT32DI32_Test.TestBuff), @TKDT32DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT32DI32_Test.BuildKDTreeM(False, length(TKDT32DI32_Test.TestBuff), TKDT32DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT32DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT32DI32_Test.TestBuff));
  TKDT32DI32_Test.Search(TKDT32DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT32DI32Distance(TKDT32DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT32DI32_Test.Clear;
  { kMean test }
  TKDT32DI32_Test.BuildKDTreeWithCluster(TKDT32DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT32DI32_Test.Search(TKDT32DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT32DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT32DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT32DI32_Test);
end;

{$ENDIF DEBUG}


function KDT34DI32Vec(const s: string): TKDT34DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT34DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT34DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT34DI32Vec(const v: TKDT34DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT34DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT34DI32Pow(const v: TKDT34DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT34DI32Distance(const v1, v2: TKDT34DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT34DI32_AxisCount - 1 do
      Result := Result + KDT34DI32Pow(v2[i] - v1[i]);
end;

function KDT34DI32Cmpare(const v1, v2: TKDT34DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT34DI32_Vec));
end;

function TKDT34DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DI32_Node;
  function SortCompare(const p1, p2: PKDT34DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT34DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT34DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT34DI32_SourceBuffer;
  dynBuff  : PKDT34DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT34DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT34DI32.SearchStoreBuff(const StoreBuffPtr: PKDT34DI32yanmicStoreBuffer; const Buff: TKDT34DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT34DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT34DI32.GetData(const index: NativeInt): PKDT34DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT34DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT34DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT34DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT34DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT34DI32.StoreBuffPtr: PKDT34DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT34DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT34DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT34DI32.BuildKDTreeWithCluster(const inBuff: TKDT34DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT34DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT34DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT34DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT34DI32.BuildKDTreeWithCluster(const inBuff: TKDT34DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI32_BuildCall);
var
  TempStoreBuff: TKDT34DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI32_BuildMethod);
var
  TempStoreBuff: TKDT34DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI32_BuildProc);
var
  TempStoreBuff: TKDT34DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT34DI32.Search(const Buff: TKDT34DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DI32_Node;

var
  NearestNeighbour: PKDT34DI32_Node;

  function FindParentNode(const BuffPtr: PKDT34DI32_Vec; NodePtr: PKDT34DI32_Node): PKDT34DI32_Node;
  var
    Next       : PKDT34DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT34DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT34DI32_Node; const BuffPtr: PKDT34DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT34DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT34DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT34DI32_Vec; const p1, p2: PKDT34DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT34DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT34DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT34DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT34DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT34DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT34DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT34DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT34DI32.Search(const Buff: TKDT34DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT34DI32.Search(const Buff: TKDT34DI32_Vec; var SearchedDistanceMin: Double): PKDT34DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT34DI32.Search(const Buff: TKDT34DI32_Vec): PKDT34DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT34DI32.Search(const inBuff: TKDT34DI32_DynamicVecBuffer; var OutBuff: TKDT34DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DI32_DynamicVecBuffer;
  outBuffPtr : PKDT34DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT34DI32_Source));
end;

procedure TKDT34DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT34DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT34DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT34DI32.PrintNodeTree(const NodePtr: PKDT34DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT34DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT34DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT34DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT34DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT34DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT34DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT34DI32.Test;
var
  TKDT34DI32_Test    : TKDT34DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT34DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT34DI32_Test := TKDT34DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT34DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT34DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT34DI32_AxisCount - 1 do
        TKDT34DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT34DI32_Test.TestBuff), length(TKDT34DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT34DI32_Test.BuildKDTreeM(False, length(TKDT34DI32_Test.TestBuff), @TKDT34DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT34DI32_Test.BuildKDTreeM(False, length(TKDT34DI32_Test.TestBuff), TKDT34DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT34DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT34DI32_Test.TestBuff));
  TKDT34DI32_Test.Search(TKDT34DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT34DI32Distance(TKDT34DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT34DI32_Test.Clear;
  { kMean test }
  TKDT34DI32_Test.BuildKDTreeWithCluster(TKDT34DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT34DI32_Test.Search(TKDT34DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT34DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT34DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT34DI32_Test);
end;

{$ENDIF DEBUG}


function KDT36DI32Vec(const s: string): TKDT36DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT36DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT36DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT36DI32Vec(const v: TKDT36DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT36DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT36DI32Pow(const v: TKDT36DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT36DI32Distance(const v1, v2: TKDT36DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT36DI32_AxisCount - 1 do
      Result := Result + KDT36DI32Pow(v2[i] - v1[i]);
end;

function KDT36DI32Cmpare(const v1, v2: TKDT36DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT36DI32_Vec));
end;

function TKDT36DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DI32_Node;
  function SortCompare(const p1, p2: PKDT36DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT36DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT36DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT36DI32_SourceBuffer;
  dynBuff  : PKDT36DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT36DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT36DI32.SearchStoreBuff(const StoreBuffPtr: PKDT36DI32yanmicStoreBuffer; const Buff: TKDT36DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT36DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT36DI32.GetData(const index: NativeInt): PKDT36DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT36DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT36DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT36DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT36DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT36DI32.StoreBuffPtr: PKDT36DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT36DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT36DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT36DI32.BuildKDTreeWithCluster(const inBuff: TKDT36DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT36DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT36DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT36DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT36DI32.BuildKDTreeWithCluster(const inBuff: TKDT36DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI32_BuildCall);
var
  TempStoreBuff: TKDT36DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI32_BuildMethod);
var
  TempStoreBuff: TKDT36DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI32_BuildProc);
var
  TempStoreBuff: TKDT36DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT36DI32.Search(const Buff: TKDT36DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DI32_Node;

var
  NearestNeighbour: PKDT36DI32_Node;

  function FindParentNode(const BuffPtr: PKDT36DI32_Vec; NodePtr: PKDT36DI32_Node): PKDT36DI32_Node;
  var
    Next       : PKDT36DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT36DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT36DI32_Node; const BuffPtr: PKDT36DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT36DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT36DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT36DI32_Vec; const p1, p2: PKDT36DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT36DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT36DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT36DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT36DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT36DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT36DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT36DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT36DI32.Search(const Buff: TKDT36DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT36DI32.Search(const Buff: TKDT36DI32_Vec; var SearchedDistanceMin: Double): PKDT36DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT36DI32.Search(const Buff: TKDT36DI32_Vec): PKDT36DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT36DI32.Search(const inBuff: TKDT36DI32_DynamicVecBuffer; var OutBuff: TKDT36DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DI32_DynamicVecBuffer;
  outBuffPtr : PKDT36DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT36DI32_Source));
end;

procedure TKDT36DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT36DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT36DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT36DI32.PrintNodeTree(const NodePtr: PKDT36DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT36DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT36DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT36DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT36DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT36DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT36DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT36DI32.Test;
var
  TKDT36DI32_Test    : TKDT36DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT36DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT36DI32_Test := TKDT36DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT36DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT36DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT36DI32_AxisCount - 1 do
        TKDT36DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT36DI32_Test.TestBuff), length(TKDT36DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT36DI32_Test.BuildKDTreeM(False, length(TKDT36DI32_Test.TestBuff), @TKDT36DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT36DI32_Test.BuildKDTreeM(False, length(TKDT36DI32_Test.TestBuff), TKDT36DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT36DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT36DI32_Test.TestBuff));
  TKDT36DI32_Test.Search(TKDT36DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT36DI32Distance(TKDT36DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT36DI32_Test.Clear;
  { kMean test }
  TKDT36DI32_Test.BuildKDTreeWithCluster(TKDT36DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT36DI32_Test.Search(TKDT36DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT36DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT36DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT36DI32_Test);
end;

{$ENDIF DEBUG}


function KDT38DI32Vec(const s: string): TKDT38DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT38DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT38DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT38DI32Vec(const v: TKDT38DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT38DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT38DI32Pow(const v: TKDT38DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT38DI32Distance(const v1, v2: TKDT38DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT38DI32_AxisCount - 1 do
      Result := Result + KDT38DI32Pow(v2[i] - v1[i]);
end;

function KDT38DI32Cmpare(const v1, v2: TKDT38DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT38DI32_Vec));
end;

function TKDT38DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DI32_Node;
  function SortCompare(const p1, p2: PKDT38DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT38DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT38DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT38DI32_SourceBuffer;
  dynBuff  : PKDT38DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT38DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT38DI32.SearchStoreBuff(const StoreBuffPtr: PKDT38DI32yanmicStoreBuffer; const Buff: TKDT38DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT38DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT38DI32.GetData(const index: NativeInt): PKDT38DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT38DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT38DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT38DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT38DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT38DI32.StoreBuffPtr: PKDT38DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT38DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT38DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT38DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT38DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT38DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT38DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT38DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT38DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT38DI32.BuildKDTreeWithCluster(const inBuff: TKDT38DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT38DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT38DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT38DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT38DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT38DI32.BuildKDTreeWithCluster(const inBuff: TKDT38DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT38DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI32_BuildCall);
var
  TempStoreBuff: TKDT38DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT38DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT38DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT38DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT38DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT38DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI32_BuildMethod);
var
  TempStoreBuff: TKDT38DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT38DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT38DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT38DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT38DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI32_BuildProc);
var
  TempStoreBuff: TKDT38DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT38DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT38DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT38DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT38DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT38DI32.Search(const Buff: TKDT38DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DI32_Node;

var
  NearestNeighbour: PKDT38DI32_Node;

  function FindParentNode(const BuffPtr: PKDT38DI32_Vec; NodePtr: PKDT38DI32_Node): PKDT38DI32_Node;
  var
    Next       : PKDT38DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT38DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT38DI32_Node; const BuffPtr: PKDT38DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT38DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT38DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT38DI32_Vec; const p1, p2: PKDT38DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT38DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT38DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT38DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT38DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT38DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT38DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT38DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT38DI32.Search(const Buff: TKDT38DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT38DI32.Search(const Buff: TKDT38DI32_Vec; var SearchedDistanceMin: Double): PKDT38DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT38DI32.Search(const Buff: TKDT38DI32_Vec): PKDT38DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT38DI32.Search(const inBuff: TKDT38DI32_DynamicVecBuffer; var OutBuff: TKDT38DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT38DI32_DynamicVecBuffer;
  outBuffPtr : PKDT38DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT38DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT38DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT38DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT38DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT38DI32_Source));
end;

procedure TKDT38DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT38DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT38DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT38DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT38DI32.PrintNodeTree(const NodePtr: PKDT38DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT38DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT38DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT38DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT38DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT38DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT38DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT38DI32.Test;
var
  TKDT38DI32_Test    : TKDT38DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT38DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT38DI32_Test := TKDT38DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT38DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT38DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT38DI32_AxisCount - 1 do
        TKDT38DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT38DI32_Test.TestBuff), length(TKDT38DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT38DI32_Test.BuildKDTreeM(False, length(TKDT38DI32_Test.TestBuff), @TKDT38DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT38DI32_Test.BuildKDTreeM(False, length(TKDT38DI32_Test.TestBuff), TKDT38DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT38DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT38DI32_Test.TestBuff));
  TKDT38DI32_Test.Search(TKDT38DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT38DI32Distance(TKDT38DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT38DI32_Test.Clear;
  { kMean test }
  TKDT38DI32_Test.BuildKDTreeWithCluster(TKDT38DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT38DI32_Test.Search(TKDT38DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT38DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT38DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT38DI32_Test);
end;

{$ENDIF DEBUG}


function KDT40DI32Vec(const s: string): TKDT40DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT40DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT40DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT40DI32Vec(const v: TKDT40DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT40DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT40DI32Pow(const v: TKDT40DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT40DI32Distance(const v1, v2: TKDT40DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT40DI32_AxisCount - 1 do
      Result := Result + KDT40DI32Pow(v2[i] - v1[i]);
end;

function KDT40DI32Cmpare(const v1, v2: TKDT40DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT40DI32_Vec));
end;

function TKDT40DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DI32_Node;
  function SortCompare(const p1, p2: PKDT40DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT40DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT40DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT40DI32_SourceBuffer;
  dynBuff  : PKDT40DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT40DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT40DI32.SearchStoreBuff(const StoreBuffPtr: PKDT40DI32yanmicStoreBuffer; const Buff: TKDT40DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT40DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT40DI32.GetData(const index: NativeInt): PKDT40DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT40DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT40DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT40DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT40DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT40DI32.StoreBuffPtr: PKDT40DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT40DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT40DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT40DI32.BuildKDTreeWithCluster(const inBuff: TKDT40DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT40DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT40DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT40DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT40DI32.BuildKDTreeWithCluster(const inBuff: TKDT40DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI32_BuildCall);
var
  TempStoreBuff: TKDT40DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI32_BuildMethod);
var
  TempStoreBuff: TKDT40DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI32_BuildProc);
var
  TempStoreBuff: TKDT40DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT40DI32.Search(const Buff: TKDT40DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DI32_Node;

var
  NearestNeighbour: PKDT40DI32_Node;

  function FindParentNode(const BuffPtr: PKDT40DI32_Vec; NodePtr: PKDT40DI32_Node): PKDT40DI32_Node;
  var
    Next       : PKDT40DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT40DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT40DI32_Node; const BuffPtr: PKDT40DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT40DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT40DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT40DI32_Vec; const p1, p2: PKDT40DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT40DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT40DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT40DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT40DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT40DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT40DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT40DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT40DI32.Search(const Buff: TKDT40DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT40DI32.Search(const Buff: TKDT40DI32_Vec; var SearchedDistanceMin: Double): PKDT40DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT40DI32.Search(const Buff: TKDT40DI32_Vec): PKDT40DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT40DI32.Search(const inBuff: TKDT40DI32_DynamicVecBuffer; var OutBuff: TKDT40DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DI32_DynamicVecBuffer;
  outBuffPtr : PKDT40DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT40DI32_Source));
end;

procedure TKDT40DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT40DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT40DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT40DI32.PrintNodeTree(const NodePtr: PKDT40DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT40DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT40DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT40DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT40DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT40DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT40DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT40DI32.Test;
var
  TKDT40DI32_Test    : TKDT40DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT40DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT40DI32_Test := TKDT40DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT40DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT40DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT40DI32_AxisCount - 1 do
        TKDT40DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT40DI32_Test.TestBuff), length(TKDT40DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT40DI32_Test.BuildKDTreeM(False, length(TKDT40DI32_Test.TestBuff), @TKDT40DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT40DI32_Test.BuildKDTreeM(False, length(TKDT40DI32_Test.TestBuff), TKDT40DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT40DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT40DI32_Test.TestBuff));
  TKDT40DI32_Test.Search(TKDT40DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT40DI32Distance(TKDT40DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT40DI32_Test.Clear;
  { kMean test }
  TKDT40DI32_Test.BuildKDTreeWithCluster(TKDT40DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT40DI32_Test.Search(TKDT40DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT40DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT40DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT40DI32_Test);
end;

{$ENDIF DEBUG}


function KDT44DI32Vec(const s: string): TKDT44DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT44DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT44DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT44DI32Vec(const v: TKDT44DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT44DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT44DI32Pow(const v: TKDT44DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT44DI32Distance(const v1, v2: TKDT44DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT44DI32_AxisCount - 1 do
      Result := Result + KDT44DI32Pow(v2[i] - v1[i]);
end;

function KDT44DI32Cmpare(const v1, v2: TKDT44DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT44DI32_Vec));
end;

function TKDT44DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DI32_Node;
  function SortCompare(const p1, p2: PKDT44DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT44DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT44DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT44DI32_SourceBuffer;
  dynBuff  : PKDT44DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT44DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT44DI32.SearchStoreBuff(const StoreBuffPtr: PKDT44DI32yanmicStoreBuffer; const Buff: TKDT44DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT44DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT44DI32.GetData(const index: NativeInt): PKDT44DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT44DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT44DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT44DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT44DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT44DI32.StoreBuffPtr: PKDT44DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT44DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT44DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT44DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT44DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT44DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT44DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT44DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT44DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT44DI32.BuildKDTreeWithCluster(const inBuff: TKDT44DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT44DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT44DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT44DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT44DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT44DI32.BuildKDTreeWithCluster(const inBuff: TKDT44DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT44DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI32_BuildCall);
var
  TempStoreBuff: TKDT44DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT44DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT44DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT44DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT44DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT44DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI32_BuildMethod);
var
  TempStoreBuff: TKDT44DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT44DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT44DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT44DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT44DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI32_BuildProc);
var
  TempStoreBuff: TKDT44DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT44DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT44DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT44DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT44DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT44DI32.Search(const Buff: TKDT44DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DI32_Node;

var
  NearestNeighbour: PKDT44DI32_Node;

  function FindParentNode(const BuffPtr: PKDT44DI32_Vec; NodePtr: PKDT44DI32_Node): PKDT44DI32_Node;
  var
    Next       : PKDT44DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT44DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT44DI32_Node; const BuffPtr: PKDT44DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT44DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT44DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT44DI32_Vec; const p1, p2: PKDT44DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT44DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT44DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT44DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT44DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT44DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT44DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT44DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT44DI32.Search(const Buff: TKDT44DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT44DI32.Search(const Buff: TKDT44DI32_Vec; var SearchedDistanceMin: Double): PKDT44DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT44DI32.Search(const Buff: TKDT44DI32_Vec): PKDT44DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT44DI32.Search(const inBuff: TKDT44DI32_DynamicVecBuffer; var OutBuff: TKDT44DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT44DI32_DynamicVecBuffer;
  outBuffPtr : PKDT44DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT44DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT44DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT44DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT44DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT44DI32_Source));
end;

procedure TKDT44DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT44DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT44DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT44DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT44DI32.PrintNodeTree(const NodePtr: PKDT44DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT44DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT44DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT44DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT44DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT44DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT44DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT44DI32.Test;
var
  TKDT44DI32_Test    : TKDT44DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT44DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT44DI32_Test := TKDT44DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT44DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT44DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT44DI32_AxisCount - 1 do
        TKDT44DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT44DI32_Test.TestBuff), length(TKDT44DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT44DI32_Test.BuildKDTreeM(False, length(TKDT44DI32_Test.TestBuff), @TKDT44DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT44DI32_Test.BuildKDTreeM(False, length(TKDT44DI32_Test.TestBuff), TKDT44DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT44DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT44DI32_Test.TestBuff));
  TKDT44DI32_Test.Search(TKDT44DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT44DI32Distance(TKDT44DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT44DI32_Test.Clear;
  { kMean test }
  TKDT44DI32_Test.BuildKDTreeWithCluster(TKDT44DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT44DI32_Test.Search(TKDT44DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT44DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT44DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT44DI32_Test);
end;

{$ENDIF DEBUG}


function KDT48DI32Vec(const s: string): TKDT48DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT48DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT48DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT48DI32Vec(const v: TKDT48DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT48DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT48DI32Pow(const v: TKDT48DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT48DI32Distance(const v1, v2: TKDT48DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT48DI32_AxisCount - 1 do
      Result := Result + KDT48DI32Pow(v2[i] - v1[i]);
end;

function KDT48DI32Cmpare(const v1, v2: TKDT48DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT48DI32_Vec));
end;

function TKDT48DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DI32_Node;
  function SortCompare(const p1, p2: PKDT48DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT48DI32_SourceBuffer;
  dynBuff  : PKDT48DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT48DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DI32.SearchStoreBuff(const StoreBuffPtr: PKDT48DI32yanmicStoreBuffer; const Buff: TKDT48DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT48DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT48DI32.GetData(const index: NativeInt): PKDT48DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT48DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DI32.StoreBuffPtr: PKDT48DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT48DI32.BuildKDTreeWithCluster(const inBuff: TKDT48DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT48DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT48DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT48DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DI32.BuildKDTreeWithCluster(const inBuff: TKDT48DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI32_BuildCall);
var
  TempStoreBuff: TKDT48DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI32_BuildMethod);
var
  TempStoreBuff: TKDT48DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI32_BuildProc);
var
  TempStoreBuff: TKDT48DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT48DI32.Search(const Buff: TKDT48DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DI32_Node;

var
  NearestNeighbour: PKDT48DI32_Node;

  function FindParentNode(const BuffPtr: PKDT48DI32_Vec; NodePtr: PKDT48DI32_Node): PKDT48DI32_Node;
  var
    Next       : PKDT48DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT48DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DI32_Node; const BuffPtr: PKDT48DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT48DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT48DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT48DI32_Vec; const p1, p2: PKDT48DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT48DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT48DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT48DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT48DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT48DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT48DI32.Search(const Buff: TKDT48DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DI32.Search(const Buff: TKDT48DI32_Vec; var SearchedDistanceMin: Double): PKDT48DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DI32.Search(const Buff: TKDT48DI32_Vec): PKDT48DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT48DI32.Search(const inBuff: TKDT48DI32_DynamicVecBuffer; var OutBuff: TKDT48DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DI32_DynamicVecBuffer;
  outBuffPtr : PKDT48DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT48DI32_Source));
end;

procedure TKDT48DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT48DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT48DI32.PrintNodeTree(const NodePtr: PKDT48DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT48DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT48DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT48DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT48DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT48DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT48DI32.Test;
var
  TKDT48DI32_Test    : TKDT48DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT48DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT48DI32_Test := TKDT48DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT48DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT48DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT48DI32_AxisCount - 1 do
        TKDT48DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT48DI32_Test.TestBuff), length(TKDT48DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT48DI32_Test.BuildKDTreeM(False, length(TKDT48DI32_Test.TestBuff), @TKDT48DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT48DI32_Test.BuildKDTreeM(False, length(TKDT48DI32_Test.TestBuff), TKDT48DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT48DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT48DI32_Test.TestBuff));
  TKDT48DI32_Test.Search(TKDT48DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT48DI32Distance(TKDT48DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT48DI32_Test.Clear;
  { kMean test }
  TKDT48DI32_Test.BuildKDTreeWithCluster(TKDT48DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT48DI32_Test.Search(TKDT48DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT48DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT48DI32_Test);
end;

{$ENDIF DEBUG}


function KDT50DI32Vec(const s: string): TKDT50DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT50DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT50DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT50DI32Vec(const v: TKDT50DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT50DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT50DI32Pow(const v: TKDT50DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT50DI32Distance(const v1, v2: TKDT50DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT50DI32_AxisCount - 1 do
      Result := Result + KDT50DI32Pow(v2[i] - v1[i]);
end;

function KDT50DI32Cmpare(const v1, v2: TKDT50DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT50DI32_Vec));
end;

function TKDT50DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DI32_Node;
  function SortCompare(const p1, p2: PKDT50DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT50DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT50DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT50DI32_SourceBuffer;
  dynBuff  : PKDT50DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT50DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT50DI32.SearchStoreBuff(const StoreBuffPtr: PKDT50DI32yanmicStoreBuffer; const Buff: TKDT50DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT50DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT50DI32.GetData(const index: NativeInt): PKDT50DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT50DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT50DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT50DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT50DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT50DI32.StoreBuffPtr: PKDT50DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT50DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT50DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT50DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT50DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT50DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT50DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT50DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT50DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT50DI32.BuildKDTreeWithCluster(const inBuff: TKDT50DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT50DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT50DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT50DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT50DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT50DI32.BuildKDTreeWithCluster(const inBuff: TKDT50DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT50DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI32_BuildCall);
var
  TempStoreBuff: TKDT50DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT50DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT50DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT50DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT50DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT50DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI32_BuildMethod);
var
  TempStoreBuff: TKDT50DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT50DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT50DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT50DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT50DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI32_BuildProc);
var
  TempStoreBuff: TKDT50DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT50DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT50DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT50DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT50DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT50DI32.Search(const Buff: TKDT50DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DI32_Node;

var
  NearestNeighbour: PKDT50DI32_Node;

  function FindParentNode(const BuffPtr: PKDT50DI32_Vec; NodePtr: PKDT50DI32_Node): PKDT50DI32_Node;
  var
    Next       : PKDT50DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT50DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT50DI32_Node; const BuffPtr: PKDT50DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT50DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT50DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT50DI32_Vec; const p1, p2: PKDT50DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT50DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT50DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT50DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT50DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT50DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT50DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT50DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT50DI32.Search(const Buff: TKDT50DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT50DI32.Search(const Buff: TKDT50DI32_Vec; var SearchedDistanceMin: Double): PKDT50DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT50DI32.Search(const Buff: TKDT50DI32_Vec): PKDT50DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT50DI32.Search(const inBuff: TKDT50DI32_DynamicVecBuffer; var OutBuff: TKDT50DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT50DI32_DynamicVecBuffer;
  outBuffPtr : PKDT50DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT50DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT50DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT50DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT50DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT50DI32_Source));
end;

procedure TKDT50DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT50DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT50DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT50DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT50DI32.PrintNodeTree(const NodePtr: PKDT50DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT50DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT50DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT50DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT50DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT50DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT50DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT50DI32.Test;
var
  TKDT50DI32_Test    : TKDT50DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT50DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT50DI32_Test := TKDT50DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT50DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT50DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT50DI32_AxisCount - 1 do
        TKDT50DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT50DI32_Test.TestBuff), length(TKDT50DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT50DI32_Test.BuildKDTreeM(False, length(TKDT50DI32_Test.TestBuff), @TKDT50DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT50DI32_Test.BuildKDTreeM(False, length(TKDT50DI32_Test.TestBuff), TKDT50DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT50DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT50DI32_Test.TestBuff));
  TKDT50DI32_Test.Search(TKDT50DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT50DI32Distance(TKDT50DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT50DI32_Test.Clear;
  { kMean test }
  TKDT50DI32_Test.BuildKDTreeWithCluster(TKDT50DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT50DI32_Test.Search(TKDT50DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT50DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT50DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT50DI32_Test);
end;

{$ENDIF DEBUG}


function KDT56DI32Vec(const s: string): TKDT56DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT56DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT56DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT56DI32Vec(const v: TKDT56DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT56DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT56DI32Pow(const v: TKDT56DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT56DI32Distance(const v1, v2: TKDT56DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT56DI32_AxisCount - 1 do
      Result := Result + KDT56DI32Pow(v2[i] - v1[i]);
end;

function KDT56DI32Cmpare(const v1, v2: TKDT56DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT56DI32_Vec));
end;

function TKDT56DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DI32_Node;
  function SortCompare(const p1, p2: PKDT56DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT56DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT56DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT56DI32_SourceBuffer;
  dynBuff  : PKDT56DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT56DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT56DI32.SearchStoreBuff(const StoreBuffPtr: PKDT56DI32yanmicStoreBuffer; const Buff: TKDT56DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT56DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT56DI32.GetData(const index: NativeInt): PKDT56DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT56DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT56DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT56DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT56DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT56DI32.StoreBuffPtr: PKDT56DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT56DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT56DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT56DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT56DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT56DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT56DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT56DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT56DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT56DI32.BuildKDTreeWithCluster(const inBuff: TKDT56DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT56DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT56DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT56DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT56DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT56DI32.BuildKDTreeWithCluster(const inBuff: TKDT56DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT56DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI32_BuildCall);
var
  TempStoreBuff: TKDT56DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT56DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT56DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT56DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT56DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT56DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI32_BuildMethod);
var
  TempStoreBuff: TKDT56DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT56DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT56DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT56DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT56DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI32_BuildProc);
var
  TempStoreBuff: TKDT56DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT56DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT56DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT56DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT56DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT56DI32.Search(const Buff: TKDT56DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DI32_Node;

var
  NearestNeighbour: PKDT56DI32_Node;

  function FindParentNode(const BuffPtr: PKDT56DI32_Vec; NodePtr: PKDT56DI32_Node): PKDT56DI32_Node;
  var
    Next       : PKDT56DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT56DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT56DI32_Node; const BuffPtr: PKDT56DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT56DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT56DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT56DI32_Vec; const p1, p2: PKDT56DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT56DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT56DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT56DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT56DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT56DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT56DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT56DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT56DI32.Search(const Buff: TKDT56DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT56DI32.Search(const Buff: TKDT56DI32_Vec; var SearchedDistanceMin: Double): PKDT56DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT56DI32.Search(const Buff: TKDT56DI32_Vec): PKDT56DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT56DI32.Search(const inBuff: TKDT56DI32_DynamicVecBuffer; var OutBuff: TKDT56DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT56DI32_DynamicVecBuffer;
  outBuffPtr : PKDT56DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT56DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT56DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT56DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT56DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT56DI32_Source));
end;

procedure TKDT56DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT56DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT56DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT56DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT56DI32.PrintNodeTree(const NodePtr: PKDT56DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT56DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT56DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT56DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT56DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT56DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT56DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT56DI32.Test;
var
  TKDT56DI32_Test    : TKDT56DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT56DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT56DI32_Test := TKDT56DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT56DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT56DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT56DI32_AxisCount - 1 do
        TKDT56DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT56DI32_Test.TestBuff), length(TKDT56DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT56DI32_Test.BuildKDTreeM(False, length(TKDT56DI32_Test.TestBuff), @TKDT56DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT56DI32_Test.BuildKDTreeM(False, length(TKDT56DI32_Test.TestBuff), TKDT56DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT56DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT56DI32_Test.TestBuff));
  TKDT56DI32_Test.Search(TKDT56DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT56DI32Distance(TKDT56DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT56DI32_Test.Clear;
  { kMean test }
  TKDT56DI32_Test.BuildKDTreeWithCluster(TKDT56DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT56DI32_Test.Search(TKDT56DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT56DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT56DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT56DI32_Test);
end;

{$ENDIF DEBUG}


function KDT60DI32Vec(const s: string): TKDT60DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT60DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT60DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT60DI32Vec(const v: TKDT60DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT60DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT60DI32Pow(const v: TKDT60DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT60DI32Distance(const v1, v2: TKDT60DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT60DI32_AxisCount - 1 do
      Result := Result + KDT60DI32Pow(v2[i] - v1[i]);
end;

function KDT60DI32Cmpare(const v1, v2: TKDT60DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT60DI32_Vec));
end;

function TKDT60DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DI32_Node;
  function SortCompare(const p1, p2: PKDT60DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT60DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT60DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT60DI32_SourceBuffer;
  dynBuff  : PKDT60DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT60DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT60DI32.SearchStoreBuff(const StoreBuffPtr: PKDT60DI32yanmicStoreBuffer; const Buff: TKDT60DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT60DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT60DI32.GetData(const index: NativeInt): PKDT60DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT60DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT60DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT60DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT60DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT60DI32.StoreBuffPtr: PKDT60DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT60DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT60DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT60DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT60DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT60DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT60DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT60DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT60DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT60DI32.BuildKDTreeWithCluster(const inBuff: TKDT60DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT60DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT60DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT60DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT60DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT60DI32.BuildKDTreeWithCluster(const inBuff: TKDT60DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT60DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI32_BuildCall);
var
  TempStoreBuff: TKDT60DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT60DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT60DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT60DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT60DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT60DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI32_BuildMethod);
var
  TempStoreBuff: TKDT60DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT60DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT60DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT60DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT60DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI32_BuildProc);
var
  TempStoreBuff: TKDT60DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT60DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT60DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT60DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT60DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT60DI32.Search(const Buff: TKDT60DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DI32_Node;

var
  NearestNeighbour: PKDT60DI32_Node;

  function FindParentNode(const BuffPtr: PKDT60DI32_Vec; NodePtr: PKDT60DI32_Node): PKDT60DI32_Node;
  var
    Next       : PKDT60DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT60DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT60DI32_Node; const BuffPtr: PKDT60DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT60DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT60DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT60DI32_Vec; const p1, p2: PKDT60DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT60DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT60DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT60DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT60DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT60DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT60DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT60DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT60DI32.Search(const Buff: TKDT60DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT60DI32.Search(const Buff: TKDT60DI32_Vec; var SearchedDistanceMin: Double): PKDT60DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT60DI32.Search(const Buff: TKDT60DI32_Vec): PKDT60DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT60DI32.Search(const inBuff: TKDT60DI32_DynamicVecBuffer; var OutBuff: TKDT60DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT60DI32_DynamicVecBuffer;
  outBuffPtr : PKDT60DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT60DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT60DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT60DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT60DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT60DI32_Source));
end;

procedure TKDT60DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT60DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT60DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT60DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT60DI32.PrintNodeTree(const NodePtr: PKDT60DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT60DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT60DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT60DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT60DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT60DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT60DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT60DI32.Test;
var
  TKDT60DI32_Test    : TKDT60DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT60DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT60DI32_Test := TKDT60DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT60DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT60DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT60DI32_AxisCount - 1 do
        TKDT60DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT60DI32_Test.TestBuff), length(TKDT60DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT60DI32_Test.BuildKDTreeM(False, length(TKDT60DI32_Test.TestBuff), @TKDT60DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT60DI32_Test.BuildKDTreeM(False, length(TKDT60DI32_Test.TestBuff), TKDT60DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT60DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT60DI32_Test.TestBuff));
  TKDT60DI32_Test.Search(TKDT60DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT60DI32Distance(TKDT60DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT60DI32_Test.Clear;
  { kMean test }
  TKDT60DI32_Test.BuildKDTreeWithCluster(TKDT60DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT60DI32_Test.Search(TKDT60DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT60DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT60DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT60DI32_Test);
end;

{$ENDIF DEBUG}


function KDT64DI32Vec(const s: string): TKDT64DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT64DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT64DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT64DI32Vec(const v: TKDT64DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT64DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT64DI32Pow(const v: TKDT64DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT64DI32Distance(const v1, v2: TKDT64DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT64DI32_AxisCount - 1 do
      Result := Result + KDT64DI32Pow(v2[i] - v1[i]);
end;

function KDT64DI32Cmpare(const v1, v2: TKDT64DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT64DI32_Vec));
end;

function TKDT64DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DI32_Node;
  function SortCompare(const p1, p2: PKDT64DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT64DI32_SourceBuffer;
  dynBuff  : PKDT64DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT64DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DI32.SearchStoreBuff(const StoreBuffPtr: PKDT64DI32yanmicStoreBuffer; const Buff: TKDT64DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT64DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT64DI32.GetData(const index: NativeInt): PKDT64DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT64DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DI32.StoreBuffPtr: PKDT64DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT64DI32.BuildKDTreeWithCluster(const inBuff: TKDT64DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT64DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT64DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT64DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DI32.BuildKDTreeWithCluster(const inBuff: TKDT64DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI32_BuildCall);
var
  TempStoreBuff: TKDT64DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI32_BuildMethod);
var
  TempStoreBuff: TKDT64DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI32_BuildProc);
var
  TempStoreBuff: TKDT64DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT64DI32.Search(const Buff: TKDT64DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DI32_Node;

var
  NearestNeighbour: PKDT64DI32_Node;

  function FindParentNode(const BuffPtr: PKDT64DI32_Vec; NodePtr: PKDT64DI32_Node): PKDT64DI32_Node;
  var
    Next       : PKDT64DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT64DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DI32_Node; const BuffPtr: PKDT64DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT64DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT64DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT64DI32_Vec; const p1, p2: PKDT64DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT64DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT64DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT64DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT64DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT64DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT64DI32.Search(const Buff: TKDT64DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DI32.Search(const Buff: TKDT64DI32_Vec; var SearchedDistanceMin: Double): PKDT64DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DI32.Search(const Buff: TKDT64DI32_Vec): PKDT64DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT64DI32.Search(const inBuff: TKDT64DI32_DynamicVecBuffer; var OutBuff: TKDT64DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DI32_DynamicVecBuffer;
  outBuffPtr : PKDT64DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT64DI32_Source));
end;

procedure TKDT64DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT64DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT64DI32.PrintNodeTree(const NodePtr: PKDT64DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT64DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT64DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT64DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT64DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT64DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT64DI32.Test;
var
  TKDT64DI32_Test    : TKDT64DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT64DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT64DI32_Test := TKDT64DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT64DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT64DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT64DI32_AxisCount - 1 do
        TKDT64DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT64DI32_Test.TestBuff), length(TKDT64DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT64DI32_Test.BuildKDTreeM(False, length(TKDT64DI32_Test.TestBuff), @TKDT64DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT64DI32_Test.BuildKDTreeM(False, length(TKDT64DI32_Test.TestBuff), TKDT64DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT64DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT64DI32_Test.TestBuff));
  TKDT64DI32_Test.Search(TKDT64DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT64DI32Distance(TKDT64DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT64DI32_Test.Clear;
  { kMean test }
  TKDT64DI32_Test.BuildKDTreeWithCluster(TKDT64DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT64DI32_Test.Search(TKDT64DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT64DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT64DI32_Test);
end;

{$ENDIF DEBUG}


function KDT72DI32Vec(const s: string): TKDT72DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT72DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT72DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT72DI32Vec(const v: TKDT72DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT72DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT72DI32Pow(const v: TKDT72DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT72DI32Distance(const v1, v2: TKDT72DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT72DI32_AxisCount - 1 do
      Result := Result + KDT72DI32Pow(v2[i] - v1[i]);
end;

function KDT72DI32Cmpare(const v1, v2: TKDT72DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT72DI32_Vec));
end;

function TKDT72DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DI32_Node;
  function SortCompare(const p1, p2: PKDT72DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT72DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT72DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT72DI32_SourceBuffer;
  dynBuff  : PKDT72DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT72DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT72DI32.SearchStoreBuff(const StoreBuffPtr: PKDT72DI32yanmicStoreBuffer; const Buff: TKDT72DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT72DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT72DI32.GetData(const index: NativeInt): PKDT72DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT72DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT72DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT72DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT72DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT72DI32.StoreBuffPtr: PKDT72DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT72DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT72DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT72DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT72DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT72DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT72DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT72DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT72DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT72DI32.BuildKDTreeWithCluster(const inBuff: TKDT72DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT72DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT72DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT72DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT72DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT72DI32.BuildKDTreeWithCluster(const inBuff: TKDT72DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT72DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI32_BuildCall);
var
  TempStoreBuff: TKDT72DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT72DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT72DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT72DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT72DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT72DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI32_BuildMethod);
var
  TempStoreBuff: TKDT72DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT72DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT72DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT72DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT72DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI32_BuildProc);
var
  TempStoreBuff: TKDT72DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT72DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT72DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT72DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT72DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT72DI32.Search(const Buff: TKDT72DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DI32_Node;

var
  NearestNeighbour: PKDT72DI32_Node;

  function FindParentNode(const BuffPtr: PKDT72DI32_Vec; NodePtr: PKDT72DI32_Node): PKDT72DI32_Node;
  var
    Next       : PKDT72DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT72DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT72DI32_Node; const BuffPtr: PKDT72DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT72DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT72DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT72DI32_Vec; const p1, p2: PKDT72DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT72DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT72DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT72DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT72DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT72DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT72DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT72DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT72DI32.Search(const Buff: TKDT72DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT72DI32.Search(const Buff: TKDT72DI32_Vec; var SearchedDistanceMin: Double): PKDT72DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT72DI32.Search(const Buff: TKDT72DI32_Vec): PKDT72DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT72DI32.Search(const inBuff: TKDT72DI32_DynamicVecBuffer; var OutBuff: TKDT72DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT72DI32_DynamicVecBuffer;
  outBuffPtr : PKDT72DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT72DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT72DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT72DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT72DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT72DI32_Source));
end;

procedure TKDT72DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT72DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT72DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT72DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT72DI32.PrintNodeTree(const NodePtr: PKDT72DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT72DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT72DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT72DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT72DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT72DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT72DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT72DI32.Test;
var
  TKDT72DI32_Test    : TKDT72DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT72DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT72DI32_Test := TKDT72DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT72DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT72DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT72DI32_AxisCount - 1 do
        TKDT72DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT72DI32_Test.TestBuff), length(TKDT72DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT72DI32_Test.BuildKDTreeM(False, length(TKDT72DI32_Test.TestBuff), @TKDT72DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT72DI32_Test.BuildKDTreeM(False, length(TKDT72DI32_Test.TestBuff), TKDT72DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT72DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT72DI32_Test.TestBuff));
  TKDT72DI32_Test.Search(TKDT72DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT72DI32Distance(TKDT72DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT72DI32_Test.Clear;
  { kMean test }
  TKDT72DI32_Test.BuildKDTreeWithCluster(TKDT72DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT72DI32_Test.Search(TKDT72DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT72DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT72DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT72DI32_Test);
end;

{$ENDIF DEBUG}


function KDT84DI32Vec(const s: string): TKDT84DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT84DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT84DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT84DI32Vec(const v: TKDT84DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT84DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT84DI32Pow(const v: TKDT84DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT84DI32Distance(const v1, v2: TKDT84DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT84DI32_AxisCount - 1 do
      Result := Result + KDT84DI32Pow(v2[i] - v1[i]);
end;

function KDT84DI32Cmpare(const v1, v2: TKDT84DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT84DI32_Vec));
end;

function TKDT84DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DI32_Node;
  function SortCompare(const p1, p2: PKDT84DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT84DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT84DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT84DI32_SourceBuffer;
  dynBuff  : PKDT84DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT84DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT84DI32.SearchStoreBuff(const StoreBuffPtr: PKDT84DI32yanmicStoreBuffer; const Buff: TKDT84DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT84DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT84DI32.GetData(const index: NativeInt): PKDT84DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT84DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT84DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT84DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT84DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT84DI32.StoreBuffPtr: PKDT84DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT84DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT84DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT84DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT84DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT84DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT84DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT84DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT84DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT84DI32.BuildKDTreeWithCluster(const inBuff: TKDT84DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT84DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT84DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT84DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT84DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT84DI32.BuildKDTreeWithCluster(const inBuff: TKDT84DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT84DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI32_BuildCall);
var
  TempStoreBuff: TKDT84DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT84DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT84DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT84DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT84DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT84DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI32_BuildMethod);
var
  TempStoreBuff: TKDT84DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT84DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT84DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT84DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT84DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI32_BuildProc);
var
  TempStoreBuff: TKDT84DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT84DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT84DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT84DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT84DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT84DI32.Search(const Buff: TKDT84DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DI32_Node;

var
  NearestNeighbour: PKDT84DI32_Node;

  function FindParentNode(const BuffPtr: PKDT84DI32_Vec; NodePtr: PKDT84DI32_Node): PKDT84DI32_Node;
  var
    Next       : PKDT84DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT84DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT84DI32_Node; const BuffPtr: PKDT84DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT84DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT84DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT84DI32_Vec; const p1, p2: PKDT84DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT84DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT84DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT84DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT84DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT84DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT84DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT84DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT84DI32.Search(const Buff: TKDT84DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT84DI32.Search(const Buff: TKDT84DI32_Vec; var SearchedDistanceMin: Double): PKDT84DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT84DI32.Search(const Buff: TKDT84DI32_Vec): PKDT84DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT84DI32.Search(const inBuff: TKDT84DI32_DynamicVecBuffer; var OutBuff: TKDT84DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT84DI32_DynamicVecBuffer;
  outBuffPtr : PKDT84DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT84DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT84DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT84DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT84DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT84DI32_Source));
end;

procedure TKDT84DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT84DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT84DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT84DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT84DI32.PrintNodeTree(const NodePtr: PKDT84DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT84DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT84DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT84DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT84DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT84DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT84DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT84DI32.Test;
var
  TKDT84DI32_Test    : TKDT84DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT84DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT84DI32_Test := TKDT84DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT84DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT84DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT84DI32_AxisCount - 1 do
        TKDT84DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT84DI32_Test.TestBuff), length(TKDT84DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT84DI32_Test.BuildKDTreeM(False, length(TKDT84DI32_Test.TestBuff), @TKDT84DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT84DI32_Test.BuildKDTreeM(False, length(TKDT84DI32_Test.TestBuff), TKDT84DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT84DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT84DI32_Test.TestBuff));
  TKDT84DI32_Test.Search(TKDT84DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT84DI32Distance(TKDT84DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT84DI32_Test.Clear;
  { kMean test }
  TKDT84DI32_Test.BuildKDTreeWithCluster(TKDT84DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT84DI32_Test.Search(TKDT84DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT84DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT84DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT84DI32_Test);
end;

{$ENDIF DEBUG}


function KDT96DI32Vec(const s: string): TKDT96DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT96DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT96DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT96DI32Vec(const v: TKDT96DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT96DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT96DI32Pow(const v: TKDT96DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT96DI32Distance(const v1, v2: TKDT96DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT96DI32_AxisCount - 1 do
      Result := Result + KDT96DI32Pow(v2[i] - v1[i]);
end;

function KDT96DI32Cmpare(const v1, v2: TKDT96DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT96DI32_Vec));
end;

function TKDT96DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DI32_Node;
  function SortCompare(const p1, p2: PKDT96DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT96DI32_SourceBuffer;
  dynBuff  : PKDT96DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT96DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DI32.SearchStoreBuff(const StoreBuffPtr: PKDT96DI32yanmicStoreBuffer; const Buff: TKDT96DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT96DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT96DI32.GetData(const index: NativeInt): PKDT96DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT96DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DI32.StoreBuffPtr: PKDT96DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT96DI32.BuildKDTreeWithCluster(const inBuff: TKDT96DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT96DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT96DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT96DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DI32.BuildKDTreeWithCluster(const inBuff: TKDT96DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI32_BuildCall);
var
  TempStoreBuff: TKDT96DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI32_BuildMethod);
var
  TempStoreBuff: TKDT96DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI32_BuildProc);
var
  TempStoreBuff: TKDT96DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT96DI32.Search(const Buff: TKDT96DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DI32_Node;

var
  NearestNeighbour: PKDT96DI32_Node;

  function FindParentNode(const BuffPtr: PKDT96DI32_Vec; NodePtr: PKDT96DI32_Node): PKDT96DI32_Node;
  var
    Next       : PKDT96DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT96DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DI32_Node; const BuffPtr: PKDT96DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT96DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT96DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT96DI32_Vec; const p1, p2: PKDT96DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT96DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT96DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT96DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT96DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT96DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT96DI32.Search(const Buff: TKDT96DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DI32.Search(const Buff: TKDT96DI32_Vec; var SearchedDistanceMin: Double): PKDT96DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DI32.Search(const Buff: TKDT96DI32_Vec): PKDT96DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT96DI32.Search(const inBuff: TKDT96DI32_DynamicVecBuffer; var OutBuff: TKDT96DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DI32_DynamicVecBuffer;
  outBuffPtr : PKDT96DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT96DI32_Source));
end;

procedure TKDT96DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT96DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT96DI32.PrintNodeTree(const NodePtr: PKDT96DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT96DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT96DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT96DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT96DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT96DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT96DI32.Test;
var
  TKDT96DI32_Test    : TKDT96DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT96DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT96DI32_Test := TKDT96DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT96DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT96DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT96DI32_AxisCount - 1 do
        TKDT96DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT96DI32_Test.TestBuff), length(TKDT96DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT96DI32_Test.BuildKDTreeM(False, length(TKDT96DI32_Test.TestBuff), @TKDT96DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT96DI32_Test.BuildKDTreeM(False, length(TKDT96DI32_Test.TestBuff), TKDT96DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT96DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT96DI32_Test.TestBuff));
  TKDT96DI32_Test.Search(TKDT96DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT96DI32Distance(TKDT96DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT96DI32_Test.Clear;
  { kMean test }
  TKDT96DI32_Test.BuildKDTreeWithCluster(TKDT96DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT96DI32_Test.Search(TKDT96DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT96DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT96DI32_Test);
end;

{$ENDIF DEBUG}


function KDT128DI32Vec(const s: string): TKDT128DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT128DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT128DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT128DI32Vec(const v: TKDT128DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT128DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT128DI32Pow(const v: TKDT128DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT128DI32Distance(const v1, v2: TKDT128DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT128DI32_AxisCount - 1 do
      Result := Result + KDT128DI32Pow(v2[i] - v1[i]);
end;

function KDT128DI32Cmpare(const v1, v2: TKDT128DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT128DI32_Vec));
end;

function TKDT128DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DI32_Node;
  function SortCompare(const p1, p2: PKDT128DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT128DI32_SourceBuffer;
  dynBuff  : PKDT128DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT128DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DI32.SearchStoreBuff(const StoreBuffPtr: PKDT128DI32yanmicStoreBuffer; const Buff: TKDT128DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT128DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT128DI32.GetData(const index: NativeInt): PKDT128DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT128DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DI32.StoreBuffPtr: PKDT128DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT128DI32.BuildKDTreeWithCluster(const inBuff: TKDT128DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT128DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT128DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT128DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DI32.BuildKDTreeWithCluster(const inBuff: TKDT128DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI32_BuildCall);
var
  TempStoreBuff: TKDT128DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI32_BuildMethod);
var
  TempStoreBuff: TKDT128DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI32_BuildProc);
var
  TempStoreBuff: TKDT128DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT128DI32.Search(const Buff: TKDT128DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DI32_Node;

var
  NearestNeighbour: PKDT128DI32_Node;

  function FindParentNode(const BuffPtr: PKDT128DI32_Vec; NodePtr: PKDT128DI32_Node): PKDT128DI32_Node;
  var
    Next       : PKDT128DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT128DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DI32_Node; const BuffPtr: PKDT128DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT128DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT128DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT128DI32_Vec; const p1, p2: PKDT128DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT128DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT128DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT128DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT128DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT128DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT128DI32.Search(const Buff: TKDT128DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DI32.Search(const Buff: TKDT128DI32_Vec; var SearchedDistanceMin: Double): PKDT128DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DI32.Search(const Buff: TKDT128DI32_Vec): PKDT128DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT128DI32.Search(const inBuff: TKDT128DI32_DynamicVecBuffer; var OutBuff: TKDT128DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DI32_DynamicVecBuffer;
  outBuffPtr : PKDT128DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT128DI32_Source));
end;

procedure TKDT128DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT128DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT128DI32.PrintNodeTree(const NodePtr: PKDT128DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT128DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT128DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT128DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT128DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT128DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT128DI32.Test;
var
  TKDT128DI32_Test    : TKDT128DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT128DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT128DI32_Test := TKDT128DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT128DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT128DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT128DI32_AxisCount - 1 do
        TKDT128DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT128DI32_Test.TestBuff), length(TKDT128DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT128DI32_Test.BuildKDTreeM(False, length(TKDT128DI32_Test.TestBuff), @TKDT128DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT128DI32_Test.BuildKDTreeM(False, length(TKDT128DI32_Test.TestBuff), TKDT128DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT128DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT128DI32_Test.TestBuff));
  TKDT128DI32_Test.Search(TKDT128DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT128DI32Distance(TKDT128DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT128DI32_Test.Clear;
  { kMean test }
  TKDT128DI32_Test.BuildKDTreeWithCluster(TKDT128DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT128DI32_Test.Search(TKDT128DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT128DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT128DI32_Test);
end;

{$ENDIF DEBUG}


function KDT140DI32Vec(const s: string): TKDT140DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT140DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT140DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT140DI32Vec(const v: TKDT140DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT140DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT140DI32Pow(const v: TKDT140DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT140DI32Distance(const v1, v2: TKDT140DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT140DI32_AxisCount - 1 do
      Result := Result + KDT140DI32Pow(v2[i] - v1[i]);
end;

function KDT140DI32Cmpare(const v1, v2: TKDT140DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT140DI32_Vec));
end;

function TKDT140DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DI32_Node;
  function SortCompare(const p1, p2: PKDT140DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT140DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT140DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT140DI32_SourceBuffer;
  dynBuff  : PKDT140DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT140DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT140DI32.SearchStoreBuff(const StoreBuffPtr: PKDT140DI32yanmicStoreBuffer; const Buff: TKDT140DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT140DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT140DI32.GetData(const index: NativeInt): PKDT140DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT140DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT140DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT140DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT140DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT140DI32.StoreBuffPtr: PKDT140DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT140DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT140DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT140DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT140DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT140DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT140DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT140DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT140DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT140DI32.BuildKDTreeWithCluster(const inBuff: TKDT140DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT140DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT140DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT140DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT140DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT140DI32.BuildKDTreeWithCluster(const inBuff: TKDT140DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT140DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI32_BuildCall);
var
  TempStoreBuff: TKDT140DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT140DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT140DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT140DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT140DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT140DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI32_BuildMethod);
var
  TempStoreBuff: TKDT140DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT140DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT140DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT140DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT140DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI32_BuildProc);
var
  TempStoreBuff: TKDT140DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT140DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT140DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT140DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT140DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT140DI32.Search(const Buff: TKDT140DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DI32_Node;

var
  NearestNeighbour: PKDT140DI32_Node;

  function FindParentNode(const BuffPtr: PKDT140DI32_Vec; NodePtr: PKDT140DI32_Node): PKDT140DI32_Node;
  var
    Next       : PKDT140DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT140DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT140DI32_Node; const BuffPtr: PKDT140DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT140DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT140DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT140DI32_Vec; const p1, p2: PKDT140DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT140DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT140DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT140DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT140DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT140DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT140DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT140DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT140DI32.Search(const Buff: TKDT140DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT140DI32.Search(const Buff: TKDT140DI32_Vec; var SearchedDistanceMin: Double): PKDT140DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT140DI32.Search(const Buff: TKDT140DI32_Vec): PKDT140DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT140DI32.Search(const inBuff: TKDT140DI32_DynamicVecBuffer; var OutBuff: TKDT140DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT140DI32_DynamicVecBuffer;
  outBuffPtr : PKDT140DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT140DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT140DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT140DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT140DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT140DI32_Source));
end;

procedure TKDT140DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT140DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT140DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT140DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT140DI32.PrintNodeTree(const NodePtr: PKDT140DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT140DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT140DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT140DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT140DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT140DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT140DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT140DI32.Test;
var
  TKDT140DI32_Test    : TKDT140DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT140DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT140DI32_Test := TKDT140DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT140DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT140DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT140DI32_AxisCount - 1 do
        TKDT140DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT140DI32_Test.TestBuff), length(TKDT140DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT140DI32_Test.BuildKDTreeM(False, length(TKDT140DI32_Test.TestBuff), @TKDT140DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT140DI32_Test.BuildKDTreeM(False, length(TKDT140DI32_Test.TestBuff), TKDT140DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT140DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT140DI32_Test.TestBuff));
  TKDT140DI32_Test.Search(TKDT140DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT140DI32Distance(TKDT140DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT140DI32_Test.Clear;
  { kMean test }
  TKDT140DI32_Test.BuildKDTreeWithCluster(TKDT140DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT140DI32_Test.Search(TKDT140DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT140DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT140DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT140DI32_Test);
end;

{$ENDIF DEBUG}


function KDT160DI32Vec(const s: string): TKDT160DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT160DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT160DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT160DI32Vec(const v: TKDT160DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT160DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT160DI32Pow(const v: TKDT160DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT160DI32Distance(const v1, v2: TKDT160DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT160DI32_AxisCount - 1 do
      Result := Result + KDT160DI32Pow(v2[i] - v1[i]);
end;

function KDT160DI32Cmpare(const v1, v2: TKDT160DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT160DI32_Vec));
end;

function TKDT160DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DI32_Node;
  function SortCompare(const p1, p2: PKDT160DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT160DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT160DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT160DI32_SourceBuffer;
  dynBuff  : PKDT160DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT160DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT160DI32.SearchStoreBuff(const StoreBuffPtr: PKDT160DI32yanmicStoreBuffer; const Buff: TKDT160DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT160DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT160DI32.GetData(const index: NativeInt): PKDT160DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT160DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT160DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT160DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT160DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT160DI32.StoreBuffPtr: PKDT160DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT160DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT160DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT160DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT160DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT160DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT160DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT160DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT160DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT160DI32.BuildKDTreeWithCluster(const inBuff: TKDT160DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT160DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT160DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT160DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT160DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT160DI32.BuildKDTreeWithCluster(const inBuff: TKDT160DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT160DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI32_BuildCall);
var
  TempStoreBuff: TKDT160DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT160DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT160DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT160DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT160DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT160DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI32_BuildMethod);
var
  TempStoreBuff: TKDT160DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT160DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT160DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT160DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT160DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI32_BuildProc);
var
  TempStoreBuff: TKDT160DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT160DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT160DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT160DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT160DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT160DI32.Search(const Buff: TKDT160DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DI32_Node;

var
  NearestNeighbour: PKDT160DI32_Node;

  function FindParentNode(const BuffPtr: PKDT160DI32_Vec; NodePtr: PKDT160DI32_Node): PKDT160DI32_Node;
  var
    Next       : PKDT160DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT160DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT160DI32_Node; const BuffPtr: PKDT160DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT160DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT160DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT160DI32_Vec; const p1, p2: PKDT160DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT160DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT160DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT160DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT160DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT160DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT160DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT160DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT160DI32.Search(const Buff: TKDT160DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT160DI32.Search(const Buff: TKDT160DI32_Vec; var SearchedDistanceMin: Double): PKDT160DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT160DI32.Search(const Buff: TKDT160DI32_Vec): PKDT160DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT160DI32.Search(const inBuff: TKDT160DI32_DynamicVecBuffer; var OutBuff: TKDT160DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT160DI32_DynamicVecBuffer;
  outBuffPtr : PKDT160DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT160DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT160DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT160DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT160DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT160DI32_Source));
end;

procedure TKDT160DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT160DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT160DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT160DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT160DI32.PrintNodeTree(const NodePtr: PKDT160DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT160DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT160DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT160DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT160DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT160DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT160DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT160DI32.Test;
var
  TKDT160DI32_Test    : TKDT160DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT160DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT160DI32_Test := TKDT160DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT160DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT160DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT160DI32_AxisCount - 1 do
        TKDT160DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT160DI32_Test.TestBuff), length(TKDT160DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT160DI32_Test.BuildKDTreeM(False, length(TKDT160DI32_Test.TestBuff), @TKDT160DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT160DI32_Test.BuildKDTreeM(False, length(TKDT160DI32_Test.TestBuff), TKDT160DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT160DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT160DI32_Test.TestBuff));
  TKDT160DI32_Test.Search(TKDT160DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT160DI32Distance(TKDT160DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT160DI32_Test.Clear;
  { kMean test }
  TKDT160DI32_Test.BuildKDTreeWithCluster(TKDT160DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT160DI32_Test.Search(TKDT160DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT160DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT160DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT160DI32_Test);
end;

{$ENDIF DEBUG}


function KDT196DI32Vec(const s: string): TKDT196DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT196DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT196DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT196DI32Vec(const v: TKDT196DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT196DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT196DI32Pow(const v: TKDT196DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT196DI32Distance(const v1, v2: TKDT196DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT196DI32_AxisCount - 1 do
      Result := Result + KDT196DI32Pow(v2[i] - v1[i]);
end;

function KDT196DI32Cmpare(const v1, v2: TKDT196DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT196DI32_Vec));
end;

function TKDT196DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DI32_Node;
  function SortCompare(const p1, p2: PKDT196DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT196DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT196DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT196DI32_SourceBuffer;
  dynBuff  : PKDT196DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT196DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT196DI32.SearchStoreBuff(const StoreBuffPtr: PKDT196DI32yanmicStoreBuffer; const Buff: TKDT196DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT196DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT196DI32.GetData(const index: NativeInt): PKDT196DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT196DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT196DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT196DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT196DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT196DI32.StoreBuffPtr: PKDT196DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT196DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT196DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT196DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT196DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT196DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT196DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT196DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT196DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT196DI32.BuildKDTreeWithCluster(const inBuff: TKDT196DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT196DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT196DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT196DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT196DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT196DI32.BuildKDTreeWithCluster(const inBuff: TKDT196DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT196DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI32_BuildCall);
var
  TempStoreBuff: TKDT196DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT196DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT196DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT196DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT196DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT196DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI32_BuildMethod);
var
  TempStoreBuff: TKDT196DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT196DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT196DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT196DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT196DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI32_BuildProc);
var
  TempStoreBuff: TKDT196DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT196DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT196DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT196DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT196DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT196DI32.Search(const Buff: TKDT196DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DI32_Node;

var
  NearestNeighbour: PKDT196DI32_Node;

  function FindParentNode(const BuffPtr: PKDT196DI32_Vec; NodePtr: PKDT196DI32_Node): PKDT196DI32_Node;
  var
    Next       : PKDT196DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT196DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT196DI32_Node; const BuffPtr: PKDT196DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT196DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT196DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT196DI32_Vec; const p1, p2: PKDT196DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT196DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT196DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT196DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT196DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT196DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT196DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT196DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT196DI32.Search(const Buff: TKDT196DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT196DI32.Search(const Buff: TKDT196DI32_Vec; var SearchedDistanceMin: Double): PKDT196DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT196DI32.Search(const Buff: TKDT196DI32_Vec): PKDT196DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT196DI32.Search(const inBuff: TKDT196DI32_DynamicVecBuffer; var OutBuff: TKDT196DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT196DI32_DynamicVecBuffer;
  outBuffPtr : PKDT196DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT196DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT196DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT196DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT196DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT196DI32_Source));
end;

procedure TKDT196DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT196DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT196DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT196DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT196DI32.PrintNodeTree(const NodePtr: PKDT196DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT196DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT196DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT196DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT196DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT196DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT196DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT196DI32.Test;
var
  TKDT196DI32_Test    : TKDT196DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT196DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT196DI32_Test := TKDT196DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT196DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT196DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT196DI32_AxisCount - 1 do
        TKDT196DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT196DI32_Test.TestBuff), length(TKDT196DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT196DI32_Test.BuildKDTreeM(False, length(TKDT196DI32_Test.TestBuff), @TKDT196DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT196DI32_Test.BuildKDTreeM(False, length(TKDT196DI32_Test.TestBuff), TKDT196DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT196DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT196DI32_Test.TestBuff));
  TKDT196DI32_Test.Search(TKDT196DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT196DI32Distance(TKDT196DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT196DI32_Test.Clear;
  { kMean test }
  TKDT196DI32_Test.BuildKDTreeWithCluster(TKDT196DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT196DI32_Test.Search(TKDT196DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT196DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT196DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT196DI32_Test);
end;

{$ENDIF DEBUG}


function KDT256DI32Vec(const s: string): TKDT256DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT256DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT256DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT256DI32Vec(const v: TKDT256DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT256DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT256DI32Pow(const v: TKDT256DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT256DI32Distance(const v1, v2: TKDT256DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT256DI32_AxisCount - 1 do
      Result := Result + KDT256DI32Pow(v2[i] - v1[i]);
end;

function KDT256DI32Cmpare(const v1, v2: TKDT256DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT256DI32_Vec));
end;

function TKDT256DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DI32_Node;
  function SortCompare(const p1, p2: PKDT256DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT256DI32_SourceBuffer;
  dynBuff  : PKDT256DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT256DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DI32.SearchStoreBuff(const StoreBuffPtr: PKDT256DI32yanmicStoreBuffer; const Buff: TKDT256DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT256DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT256DI32.GetData(const index: NativeInt): PKDT256DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT256DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DI32.StoreBuffPtr: PKDT256DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT256DI32.BuildKDTreeWithCluster(const inBuff: TKDT256DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT256DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT256DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT256DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DI32.BuildKDTreeWithCluster(const inBuff: TKDT256DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI32_BuildCall);
var
  TempStoreBuff: TKDT256DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI32_BuildMethod);
var
  TempStoreBuff: TKDT256DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI32_BuildProc);
var
  TempStoreBuff: TKDT256DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT256DI32.Search(const Buff: TKDT256DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DI32_Node;

var
  NearestNeighbour: PKDT256DI32_Node;

  function FindParentNode(const BuffPtr: PKDT256DI32_Vec; NodePtr: PKDT256DI32_Node): PKDT256DI32_Node;
  var
    Next       : PKDT256DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT256DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DI32_Node; const BuffPtr: PKDT256DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT256DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT256DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT256DI32_Vec; const p1, p2: PKDT256DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT256DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT256DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT256DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT256DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT256DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT256DI32.Search(const Buff: TKDT256DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DI32.Search(const Buff: TKDT256DI32_Vec; var SearchedDistanceMin: Double): PKDT256DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DI32.Search(const Buff: TKDT256DI32_Vec): PKDT256DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT256DI32.Search(const inBuff: TKDT256DI32_DynamicVecBuffer; var OutBuff: TKDT256DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DI32_DynamicVecBuffer;
  outBuffPtr : PKDT256DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT256DI32_Source));
end;

procedure TKDT256DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT256DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT256DI32.PrintNodeTree(const NodePtr: PKDT256DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT256DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT256DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT256DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT256DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT256DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT256DI32.Test;
var
  TKDT256DI32_Test    : TKDT256DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT256DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT256DI32_Test := TKDT256DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT256DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT256DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT256DI32_AxisCount - 1 do
        TKDT256DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT256DI32_Test.TestBuff), length(TKDT256DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT256DI32_Test.BuildKDTreeM(False, length(TKDT256DI32_Test.TestBuff), @TKDT256DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT256DI32_Test.BuildKDTreeM(False, length(TKDT256DI32_Test.TestBuff), TKDT256DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT256DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT256DI32_Test.TestBuff));
  TKDT256DI32_Test.Search(TKDT256DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT256DI32Distance(TKDT256DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT256DI32_Test.Clear;
  { kMean test }
  TKDT256DI32_Test.BuildKDTreeWithCluster(TKDT256DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT256DI32_Test.Search(TKDT256DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT256DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT256DI32_Test);
end;

{$ENDIF DEBUG}


function KDT272DI32Vec(const s: string): TKDT272DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT272DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT272DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT272DI32Vec(const v: TKDT272DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT272DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT272DI32Pow(const v: TKDT272DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT272DI32Distance(const v1, v2: TKDT272DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT272DI32_AxisCount - 1 do
      Result := Result + KDT272DI32Pow(v2[i] - v1[i]);
end;

function KDT272DI32Cmpare(const v1, v2: TKDT272DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT272DI32_Vec));
end;

function TKDT272DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DI32_Node;
  function SortCompare(const p1, p2: PKDT272DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT272DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT272DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT272DI32_SourceBuffer;
  dynBuff  : PKDT272DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT272DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT272DI32.SearchStoreBuff(const StoreBuffPtr: PKDT272DI32yanmicStoreBuffer; const Buff: TKDT272DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT272DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT272DI32.GetData(const index: NativeInt): PKDT272DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT272DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT272DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT272DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT272DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT272DI32.StoreBuffPtr: PKDT272DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT272DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT272DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT272DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT272DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT272DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT272DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT272DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT272DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT272DI32.BuildKDTreeWithCluster(const inBuff: TKDT272DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT272DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT272DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT272DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT272DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT272DI32.BuildKDTreeWithCluster(const inBuff: TKDT272DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT272DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI32_BuildCall);
var
  TempStoreBuff: TKDT272DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT272DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT272DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT272DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT272DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT272DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI32_BuildMethod);
var
  TempStoreBuff: TKDT272DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT272DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT272DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT272DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT272DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI32_BuildProc);
var
  TempStoreBuff: TKDT272DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT272DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT272DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT272DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT272DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT272DI32.Search(const Buff: TKDT272DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DI32_Node;

var
  NearestNeighbour: PKDT272DI32_Node;

  function FindParentNode(const BuffPtr: PKDT272DI32_Vec; NodePtr: PKDT272DI32_Node): PKDT272DI32_Node;
  var
    Next       : PKDT272DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT272DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT272DI32_Node; const BuffPtr: PKDT272DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT272DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT272DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT272DI32_Vec; const p1, p2: PKDT272DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT272DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT272DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT272DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT272DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT272DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT272DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT272DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT272DI32.Search(const Buff: TKDT272DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT272DI32.Search(const Buff: TKDT272DI32_Vec; var SearchedDistanceMin: Double): PKDT272DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT272DI32.Search(const Buff: TKDT272DI32_Vec): PKDT272DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT272DI32.Search(const inBuff: TKDT272DI32_DynamicVecBuffer; var OutBuff: TKDT272DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT272DI32_DynamicVecBuffer;
  outBuffPtr : PKDT272DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT272DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT272DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT272DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT272DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT272DI32_Source));
end;

procedure TKDT272DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT272DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT272DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT272DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT272DI32.PrintNodeTree(const NodePtr: PKDT272DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT272DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT272DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT272DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT272DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT272DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT272DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT272DI32.Test;
var
  TKDT272DI32_Test    : TKDT272DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT272DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT272DI32_Test := TKDT272DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT272DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT272DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT272DI32_AxisCount - 1 do
        TKDT272DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT272DI32_Test.TestBuff), length(TKDT272DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT272DI32_Test.BuildKDTreeM(False, length(TKDT272DI32_Test.TestBuff), @TKDT272DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT272DI32_Test.BuildKDTreeM(False, length(TKDT272DI32_Test.TestBuff), TKDT272DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT272DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT272DI32_Test.TestBuff));
  TKDT272DI32_Test.Search(TKDT272DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT272DI32Distance(TKDT272DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT272DI32_Test.Clear;
  { kMean test }
  TKDT272DI32_Test.BuildKDTreeWithCluster(TKDT272DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT272DI32_Test.Search(TKDT272DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT272DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT272DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT272DI32_Test);
end;

{$ENDIF DEBUG}


function KDT288DI32Vec(const s: string): TKDT288DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT288DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT288DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT288DI32Vec(const v: TKDT288DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT288DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT288DI32Pow(const v: TKDT288DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT288DI32Distance(const v1, v2: TKDT288DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT288DI32_AxisCount - 1 do
      Result := Result + KDT288DI32Pow(v2[i] - v1[i]);
end;

function KDT288DI32Cmpare(const v1, v2: TKDT288DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT288DI32_Vec));
end;

function TKDT288DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DI32_Node;
  function SortCompare(const p1, p2: PKDT288DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT288DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT288DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT288DI32_SourceBuffer;
  dynBuff  : PKDT288DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT288DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT288DI32.SearchStoreBuff(const StoreBuffPtr: PKDT288DI32yanmicStoreBuffer; const Buff: TKDT288DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT288DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT288DI32.GetData(const index: NativeInt): PKDT288DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT288DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT288DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT288DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT288DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT288DI32.StoreBuffPtr: PKDT288DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT288DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT288DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT288DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT288DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT288DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT288DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT288DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT288DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT288DI32.BuildKDTreeWithCluster(const inBuff: TKDT288DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT288DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT288DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT288DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT288DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT288DI32.BuildKDTreeWithCluster(const inBuff: TKDT288DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT288DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI32_BuildCall);
var
  TempStoreBuff: TKDT288DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT288DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT288DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT288DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT288DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT288DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI32_BuildMethod);
var
  TempStoreBuff: TKDT288DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT288DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT288DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT288DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT288DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI32_BuildProc);
var
  TempStoreBuff: TKDT288DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT288DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT288DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT288DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT288DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT288DI32.Search(const Buff: TKDT288DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DI32_Node;

var
  NearestNeighbour: PKDT288DI32_Node;

  function FindParentNode(const BuffPtr: PKDT288DI32_Vec; NodePtr: PKDT288DI32_Node): PKDT288DI32_Node;
  var
    Next       : PKDT288DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT288DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT288DI32_Node; const BuffPtr: PKDT288DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT288DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT288DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT288DI32_Vec; const p1, p2: PKDT288DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT288DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT288DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT288DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT288DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT288DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT288DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT288DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT288DI32.Search(const Buff: TKDT288DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT288DI32.Search(const Buff: TKDT288DI32_Vec; var SearchedDistanceMin: Double): PKDT288DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT288DI32.Search(const Buff: TKDT288DI32_Vec): PKDT288DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT288DI32.Search(const inBuff: TKDT288DI32_DynamicVecBuffer; var OutBuff: TKDT288DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT288DI32_DynamicVecBuffer;
  outBuffPtr : PKDT288DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT288DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT288DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT288DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT288DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT288DI32_Source));
end;

procedure TKDT288DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT288DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT288DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT288DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT288DI32.PrintNodeTree(const NodePtr: PKDT288DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT288DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT288DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT288DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT288DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT288DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT288DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT288DI32.Test;
var
  TKDT288DI32_Test    : TKDT288DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT288DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT288DI32_Test := TKDT288DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT288DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT288DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT288DI32_AxisCount - 1 do
        TKDT288DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT288DI32_Test.TestBuff), length(TKDT288DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT288DI32_Test.BuildKDTreeM(False, length(TKDT288DI32_Test.TestBuff), @TKDT288DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT288DI32_Test.BuildKDTreeM(False, length(TKDT288DI32_Test.TestBuff), TKDT288DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT288DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT288DI32_Test.TestBuff));
  TKDT288DI32_Test.Search(TKDT288DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT288DI32Distance(TKDT288DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT288DI32_Test.Clear;
  { kMean test }
  TKDT288DI32_Test.BuildKDTreeWithCluster(TKDT288DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT288DI32_Test.Search(TKDT288DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT288DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT288DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT288DI32_Test);
end;

{$ENDIF DEBUG}


function KDT372DI32Vec(const s: string): TKDT372DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT372DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT372DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT372DI32Vec(const v: TKDT372DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT372DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT372DI32Pow(const v: TKDT372DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT372DI32Distance(const v1, v2: TKDT372DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT372DI32_AxisCount - 1 do
      Result := Result + KDT372DI32Pow(v2[i] - v1[i]);
end;

function KDT372DI32Cmpare(const v1, v2: TKDT372DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT372DI32_Vec));
end;

function TKDT372DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DI32_Node;
  function SortCompare(const p1, p2: PKDT372DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT372DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT372DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT372DI32_SourceBuffer;
  dynBuff  : PKDT372DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT372DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT372DI32.SearchStoreBuff(const StoreBuffPtr: PKDT372DI32yanmicStoreBuffer; const Buff: TKDT372DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT372DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT372DI32.GetData(const index: NativeInt): PKDT372DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT372DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT372DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT372DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT372DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT372DI32.StoreBuffPtr: PKDT372DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT372DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT372DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT372DI32.BuildKDTreeWithCluster(const inBuff: TKDT372DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT372DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT372DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT372DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT372DI32.BuildKDTreeWithCluster(const inBuff: TKDT372DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI32_BuildCall);
var
  TempStoreBuff: TKDT372DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI32_BuildMethod);
var
  TempStoreBuff: TKDT372DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI32_BuildProc);
var
  TempStoreBuff: TKDT372DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT372DI32.Search(const Buff: TKDT372DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DI32_Node;

var
  NearestNeighbour: PKDT372DI32_Node;

  function FindParentNode(const BuffPtr: PKDT372DI32_Vec; NodePtr: PKDT372DI32_Node): PKDT372DI32_Node;
  var
    Next       : PKDT372DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT372DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT372DI32_Node; const BuffPtr: PKDT372DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT372DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT372DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT372DI32_Vec; const p1, p2: PKDT372DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT372DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT372DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT372DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT372DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT372DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT372DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT372DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT372DI32.Search(const Buff: TKDT372DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT372DI32.Search(const Buff: TKDT372DI32_Vec; var SearchedDistanceMin: Double): PKDT372DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT372DI32.Search(const Buff: TKDT372DI32_Vec): PKDT372DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT372DI32.Search(const inBuff: TKDT372DI32_DynamicVecBuffer; var OutBuff: TKDT372DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DI32_DynamicVecBuffer;
  outBuffPtr : PKDT372DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT372DI32_Source));
end;

procedure TKDT372DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT372DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT372DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT372DI32.PrintNodeTree(const NodePtr: PKDT372DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT372DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT372DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT372DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT372DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT372DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT372DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT372DI32.Test;
var
  TKDT372DI32_Test    : TKDT372DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT372DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT372DI32_Test := TKDT372DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT372DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT372DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT372DI32_AxisCount - 1 do
        TKDT372DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT372DI32_Test.TestBuff), length(TKDT372DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT372DI32_Test.BuildKDTreeM(False, length(TKDT372DI32_Test.TestBuff), @TKDT372DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT372DI32_Test.BuildKDTreeM(False, length(TKDT372DI32_Test.TestBuff), TKDT372DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT372DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT372DI32_Test.TestBuff));
  TKDT372DI32_Test.Search(TKDT372DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT372DI32Distance(TKDT372DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT372DI32_Test.Clear;
  { kMean test }
  TKDT372DI32_Test.BuildKDTreeWithCluster(TKDT372DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT372DI32_Test.Search(TKDT372DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT372DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT372DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT372DI32_Test);
end;

{$ENDIF DEBUG}


function KDT512DI32Vec(const s: string): TKDT512DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT512DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT512DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT512DI32Vec(const v: TKDT512DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT512DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT512DI32Pow(const v: TKDT512DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT512DI32Distance(const v1, v2: TKDT512DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT512DI32_AxisCount - 1 do
      Result := Result + KDT512DI32Pow(v2[i] - v1[i]);
end;

function KDT512DI32Cmpare(const v1, v2: TKDT512DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT512DI32_Vec));
end;

function TKDT512DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DI32_Node;
  function SortCompare(const p1, p2: PKDT512DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT512DI32_SourceBuffer;
  dynBuff  : PKDT512DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT512DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DI32.SearchStoreBuff(const StoreBuffPtr: PKDT512DI32yanmicStoreBuffer; const Buff: TKDT512DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT512DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT512DI32.GetData(const index: NativeInt): PKDT512DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT512DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DI32.StoreBuffPtr: PKDT512DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT512DI32.BuildKDTreeWithCluster(const inBuff: TKDT512DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT512DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT512DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT512DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DI32.BuildKDTreeWithCluster(const inBuff: TKDT512DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI32_BuildCall);
var
  TempStoreBuff: TKDT512DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI32_BuildMethod);
var
  TempStoreBuff: TKDT512DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI32_BuildProc);
var
  TempStoreBuff: TKDT512DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT512DI32.Search(const Buff: TKDT512DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DI32_Node;

var
  NearestNeighbour: PKDT512DI32_Node;

  function FindParentNode(const BuffPtr: PKDT512DI32_Vec; NodePtr: PKDT512DI32_Node): PKDT512DI32_Node;
  var
    Next       : PKDT512DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT512DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DI32_Node; const BuffPtr: PKDT512DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT512DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT512DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT512DI32_Vec; const p1, p2: PKDT512DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT512DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT512DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT512DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT512DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT512DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT512DI32.Search(const Buff: TKDT512DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DI32.Search(const Buff: TKDT512DI32_Vec; var SearchedDistanceMin: Double): PKDT512DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DI32.Search(const Buff: TKDT512DI32_Vec): PKDT512DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT512DI32.Search(const inBuff: TKDT512DI32_DynamicVecBuffer; var OutBuff: TKDT512DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DI32_DynamicVecBuffer;
  outBuffPtr : PKDT512DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT512DI32_Source));
end;

procedure TKDT512DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT512DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT512DI32.PrintNodeTree(const NodePtr: PKDT512DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT512DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT512DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT512DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT512DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT512DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT512DI32.Test;
var
  TKDT512DI32_Test    : TKDT512DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT512DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT512DI32_Test := TKDT512DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT512DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT512DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT512DI32_AxisCount - 1 do
        TKDT512DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT512DI32_Test.TestBuff), length(TKDT512DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT512DI32_Test.BuildKDTreeM(False, length(TKDT512DI32_Test.TestBuff), @TKDT512DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT512DI32_Test.BuildKDTreeM(False, length(TKDT512DI32_Test.TestBuff), TKDT512DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT512DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT512DI32_Test.TestBuff));
  TKDT512DI32_Test.Search(TKDT512DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT512DI32Distance(TKDT512DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT512DI32_Test.Clear;
  { kMean test }
  TKDT512DI32_Test.BuildKDTreeWithCluster(TKDT512DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT512DI32_Test.Search(TKDT512DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT512DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT512DI32_Test);
end;

{$ENDIF DEBUG}


function KDT576DI32Vec(const s: string): TKDT576DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT576DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT576DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT576DI32Vec(const v: TKDT576DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT576DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT576DI32Pow(const v: TKDT576DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT576DI32Distance(const v1, v2: TKDT576DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT576DI32_AxisCount - 1 do
      Result := Result + KDT576DI32Pow(v2[i] - v1[i]);
end;

function KDT576DI32Cmpare(const v1, v2: TKDT576DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT576DI32_Vec));
end;

function TKDT576DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DI32_Node;
  function SortCompare(const p1, p2: PKDT576DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT576DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT576DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT576DI32_SourceBuffer;
  dynBuff  : PKDT576DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT576DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT576DI32.SearchStoreBuff(const StoreBuffPtr: PKDT576DI32yanmicStoreBuffer; const Buff: TKDT576DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT576DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT576DI32.GetData(const index: NativeInt): PKDT576DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT576DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT576DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT576DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT576DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT576DI32.StoreBuffPtr: PKDT576DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT576DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT576DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT576DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT576DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT576DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT576DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT576DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT576DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT576DI32.BuildKDTreeWithCluster(const inBuff: TKDT576DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT576DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT576DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT576DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT576DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT576DI32.BuildKDTreeWithCluster(const inBuff: TKDT576DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT576DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI32_BuildCall);
var
  TempStoreBuff: TKDT576DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT576DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT576DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT576DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT576DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT576DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI32_BuildMethod);
var
  TempStoreBuff: TKDT576DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT576DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT576DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT576DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT576DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI32_BuildProc);
var
  TempStoreBuff: TKDT576DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT576DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT576DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT576DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT576DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT576DI32.Search(const Buff: TKDT576DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DI32_Node;

var
  NearestNeighbour: PKDT576DI32_Node;

  function FindParentNode(const BuffPtr: PKDT576DI32_Vec; NodePtr: PKDT576DI32_Node): PKDT576DI32_Node;
  var
    Next       : PKDT576DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT576DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT576DI32_Node; const BuffPtr: PKDT576DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT576DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT576DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT576DI32_Vec; const p1, p2: PKDT576DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT576DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT576DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT576DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT576DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT576DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT576DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT576DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT576DI32.Search(const Buff: TKDT576DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT576DI32.Search(const Buff: TKDT576DI32_Vec; var SearchedDistanceMin: Double): PKDT576DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT576DI32.Search(const Buff: TKDT576DI32_Vec): PKDT576DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT576DI32.Search(const inBuff: TKDT576DI32_DynamicVecBuffer; var OutBuff: TKDT576DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT576DI32_DynamicVecBuffer;
  outBuffPtr : PKDT576DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT576DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT576DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT576DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT576DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT576DI32_Source));
end;

procedure TKDT576DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT576DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT576DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT576DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT576DI32.PrintNodeTree(const NodePtr: PKDT576DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT576DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT576DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT576DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT576DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT576DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT576DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT576DI32.Test;
var
  TKDT576DI32_Test    : TKDT576DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT576DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT576DI32_Test := TKDT576DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT576DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT576DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT576DI32_AxisCount - 1 do
        TKDT576DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT576DI32_Test.TestBuff), length(TKDT576DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT576DI32_Test.BuildKDTreeM(False, length(TKDT576DI32_Test.TestBuff), @TKDT576DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT576DI32_Test.BuildKDTreeM(False, length(TKDT576DI32_Test.TestBuff), TKDT576DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT576DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT576DI32_Test.TestBuff));
  TKDT576DI32_Test.Search(TKDT576DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT576DI32Distance(TKDT576DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT576DI32_Test.Clear;
  { kMean test }
  TKDT576DI32_Test.BuildKDTreeWithCluster(TKDT576DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT576DI32_Test.Search(TKDT576DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT576DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT576DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT576DI32_Test);
end;

{$ENDIF DEBUG}


function KDT768DI32Vec(const s: string): TKDT768DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT768DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT768DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT768DI32Vec(const v: TKDT768DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT768DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT768DI32Pow(const v: TKDT768DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT768DI32Distance(const v1, v2: TKDT768DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT768DI32_AxisCount - 1 do
      Result := Result + KDT768DI32Pow(v2[i] - v1[i]);
end;

function KDT768DI32Cmpare(const v1, v2: TKDT768DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT768DI32_Vec));
end;

function TKDT768DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DI32_Node;
  function SortCompare(const p1, p2: PKDT768DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT768DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT768DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT768DI32_SourceBuffer;
  dynBuff  : PKDT768DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT768DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT768DI32.SearchStoreBuff(const StoreBuffPtr: PKDT768DI32yanmicStoreBuffer; const Buff: TKDT768DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT768DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT768DI32.GetData(const index: NativeInt): PKDT768DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT768DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT768DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT768DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT768DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT768DI32.StoreBuffPtr: PKDT768DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT768DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT768DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT768DI32.BuildKDTreeWithCluster(const inBuff: TKDT768DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT768DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT768DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT768DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT768DI32.BuildKDTreeWithCluster(const inBuff: TKDT768DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI32_BuildCall);
var
  TempStoreBuff: TKDT768DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI32_BuildMethod);
var
  TempStoreBuff: TKDT768DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI32_BuildProc);
var
  TempStoreBuff: TKDT768DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT768DI32.Search(const Buff: TKDT768DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DI32_Node;

var
  NearestNeighbour: PKDT768DI32_Node;

  function FindParentNode(const BuffPtr: PKDT768DI32_Vec; NodePtr: PKDT768DI32_Node): PKDT768DI32_Node;
  var
    Next       : PKDT768DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT768DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT768DI32_Node; const BuffPtr: PKDT768DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT768DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT768DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT768DI32_Vec; const p1, p2: PKDT768DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT768DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT768DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT768DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT768DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT768DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT768DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT768DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT768DI32.Search(const Buff: TKDT768DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT768DI32.Search(const Buff: TKDT768DI32_Vec; var SearchedDistanceMin: Double): PKDT768DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT768DI32.Search(const Buff: TKDT768DI32_Vec): PKDT768DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT768DI32.Search(const inBuff: TKDT768DI32_DynamicVecBuffer; var OutBuff: TKDT768DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DI32_DynamicVecBuffer;
  outBuffPtr : PKDT768DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT768DI32_Source));
end;

procedure TKDT768DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT768DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT768DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT768DI32.PrintNodeTree(const NodePtr: PKDT768DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT768DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT768DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT768DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT768DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT768DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT768DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT768DI32.Test;
var
  TKDT768DI32_Test    : TKDT768DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT768DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT768DI32_Test := TKDT768DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT768DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT768DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT768DI32_AxisCount - 1 do
        TKDT768DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT768DI32_Test.TestBuff), length(TKDT768DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT768DI32_Test.BuildKDTreeM(False, length(TKDT768DI32_Test.TestBuff), @TKDT768DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT768DI32_Test.BuildKDTreeM(False, length(TKDT768DI32_Test.TestBuff), TKDT768DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT768DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT768DI32_Test.TestBuff));
  TKDT768DI32_Test.Search(TKDT768DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT768DI32Distance(TKDT768DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT768DI32_Test.Clear;
  { kMean test }
  TKDT768DI32_Test.BuildKDTreeWithCluster(TKDT768DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT768DI32_Test.Search(TKDT768DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT768DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT768DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT768DI32_Test);
end;

{$ENDIF DEBUG}


function KDT1024DI32Vec(const s: string): TKDT1024DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1024DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1024DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1024DI32Vec(const v: TKDT1024DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1024DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1024DI32Pow(const v: TKDT1024DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT1024DI32Distance(const v1, v2: TKDT1024DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1024DI32_AxisCount - 1 do
      Result := Result + KDT1024DI32Pow(v2[i] - v1[i]);
end;

function KDT1024DI32Cmpare(const v1, v2: TKDT1024DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1024DI32_Vec));
end;

function TKDT1024DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DI32_Node;
  function SortCompare(const p1, p2: PKDT1024DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1024DI32_SourceBuffer;
  dynBuff  : PKDT1024DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1024DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DI32.SearchStoreBuff(const StoreBuffPtr: PKDT1024DI32yanmicStoreBuffer; const Buff: TKDT1024DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1024DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1024DI32.GetData(const index: NativeInt): PKDT1024DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1024DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DI32.StoreBuffPtr: PKDT1024DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1024DI32.BuildKDTreeWithCluster(const inBuff: TKDT1024DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1024DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1024DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1024DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DI32.BuildKDTreeWithCluster(const inBuff: TKDT1024DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI32_BuildCall);
var
  TempStoreBuff: TKDT1024DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI32_BuildMethod);
var
  TempStoreBuff: TKDT1024DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI32_BuildProc);
var
  TempStoreBuff: TKDT1024DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1024DI32.Search(const Buff: TKDT1024DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DI32_Node;

var
  NearestNeighbour: PKDT1024DI32_Node;

  function FindParentNode(const BuffPtr: PKDT1024DI32_Vec; NodePtr: PKDT1024DI32_Node): PKDT1024DI32_Node;
  var
    Next       : PKDT1024DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1024DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DI32_Node; const BuffPtr: PKDT1024DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1024DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1024DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1024DI32_Vec; const p1, p2: PKDT1024DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1024DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1024DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1024DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1024DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1024DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DI32.Search(const Buff: TKDT1024DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DI32.Search(const Buff: TKDT1024DI32_Vec; var SearchedDistanceMin: Double): PKDT1024DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DI32.Search(const Buff: TKDT1024DI32_Vec): PKDT1024DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1024DI32.Search(const inBuff: TKDT1024DI32_DynamicVecBuffer; var OutBuff: TKDT1024DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DI32_DynamicVecBuffer;
  outBuffPtr : PKDT1024DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1024DI32_Source));
end;

procedure TKDT1024DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1024DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1024DI32.PrintNodeTree(const NodePtr: PKDT1024DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1024DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1024DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1024DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1024DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1024DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1024DI32.Test;
var
  TKDT1024DI32_Test    : TKDT1024DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1024DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1024DI32_Test := TKDT1024DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1024DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT1024DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT1024DI32_AxisCount - 1 do
        TKDT1024DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1024DI32_Test.TestBuff), length(TKDT1024DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1024DI32_Test.BuildKDTreeM(False, length(TKDT1024DI32_Test.TestBuff), @TKDT1024DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1024DI32_Test.BuildKDTreeM(False, length(TKDT1024DI32_Test.TestBuff), TKDT1024DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1024DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1024DI32_Test.TestBuff));
  TKDT1024DI32_Test.Search(TKDT1024DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1024DI32Distance(TKDT1024DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1024DI32_Test.Clear;
  { kMean test }
  TKDT1024DI32_Test.BuildKDTreeWithCluster(TKDT1024DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1024DI32_Test.Search(TKDT1024DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1024DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1024DI32_Test);
end;

{$ENDIF DEBUG}


function KDT1040DI32Vec(const s: string): TKDT1040DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1040DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1040DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1040DI32Vec(const v: TKDT1040DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1040DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1040DI32Pow(const v: TKDT1040DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT1040DI32Distance(const v1, v2: TKDT1040DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1040DI32_AxisCount - 1 do
      Result := Result + KDT1040DI32Pow(v2[i] - v1[i]);
end;

function KDT1040DI32Cmpare(const v1, v2: TKDT1040DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1040DI32_Vec));
end;

function TKDT1040DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DI32_Node;
  function SortCompare(const p1, p2: PKDT1040DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1040DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1040DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1040DI32_SourceBuffer;
  dynBuff  : PKDT1040DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1040DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1040DI32.SearchStoreBuff(const StoreBuffPtr: PKDT1040DI32yanmicStoreBuffer; const Buff: TKDT1040DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1040DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1040DI32.GetData(const index: NativeInt): PKDT1040DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1040DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1040DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1040DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1040DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1040DI32.StoreBuffPtr: PKDT1040DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1040DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1040DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1040DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1040DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1040DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1040DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1040DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1040DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1040DI32.BuildKDTreeWithCluster(const inBuff: TKDT1040DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1040DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1040DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1040DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1040DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1040DI32.BuildKDTreeWithCluster(const inBuff: TKDT1040DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1040DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI32_BuildCall);
var
  TempStoreBuff: TKDT1040DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1040DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1040DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1040DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1040DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1040DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI32_BuildMethod);
var
  TempStoreBuff: TKDT1040DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1040DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1040DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1040DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1040DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI32_BuildProc);
var
  TempStoreBuff: TKDT1040DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1040DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1040DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1040DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1040DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1040DI32.Search(const Buff: TKDT1040DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DI32_Node;

var
  NearestNeighbour: PKDT1040DI32_Node;

  function FindParentNode(const BuffPtr: PKDT1040DI32_Vec; NodePtr: PKDT1040DI32_Node): PKDT1040DI32_Node;
  var
    Next       : PKDT1040DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1040DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1040DI32_Node; const BuffPtr: PKDT1040DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1040DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1040DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1040DI32_Vec; const p1, p2: PKDT1040DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1040DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1040DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1040DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1040DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1040DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1040DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1040DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT1040DI32.Search(const Buff: TKDT1040DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1040DI32.Search(const Buff: TKDT1040DI32_Vec; var SearchedDistanceMin: Double): PKDT1040DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1040DI32.Search(const Buff: TKDT1040DI32_Vec): PKDT1040DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1040DI32.Search(const inBuff: TKDT1040DI32_DynamicVecBuffer; var OutBuff: TKDT1040DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1040DI32_DynamicVecBuffer;
  outBuffPtr : PKDT1040DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1040DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1040DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1040DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1040DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1040DI32_Source));
end;

procedure TKDT1040DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1040DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1040DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1040DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1040DI32.PrintNodeTree(const NodePtr: PKDT1040DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1040DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1040DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1040DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1040DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1040DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1040DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1040DI32.Test;
var
  TKDT1040DI32_Test    : TKDT1040DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1040DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1040DI32_Test := TKDT1040DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1040DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT1040DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT1040DI32_AxisCount - 1 do
        TKDT1040DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1040DI32_Test.TestBuff), length(TKDT1040DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1040DI32_Test.BuildKDTreeM(False, length(TKDT1040DI32_Test.TestBuff), @TKDT1040DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1040DI32_Test.BuildKDTreeM(False, length(TKDT1040DI32_Test.TestBuff), TKDT1040DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1040DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1040DI32_Test.TestBuff));
  TKDT1040DI32_Test.Search(TKDT1040DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1040DI32Distance(TKDT1040DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1040DI32_Test.Clear;
  { kMean test }
  TKDT1040DI32_Test.BuildKDTreeWithCluster(TKDT1040DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1040DI32_Test.Search(TKDT1040DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1040DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1040DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1040DI32_Test);
end;

{$ENDIF DEBUG}


function KDT1056DI32Vec(const s: string): TKDT1056DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1056DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1056DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1056DI32Vec(const v: TKDT1056DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1056DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1056DI32Pow(const v: TKDT1056DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT1056DI32Distance(const v1, v2: TKDT1056DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1056DI32_AxisCount - 1 do
      Result := Result + KDT1056DI32Pow(v2[i] - v1[i]);
end;

function KDT1056DI32Cmpare(const v1, v2: TKDT1056DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1056DI32_Vec));
end;

function TKDT1056DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DI32_Node;
  function SortCompare(const p1, p2: PKDT1056DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1056DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1056DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1056DI32_SourceBuffer;
  dynBuff  : PKDT1056DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1056DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1056DI32.SearchStoreBuff(const StoreBuffPtr: PKDT1056DI32yanmicStoreBuffer; const Buff: TKDT1056DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1056DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1056DI32.GetData(const index: NativeInt): PKDT1056DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1056DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1056DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1056DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1056DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1056DI32.StoreBuffPtr: PKDT1056DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1056DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1056DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1056DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1056DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1056DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1056DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1056DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1056DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1056DI32.BuildKDTreeWithCluster(const inBuff: TKDT1056DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1056DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1056DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1056DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1056DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1056DI32.BuildKDTreeWithCluster(const inBuff: TKDT1056DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1056DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI32_BuildCall);
var
  TempStoreBuff: TKDT1056DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1056DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1056DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1056DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1056DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1056DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI32_BuildMethod);
var
  TempStoreBuff: TKDT1056DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1056DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1056DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1056DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1056DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI32_BuildProc);
var
  TempStoreBuff: TKDT1056DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1056DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1056DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1056DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1056DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1056DI32.Search(const Buff: TKDT1056DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DI32_Node;

var
  NearestNeighbour: PKDT1056DI32_Node;

  function FindParentNode(const BuffPtr: PKDT1056DI32_Vec; NodePtr: PKDT1056DI32_Node): PKDT1056DI32_Node;
  var
    Next       : PKDT1056DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1056DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1056DI32_Node; const BuffPtr: PKDT1056DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1056DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1056DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1056DI32_Vec; const p1, p2: PKDT1056DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1056DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1056DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1056DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1056DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1056DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1056DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1056DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT1056DI32.Search(const Buff: TKDT1056DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1056DI32.Search(const Buff: TKDT1056DI32_Vec; var SearchedDistanceMin: Double): PKDT1056DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1056DI32.Search(const Buff: TKDT1056DI32_Vec): PKDT1056DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1056DI32.Search(const inBuff: TKDT1056DI32_DynamicVecBuffer; var OutBuff: TKDT1056DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1056DI32_DynamicVecBuffer;
  outBuffPtr : PKDT1056DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1056DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1056DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1056DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1056DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1056DI32_Source));
end;

procedure TKDT1056DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1056DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1056DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1056DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1056DI32.PrintNodeTree(const NodePtr: PKDT1056DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1056DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1056DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1056DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1056DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1056DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1056DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1056DI32.Test;
var
  TKDT1056DI32_Test    : TKDT1056DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1056DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1056DI32_Test := TKDT1056DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1056DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT1056DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT1056DI32_AxisCount - 1 do
        TKDT1056DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1056DI32_Test.TestBuff), length(TKDT1056DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1056DI32_Test.BuildKDTreeM(False, length(TKDT1056DI32_Test.TestBuff), @TKDT1056DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1056DI32_Test.BuildKDTreeM(False, length(TKDT1056DI32_Test.TestBuff), TKDT1056DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1056DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1056DI32_Test.TestBuff));
  TKDT1056DI32_Test.Search(TKDT1056DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1056DI32Distance(TKDT1056DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1056DI32_Test.Clear;
  { kMean test }
  TKDT1056DI32_Test.BuildKDTreeWithCluster(TKDT1056DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1056DI32_Test.Search(TKDT1056DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1056DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1056DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1056DI32_Test);
end;

{$ENDIF DEBUG}


function KDT1536DI32Vec(const s: string): TKDT1536DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1536DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1536DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1536DI32Vec(const v: TKDT1536DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1536DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1536DI32Pow(const v: TKDT1536DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT1536DI32Distance(const v1, v2: TKDT1536DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1536DI32_AxisCount - 1 do
      Result := Result + KDT1536DI32Pow(v2[i] - v1[i]);
end;

function KDT1536DI32Cmpare(const v1, v2: TKDT1536DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1536DI32_Vec));
end;

function TKDT1536DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DI32_Node;
  function SortCompare(const p1, p2: PKDT1536DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1536DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1536DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1536DI32_SourceBuffer;
  dynBuff  : PKDT1536DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1536DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1536DI32.SearchStoreBuff(const StoreBuffPtr: PKDT1536DI32yanmicStoreBuffer; const Buff: TKDT1536DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1536DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1536DI32.GetData(const index: NativeInt): PKDT1536DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1536DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1536DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1536DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1536DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1536DI32.StoreBuffPtr: PKDT1536DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1536DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1536DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1536DI32.BuildKDTreeWithCluster(const inBuff: TKDT1536DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1536DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1536DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1536DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1536DI32.BuildKDTreeWithCluster(const inBuff: TKDT1536DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI32_BuildCall);
var
  TempStoreBuff: TKDT1536DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI32_BuildMethod);
var
  TempStoreBuff: TKDT1536DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI32_BuildProc);
var
  TempStoreBuff: TKDT1536DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1536DI32.Search(const Buff: TKDT1536DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DI32_Node;

var
  NearestNeighbour: PKDT1536DI32_Node;

  function FindParentNode(const BuffPtr: PKDT1536DI32_Vec; NodePtr: PKDT1536DI32_Node): PKDT1536DI32_Node;
  var
    Next       : PKDT1536DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1536DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1536DI32_Node; const BuffPtr: PKDT1536DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1536DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1536DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1536DI32_Vec; const p1, p2: PKDT1536DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1536DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1536DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1536DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1536DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1536DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1536DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1536DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT1536DI32.Search(const Buff: TKDT1536DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1536DI32.Search(const Buff: TKDT1536DI32_Vec; var SearchedDistanceMin: Double): PKDT1536DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1536DI32.Search(const Buff: TKDT1536DI32_Vec): PKDT1536DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1536DI32.Search(const inBuff: TKDT1536DI32_DynamicVecBuffer; var OutBuff: TKDT1536DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DI32_DynamicVecBuffer;
  outBuffPtr : PKDT1536DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1536DI32_Source));
end;

procedure TKDT1536DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1536DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1536DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1536DI32.PrintNodeTree(const NodePtr: PKDT1536DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1536DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1536DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1536DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1536DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1536DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1536DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1536DI32.Test;
var
  TKDT1536DI32_Test    : TKDT1536DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1536DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1536DI32_Test := TKDT1536DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1536DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT1536DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT1536DI32_AxisCount - 1 do
        TKDT1536DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1536DI32_Test.TestBuff), length(TKDT1536DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1536DI32_Test.BuildKDTreeM(False, length(TKDT1536DI32_Test.TestBuff), @TKDT1536DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1536DI32_Test.BuildKDTreeM(False, length(TKDT1536DI32_Test.TestBuff), TKDT1536DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1536DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1536DI32_Test.TestBuff));
  TKDT1536DI32_Test.Search(TKDT1536DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1536DI32Distance(TKDT1536DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1536DI32_Test.Clear;
  { kMean test }
  TKDT1536DI32_Test.BuildKDTreeWithCluster(TKDT1536DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1536DI32_Test.Search(TKDT1536DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1536DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1536DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1536DI32_Test);
end;

{$ENDIF DEBUG}


function KDT1920DI32Vec(const s: string): TKDT1920DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1920DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1920DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1920DI32Vec(const v: TKDT1920DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1920DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1920DI32Pow(const v: TKDT1920DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT1920DI32Distance(const v1, v2: TKDT1920DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1920DI32_AxisCount - 1 do
      Result := Result + KDT1920DI32Pow(v2[i] - v1[i]);
end;

function KDT1920DI32Cmpare(const v1, v2: TKDT1920DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1920DI32_Vec));
end;

function TKDT1920DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DI32_Node;
  function SortCompare(const p1, p2: PKDT1920DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1920DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1920DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1920DI32_SourceBuffer;
  dynBuff  : PKDT1920DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1920DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1920DI32.SearchStoreBuff(const StoreBuffPtr: PKDT1920DI32yanmicStoreBuffer; const Buff: TKDT1920DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1920DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1920DI32.GetData(const index: NativeInt): PKDT1920DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1920DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1920DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1920DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1920DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1920DI32.StoreBuffPtr: PKDT1920DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1920DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1920DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1920DI32.BuildKDTreeWithCluster(const inBuff: TKDT1920DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1920DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1920DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1920DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1920DI32.BuildKDTreeWithCluster(const inBuff: TKDT1920DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI32_BuildCall);
var
  TempStoreBuff: TKDT1920DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI32_BuildMethod);
var
  TempStoreBuff: TKDT1920DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI32_BuildProc);
var
  TempStoreBuff: TKDT1920DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1920DI32.Search(const Buff: TKDT1920DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DI32_Node;

var
  NearestNeighbour: PKDT1920DI32_Node;

  function FindParentNode(const BuffPtr: PKDT1920DI32_Vec; NodePtr: PKDT1920DI32_Node): PKDT1920DI32_Node;
  var
    Next       : PKDT1920DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1920DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1920DI32_Node; const BuffPtr: PKDT1920DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1920DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1920DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1920DI32_Vec; const p1, p2: PKDT1920DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1920DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1920DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1920DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1920DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1920DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1920DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1920DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT1920DI32.Search(const Buff: TKDT1920DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1920DI32.Search(const Buff: TKDT1920DI32_Vec; var SearchedDistanceMin: Double): PKDT1920DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1920DI32.Search(const Buff: TKDT1920DI32_Vec): PKDT1920DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1920DI32.Search(const inBuff: TKDT1920DI32_DynamicVecBuffer; var OutBuff: TKDT1920DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DI32_DynamicVecBuffer;
  outBuffPtr : PKDT1920DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1920DI32_Source));
end;

procedure TKDT1920DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1920DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1920DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1920DI32.PrintNodeTree(const NodePtr: PKDT1920DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1920DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1920DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1920DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1920DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1920DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1920DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1920DI32.Test;
var
  TKDT1920DI32_Test    : TKDT1920DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1920DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1920DI32_Test := TKDT1920DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1920DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT1920DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT1920DI32_AxisCount - 1 do
        TKDT1920DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1920DI32_Test.TestBuff), length(TKDT1920DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1920DI32_Test.BuildKDTreeM(False, length(TKDT1920DI32_Test.TestBuff), @TKDT1920DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1920DI32_Test.BuildKDTreeM(False, length(TKDT1920DI32_Test.TestBuff), TKDT1920DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1920DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1920DI32_Test.TestBuff));
  TKDT1920DI32_Test.Search(TKDT1920DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1920DI32Distance(TKDT1920DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1920DI32_Test.Clear;
  { kMean test }
  TKDT1920DI32_Test.BuildKDTreeWithCluster(TKDT1920DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1920DI32_Test.Search(TKDT1920DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1920DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1920DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1920DI32_Test);
end;

{$ENDIF DEBUG}


function KDT1980DI32Vec(const s: string): TKDT1980DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1980DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1980DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1980DI32Vec(const v: TKDT1980DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1980DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT1980DI32Pow(const v: TKDT1980DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT1980DI32Distance(const v1, v2: TKDT1980DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1980DI32_AxisCount - 1 do
      Result := Result + KDT1980DI32Pow(v2[i] - v1[i]);
end;

function KDT1980DI32Cmpare(const v1, v2: TKDT1980DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1980DI32_Vec));
end;

function TKDT1980DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DI32_Node;
  function SortCompare(const p1, p2: PKDT1980DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1980DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1980DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1980DI32_SourceBuffer;
  dynBuff  : PKDT1980DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1980DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1980DI32.SearchStoreBuff(const StoreBuffPtr: PKDT1980DI32yanmicStoreBuffer; const Buff: TKDT1980DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1980DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1980DI32.GetData(const index: NativeInt): PKDT1980DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1980DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1980DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1980DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1980DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1980DI32.StoreBuffPtr: PKDT1980DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1980DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1980DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1980DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1980DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1980DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1980DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1980DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1980DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1980DI32.BuildKDTreeWithCluster(const inBuff: TKDT1980DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1980DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1980DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1980DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1980DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1980DI32.BuildKDTreeWithCluster(const inBuff: TKDT1980DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1980DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI32_BuildCall);
var
  TempStoreBuff: TKDT1980DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1980DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1980DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1980DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1980DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1980DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI32_BuildMethod);
var
  TempStoreBuff: TKDT1980DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1980DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1980DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1980DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1980DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI32_BuildProc);
var
  TempStoreBuff: TKDT1980DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1980DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1980DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1980DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1980DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1980DI32.Search(const Buff: TKDT1980DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DI32_Node;

var
  NearestNeighbour: PKDT1980DI32_Node;

  function FindParentNode(const BuffPtr: PKDT1980DI32_Vec; NodePtr: PKDT1980DI32_Node): PKDT1980DI32_Node;
  var
    Next       : PKDT1980DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1980DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1980DI32_Node; const BuffPtr: PKDT1980DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1980DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1980DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1980DI32_Vec; const p1, p2: PKDT1980DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1980DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1980DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1980DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1980DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1980DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1980DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1980DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT1980DI32.Search(const Buff: TKDT1980DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1980DI32.Search(const Buff: TKDT1980DI32_Vec; var SearchedDistanceMin: Double): PKDT1980DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1980DI32.Search(const Buff: TKDT1980DI32_Vec): PKDT1980DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1980DI32.Search(const inBuff: TKDT1980DI32_DynamicVecBuffer; var OutBuff: TKDT1980DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1980DI32_DynamicVecBuffer;
  outBuffPtr : PKDT1980DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1980DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1980DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1980DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1980DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1980DI32_Source));
end;

procedure TKDT1980DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1980DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1980DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1980DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1980DI32.PrintNodeTree(const NodePtr: PKDT1980DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1980DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1980DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1980DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1980DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1980DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1980DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1980DI32.Test;
var
  TKDT1980DI32_Test    : TKDT1980DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1980DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1980DI32_Test := TKDT1980DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1980DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT1980DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT1980DI32_AxisCount - 1 do
        TKDT1980DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1980DI32_Test.TestBuff), length(TKDT1980DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1980DI32_Test.BuildKDTreeM(False, length(TKDT1980DI32_Test.TestBuff), @TKDT1980DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1980DI32_Test.BuildKDTreeM(False, length(TKDT1980DI32_Test.TestBuff), TKDT1980DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1980DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1980DI32_Test.TestBuff));
  TKDT1980DI32_Test.Search(TKDT1980DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1980DI32Distance(TKDT1980DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1980DI32_Test.Clear;
  { kMean test }
  TKDT1980DI32_Test.BuildKDTreeWithCluster(TKDT1980DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1980DI32_Test.Search(TKDT1980DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1980DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1980DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1980DI32_Test);
end;

{$ENDIF DEBUG}


function KDT2048DI32Vec(const s: string): TKDT2048DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT2048DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT2048DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT2048DI32Vec(const v: TKDT2048DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT2048DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT2048DI32Pow(const v: TKDT2048DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT2048DI32Distance(const v1, v2: TKDT2048DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT2048DI32_AxisCount - 1 do
      Result := Result + KDT2048DI32Pow(v2[i] - v1[i]);
end;

function KDT2048DI32Cmpare(const v1, v2: TKDT2048DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT2048DI32_Vec));
end;

function TKDT2048DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DI32_Node;
  function SortCompare(const p1, p2: PKDT2048DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2048DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2048DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2048DI32_SourceBuffer;
  dynBuff  : PKDT2048DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT2048DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2048DI32.SearchStoreBuff(const StoreBuffPtr: PKDT2048DI32yanmicStoreBuffer; const Buff: TKDT2048DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT2048DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT2048DI32.GetData(const index: NativeInt): PKDT2048DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2048DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2048DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2048DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2048DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2048DI32.StoreBuffPtr: PKDT2048DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2048DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2048DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2048DI32.BuildKDTreeWithCluster(const inBuff: TKDT2048DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT2048DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT2048DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT2048DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2048DI32.BuildKDTreeWithCluster(const inBuff: TKDT2048DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI32_BuildCall);
var
  TempStoreBuff: TKDT2048DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI32_BuildMethod);
var
  TempStoreBuff: TKDT2048DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI32_BuildProc);
var
  TempStoreBuff: TKDT2048DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2048DI32.Search(const Buff: TKDT2048DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DI32_Node;

var
  NearestNeighbour: PKDT2048DI32_Node;

  function FindParentNode(const BuffPtr: PKDT2048DI32_Vec; NodePtr: PKDT2048DI32_Node): PKDT2048DI32_Node;
  var
    Next       : PKDT2048DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT2048DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2048DI32_Node; const BuffPtr: PKDT2048DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2048DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT2048DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2048DI32_Vec; const p1, p2: PKDT2048DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2048DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2048DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2048DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2048DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2048DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2048DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2048DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT2048DI32.Search(const Buff: TKDT2048DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2048DI32.Search(const Buff: TKDT2048DI32_Vec; var SearchedDistanceMin: Double): PKDT2048DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2048DI32.Search(const Buff: TKDT2048DI32_Vec): PKDT2048DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2048DI32.Search(const inBuff: TKDT2048DI32_DynamicVecBuffer; var OutBuff: TKDT2048DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DI32_DynamicVecBuffer;
  outBuffPtr : PKDT2048DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2048DI32_Source));
end;

procedure TKDT2048DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2048DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2048DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT2048DI32.PrintNodeTree(const NodePtr: PKDT2048DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2048DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2048DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2048DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2048DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT2048DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT2048DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2048DI32.Test;
var
  TKDT2048DI32_Test    : TKDT2048DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2048DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2048DI32_Test := TKDT2048DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2048DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT2048DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT2048DI32_AxisCount - 1 do
        TKDT2048DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT2048DI32_Test.TestBuff), length(TKDT2048DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2048DI32_Test.BuildKDTreeM(False, length(TKDT2048DI32_Test.TestBuff), @TKDT2048DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2048DI32_Test.BuildKDTreeM(False, length(TKDT2048DI32_Test.TestBuff), TKDT2048DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2048DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2048DI32_Test.TestBuff));
  TKDT2048DI32_Test.Search(TKDT2048DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2048DI32Distance(TKDT2048DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2048DI32_Test.Clear;
  { kMean test }
  TKDT2048DI32_Test.BuildKDTreeWithCluster(TKDT2048DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2048DI32_Test.Search(TKDT2048DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2048DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2048DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2048DI32_Test);
end;

{$ENDIF DEBUG}


function KDT3072DI32Vec(const s: string): TKDT3072DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3072DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3072DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3072DI32Vec(const v: TKDT3072DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3072DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT3072DI32Pow(const v: TKDT3072DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT3072DI32Distance(const v1, v2: TKDT3072DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3072DI32_AxisCount - 1 do
      Result := Result + KDT3072DI32Pow(v2[i] - v1[i]);
end;

function KDT3072DI32Cmpare(const v1, v2: TKDT3072DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3072DI32_Vec));
end;

function TKDT3072DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DI32_Node;
  function SortCompare(const p1, p2: PKDT3072DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3072DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3072DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3072DI32_SourceBuffer;
  dynBuff  : PKDT3072DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3072DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3072DI32.SearchStoreBuff(const StoreBuffPtr: PKDT3072DI32yanmicStoreBuffer; const Buff: TKDT3072DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3072DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3072DI32.GetData(const index: NativeInt): PKDT3072DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3072DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3072DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3072DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3072DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3072DI32.StoreBuffPtr: PKDT3072DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3072DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3072DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3072DI32.BuildKDTreeWithCluster(const inBuff: TKDT3072DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3072DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3072DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3072DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3072DI32.BuildKDTreeWithCluster(const inBuff: TKDT3072DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI32_BuildCall);
var
  TempStoreBuff: TKDT3072DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI32_BuildMethod);
var
  TempStoreBuff: TKDT3072DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI32_BuildProc);
var
  TempStoreBuff: TKDT3072DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3072DI32.Search(const Buff: TKDT3072DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DI32_Node;

var
  NearestNeighbour: PKDT3072DI32_Node;

  function FindParentNode(const BuffPtr: PKDT3072DI32_Vec; NodePtr: PKDT3072DI32_Node): PKDT3072DI32_Node;
  var
    Next       : PKDT3072DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3072DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3072DI32_Node; const BuffPtr: PKDT3072DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3072DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3072DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3072DI32_Vec; const p1, p2: PKDT3072DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3072DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3072DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3072DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3072DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3072DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3072DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3072DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT3072DI32.Search(const Buff: TKDT3072DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3072DI32.Search(const Buff: TKDT3072DI32_Vec; var SearchedDistanceMin: Double): PKDT3072DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3072DI32.Search(const Buff: TKDT3072DI32_Vec): PKDT3072DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3072DI32.Search(const inBuff: TKDT3072DI32_DynamicVecBuffer; var OutBuff: TKDT3072DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DI32_DynamicVecBuffer;
  outBuffPtr : PKDT3072DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3072DI32_Source));
end;

procedure TKDT3072DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3072DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3072DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3072DI32.PrintNodeTree(const NodePtr: PKDT3072DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3072DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3072DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3072DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3072DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3072DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3072DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3072DI32.Test;
var
  TKDT3072DI32_Test    : TKDT3072DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3072DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3072DI32_Test := TKDT3072DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3072DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT3072DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT3072DI32_AxisCount - 1 do
        TKDT3072DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT3072DI32_Test.TestBuff), length(TKDT3072DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3072DI32_Test.BuildKDTreeM(False, length(TKDT3072DI32_Test.TestBuff), @TKDT3072DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3072DI32_Test.BuildKDTreeM(False, length(TKDT3072DI32_Test.TestBuff), TKDT3072DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3072DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3072DI32_Test.TestBuff));
  TKDT3072DI32_Test.Search(TKDT3072DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3072DI32Distance(TKDT3072DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3072DI32_Test.Clear;
  { kMean test }
  TKDT3072DI32_Test.BuildKDTreeWithCluster(TKDT3072DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3072DI32_Test.Search(TKDT3072DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3072DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3072DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3072DI32_Test);
end;

{$ENDIF DEBUG}


function KDT3088DI32Vec(const s: string): TKDT3088DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3088DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3088DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3088DI32Vec(const v: TKDT3088DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3088DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT3088DI32Pow(const v: TKDT3088DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT3088DI32Distance(const v1, v2: TKDT3088DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3088DI32_AxisCount - 1 do
      Result := Result + KDT3088DI32Pow(v2[i] - v1[i]);
end;

function KDT3088DI32Cmpare(const v1, v2: TKDT3088DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3088DI32_Vec));
end;

function TKDT3088DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DI32_Node;
  function SortCompare(const p1, p2: PKDT3088DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3088DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3088DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3088DI32_SourceBuffer;
  dynBuff  : PKDT3088DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3088DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3088DI32.SearchStoreBuff(const StoreBuffPtr: PKDT3088DI32yanmicStoreBuffer; const Buff: TKDT3088DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3088DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3088DI32.GetData(const index: NativeInt): PKDT3088DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3088DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3088DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3088DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3088DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3088DI32.StoreBuffPtr: PKDT3088DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3088DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3088DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3088DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3088DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3088DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3088DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3088DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3088DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3088DI32.BuildKDTreeWithCluster(const inBuff: TKDT3088DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3088DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3088DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3088DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3088DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3088DI32.BuildKDTreeWithCluster(const inBuff: TKDT3088DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3088DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI32_BuildCall);
var
  TempStoreBuff: TKDT3088DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3088DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3088DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3088DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3088DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3088DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI32_BuildMethod);
var
  TempStoreBuff: TKDT3088DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3088DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3088DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3088DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3088DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI32_BuildProc);
var
  TempStoreBuff: TKDT3088DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3088DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3088DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3088DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3088DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3088DI32.Search(const Buff: TKDT3088DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DI32_Node;

var
  NearestNeighbour: PKDT3088DI32_Node;

  function FindParentNode(const BuffPtr: PKDT3088DI32_Vec; NodePtr: PKDT3088DI32_Node): PKDT3088DI32_Node;
  var
    Next       : PKDT3088DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3088DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3088DI32_Node; const BuffPtr: PKDT3088DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3088DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3088DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3088DI32_Vec; const p1, p2: PKDT3088DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3088DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3088DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3088DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3088DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3088DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3088DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3088DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT3088DI32.Search(const Buff: TKDT3088DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3088DI32.Search(const Buff: TKDT3088DI32_Vec; var SearchedDistanceMin: Double): PKDT3088DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3088DI32.Search(const Buff: TKDT3088DI32_Vec): PKDT3088DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3088DI32.Search(const inBuff: TKDT3088DI32_DynamicVecBuffer; var OutBuff: TKDT3088DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3088DI32_DynamicVecBuffer;
  outBuffPtr : PKDT3088DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3088DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3088DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3088DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3088DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3088DI32_Source));
end;

procedure TKDT3088DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3088DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3088DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3088DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3088DI32.PrintNodeTree(const NodePtr: PKDT3088DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3088DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3088DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3088DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3088DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3088DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3088DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3088DI32.Test;
var
  TKDT3088DI32_Test    : TKDT3088DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3088DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3088DI32_Test := TKDT3088DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3088DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT3088DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT3088DI32_AxisCount - 1 do
        TKDT3088DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT3088DI32_Test.TestBuff), length(TKDT3088DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3088DI32_Test.BuildKDTreeM(False, length(TKDT3088DI32_Test.TestBuff), @TKDT3088DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3088DI32_Test.BuildKDTreeM(False, length(TKDT3088DI32_Test.TestBuff), TKDT3088DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3088DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3088DI32_Test.TestBuff));
  TKDT3088DI32_Test.Search(TKDT3088DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3088DI32Distance(TKDT3088DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3088DI32_Test.Clear;
  { kMean test }
  TKDT3088DI32_Test.BuildKDTreeWithCluster(TKDT3088DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3088DI32_Test.Search(TKDT3088DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3088DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3088DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3088DI32_Test);
end;

{$ENDIF DEBUG}


function KDT3104DI32Vec(const s: string): TKDT3104DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3104DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3104DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3104DI32Vec(const v: TKDT3104DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3104DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT3104DI32Pow(const v: TKDT3104DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT3104DI32Distance(const v1, v2: TKDT3104DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3104DI32_AxisCount - 1 do
      Result := Result + KDT3104DI32Pow(v2[i] - v1[i]);
end;

function KDT3104DI32Cmpare(const v1, v2: TKDT3104DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3104DI32_Vec));
end;

function TKDT3104DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DI32_Node;
  function SortCompare(const p1, p2: PKDT3104DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3104DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3104DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3104DI32_SourceBuffer;
  dynBuff  : PKDT3104DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3104DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3104DI32.SearchStoreBuff(const StoreBuffPtr: PKDT3104DI32yanmicStoreBuffer; const Buff: TKDT3104DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3104DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3104DI32.GetData(const index: NativeInt): PKDT3104DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3104DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3104DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3104DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3104DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3104DI32.StoreBuffPtr: PKDT3104DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3104DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3104DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3104DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3104DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3104DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3104DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3104DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3104DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3104DI32.BuildKDTreeWithCluster(const inBuff: TKDT3104DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3104DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3104DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3104DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3104DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3104DI32.BuildKDTreeWithCluster(const inBuff: TKDT3104DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3104DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI32_BuildCall);
var
  TempStoreBuff: TKDT3104DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3104DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3104DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3104DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3104DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3104DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI32_BuildMethod);
var
  TempStoreBuff: TKDT3104DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3104DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3104DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3104DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3104DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI32_BuildProc);
var
  TempStoreBuff: TKDT3104DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3104DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3104DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3104DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3104DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3104DI32.Search(const Buff: TKDT3104DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DI32_Node;

var
  NearestNeighbour: PKDT3104DI32_Node;

  function FindParentNode(const BuffPtr: PKDT3104DI32_Vec; NodePtr: PKDT3104DI32_Node): PKDT3104DI32_Node;
  var
    Next       : PKDT3104DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3104DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3104DI32_Node; const BuffPtr: PKDT3104DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3104DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3104DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3104DI32_Vec; const p1, p2: PKDT3104DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3104DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3104DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3104DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3104DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3104DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3104DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3104DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT3104DI32.Search(const Buff: TKDT3104DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3104DI32.Search(const Buff: TKDT3104DI32_Vec; var SearchedDistanceMin: Double): PKDT3104DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3104DI32.Search(const Buff: TKDT3104DI32_Vec): PKDT3104DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3104DI32.Search(const inBuff: TKDT3104DI32_DynamicVecBuffer; var OutBuff: TKDT3104DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3104DI32_DynamicVecBuffer;
  outBuffPtr : PKDT3104DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3104DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3104DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3104DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3104DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3104DI32_Source));
end;

procedure TKDT3104DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3104DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3104DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3104DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3104DI32.PrintNodeTree(const NodePtr: PKDT3104DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3104DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3104DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3104DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3104DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3104DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3104DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3104DI32.Test;
var
  TKDT3104DI32_Test    : TKDT3104DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3104DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3104DI32_Test := TKDT3104DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3104DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT3104DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT3104DI32_AxisCount - 1 do
        TKDT3104DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT3104DI32_Test.TestBuff), length(TKDT3104DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3104DI32_Test.BuildKDTreeM(False, length(TKDT3104DI32_Test.TestBuff), @TKDT3104DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3104DI32_Test.BuildKDTreeM(False, length(TKDT3104DI32_Test.TestBuff), TKDT3104DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3104DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3104DI32_Test.TestBuff));
  TKDT3104DI32_Test.Search(TKDT3104DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3104DI32Distance(TKDT3104DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3104DI32_Test.Clear;
  { kMean test }
  TKDT3104DI32_Test.BuildKDTreeWithCluster(TKDT3104DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3104DI32_Test.Search(TKDT3104DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3104DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3104DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3104DI32_Test);
end;

{$ENDIF DEBUG}


function KDT4096DI32Vec(const s: string): TKDT4096DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT4096DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT4096DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT4096DI32Vec(const v: TKDT4096DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT4096DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT4096DI32Pow(const v: TKDT4096DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT4096DI32Distance(const v1, v2: TKDT4096DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT4096DI32_AxisCount - 1 do
      Result := Result + KDT4096DI32Pow(v2[i] - v1[i]);
end;

function KDT4096DI32Cmpare(const v1, v2: TKDT4096DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT4096DI32_Vec));
end;

function TKDT4096DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DI32_Node;
  function SortCompare(const p1, p2: PKDT4096DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4096DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4096DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4096DI32_SourceBuffer;
  dynBuff  : PKDT4096DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT4096DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4096DI32.SearchStoreBuff(const StoreBuffPtr: PKDT4096DI32yanmicStoreBuffer; const Buff: TKDT4096DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT4096DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT4096DI32.GetData(const index: NativeInt): PKDT4096DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4096DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4096DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4096DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4096DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4096DI32.StoreBuffPtr: PKDT4096DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4096DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4096DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4096DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4096DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4096DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4096DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4096DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4096DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4096DI32.BuildKDTreeWithCluster(const inBuff: TKDT4096DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT4096DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT4096DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT4096DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4096DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4096DI32.BuildKDTreeWithCluster(const inBuff: TKDT4096DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4096DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI32_BuildCall);
var
  TempStoreBuff: TKDT4096DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4096DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4096DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4096DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4096DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT4096DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI32_BuildMethod);
var
  TempStoreBuff: TKDT4096DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4096DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4096DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4096DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4096DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI32_BuildProc);
var
  TempStoreBuff: TKDT4096DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4096DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4096DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4096DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4096DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT4096DI32.Search(const Buff: TKDT4096DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DI32_Node;

var
  NearestNeighbour: PKDT4096DI32_Node;

  function FindParentNode(const BuffPtr: PKDT4096DI32_Vec; NodePtr: PKDT4096DI32_Node): PKDT4096DI32_Node;
  var
    Next       : PKDT4096DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT4096DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4096DI32_Node; const BuffPtr: PKDT4096DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4096DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT4096DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4096DI32_Vec; const p1, p2: PKDT4096DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4096DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4096DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4096DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4096DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4096DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4096DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4096DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT4096DI32.Search(const Buff: TKDT4096DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4096DI32.Search(const Buff: TKDT4096DI32_Vec; var SearchedDistanceMin: Double): PKDT4096DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4096DI32.Search(const Buff: TKDT4096DI32_Vec): PKDT4096DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4096DI32.Search(const inBuff: TKDT4096DI32_DynamicVecBuffer; var OutBuff: TKDT4096DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4096DI32_DynamicVecBuffer;
  outBuffPtr : PKDT4096DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4096DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4096DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4096DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4096DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4096DI32_Source));
end;

procedure TKDT4096DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4096DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4096DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4096DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT4096DI32.PrintNodeTree(const NodePtr: PKDT4096DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4096DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4096DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4096DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4096DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT4096DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT4096DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4096DI32.Test;
var
  TKDT4096DI32_Test    : TKDT4096DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4096DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4096DI32_Test := TKDT4096DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4096DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT4096DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT4096DI32_AxisCount - 1 do
        TKDT4096DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT4096DI32_Test.TestBuff), length(TKDT4096DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4096DI32_Test.BuildKDTreeM(False, length(TKDT4096DI32_Test.TestBuff), @TKDT4096DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4096DI32_Test.BuildKDTreeM(False, length(TKDT4096DI32_Test.TestBuff), TKDT4096DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4096DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4096DI32_Test.TestBuff));
  TKDT4096DI32_Test.Search(TKDT4096DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4096DI32Distance(TKDT4096DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4096DI32_Test.Clear;
  { kMean test }
  TKDT4096DI32_Test.BuildKDTreeWithCluster(TKDT4096DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4096DI32_Test.Search(TKDT4096DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4096DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4096DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4096DI32_Test);
end;

{$ENDIF DEBUG}


function KDT8192DI32Vec(const s: string): TKDT8192DI32_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT8192DI32_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT8192DI32_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT8192DI32Vec(const v: TKDT8192DI32_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT8192DI32_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

function KDT8192DI32Pow(const v: TKDT8192DI32_VecType): Double;
begin
  Result := v * v;
end;

function KDT8192DI32Distance(const v1, v2: TKDT8192DI32_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT8192DI32_AxisCount - 1 do
      Result := Result + KDT8192DI32Pow(v2[i] - v1[i]);
end;

function KDT8192DI32Cmpare(const v1, v2: TKDT8192DI32_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT8192DI32_Vec));
end;

function TKDT8192DI32.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DI32_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DI32_Node;
  function SortCompare(const p1, p2: PKDT8192DI32_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8192DI32_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8192DI32_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8192DI32_SourceBuffer;
  dynBuff  : PKDT8192DI32yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT8192DI32_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8192DI32.SearchStoreBuff(const StoreBuffPtr: PKDT8192DI32yanmicStoreBuffer; const Buff: TKDT8192DI32_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT8192DI32Cmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT8192DI32.GetData(const index: NativeInt): PKDT8192DI32_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8192DI32.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8192DI32.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8192DI32.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8192DI32_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8192DI32.StoreBuffPtr: PKDT8192DI32yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8192DI32.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DI32_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8192DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8192DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8192DI32.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DI32_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8192DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8192DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DI32.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DI32_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DI32yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8192DI32_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8192DI32_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DI32_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8192DI32.BuildKDTreeWithCluster(const inBuff: TKDT8192DI32_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT8192DI32_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT8192DI32_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT8192DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8192DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8192DI32.BuildKDTreeWithCluster(const inBuff: TKDT8192DI32_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8192DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI32_BuildCall);
var
  TempStoreBuff: TKDT8192DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8192DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8192DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8192DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8192DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DI32.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI32_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT8192DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI32_BuildMethod);
var
  TempStoreBuff: TKDT8192DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8192DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8192DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8192DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8192DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DI32.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI32_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI32_BuildProc);
var
  TempStoreBuff: TKDT8192DI32yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DI32_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8192DI32_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8192DI32_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8192DI32_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8192DI32_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DI32.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI32_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT8192DI32.Search(const Buff: TKDT8192DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DI32_Node;

var
  NearestNeighbour: PKDT8192DI32_Node;

  function FindParentNode(const BuffPtr: PKDT8192DI32_Vec; NodePtr: PKDT8192DI32_Node): PKDT8192DI32_Node;
  var
    Next       : PKDT8192DI32_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT8192DI32_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8192DI32_Node; const BuffPtr: PKDT8192DI32_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8192DI32Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT8192DI32_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8192DI32_Vec; const p1, p2: PKDT8192DI32_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8192DI32Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8192DI32Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8192DI32_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8192DI32_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8192DI32_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8192DI32Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8192DI32_Node(NearestNodes[0]);
    end;
end;

function TKDT8192DI32.Search(const Buff: TKDT8192DI32_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DI32_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8192DI32.Search(const Buff: TKDT8192DI32_Vec; var SearchedDistanceMin: Double): PKDT8192DI32_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8192DI32.Search(const Buff: TKDT8192DI32_Vec): PKDT8192DI32_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8192DI32.Search(const inBuff: TKDT8192DI32_DynamicVecBuffer; var OutBuff: TKDT8192DI32_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8192DI32_DynamicVecBuffer;
  outBuffPtr : PKDT8192DI32_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8192DI32_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8192DI32_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8192DI32_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8192DI32.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8192DI32_Source));
end;

procedure TKDT8192DI32.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8192DI32_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8192DI32.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8192DI32.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT8192DI32.PrintNodeTree(const NodePtr: PKDT8192DI32_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8192DI32_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8192DI32Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8192DI32.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8192DI32Vec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT8192DI32.Test_BuildM(IndexFor: NativeInt; var Source: TKDT8192DI32_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8192DI32.Test;
var
  TKDT8192DI32_Test    : TKDT8192DI32;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8192DI32_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8192DI32_Test := TKDT8192DI32.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8192DI32_Test.TestBuff, 300);
  for i := 0 to length(TKDT8192DI32_Test.TestBuff) - 1 do
    for j := 0 to TKDT8192DI32_AxisCount - 1 do
        TKDT8192DI32_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT8192DI32_Test.TestBuff), length(TKDT8192DI32_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8192DI32_Test.BuildKDTreeM(False, length(TKDT8192DI32_Test.TestBuff), @TKDT8192DI32_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8192DI32_Test.BuildKDTreeM(False, length(TKDT8192DI32_Test.TestBuff), TKDT8192DI32_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8192DI32_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8192DI32_Test.TestBuff));
  TKDT8192DI32_Test.Search(TKDT8192DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8192DI32Distance(TKDT8192DI32_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8192DI32_Test.Clear;
  { kMean test }
  TKDT8192DI32_Test.BuildKDTreeWithCluster(TKDT8192DI32_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8192DI32_Test.Search(TKDT8192DI32_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8192DI32_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8192DI32_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8192DI32_Test);
end;

{$ENDIF DEBUG}

{$IFDEF DEBUG}
procedure Test_All;
begin
  TKDT1DI32.Test();
  TKDT2DI32.Test();
  TKDT3DI32.Test();
  TKDT4DI32.Test();
  TKDT5DI32.Test();
  TKDT6DI32.Test();
  TKDT7DI32.Test();
  TKDT8DI32.Test();
  TKDT9DI32.Test();
  TKDT10DI32.Test();
  TKDT11DI32.Test();
  TKDT12DI32.Test();
  TKDT13DI32.Test();
  TKDT14DI32.Test();
  TKDT15DI32.Test();
  TKDT16DI32.Test();
  TKDT17DI32.Test();
  TKDT18DI32.Test();
  TKDT19DI32.Test();
  TKDT20DI32.Test();
  TKDT21DI32.Test();
  TKDT22DI32.Test();
  TKDT23DI32.Test();
  TKDT24DI32.Test();
  TKDT25DI32.Test();
  TKDT26DI32.Test();
  TKDT27DI32.Test();
  TKDT28DI32.Test();
  TKDT29DI32.Test();
  TKDT30DI32.Test();
  TKDT32DI32.Test();
  TKDT34DI32.Test();
  TKDT36DI32.Test();
  TKDT38DI32.Test();
  TKDT40DI32.Test();
  TKDT44DI32.Test();
  TKDT48DI32.Test();
  TKDT50DI32.Test();
  TKDT56DI32.Test();
  TKDT60DI32.Test();
  TKDT64DI32.Test();
  TKDT72DI32.Test();
  TKDT84DI32.Test();
  TKDT96DI32.Test();
  TKDT128DI32.Test();
  TKDT140DI32.Test();
  TKDT160DI32.Test();
  TKDT196DI32.Test();
  TKDT256DI32.Test();
  TKDT272DI32.Test();
  TKDT288DI32.Test();
  TKDT372DI32.Test();
  TKDT512DI32.Test();
  TKDT576DI32.Test();
  TKDT768DI32.Test();
  TKDT1024DI32.Test();
  TKDT1040DI32.Test();
  TKDT1056DI32.Test();
  TKDT1536DI32.Test();
  TKDT1920DI32.Test();
  TKDT1980DI32.Test();
  TKDT2048DI32.Test();
  TKDT3072DI32.Test();
  TKDT3088DI32.Test();
  TKDT3104DI32.Test();
  TKDT4096DI32.Test();
  TKDT8192DI32.Test();
  DoStatus('All Test Finished');
end;
{$ENDIF}




initialization

finalization

end.

