{ Fast KDTree Double Type support                                                }
{ ****************************************************************************** }
{ * fast KDTree Support,writen by QQ 600585@qq.com                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ ****************************************************************************** }

unit FastKDTreeE;

interface

uses CoreClasses, KM;

{$I zDefine.inc}

{$IFDEF FPC}
{$DEFINE DEBUG}
{$ENDIF FPC}

const

  // extended float: KDTree
  TKDT1DE_AxisCount = 1;
  TKDT2DE_AxisCount = 2;
  TKDT3DE_AxisCount = 3;
  TKDT4DE_AxisCount = 4;
  TKDT5DE_AxisCount = 5;
  TKDT6DE_AxisCount = 6;
  TKDT7DE_AxisCount = 7;
  TKDT8DE_AxisCount = 8;
  TKDT9DE_AxisCount = 9;
  TKDT10DE_AxisCount = 10;
  TKDT11DE_AxisCount = 11;
  TKDT12DE_AxisCount = 12;
  TKDT13DE_AxisCount = 13;
  TKDT14DE_AxisCount = 14;
  TKDT15DE_AxisCount = 15;
  TKDT16DE_AxisCount = 16;
  TKDT17DE_AxisCount = 17;
  TKDT18DE_AxisCount = 18;
  TKDT19DE_AxisCount = 19;
  TKDT20DE_AxisCount = 20;
  TKDT21DE_AxisCount = 21;
  TKDT22DE_AxisCount = 22;
  TKDT23DE_AxisCount = 23;
  TKDT24DE_AxisCount = 24;
  TKDT25DE_AxisCount = 25;
  TKDT26DE_AxisCount = 26;
  TKDT27DE_AxisCount = 27;
  TKDT28DE_AxisCount = 28;
  TKDT29DE_AxisCount = 29;
  TKDT30DE_AxisCount = 30;
  TKDT32DE_AxisCount = 32;
  TKDT34DE_AxisCount = 34;
  TKDT36DE_AxisCount = 36;
  TKDT38DE_AxisCount = 38;
  TKDT40DE_AxisCount = 40;
  TKDT44DE_AxisCount = 44;
  TKDT48DE_AxisCount = 48;
  TKDT50DE_AxisCount = 50;
  TKDT56DE_AxisCount = 56;
  TKDT60DE_AxisCount = 60;
  TKDT64DE_AxisCount = 64;
  TKDT72DE_AxisCount = 72;
  TKDT84DE_AxisCount = 84;
  TKDT96DE_AxisCount = 96;
  TKDT128DE_AxisCount = 128;
  TKDT140DE_AxisCount = 140;
  TKDT160DE_AxisCount = 160;
  TKDT196DE_AxisCount = 196;
  TKDT256DE_AxisCount = 256;
  TKDT272DE_AxisCount = 272;
  TKDT288DE_AxisCount = 288;
  TKDT372DE_AxisCount = 372;
  TKDT512DE_AxisCount = 512;
  TKDT576DE_AxisCount = 576;
  TKDT768DE_AxisCount = 768;
  TKDT1024DE_AxisCount = 1024;
  TKDT1040DE_AxisCount = 1040;
  TKDT1056DE_AxisCount = 1056;
  TKDT1536DE_AxisCount = 1536;
  TKDT1920DE_AxisCount = 1920;
  TKDT1980DE_AxisCount = 1980;
  TKDT2048DE_AxisCount = 2048;
  TKDT3072DE_AxisCount = 3072;
  TKDT3088DE_AxisCount = 3088;
  TKDT3104DE_AxisCount = 3104;
  TKDT4096DE_AxisCount = 4096;
  TKDT8192DE_AxisCount = 8192;

type

  // extended float: KDTree
  TKDT1DE = class; TKDT1DE_VecType = Extended; // 1D
  TKDT2DE = class; TKDT2DE_VecType = Extended; // 2D
  TKDT3DE = class; TKDT3DE_VecType = Extended; // 3D
  TKDT4DE = class; TKDT4DE_VecType = Extended; // 4D
  TKDT5DE = class; TKDT5DE_VecType = Extended; // 5D
  TKDT6DE = class; TKDT6DE_VecType = Extended; // 6D
  TKDT7DE = class; TKDT7DE_VecType = Extended; // 7D
  TKDT8DE = class; TKDT8DE_VecType = Extended; // 8D
  TKDT9DE = class; TKDT9DE_VecType = Extended; // 9D
  TKDT10DE = class; TKDT10DE_VecType = Extended; // 10D
  TKDT11DE = class; TKDT11DE_VecType = Extended; // 11D
  TKDT12DE = class; TKDT12DE_VecType = Extended; // 12D
  TKDT13DE = class; TKDT13DE_VecType = Extended; // 13D
  TKDT14DE = class; TKDT14DE_VecType = Extended; // 14D
  TKDT15DE = class; TKDT15DE_VecType = Extended; // 15D
  TKDT16DE = class; TKDT16DE_VecType = Extended; // 16D
  TKDT17DE = class; TKDT17DE_VecType = Extended; // 17D
  TKDT18DE = class; TKDT18DE_VecType = Extended; // 18D
  TKDT19DE = class; TKDT19DE_VecType = Extended; // 19D
  TKDT20DE = class; TKDT20DE_VecType = Extended; // 20D
  TKDT21DE = class; TKDT21DE_VecType = Extended; // 21D
  TKDT22DE = class; TKDT22DE_VecType = Extended; // 22D
  TKDT23DE = class; TKDT23DE_VecType = Extended; // 23D
  TKDT24DE = class; TKDT24DE_VecType = Extended; // 24D
  TKDT25DE = class; TKDT25DE_VecType = Extended; // 25D
  TKDT26DE = class; TKDT26DE_VecType = Extended; // 26D
  TKDT27DE = class; TKDT27DE_VecType = Extended; // 27D
  TKDT28DE = class; TKDT28DE_VecType = Extended; // 28D
  TKDT29DE = class; TKDT29DE_VecType = Extended; // 29D
  TKDT30DE = class; TKDT30DE_VecType = Extended; // 30D
  TKDT32DE = class; TKDT32DE_VecType = Extended; // 32D
  TKDT34DE = class; TKDT34DE_VecType = Extended; // 34D
  TKDT36DE = class; TKDT36DE_VecType = Extended; // 36D
  TKDT38DE = class; TKDT38DE_VecType = Extended; // 38D
  TKDT40DE = class; TKDT40DE_VecType = Extended; // 40D
  TKDT44DE = class; TKDT44DE_VecType = Extended; // 44D
  TKDT48DE = class; TKDT48DE_VecType = Extended; // 48D
  TKDT50DE = class; TKDT50DE_VecType = Extended; // 50D
  TKDT56DE = class; TKDT56DE_VecType = Extended; // 56D
  TKDT60DE = class; TKDT60DE_VecType = Extended; // 60D
  TKDT64DE = class; TKDT64DE_VecType = Extended; // 64D
  TKDT72DE = class; TKDT72DE_VecType = Extended; // 72D
  TKDT84DE = class; TKDT84DE_VecType = Extended; // 84D
  TKDT96DE = class; TKDT96DE_VecType = Extended; // 96D
  TKDT128DE = class; TKDT128DE_VecType = Extended; // 128D
  TKDT140DE = class; TKDT140DE_VecType = Extended; // 140D
  TKDT160DE = class; TKDT160DE_VecType = Extended; // 160D
  TKDT196DE = class; TKDT196DE_VecType = Extended; // 196D
  TKDT256DE = class; TKDT256DE_VecType = Extended; // 256D
  TKDT272DE = class; TKDT272DE_VecType = Extended; // 272D
  TKDT288DE = class; TKDT288DE_VecType = Extended; // 288D
  TKDT372DE = class; TKDT372DE_VecType = Extended; // 372D
  TKDT512DE = class; TKDT512DE_VecType = Extended; // 512D
  TKDT576DE = class; TKDT576DE_VecType = Extended; // 576D
  TKDT768DE = class; TKDT768DE_VecType = Extended; // 768D
  TKDT1024DE = class; TKDT1024DE_VecType = Extended; // 1024D
  TKDT1040DE = class; TKDT1040DE_VecType = Extended; // 1040D
  TKDT1056DE = class; TKDT1056DE_VecType = Extended; // 1056D
  TKDT1536DE = class; TKDT1536DE_VecType = Extended; // 1536D
  TKDT1920DE = class; TKDT1920DE_VecType = Extended; // 1920D
  TKDT1980DE = class; TKDT1980DE_VecType = Extended; // 1980D
  TKDT2048DE = class; TKDT2048DE_VecType = Extended; // 2048D
  TKDT3072DE = class; TKDT3072DE_VecType = Extended; // 3072D
  TKDT3088DE = class; TKDT3088DE_VecType = Extended; // 3088D
  TKDT3104DE = class; TKDT3104DE_VecType = Extended; // 3104D
  TKDT4096DE = class; TKDT4096DE_VecType = Extended; // 4096D
  TKDT8192DE = class; TKDT8192DE_VecType = Extended; // 8192D










  // extended float: KDTree


  TKDT1DE_Vec = array [0 .. TKDT1DE_AxisCount - 1] of TKDT1DE_VecType;
  PKDT1DE_Vec = ^TKDT1DE_Vec;

  TKDT1DE_DynamicVecBuffer = array of TKDT1DE_Vec;
  PKDT1DE_DynamicVecBuffer = ^TKDT1DE_DynamicVecBuffer;

  TKDT1DE_Source = packed record
    Buff: TKDT1DE_Vec;
    index: Int64;
  end;

  PKDT1DE_Source       = ^TKDT1DE_Source;
  TKDT1DE_SourceBuffer = array [0 .. 0] of PKDT1DE_Source;
  PKDT1DE_SourceBuffer = ^TKDT1DE_SourceBuffer;

  TKDT1DEyanmicSourceBuffer = array of PKDT1DE_Source;
  PKDT1DEyanmicSourceBuffer = ^TKDT1DEyanmicSourceBuffer;

  TKDT1DEyanmicStoreBuffer = array of TKDT1DE_Source;
  PKDT1DEyanmicStoreBuffer = ^TKDT1DEyanmicStoreBuffer;

  PKDT1DE_Node = ^TKDT1DE_Node;

  TKDT1DE_Node = packed record
    Parent, Right, Left: PKDT1DE_Node;
    vec: PKDT1DE_Source;
  end;

  TKDT1DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1DE_Source);
  TKDT1DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1DE_Source) of object;
  {$IFNDEF FPC}
  TKDT1DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1DE_Source);
  {$ENDIF}

  TKDT1DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1DEyanmicStoreBuffer;
    KDBuff     : TKDT1DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1DEyanmicStoreBuffer; const Buff: TKDT1DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DE_Node; overload;
    function Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DE_Node; overload;
    function Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double): PKDT1DE_Node; overload;
    function Search(const Buff: TKDT1DE_Vec): PKDT1DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1DE_DynamicVecBuffer; var OutBuff: TKDT1DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT2DE_Vec = array [0 .. TKDT2DE_AxisCount - 1] of TKDT2DE_VecType;
  PKDT2DE_Vec = ^TKDT2DE_Vec;

  TKDT2DE_DynamicVecBuffer = array of TKDT2DE_Vec;
  PKDT2DE_DynamicVecBuffer = ^TKDT2DE_DynamicVecBuffer;

  TKDT2DE_Source = packed record
    Buff: TKDT2DE_Vec;
    index: Int64;
  end;

  PKDT2DE_Source       = ^TKDT2DE_Source;
  TKDT2DE_SourceBuffer = array [0 .. 0] of PKDT2DE_Source;
  PKDT2DE_SourceBuffer = ^TKDT2DE_SourceBuffer;

  TKDT2DEyanmicSourceBuffer = array of PKDT2DE_Source;
  PKDT2DEyanmicSourceBuffer = ^TKDT2DEyanmicSourceBuffer;

  TKDT2DEyanmicStoreBuffer = array of TKDT2DE_Source;
  PKDT2DEyanmicStoreBuffer = ^TKDT2DEyanmicStoreBuffer;

  PKDT2DE_Node = ^TKDT2DE_Node;

  TKDT2DE_Node = packed record
    Parent, Right, Left: PKDT2DE_Node;
    vec: PKDT2DE_Source;
  end;

  TKDT2DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT2DE_Source);
  TKDT2DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT2DE_Source) of object;
  {$IFNDEF FPC}
  TKDT2DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT2DE_Source);
  {$ENDIF}

  TKDT2DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2DEyanmicStoreBuffer;
    KDBuff     : TKDT2DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT2DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT2DEyanmicStoreBuffer; const Buff: TKDT2DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT2DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DE_Node; overload;
    function Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DE_Node; overload;
    function Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double): PKDT2DE_Node; overload;
    function Search(const Buff: TKDT2DE_Vec): PKDT2DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2DE_DynamicVecBuffer; var OutBuff: TKDT2DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT2DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT2DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3DE_Vec = array [0 .. TKDT3DE_AxisCount - 1] of TKDT3DE_VecType;
  PKDT3DE_Vec = ^TKDT3DE_Vec;

  TKDT3DE_DynamicVecBuffer = array of TKDT3DE_Vec;
  PKDT3DE_DynamicVecBuffer = ^TKDT3DE_DynamicVecBuffer;

  TKDT3DE_Source = packed record
    Buff: TKDT3DE_Vec;
    index: Int64;
  end;

  PKDT3DE_Source       = ^TKDT3DE_Source;
  TKDT3DE_SourceBuffer = array [0 .. 0] of PKDT3DE_Source;
  PKDT3DE_SourceBuffer = ^TKDT3DE_SourceBuffer;

  TKDT3DEyanmicSourceBuffer = array of PKDT3DE_Source;
  PKDT3DEyanmicSourceBuffer = ^TKDT3DEyanmicSourceBuffer;

  TKDT3DEyanmicStoreBuffer = array of TKDT3DE_Source;
  PKDT3DEyanmicStoreBuffer = ^TKDT3DEyanmicStoreBuffer;

  PKDT3DE_Node = ^TKDT3DE_Node;

  TKDT3DE_Node = packed record
    Parent, Right, Left: PKDT3DE_Node;
    vec: PKDT3DE_Source;
  end;

  TKDT3DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3DE_Source);
  TKDT3DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3DE_Source) of object;
  {$IFNDEF FPC}
  TKDT3DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3DE_Source);
  {$ENDIF}

  TKDT3DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3DEyanmicStoreBuffer;
    KDBuff     : TKDT3DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3DEyanmicStoreBuffer; const Buff: TKDT3DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DE_Node; overload;
    function Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DE_Node; overload;
    function Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double): PKDT3DE_Node; overload;
    function Search(const Buff: TKDT3DE_Vec): PKDT3DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3DE_DynamicVecBuffer; var OutBuff: TKDT3DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT4DE_Vec = array [0 .. TKDT4DE_AxisCount - 1] of TKDT4DE_VecType;
  PKDT4DE_Vec = ^TKDT4DE_Vec;

  TKDT4DE_DynamicVecBuffer = array of TKDT4DE_Vec;
  PKDT4DE_DynamicVecBuffer = ^TKDT4DE_DynamicVecBuffer;

  TKDT4DE_Source = packed record
    Buff: TKDT4DE_Vec;
    index: Int64;
  end;

  PKDT4DE_Source       = ^TKDT4DE_Source;
  TKDT4DE_SourceBuffer = array [0 .. 0] of PKDT4DE_Source;
  PKDT4DE_SourceBuffer = ^TKDT4DE_SourceBuffer;

  TKDT4DEyanmicSourceBuffer = array of PKDT4DE_Source;
  PKDT4DEyanmicSourceBuffer = ^TKDT4DEyanmicSourceBuffer;

  TKDT4DEyanmicStoreBuffer = array of TKDT4DE_Source;
  PKDT4DEyanmicStoreBuffer = ^TKDT4DEyanmicStoreBuffer;

  PKDT4DE_Node = ^TKDT4DE_Node;

  TKDT4DE_Node = packed record
    Parent, Right, Left: PKDT4DE_Node;
    vec: PKDT4DE_Source;
  end;

  TKDT4DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT4DE_Source);
  TKDT4DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT4DE_Source) of object;
  {$IFNDEF FPC}
  TKDT4DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT4DE_Source);
  {$ENDIF}

  TKDT4DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT4DEyanmicStoreBuffer;
    KDBuff     : TKDT4DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT4DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT4DEyanmicStoreBuffer; const Buff: TKDT4DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT4DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT4DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DE_Node; overload;
    function Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DE_Node; overload;
    function Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double): PKDT4DE_Node; overload;
    function Search(const Buff: TKDT4DE_Vec): PKDT4DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4DE_DynamicVecBuffer; var OutBuff: TKDT4DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT4DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT4DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT5DE_Vec = array [0 .. TKDT5DE_AxisCount - 1] of TKDT5DE_VecType;
  PKDT5DE_Vec = ^TKDT5DE_Vec;

  TKDT5DE_DynamicVecBuffer = array of TKDT5DE_Vec;
  PKDT5DE_DynamicVecBuffer = ^TKDT5DE_DynamicVecBuffer;

  TKDT5DE_Source = packed record
    Buff: TKDT5DE_Vec;
    index: Int64;
  end;

  PKDT5DE_Source       = ^TKDT5DE_Source;
  TKDT5DE_SourceBuffer = array [0 .. 0] of PKDT5DE_Source;
  PKDT5DE_SourceBuffer = ^TKDT5DE_SourceBuffer;

  TKDT5DEyanmicSourceBuffer = array of PKDT5DE_Source;
  PKDT5DEyanmicSourceBuffer = ^TKDT5DEyanmicSourceBuffer;

  TKDT5DEyanmicStoreBuffer = array of TKDT5DE_Source;
  PKDT5DEyanmicStoreBuffer = ^TKDT5DEyanmicStoreBuffer;

  PKDT5DE_Node = ^TKDT5DE_Node;

  TKDT5DE_Node = packed record
    Parent, Right, Left: PKDT5DE_Node;
    vec: PKDT5DE_Source;
  end;

  TKDT5DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT5DE_Source);
  TKDT5DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT5DE_Source) of object;
  {$IFNDEF FPC}
  TKDT5DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT5DE_Source);
  {$ENDIF}

  TKDT5DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT5DEyanmicStoreBuffer;
    KDBuff     : TKDT5DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT5DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT5DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT5DEyanmicStoreBuffer; const Buff: TKDT5DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT5DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT5DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT5DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT5DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DE_Node; overload;
    function Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DE_Node; overload;
    function Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double): PKDT5DE_Node; overload;
    function Search(const Buff: TKDT5DE_Vec): PKDT5DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT5DE_DynamicVecBuffer; var OutBuff: TKDT5DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT5DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT5DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT6DE_Vec = array [0 .. TKDT6DE_AxisCount - 1] of TKDT6DE_VecType;
  PKDT6DE_Vec = ^TKDT6DE_Vec;

  TKDT6DE_DynamicVecBuffer = array of TKDT6DE_Vec;
  PKDT6DE_DynamicVecBuffer = ^TKDT6DE_DynamicVecBuffer;

  TKDT6DE_Source = packed record
    Buff: TKDT6DE_Vec;
    index: Int64;
  end;

  PKDT6DE_Source       = ^TKDT6DE_Source;
  TKDT6DE_SourceBuffer = array [0 .. 0] of PKDT6DE_Source;
  PKDT6DE_SourceBuffer = ^TKDT6DE_SourceBuffer;

  TKDT6DEyanmicSourceBuffer = array of PKDT6DE_Source;
  PKDT6DEyanmicSourceBuffer = ^TKDT6DEyanmicSourceBuffer;

  TKDT6DEyanmicStoreBuffer = array of TKDT6DE_Source;
  PKDT6DEyanmicStoreBuffer = ^TKDT6DEyanmicStoreBuffer;

  PKDT6DE_Node = ^TKDT6DE_Node;

  TKDT6DE_Node = packed record
    Parent, Right, Left: PKDT6DE_Node;
    vec: PKDT6DE_Source;
  end;

  TKDT6DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT6DE_Source);
  TKDT6DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT6DE_Source) of object;
  {$IFNDEF FPC}
  TKDT6DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT6DE_Source);
  {$ENDIF}

  TKDT6DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT6DEyanmicStoreBuffer;
    KDBuff     : TKDT6DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT6DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT6DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT6DEyanmicStoreBuffer; const Buff: TKDT6DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT6DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT6DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT6DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DE_Node; overload;
    function Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DE_Node; overload;
    function Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double): PKDT6DE_Node; overload;
    function Search(const Buff: TKDT6DE_Vec): PKDT6DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT6DE_DynamicVecBuffer; var OutBuff: TKDT6DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT6DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT6DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT7DE_Vec = array [0 .. TKDT7DE_AxisCount - 1] of TKDT7DE_VecType;
  PKDT7DE_Vec = ^TKDT7DE_Vec;

  TKDT7DE_DynamicVecBuffer = array of TKDT7DE_Vec;
  PKDT7DE_DynamicVecBuffer = ^TKDT7DE_DynamicVecBuffer;

  TKDT7DE_Source = packed record
    Buff: TKDT7DE_Vec;
    index: Int64;
  end;

  PKDT7DE_Source       = ^TKDT7DE_Source;
  TKDT7DE_SourceBuffer = array [0 .. 0] of PKDT7DE_Source;
  PKDT7DE_SourceBuffer = ^TKDT7DE_SourceBuffer;

  TKDT7DEyanmicSourceBuffer = array of PKDT7DE_Source;
  PKDT7DEyanmicSourceBuffer = ^TKDT7DEyanmicSourceBuffer;

  TKDT7DEyanmicStoreBuffer = array of TKDT7DE_Source;
  PKDT7DEyanmicStoreBuffer = ^TKDT7DEyanmicStoreBuffer;

  PKDT7DE_Node = ^TKDT7DE_Node;

  TKDT7DE_Node = packed record
    Parent, Right, Left: PKDT7DE_Node;
    vec: PKDT7DE_Source;
  end;

  TKDT7DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT7DE_Source);
  TKDT7DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT7DE_Source) of object;
  {$IFNDEF FPC}
  TKDT7DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT7DE_Source);
  {$ENDIF}

  TKDT7DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT7DEyanmicStoreBuffer;
    KDBuff     : TKDT7DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT7DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT7DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT7DEyanmicStoreBuffer; const Buff: TKDT7DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT7DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT7DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT7DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT7DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DE_Node; overload;
    function Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DE_Node; overload;
    function Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double): PKDT7DE_Node; overload;
    function Search(const Buff: TKDT7DE_Vec): PKDT7DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT7DE_DynamicVecBuffer; var OutBuff: TKDT7DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT7DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT7DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT8DE_Vec = array [0 .. TKDT8DE_AxisCount - 1] of TKDT8DE_VecType;
  PKDT8DE_Vec = ^TKDT8DE_Vec;

  TKDT8DE_DynamicVecBuffer = array of TKDT8DE_Vec;
  PKDT8DE_DynamicVecBuffer = ^TKDT8DE_DynamicVecBuffer;

  TKDT8DE_Source = packed record
    Buff: TKDT8DE_Vec;
    index: Int64;
  end;

  PKDT8DE_Source       = ^TKDT8DE_Source;
  TKDT8DE_SourceBuffer = array [0 .. 0] of PKDT8DE_Source;
  PKDT8DE_SourceBuffer = ^TKDT8DE_SourceBuffer;

  TKDT8DEyanmicSourceBuffer = array of PKDT8DE_Source;
  PKDT8DEyanmicSourceBuffer = ^TKDT8DEyanmicSourceBuffer;

  TKDT8DEyanmicStoreBuffer = array of TKDT8DE_Source;
  PKDT8DEyanmicStoreBuffer = ^TKDT8DEyanmicStoreBuffer;

  PKDT8DE_Node = ^TKDT8DE_Node;

  TKDT8DE_Node = packed record
    Parent, Right, Left: PKDT8DE_Node;
    vec: PKDT8DE_Source;
  end;

  TKDT8DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT8DE_Source);
  TKDT8DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT8DE_Source) of object;
  {$IFNDEF FPC}
  TKDT8DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT8DE_Source);
  {$ENDIF}

  TKDT8DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT8DEyanmicStoreBuffer;
    KDBuff     : TKDT8DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT8DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT8DEyanmicStoreBuffer; const Buff: TKDT8DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT8DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT8DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DE_Node; overload;
    function Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DE_Node; overload;
    function Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double): PKDT8DE_Node; overload;
    function Search(const Buff: TKDT8DE_Vec): PKDT8DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8DE_DynamicVecBuffer; var OutBuff: TKDT8DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT8DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT8DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT9DE_Vec = array [0 .. TKDT9DE_AxisCount - 1] of TKDT9DE_VecType;
  PKDT9DE_Vec = ^TKDT9DE_Vec;

  TKDT9DE_DynamicVecBuffer = array of TKDT9DE_Vec;
  PKDT9DE_DynamicVecBuffer = ^TKDT9DE_DynamicVecBuffer;

  TKDT9DE_Source = packed record
    Buff: TKDT9DE_Vec;
    index: Int64;
  end;

  PKDT9DE_Source       = ^TKDT9DE_Source;
  TKDT9DE_SourceBuffer = array [0 .. 0] of PKDT9DE_Source;
  PKDT9DE_SourceBuffer = ^TKDT9DE_SourceBuffer;

  TKDT9DEyanmicSourceBuffer = array of PKDT9DE_Source;
  PKDT9DEyanmicSourceBuffer = ^TKDT9DEyanmicSourceBuffer;

  TKDT9DEyanmicStoreBuffer = array of TKDT9DE_Source;
  PKDT9DEyanmicStoreBuffer = ^TKDT9DEyanmicStoreBuffer;

  PKDT9DE_Node = ^TKDT9DE_Node;

  TKDT9DE_Node = packed record
    Parent, Right, Left: PKDT9DE_Node;
    vec: PKDT9DE_Source;
  end;

  TKDT9DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT9DE_Source);
  TKDT9DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT9DE_Source) of object;
  {$IFNDEF FPC}
  TKDT9DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT9DE_Source);
  {$ENDIF}

  TKDT9DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT9DEyanmicStoreBuffer;
    KDBuff     : TKDT9DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT9DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT9DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT9DEyanmicStoreBuffer; const Buff: TKDT9DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT9DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT9DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT9DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT9DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DE_Node; overload;
    function Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DE_Node; overload;
    function Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double): PKDT9DE_Node; overload;
    function Search(const Buff: TKDT9DE_Vec): PKDT9DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT9DE_DynamicVecBuffer; var OutBuff: TKDT9DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT9DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT9DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT10DE_Vec = array [0 .. TKDT10DE_AxisCount - 1] of TKDT10DE_VecType;
  PKDT10DE_Vec = ^TKDT10DE_Vec;

  TKDT10DE_DynamicVecBuffer = array of TKDT10DE_Vec;
  PKDT10DE_DynamicVecBuffer = ^TKDT10DE_DynamicVecBuffer;

  TKDT10DE_Source = packed record
    Buff: TKDT10DE_Vec;
    index: Int64;
  end;

  PKDT10DE_Source       = ^TKDT10DE_Source;
  TKDT10DE_SourceBuffer = array [0 .. 0] of PKDT10DE_Source;
  PKDT10DE_SourceBuffer = ^TKDT10DE_SourceBuffer;

  TKDT10DEyanmicSourceBuffer = array of PKDT10DE_Source;
  PKDT10DEyanmicSourceBuffer = ^TKDT10DEyanmicSourceBuffer;

  TKDT10DEyanmicStoreBuffer = array of TKDT10DE_Source;
  PKDT10DEyanmicStoreBuffer = ^TKDT10DEyanmicStoreBuffer;

  PKDT10DE_Node = ^TKDT10DE_Node;

  TKDT10DE_Node = packed record
    Parent, Right, Left: PKDT10DE_Node;
    vec: PKDT10DE_Source;
  end;

  TKDT10DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT10DE_Source);
  TKDT10DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT10DE_Source) of object;
  {$IFNDEF FPC}
  TKDT10DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT10DE_Source);
  {$ENDIF}

  TKDT10DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT10DEyanmicStoreBuffer;
    KDBuff     : TKDT10DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT10DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT10DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT10DEyanmicStoreBuffer; const Buff: TKDT10DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT10DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT10DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT10DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DE_Node; overload;
    function Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DE_Node; overload;
    function Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double): PKDT10DE_Node; overload;
    function Search(const Buff: TKDT10DE_Vec): PKDT10DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT10DE_DynamicVecBuffer; var OutBuff: TKDT10DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT10DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT10DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT11DE_Vec = array [0 .. TKDT11DE_AxisCount - 1] of TKDT11DE_VecType;
  PKDT11DE_Vec = ^TKDT11DE_Vec;

  TKDT11DE_DynamicVecBuffer = array of TKDT11DE_Vec;
  PKDT11DE_DynamicVecBuffer = ^TKDT11DE_DynamicVecBuffer;

  TKDT11DE_Source = packed record
    Buff: TKDT11DE_Vec;
    index: Int64;
  end;

  PKDT11DE_Source       = ^TKDT11DE_Source;
  TKDT11DE_SourceBuffer = array [0 .. 0] of PKDT11DE_Source;
  PKDT11DE_SourceBuffer = ^TKDT11DE_SourceBuffer;

  TKDT11DEyanmicSourceBuffer = array of PKDT11DE_Source;
  PKDT11DEyanmicSourceBuffer = ^TKDT11DEyanmicSourceBuffer;

  TKDT11DEyanmicStoreBuffer = array of TKDT11DE_Source;
  PKDT11DEyanmicStoreBuffer = ^TKDT11DEyanmicStoreBuffer;

  PKDT11DE_Node = ^TKDT11DE_Node;

  TKDT11DE_Node = packed record
    Parent, Right, Left: PKDT11DE_Node;
    vec: PKDT11DE_Source;
  end;

  TKDT11DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT11DE_Source);
  TKDT11DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT11DE_Source) of object;
  {$IFNDEF FPC}
  TKDT11DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT11DE_Source);
  {$ENDIF}

  TKDT11DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT11DEyanmicStoreBuffer;
    KDBuff     : TKDT11DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT11DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT11DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT11DEyanmicStoreBuffer; const Buff: TKDT11DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT11DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT11DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT11DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT11DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DE_Node; overload;
    function Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DE_Node; overload;
    function Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double): PKDT11DE_Node; overload;
    function Search(const Buff: TKDT11DE_Vec): PKDT11DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT11DE_DynamicVecBuffer; var OutBuff: TKDT11DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT11DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT11DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT12DE_Vec = array [0 .. TKDT12DE_AxisCount - 1] of TKDT12DE_VecType;
  PKDT12DE_Vec = ^TKDT12DE_Vec;

  TKDT12DE_DynamicVecBuffer = array of TKDT12DE_Vec;
  PKDT12DE_DynamicVecBuffer = ^TKDT12DE_DynamicVecBuffer;

  TKDT12DE_Source = packed record
    Buff: TKDT12DE_Vec;
    index: Int64;
  end;

  PKDT12DE_Source       = ^TKDT12DE_Source;
  TKDT12DE_SourceBuffer = array [0 .. 0] of PKDT12DE_Source;
  PKDT12DE_SourceBuffer = ^TKDT12DE_SourceBuffer;

  TKDT12DEyanmicSourceBuffer = array of PKDT12DE_Source;
  PKDT12DEyanmicSourceBuffer = ^TKDT12DEyanmicSourceBuffer;

  TKDT12DEyanmicStoreBuffer = array of TKDT12DE_Source;
  PKDT12DEyanmicStoreBuffer = ^TKDT12DEyanmicStoreBuffer;

  PKDT12DE_Node = ^TKDT12DE_Node;

  TKDT12DE_Node = packed record
    Parent, Right, Left: PKDT12DE_Node;
    vec: PKDT12DE_Source;
  end;

  TKDT12DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT12DE_Source);
  TKDT12DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT12DE_Source) of object;
  {$IFNDEF FPC}
  TKDT12DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT12DE_Source);
  {$ENDIF}

  TKDT12DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT12DEyanmicStoreBuffer;
    KDBuff     : TKDT12DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT12DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT12DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT12DEyanmicStoreBuffer; const Buff: TKDT12DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT12DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT12DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT12DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DE_Node; overload;
    function Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DE_Node; overload;
    function Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double): PKDT12DE_Node; overload;
    function Search(const Buff: TKDT12DE_Vec): PKDT12DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT12DE_DynamicVecBuffer; var OutBuff: TKDT12DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT12DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT12DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT13DE_Vec = array [0 .. TKDT13DE_AxisCount - 1] of TKDT13DE_VecType;
  PKDT13DE_Vec = ^TKDT13DE_Vec;

  TKDT13DE_DynamicVecBuffer = array of TKDT13DE_Vec;
  PKDT13DE_DynamicVecBuffer = ^TKDT13DE_DynamicVecBuffer;

  TKDT13DE_Source = packed record
    Buff: TKDT13DE_Vec;
    index: Int64;
  end;

  PKDT13DE_Source       = ^TKDT13DE_Source;
  TKDT13DE_SourceBuffer = array [0 .. 0] of PKDT13DE_Source;
  PKDT13DE_SourceBuffer = ^TKDT13DE_SourceBuffer;

  TKDT13DEyanmicSourceBuffer = array of PKDT13DE_Source;
  PKDT13DEyanmicSourceBuffer = ^TKDT13DEyanmicSourceBuffer;

  TKDT13DEyanmicStoreBuffer = array of TKDT13DE_Source;
  PKDT13DEyanmicStoreBuffer = ^TKDT13DEyanmicStoreBuffer;

  PKDT13DE_Node = ^TKDT13DE_Node;

  TKDT13DE_Node = packed record
    Parent, Right, Left: PKDT13DE_Node;
    vec: PKDT13DE_Source;
  end;

  TKDT13DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT13DE_Source);
  TKDT13DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT13DE_Source) of object;
  {$IFNDEF FPC}
  TKDT13DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT13DE_Source);
  {$ENDIF}

  TKDT13DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT13DEyanmicStoreBuffer;
    KDBuff     : TKDT13DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT13DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT13DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT13DEyanmicStoreBuffer; const Buff: TKDT13DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT13DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT13DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT13DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT13DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DE_Node; overload;
    function Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DE_Node; overload;
    function Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double): PKDT13DE_Node; overload;
    function Search(const Buff: TKDT13DE_Vec): PKDT13DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT13DE_DynamicVecBuffer; var OutBuff: TKDT13DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT13DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT13DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT14DE_Vec = array [0 .. TKDT14DE_AxisCount - 1] of TKDT14DE_VecType;
  PKDT14DE_Vec = ^TKDT14DE_Vec;

  TKDT14DE_DynamicVecBuffer = array of TKDT14DE_Vec;
  PKDT14DE_DynamicVecBuffer = ^TKDT14DE_DynamicVecBuffer;

  TKDT14DE_Source = packed record
    Buff: TKDT14DE_Vec;
    index: Int64;
  end;

  PKDT14DE_Source       = ^TKDT14DE_Source;
  TKDT14DE_SourceBuffer = array [0 .. 0] of PKDT14DE_Source;
  PKDT14DE_SourceBuffer = ^TKDT14DE_SourceBuffer;

  TKDT14DEyanmicSourceBuffer = array of PKDT14DE_Source;
  PKDT14DEyanmicSourceBuffer = ^TKDT14DEyanmicSourceBuffer;

  TKDT14DEyanmicStoreBuffer = array of TKDT14DE_Source;
  PKDT14DEyanmicStoreBuffer = ^TKDT14DEyanmicStoreBuffer;

  PKDT14DE_Node = ^TKDT14DE_Node;

  TKDT14DE_Node = packed record
    Parent, Right, Left: PKDT14DE_Node;
    vec: PKDT14DE_Source;
  end;

  TKDT14DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT14DE_Source);
  TKDT14DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT14DE_Source) of object;
  {$IFNDEF FPC}
  TKDT14DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT14DE_Source);
  {$ENDIF}

  TKDT14DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT14DEyanmicStoreBuffer;
    KDBuff     : TKDT14DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT14DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT14DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT14DEyanmicStoreBuffer; const Buff: TKDT14DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT14DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT14DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT14DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DE_Node; overload;
    function Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DE_Node; overload;
    function Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double): PKDT14DE_Node; overload;
    function Search(const Buff: TKDT14DE_Vec): PKDT14DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT14DE_DynamicVecBuffer; var OutBuff: TKDT14DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT14DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT14DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT15DE_Vec = array [0 .. TKDT15DE_AxisCount - 1] of TKDT15DE_VecType;
  PKDT15DE_Vec = ^TKDT15DE_Vec;

  TKDT15DE_DynamicVecBuffer = array of TKDT15DE_Vec;
  PKDT15DE_DynamicVecBuffer = ^TKDT15DE_DynamicVecBuffer;

  TKDT15DE_Source = packed record
    Buff: TKDT15DE_Vec;
    index: Int64;
  end;

  PKDT15DE_Source       = ^TKDT15DE_Source;
  TKDT15DE_SourceBuffer = array [0 .. 0] of PKDT15DE_Source;
  PKDT15DE_SourceBuffer = ^TKDT15DE_SourceBuffer;

  TKDT15DEyanmicSourceBuffer = array of PKDT15DE_Source;
  PKDT15DEyanmicSourceBuffer = ^TKDT15DEyanmicSourceBuffer;

  TKDT15DEyanmicStoreBuffer = array of TKDT15DE_Source;
  PKDT15DEyanmicStoreBuffer = ^TKDT15DEyanmicStoreBuffer;

  PKDT15DE_Node = ^TKDT15DE_Node;

  TKDT15DE_Node = packed record
    Parent, Right, Left: PKDT15DE_Node;
    vec: PKDT15DE_Source;
  end;

  TKDT15DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT15DE_Source);
  TKDT15DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT15DE_Source) of object;
  {$IFNDEF FPC}
  TKDT15DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT15DE_Source);
  {$ENDIF}

  TKDT15DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT15DEyanmicStoreBuffer;
    KDBuff     : TKDT15DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT15DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT15DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT15DEyanmicStoreBuffer; const Buff: TKDT15DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT15DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT15DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT15DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT15DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DE_Node; overload;
    function Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DE_Node; overload;
    function Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double): PKDT15DE_Node; overload;
    function Search(const Buff: TKDT15DE_Vec): PKDT15DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT15DE_DynamicVecBuffer; var OutBuff: TKDT15DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT15DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT15DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT16DE_Vec = array [0 .. TKDT16DE_AxisCount - 1] of TKDT16DE_VecType;
  PKDT16DE_Vec = ^TKDT16DE_Vec;

  TKDT16DE_DynamicVecBuffer = array of TKDT16DE_Vec;
  PKDT16DE_DynamicVecBuffer = ^TKDT16DE_DynamicVecBuffer;

  TKDT16DE_Source = packed record
    Buff: TKDT16DE_Vec;
    index: Int64;
  end;

  PKDT16DE_Source       = ^TKDT16DE_Source;
  TKDT16DE_SourceBuffer = array [0 .. 0] of PKDT16DE_Source;
  PKDT16DE_SourceBuffer = ^TKDT16DE_SourceBuffer;

  TKDT16DEyanmicSourceBuffer = array of PKDT16DE_Source;
  PKDT16DEyanmicSourceBuffer = ^TKDT16DEyanmicSourceBuffer;

  TKDT16DEyanmicStoreBuffer = array of TKDT16DE_Source;
  PKDT16DEyanmicStoreBuffer = ^TKDT16DEyanmicStoreBuffer;

  PKDT16DE_Node = ^TKDT16DE_Node;

  TKDT16DE_Node = packed record
    Parent, Right, Left: PKDT16DE_Node;
    vec: PKDT16DE_Source;
  end;

  TKDT16DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT16DE_Source);
  TKDT16DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT16DE_Source) of object;
  {$IFNDEF FPC}
  TKDT16DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT16DE_Source);
  {$ENDIF}

  TKDT16DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT16DEyanmicStoreBuffer;
    KDBuff     : TKDT16DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT16DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT16DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT16DEyanmicStoreBuffer; const Buff: TKDT16DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT16DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT16DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT16DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DE_Node; overload;
    function Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DE_Node; overload;
    function Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double): PKDT16DE_Node; overload;
    function Search(const Buff: TKDT16DE_Vec): PKDT16DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT16DE_DynamicVecBuffer; var OutBuff: TKDT16DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT16DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT16DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT17DE_Vec = array [0 .. TKDT17DE_AxisCount - 1] of TKDT17DE_VecType;
  PKDT17DE_Vec = ^TKDT17DE_Vec;

  TKDT17DE_DynamicVecBuffer = array of TKDT17DE_Vec;
  PKDT17DE_DynamicVecBuffer = ^TKDT17DE_DynamicVecBuffer;

  TKDT17DE_Source = packed record
    Buff: TKDT17DE_Vec;
    index: Int64;
  end;

  PKDT17DE_Source       = ^TKDT17DE_Source;
  TKDT17DE_SourceBuffer = array [0 .. 0] of PKDT17DE_Source;
  PKDT17DE_SourceBuffer = ^TKDT17DE_SourceBuffer;

  TKDT17DEyanmicSourceBuffer = array of PKDT17DE_Source;
  PKDT17DEyanmicSourceBuffer = ^TKDT17DEyanmicSourceBuffer;

  TKDT17DEyanmicStoreBuffer = array of TKDT17DE_Source;
  PKDT17DEyanmicStoreBuffer = ^TKDT17DEyanmicStoreBuffer;

  PKDT17DE_Node = ^TKDT17DE_Node;

  TKDT17DE_Node = packed record
    Parent, Right, Left: PKDT17DE_Node;
    vec: PKDT17DE_Source;
  end;

  TKDT17DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT17DE_Source);
  TKDT17DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT17DE_Source) of object;
  {$IFNDEF FPC}
  TKDT17DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT17DE_Source);
  {$ENDIF}

  TKDT17DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT17DEyanmicStoreBuffer;
    KDBuff     : TKDT17DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT17DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT17DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT17DEyanmicStoreBuffer; const Buff: TKDT17DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT17DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT17DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT17DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT17DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DE_Node; overload;
    function Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DE_Node; overload;
    function Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double): PKDT17DE_Node; overload;
    function Search(const Buff: TKDT17DE_Vec): PKDT17DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT17DE_DynamicVecBuffer; var OutBuff: TKDT17DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT17DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT17DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT18DE_Vec = array [0 .. TKDT18DE_AxisCount - 1] of TKDT18DE_VecType;
  PKDT18DE_Vec = ^TKDT18DE_Vec;

  TKDT18DE_DynamicVecBuffer = array of TKDT18DE_Vec;
  PKDT18DE_DynamicVecBuffer = ^TKDT18DE_DynamicVecBuffer;

  TKDT18DE_Source = packed record
    Buff: TKDT18DE_Vec;
    index: Int64;
  end;

  PKDT18DE_Source       = ^TKDT18DE_Source;
  TKDT18DE_SourceBuffer = array [0 .. 0] of PKDT18DE_Source;
  PKDT18DE_SourceBuffer = ^TKDT18DE_SourceBuffer;

  TKDT18DEyanmicSourceBuffer = array of PKDT18DE_Source;
  PKDT18DEyanmicSourceBuffer = ^TKDT18DEyanmicSourceBuffer;

  TKDT18DEyanmicStoreBuffer = array of TKDT18DE_Source;
  PKDT18DEyanmicStoreBuffer = ^TKDT18DEyanmicStoreBuffer;

  PKDT18DE_Node = ^TKDT18DE_Node;

  TKDT18DE_Node = packed record
    Parent, Right, Left: PKDT18DE_Node;
    vec: PKDT18DE_Source;
  end;

  TKDT18DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT18DE_Source);
  TKDT18DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT18DE_Source) of object;
  {$IFNDEF FPC}
  TKDT18DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT18DE_Source);
  {$ENDIF}

  TKDT18DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT18DEyanmicStoreBuffer;
    KDBuff     : TKDT18DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT18DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT18DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT18DEyanmicStoreBuffer; const Buff: TKDT18DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT18DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT18DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT18DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DE_Node; overload;
    function Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DE_Node; overload;
    function Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double): PKDT18DE_Node; overload;
    function Search(const Buff: TKDT18DE_Vec): PKDT18DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT18DE_DynamicVecBuffer; var OutBuff: TKDT18DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT18DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT18DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT19DE_Vec = array [0 .. TKDT19DE_AxisCount - 1] of TKDT19DE_VecType;
  PKDT19DE_Vec = ^TKDT19DE_Vec;

  TKDT19DE_DynamicVecBuffer = array of TKDT19DE_Vec;
  PKDT19DE_DynamicVecBuffer = ^TKDT19DE_DynamicVecBuffer;

  TKDT19DE_Source = packed record
    Buff: TKDT19DE_Vec;
    index: Int64;
  end;

  PKDT19DE_Source       = ^TKDT19DE_Source;
  TKDT19DE_SourceBuffer = array [0 .. 0] of PKDT19DE_Source;
  PKDT19DE_SourceBuffer = ^TKDT19DE_SourceBuffer;

  TKDT19DEyanmicSourceBuffer = array of PKDT19DE_Source;
  PKDT19DEyanmicSourceBuffer = ^TKDT19DEyanmicSourceBuffer;

  TKDT19DEyanmicStoreBuffer = array of TKDT19DE_Source;
  PKDT19DEyanmicStoreBuffer = ^TKDT19DEyanmicStoreBuffer;

  PKDT19DE_Node = ^TKDT19DE_Node;

  TKDT19DE_Node = packed record
    Parent, Right, Left: PKDT19DE_Node;
    vec: PKDT19DE_Source;
  end;

  TKDT19DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT19DE_Source);
  TKDT19DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT19DE_Source) of object;
  {$IFNDEF FPC}
  TKDT19DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT19DE_Source);
  {$ENDIF}

  TKDT19DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT19DEyanmicStoreBuffer;
    KDBuff     : TKDT19DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT19DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT19DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT19DEyanmicStoreBuffer; const Buff: TKDT19DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT19DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT19DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT19DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT19DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DE_Node; overload;
    function Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DE_Node; overload;
    function Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double): PKDT19DE_Node; overload;
    function Search(const Buff: TKDT19DE_Vec): PKDT19DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT19DE_DynamicVecBuffer; var OutBuff: TKDT19DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT19DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT19DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT20DE_Vec = array [0 .. TKDT20DE_AxisCount - 1] of TKDT20DE_VecType;
  PKDT20DE_Vec = ^TKDT20DE_Vec;

  TKDT20DE_DynamicVecBuffer = array of TKDT20DE_Vec;
  PKDT20DE_DynamicVecBuffer = ^TKDT20DE_DynamicVecBuffer;

  TKDT20DE_Source = packed record
    Buff: TKDT20DE_Vec;
    index: Int64;
  end;

  PKDT20DE_Source       = ^TKDT20DE_Source;
  TKDT20DE_SourceBuffer = array [0 .. 0] of PKDT20DE_Source;
  PKDT20DE_SourceBuffer = ^TKDT20DE_SourceBuffer;

  TKDT20DEyanmicSourceBuffer = array of PKDT20DE_Source;
  PKDT20DEyanmicSourceBuffer = ^TKDT20DEyanmicSourceBuffer;

  TKDT20DEyanmicStoreBuffer = array of TKDT20DE_Source;
  PKDT20DEyanmicStoreBuffer = ^TKDT20DEyanmicStoreBuffer;

  PKDT20DE_Node = ^TKDT20DE_Node;

  TKDT20DE_Node = packed record
    Parent, Right, Left: PKDT20DE_Node;
    vec: PKDT20DE_Source;
  end;

  TKDT20DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT20DE_Source);
  TKDT20DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT20DE_Source) of object;
  {$IFNDEF FPC}
  TKDT20DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT20DE_Source);
  {$ENDIF}

  TKDT20DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT20DEyanmicStoreBuffer;
    KDBuff     : TKDT20DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT20DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT20DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT20DEyanmicStoreBuffer; const Buff: TKDT20DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT20DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT20DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT20DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DE_Node; overload;
    function Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DE_Node; overload;
    function Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double): PKDT20DE_Node; overload;
    function Search(const Buff: TKDT20DE_Vec): PKDT20DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT20DE_DynamicVecBuffer; var OutBuff: TKDT20DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT20DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT20DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT21DE_Vec = array [0 .. TKDT21DE_AxisCount - 1] of TKDT21DE_VecType;
  PKDT21DE_Vec = ^TKDT21DE_Vec;

  TKDT21DE_DynamicVecBuffer = array of TKDT21DE_Vec;
  PKDT21DE_DynamicVecBuffer = ^TKDT21DE_DynamicVecBuffer;

  TKDT21DE_Source = packed record
    Buff: TKDT21DE_Vec;
    index: Int64;
  end;

  PKDT21DE_Source       = ^TKDT21DE_Source;
  TKDT21DE_SourceBuffer = array [0 .. 0] of PKDT21DE_Source;
  PKDT21DE_SourceBuffer = ^TKDT21DE_SourceBuffer;

  TKDT21DEyanmicSourceBuffer = array of PKDT21DE_Source;
  PKDT21DEyanmicSourceBuffer = ^TKDT21DEyanmicSourceBuffer;

  TKDT21DEyanmicStoreBuffer = array of TKDT21DE_Source;
  PKDT21DEyanmicStoreBuffer = ^TKDT21DEyanmicStoreBuffer;

  PKDT21DE_Node = ^TKDT21DE_Node;

  TKDT21DE_Node = packed record
    Parent, Right, Left: PKDT21DE_Node;
    vec: PKDT21DE_Source;
  end;

  TKDT21DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT21DE_Source);
  TKDT21DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT21DE_Source) of object;
  {$IFNDEF FPC}
  TKDT21DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT21DE_Source);
  {$ENDIF}

  TKDT21DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT21DEyanmicStoreBuffer;
    KDBuff     : TKDT21DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT21DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT21DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT21DEyanmicStoreBuffer; const Buff: TKDT21DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT21DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT21DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT21DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT21DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DE_Node; overload;
    function Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DE_Node; overload;
    function Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double): PKDT21DE_Node; overload;
    function Search(const Buff: TKDT21DE_Vec): PKDT21DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT21DE_DynamicVecBuffer; var OutBuff: TKDT21DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT21DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT21DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT22DE_Vec = array [0 .. TKDT22DE_AxisCount - 1] of TKDT22DE_VecType;
  PKDT22DE_Vec = ^TKDT22DE_Vec;

  TKDT22DE_DynamicVecBuffer = array of TKDT22DE_Vec;
  PKDT22DE_DynamicVecBuffer = ^TKDT22DE_DynamicVecBuffer;

  TKDT22DE_Source = packed record
    Buff: TKDT22DE_Vec;
    index: Int64;
  end;

  PKDT22DE_Source       = ^TKDT22DE_Source;
  TKDT22DE_SourceBuffer = array [0 .. 0] of PKDT22DE_Source;
  PKDT22DE_SourceBuffer = ^TKDT22DE_SourceBuffer;

  TKDT22DEyanmicSourceBuffer = array of PKDT22DE_Source;
  PKDT22DEyanmicSourceBuffer = ^TKDT22DEyanmicSourceBuffer;

  TKDT22DEyanmicStoreBuffer = array of TKDT22DE_Source;
  PKDT22DEyanmicStoreBuffer = ^TKDT22DEyanmicStoreBuffer;

  PKDT22DE_Node = ^TKDT22DE_Node;

  TKDT22DE_Node = packed record
    Parent, Right, Left: PKDT22DE_Node;
    vec: PKDT22DE_Source;
  end;

  TKDT22DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT22DE_Source);
  TKDT22DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT22DE_Source) of object;
  {$IFNDEF FPC}
  TKDT22DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT22DE_Source);
  {$ENDIF}

  TKDT22DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT22DEyanmicStoreBuffer;
    KDBuff     : TKDT22DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT22DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT22DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT22DEyanmicStoreBuffer; const Buff: TKDT22DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT22DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT22DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT22DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DE_Node; overload;
    function Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DE_Node; overload;
    function Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double): PKDT22DE_Node; overload;
    function Search(const Buff: TKDT22DE_Vec): PKDT22DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT22DE_DynamicVecBuffer; var OutBuff: TKDT22DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT22DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT22DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT23DE_Vec = array [0 .. TKDT23DE_AxisCount - 1] of TKDT23DE_VecType;
  PKDT23DE_Vec = ^TKDT23DE_Vec;

  TKDT23DE_DynamicVecBuffer = array of TKDT23DE_Vec;
  PKDT23DE_DynamicVecBuffer = ^TKDT23DE_DynamicVecBuffer;

  TKDT23DE_Source = packed record
    Buff: TKDT23DE_Vec;
    index: Int64;
  end;

  PKDT23DE_Source       = ^TKDT23DE_Source;
  TKDT23DE_SourceBuffer = array [0 .. 0] of PKDT23DE_Source;
  PKDT23DE_SourceBuffer = ^TKDT23DE_SourceBuffer;

  TKDT23DEyanmicSourceBuffer = array of PKDT23DE_Source;
  PKDT23DEyanmicSourceBuffer = ^TKDT23DEyanmicSourceBuffer;

  TKDT23DEyanmicStoreBuffer = array of TKDT23DE_Source;
  PKDT23DEyanmicStoreBuffer = ^TKDT23DEyanmicStoreBuffer;

  PKDT23DE_Node = ^TKDT23DE_Node;

  TKDT23DE_Node = packed record
    Parent, Right, Left: PKDT23DE_Node;
    vec: PKDT23DE_Source;
  end;

  TKDT23DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT23DE_Source);
  TKDT23DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT23DE_Source) of object;
  {$IFNDEF FPC}
  TKDT23DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT23DE_Source);
  {$ENDIF}

  TKDT23DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT23DEyanmicStoreBuffer;
    KDBuff     : TKDT23DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT23DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT23DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT23DEyanmicStoreBuffer; const Buff: TKDT23DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT23DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT23DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT23DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT23DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DE_Node; overload;
    function Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DE_Node; overload;
    function Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double): PKDT23DE_Node; overload;
    function Search(const Buff: TKDT23DE_Vec): PKDT23DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT23DE_DynamicVecBuffer; var OutBuff: TKDT23DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT23DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT23DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT24DE_Vec = array [0 .. TKDT24DE_AxisCount - 1] of TKDT24DE_VecType;
  PKDT24DE_Vec = ^TKDT24DE_Vec;

  TKDT24DE_DynamicVecBuffer = array of TKDT24DE_Vec;
  PKDT24DE_DynamicVecBuffer = ^TKDT24DE_DynamicVecBuffer;

  TKDT24DE_Source = packed record
    Buff: TKDT24DE_Vec;
    index: Int64;
  end;

  PKDT24DE_Source       = ^TKDT24DE_Source;
  TKDT24DE_SourceBuffer = array [0 .. 0] of PKDT24DE_Source;
  PKDT24DE_SourceBuffer = ^TKDT24DE_SourceBuffer;

  TKDT24DEyanmicSourceBuffer = array of PKDT24DE_Source;
  PKDT24DEyanmicSourceBuffer = ^TKDT24DEyanmicSourceBuffer;

  TKDT24DEyanmicStoreBuffer = array of TKDT24DE_Source;
  PKDT24DEyanmicStoreBuffer = ^TKDT24DEyanmicStoreBuffer;

  PKDT24DE_Node = ^TKDT24DE_Node;

  TKDT24DE_Node = packed record
    Parent, Right, Left: PKDT24DE_Node;
    vec: PKDT24DE_Source;
  end;

  TKDT24DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT24DE_Source);
  TKDT24DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT24DE_Source) of object;
  {$IFNDEF FPC}
  TKDT24DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT24DE_Source);
  {$ENDIF}

  TKDT24DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT24DEyanmicStoreBuffer;
    KDBuff     : TKDT24DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT24DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT24DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT24DEyanmicStoreBuffer; const Buff: TKDT24DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT24DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT24DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT24DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DE_Node; overload;
    function Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DE_Node; overload;
    function Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double): PKDT24DE_Node; overload;
    function Search(const Buff: TKDT24DE_Vec): PKDT24DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT24DE_DynamicVecBuffer; var OutBuff: TKDT24DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT24DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT24DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT25DE_Vec = array [0 .. TKDT25DE_AxisCount - 1] of TKDT25DE_VecType;
  PKDT25DE_Vec = ^TKDT25DE_Vec;

  TKDT25DE_DynamicVecBuffer = array of TKDT25DE_Vec;
  PKDT25DE_DynamicVecBuffer = ^TKDT25DE_DynamicVecBuffer;

  TKDT25DE_Source = packed record
    Buff: TKDT25DE_Vec;
    index: Int64;
  end;

  PKDT25DE_Source       = ^TKDT25DE_Source;
  TKDT25DE_SourceBuffer = array [0 .. 0] of PKDT25DE_Source;
  PKDT25DE_SourceBuffer = ^TKDT25DE_SourceBuffer;

  TKDT25DEyanmicSourceBuffer = array of PKDT25DE_Source;
  PKDT25DEyanmicSourceBuffer = ^TKDT25DEyanmicSourceBuffer;

  TKDT25DEyanmicStoreBuffer = array of TKDT25DE_Source;
  PKDT25DEyanmicStoreBuffer = ^TKDT25DEyanmicStoreBuffer;

  PKDT25DE_Node = ^TKDT25DE_Node;

  TKDT25DE_Node = packed record
    Parent, Right, Left: PKDT25DE_Node;
    vec: PKDT25DE_Source;
  end;

  TKDT25DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT25DE_Source);
  TKDT25DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT25DE_Source) of object;
  {$IFNDEF FPC}
  TKDT25DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT25DE_Source);
  {$ENDIF}

  TKDT25DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT25DEyanmicStoreBuffer;
    KDBuff     : TKDT25DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT25DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT25DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT25DEyanmicStoreBuffer; const Buff: TKDT25DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT25DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT25DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT25DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT25DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DE_Node; overload;
    function Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DE_Node; overload;
    function Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double): PKDT25DE_Node; overload;
    function Search(const Buff: TKDT25DE_Vec): PKDT25DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT25DE_DynamicVecBuffer; var OutBuff: TKDT25DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT25DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT25DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT26DE_Vec = array [0 .. TKDT26DE_AxisCount - 1] of TKDT26DE_VecType;
  PKDT26DE_Vec = ^TKDT26DE_Vec;

  TKDT26DE_DynamicVecBuffer = array of TKDT26DE_Vec;
  PKDT26DE_DynamicVecBuffer = ^TKDT26DE_DynamicVecBuffer;

  TKDT26DE_Source = packed record
    Buff: TKDT26DE_Vec;
    index: Int64;
  end;

  PKDT26DE_Source       = ^TKDT26DE_Source;
  TKDT26DE_SourceBuffer = array [0 .. 0] of PKDT26DE_Source;
  PKDT26DE_SourceBuffer = ^TKDT26DE_SourceBuffer;

  TKDT26DEyanmicSourceBuffer = array of PKDT26DE_Source;
  PKDT26DEyanmicSourceBuffer = ^TKDT26DEyanmicSourceBuffer;

  TKDT26DEyanmicStoreBuffer = array of TKDT26DE_Source;
  PKDT26DEyanmicStoreBuffer = ^TKDT26DEyanmicStoreBuffer;

  PKDT26DE_Node = ^TKDT26DE_Node;

  TKDT26DE_Node = packed record
    Parent, Right, Left: PKDT26DE_Node;
    vec: PKDT26DE_Source;
  end;

  TKDT26DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT26DE_Source);
  TKDT26DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT26DE_Source) of object;
  {$IFNDEF FPC}
  TKDT26DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT26DE_Source);
  {$ENDIF}

  TKDT26DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT26DEyanmicStoreBuffer;
    KDBuff     : TKDT26DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT26DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT26DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT26DEyanmicStoreBuffer; const Buff: TKDT26DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT26DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT26DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT26DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT26DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DE_Node; overload;
    function Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DE_Node; overload;
    function Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double): PKDT26DE_Node; overload;
    function Search(const Buff: TKDT26DE_Vec): PKDT26DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT26DE_DynamicVecBuffer; var OutBuff: TKDT26DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT26DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT26DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT27DE_Vec = array [0 .. TKDT27DE_AxisCount - 1] of TKDT27DE_VecType;
  PKDT27DE_Vec = ^TKDT27DE_Vec;

  TKDT27DE_DynamicVecBuffer = array of TKDT27DE_Vec;
  PKDT27DE_DynamicVecBuffer = ^TKDT27DE_DynamicVecBuffer;

  TKDT27DE_Source = packed record
    Buff: TKDT27DE_Vec;
    index: Int64;
  end;

  PKDT27DE_Source       = ^TKDT27DE_Source;
  TKDT27DE_SourceBuffer = array [0 .. 0] of PKDT27DE_Source;
  PKDT27DE_SourceBuffer = ^TKDT27DE_SourceBuffer;

  TKDT27DEyanmicSourceBuffer = array of PKDT27DE_Source;
  PKDT27DEyanmicSourceBuffer = ^TKDT27DEyanmicSourceBuffer;

  TKDT27DEyanmicStoreBuffer = array of TKDT27DE_Source;
  PKDT27DEyanmicStoreBuffer = ^TKDT27DEyanmicStoreBuffer;

  PKDT27DE_Node = ^TKDT27DE_Node;

  TKDT27DE_Node = packed record
    Parent, Right, Left: PKDT27DE_Node;
    vec: PKDT27DE_Source;
  end;

  TKDT27DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT27DE_Source);
  TKDT27DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT27DE_Source) of object;
  {$IFNDEF FPC}
  TKDT27DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT27DE_Source);
  {$ENDIF}

  TKDT27DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT27DEyanmicStoreBuffer;
    KDBuff     : TKDT27DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT27DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT27DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT27DEyanmicStoreBuffer; const Buff: TKDT27DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT27DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT27DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT27DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT27DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DE_Node; overload;
    function Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DE_Node; overload;
    function Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double): PKDT27DE_Node; overload;
    function Search(const Buff: TKDT27DE_Vec): PKDT27DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT27DE_DynamicVecBuffer; var OutBuff: TKDT27DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT27DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT27DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT28DE_Vec = array [0 .. TKDT28DE_AxisCount - 1] of TKDT28DE_VecType;
  PKDT28DE_Vec = ^TKDT28DE_Vec;

  TKDT28DE_DynamicVecBuffer = array of TKDT28DE_Vec;
  PKDT28DE_DynamicVecBuffer = ^TKDT28DE_DynamicVecBuffer;

  TKDT28DE_Source = packed record
    Buff: TKDT28DE_Vec;
    index: Int64;
  end;

  PKDT28DE_Source       = ^TKDT28DE_Source;
  TKDT28DE_SourceBuffer = array [0 .. 0] of PKDT28DE_Source;
  PKDT28DE_SourceBuffer = ^TKDT28DE_SourceBuffer;

  TKDT28DEyanmicSourceBuffer = array of PKDT28DE_Source;
  PKDT28DEyanmicSourceBuffer = ^TKDT28DEyanmicSourceBuffer;

  TKDT28DEyanmicStoreBuffer = array of TKDT28DE_Source;
  PKDT28DEyanmicStoreBuffer = ^TKDT28DEyanmicStoreBuffer;

  PKDT28DE_Node = ^TKDT28DE_Node;

  TKDT28DE_Node = packed record
    Parent, Right, Left: PKDT28DE_Node;
    vec: PKDT28DE_Source;
  end;

  TKDT28DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT28DE_Source);
  TKDT28DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT28DE_Source) of object;
  {$IFNDEF FPC}
  TKDT28DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT28DE_Source);
  {$ENDIF}

  TKDT28DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT28DEyanmicStoreBuffer;
    KDBuff     : TKDT28DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT28DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT28DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT28DEyanmicStoreBuffer; const Buff: TKDT28DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT28DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT28DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT28DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT28DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DE_Node; overload;
    function Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DE_Node; overload;
    function Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double): PKDT28DE_Node; overload;
    function Search(const Buff: TKDT28DE_Vec): PKDT28DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT28DE_DynamicVecBuffer; var OutBuff: TKDT28DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT28DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT28DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT29DE_Vec = array [0 .. TKDT29DE_AxisCount - 1] of TKDT29DE_VecType;
  PKDT29DE_Vec = ^TKDT29DE_Vec;

  TKDT29DE_DynamicVecBuffer = array of TKDT29DE_Vec;
  PKDT29DE_DynamicVecBuffer = ^TKDT29DE_DynamicVecBuffer;

  TKDT29DE_Source = packed record
    Buff: TKDT29DE_Vec;
    index: Int64;
  end;

  PKDT29DE_Source       = ^TKDT29DE_Source;
  TKDT29DE_SourceBuffer = array [0 .. 0] of PKDT29DE_Source;
  PKDT29DE_SourceBuffer = ^TKDT29DE_SourceBuffer;

  TKDT29DEyanmicSourceBuffer = array of PKDT29DE_Source;
  PKDT29DEyanmicSourceBuffer = ^TKDT29DEyanmicSourceBuffer;

  TKDT29DEyanmicStoreBuffer = array of TKDT29DE_Source;
  PKDT29DEyanmicStoreBuffer = ^TKDT29DEyanmicStoreBuffer;

  PKDT29DE_Node = ^TKDT29DE_Node;

  TKDT29DE_Node = packed record
    Parent, Right, Left: PKDT29DE_Node;
    vec: PKDT29DE_Source;
  end;

  TKDT29DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT29DE_Source);
  TKDT29DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT29DE_Source) of object;
  {$IFNDEF FPC}
  TKDT29DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT29DE_Source);
  {$ENDIF}

  TKDT29DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT29DEyanmicStoreBuffer;
    KDBuff     : TKDT29DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT29DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT29DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT29DEyanmicStoreBuffer; const Buff: TKDT29DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT29DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT29DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT29DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT29DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DE_Node; overload;
    function Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DE_Node; overload;
    function Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double): PKDT29DE_Node; overload;
    function Search(const Buff: TKDT29DE_Vec): PKDT29DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT29DE_DynamicVecBuffer; var OutBuff: TKDT29DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT29DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT29DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT30DE_Vec = array [0 .. TKDT30DE_AxisCount - 1] of TKDT30DE_VecType;
  PKDT30DE_Vec = ^TKDT30DE_Vec;

  TKDT30DE_DynamicVecBuffer = array of TKDT30DE_Vec;
  PKDT30DE_DynamicVecBuffer = ^TKDT30DE_DynamicVecBuffer;

  TKDT30DE_Source = packed record
    Buff: TKDT30DE_Vec;
    index: Int64;
  end;

  PKDT30DE_Source       = ^TKDT30DE_Source;
  TKDT30DE_SourceBuffer = array [0 .. 0] of PKDT30DE_Source;
  PKDT30DE_SourceBuffer = ^TKDT30DE_SourceBuffer;

  TKDT30DEyanmicSourceBuffer = array of PKDT30DE_Source;
  PKDT30DEyanmicSourceBuffer = ^TKDT30DEyanmicSourceBuffer;

  TKDT30DEyanmicStoreBuffer = array of TKDT30DE_Source;
  PKDT30DEyanmicStoreBuffer = ^TKDT30DEyanmicStoreBuffer;

  PKDT30DE_Node = ^TKDT30DE_Node;

  TKDT30DE_Node = packed record
    Parent, Right, Left: PKDT30DE_Node;
    vec: PKDT30DE_Source;
  end;

  TKDT30DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT30DE_Source);
  TKDT30DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT30DE_Source) of object;
  {$IFNDEF FPC}
  TKDT30DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT30DE_Source);
  {$ENDIF}

  TKDT30DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT30DEyanmicStoreBuffer;
    KDBuff     : TKDT30DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT30DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT30DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT30DEyanmicStoreBuffer; const Buff: TKDT30DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT30DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT30DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT30DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT30DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DE_Node; overload;
    function Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DE_Node; overload;
    function Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double): PKDT30DE_Node; overload;
    function Search(const Buff: TKDT30DE_Vec): PKDT30DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT30DE_DynamicVecBuffer; var OutBuff: TKDT30DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT30DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT30DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT32DE_Vec = array [0 .. TKDT32DE_AxisCount - 1] of TKDT32DE_VecType;
  PKDT32DE_Vec = ^TKDT32DE_Vec;

  TKDT32DE_DynamicVecBuffer = array of TKDT32DE_Vec;
  PKDT32DE_DynamicVecBuffer = ^TKDT32DE_DynamicVecBuffer;

  TKDT32DE_Source = packed record
    Buff: TKDT32DE_Vec;
    index: Int64;
  end;

  PKDT32DE_Source       = ^TKDT32DE_Source;
  TKDT32DE_SourceBuffer = array [0 .. 0] of PKDT32DE_Source;
  PKDT32DE_SourceBuffer = ^TKDT32DE_SourceBuffer;

  TKDT32DEyanmicSourceBuffer = array of PKDT32DE_Source;
  PKDT32DEyanmicSourceBuffer = ^TKDT32DEyanmicSourceBuffer;

  TKDT32DEyanmicStoreBuffer = array of TKDT32DE_Source;
  PKDT32DEyanmicStoreBuffer = ^TKDT32DEyanmicStoreBuffer;

  PKDT32DE_Node = ^TKDT32DE_Node;

  TKDT32DE_Node = packed record
    Parent, Right, Left: PKDT32DE_Node;
    vec: PKDT32DE_Source;
  end;

  TKDT32DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT32DE_Source);
  TKDT32DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT32DE_Source) of object;
  {$IFNDEF FPC}
  TKDT32DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT32DE_Source);
  {$ENDIF}

  TKDT32DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT32DEyanmicStoreBuffer;
    KDBuff     : TKDT32DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT32DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT32DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT32DEyanmicStoreBuffer; const Buff: TKDT32DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT32DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT32DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT32DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT32DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DE_Node; overload;
    function Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DE_Node; overload;
    function Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double): PKDT32DE_Node; overload;
    function Search(const Buff: TKDT32DE_Vec): PKDT32DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT32DE_DynamicVecBuffer; var OutBuff: TKDT32DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT32DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT32DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT34DE_Vec = array [0 .. TKDT34DE_AxisCount - 1] of TKDT34DE_VecType;
  PKDT34DE_Vec = ^TKDT34DE_Vec;

  TKDT34DE_DynamicVecBuffer = array of TKDT34DE_Vec;
  PKDT34DE_DynamicVecBuffer = ^TKDT34DE_DynamicVecBuffer;

  TKDT34DE_Source = packed record
    Buff: TKDT34DE_Vec;
    index: Int64;
  end;

  PKDT34DE_Source       = ^TKDT34DE_Source;
  TKDT34DE_SourceBuffer = array [0 .. 0] of PKDT34DE_Source;
  PKDT34DE_SourceBuffer = ^TKDT34DE_SourceBuffer;

  TKDT34DEyanmicSourceBuffer = array of PKDT34DE_Source;
  PKDT34DEyanmicSourceBuffer = ^TKDT34DEyanmicSourceBuffer;

  TKDT34DEyanmicStoreBuffer = array of TKDT34DE_Source;
  PKDT34DEyanmicStoreBuffer = ^TKDT34DEyanmicStoreBuffer;

  PKDT34DE_Node = ^TKDT34DE_Node;

  TKDT34DE_Node = packed record
    Parent, Right, Left: PKDT34DE_Node;
    vec: PKDT34DE_Source;
  end;

  TKDT34DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT34DE_Source);
  TKDT34DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT34DE_Source) of object;
  {$IFNDEF FPC}
  TKDT34DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT34DE_Source);
  {$ENDIF}

  TKDT34DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT34DEyanmicStoreBuffer;
    KDBuff     : TKDT34DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT34DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT34DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT34DEyanmicStoreBuffer; const Buff: TKDT34DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT34DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT34DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT34DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT34DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DE_Node; overload;
    function Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DE_Node; overload;
    function Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double): PKDT34DE_Node; overload;
    function Search(const Buff: TKDT34DE_Vec): PKDT34DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT34DE_DynamicVecBuffer; var OutBuff: TKDT34DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT34DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT34DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT36DE_Vec = array [0 .. TKDT36DE_AxisCount - 1] of TKDT36DE_VecType;
  PKDT36DE_Vec = ^TKDT36DE_Vec;

  TKDT36DE_DynamicVecBuffer = array of TKDT36DE_Vec;
  PKDT36DE_DynamicVecBuffer = ^TKDT36DE_DynamicVecBuffer;

  TKDT36DE_Source = packed record
    Buff: TKDT36DE_Vec;
    index: Int64;
  end;

  PKDT36DE_Source       = ^TKDT36DE_Source;
  TKDT36DE_SourceBuffer = array [0 .. 0] of PKDT36DE_Source;
  PKDT36DE_SourceBuffer = ^TKDT36DE_SourceBuffer;

  TKDT36DEyanmicSourceBuffer = array of PKDT36DE_Source;
  PKDT36DEyanmicSourceBuffer = ^TKDT36DEyanmicSourceBuffer;

  TKDT36DEyanmicStoreBuffer = array of TKDT36DE_Source;
  PKDT36DEyanmicStoreBuffer = ^TKDT36DEyanmicStoreBuffer;

  PKDT36DE_Node = ^TKDT36DE_Node;

  TKDT36DE_Node = packed record
    Parent, Right, Left: PKDT36DE_Node;
    vec: PKDT36DE_Source;
  end;

  TKDT36DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT36DE_Source);
  TKDT36DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT36DE_Source) of object;
  {$IFNDEF FPC}
  TKDT36DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT36DE_Source);
  {$ENDIF}

  TKDT36DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT36DEyanmicStoreBuffer;
    KDBuff     : TKDT36DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT36DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT36DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT36DEyanmicStoreBuffer; const Buff: TKDT36DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT36DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT36DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT36DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT36DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DE_Node; overload;
    function Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DE_Node; overload;
    function Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double): PKDT36DE_Node; overload;
    function Search(const Buff: TKDT36DE_Vec): PKDT36DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT36DE_DynamicVecBuffer; var OutBuff: TKDT36DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT36DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT36DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT38DE_Vec = array [0 .. TKDT38DE_AxisCount - 1] of TKDT38DE_VecType;
  PKDT38DE_Vec = ^TKDT38DE_Vec;

  TKDT38DE_DynamicVecBuffer = array of TKDT38DE_Vec;
  PKDT38DE_DynamicVecBuffer = ^TKDT38DE_DynamicVecBuffer;

  TKDT38DE_Source = packed record
    Buff: TKDT38DE_Vec;
    index: Int64;
  end;

  PKDT38DE_Source       = ^TKDT38DE_Source;
  TKDT38DE_SourceBuffer = array [0 .. 0] of PKDT38DE_Source;
  PKDT38DE_SourceBuffer = ^TKDT38DE_SourceBuffer;

  TKDT38DEyanmicSourceBuffer = array of PKDT38DE_Source;
  PKDT38DEyanmicSourceBuffer = ^TKDT38DEyanmicSourceBuffer;

  TKDT38DEyanmicStoreBuffer = array of TKDT38DE_Source;
  PKDT38DEyanmicStoreBuffer = ^TKDT38DEyanmicStoreBuffer;

  PKDT38DE_Node = ^TKDT38DE_Node;

  TKDT38DE_Node = packed record
    Parent, Right, Left: PKDT38DE_Node;
    vec: PKDT38DE_Source;
  end;

  TKDT38DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT38DE_Source);
  TKDT38DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT38DE_Source) of object;
  {$IFNDEF FPC}
  TKDT38DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT38DE_Source);
  {$ENDIF}

  TKDT38DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT38DEyanmicStoreBuffer;
    KDBuff     : TKDT38DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT38DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT38DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT38DEyanmicStoreBuffer; const Buff: TKDT38DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT38DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT38DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT38DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT38DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DE_Node; overload;
    function Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DE_Node; overload;
    function Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double): PKDT38DE_Node; overload;
    function Search(const Buff: TKDT38DE_Vec): PKDT38DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT38DE_DynamicVecBuffer; var OutBuff: TKDT38DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT38DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT38DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT40DE_Vec = array [0 .. TKDT40DE_AxisCount - 1] of TKDT40DE_VecType;
  PKDT40DE_Vec = ^TKDT40DE_Vec;

  TKDT40DE_DynamicVecBuffer = array of TKDT40DE_Vec;
  PKDT40DE_DynamicVecBuffer = ^TKDT40DE_DynamicVecBuffer;

  TKDT40DE_Source = packed record
    Buff: TKDT40DE_Vec;
    index: Int64;
  end;

  PKDT40DE_Source       = ^TKDT40DE_Source;
  TKDT40DE_SourceBuffer = array [0 .. 0] of PKDT40DE_Source;
  PKDT40DE_SourceBuffer = ^TKDT40DE_SourceBuffer;

  TKDT40DEyanmicSourceBuffer = array of PKDT40DE_Source;
  PKDT40DEyanmicSourceBuffer = ^TKDT40DEyanmicSourceBuffer;

  TKDT40DEyanmicStoreBuffer = array of TKDT40DE_Source;
  PKDT40DEyanmicStoreBuffer = ^TKDT40DEyanmicStoreBuffer;

  PKDT40DE_Node = ^TKDT40DE_Node;

  TKDT40DE_Node = packed record
    Parent, Right, Left: PKDT40DE_Node;
    vec: PKDT40DE_Source;
  end;

  TKDT40DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT40DE_Source);
  TKDT40DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT40DE_Source) of object;
  {$IFNDEF FPC}
  TKDT40DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT40DE_Source);
  {$ENDIF}

  TKDT40DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT40DEyanmicStoreBuffer;
    KDBuff     : TKDT40DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT40DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT40DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT40DEyanmicStoreBuffer; const Buff: TKDT40DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT40DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT40DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT40DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT40DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DE_Node; overload;
    function Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DE_Node; overload;
    function Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double): PKDT40DE_Node; overload;
    function Search(const Buff: TKDT40DE_Vec): PKDT40DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT40DE_DynamicVecBuffer; var OutBuff: TKDT40DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT40DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT40DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT44DE_Vec = array [0 .. TKDT44DE_AxisCount - 1] of TKDT44DE_VecType;
  PKDT44DE_Vec = ^TKDT44DE_Vec;

  TKDT44DE_DynamicVecBuffer = array of TKDT44DE_Vec;
  PKDT44DE_DynamicVecBuffer = ^TKDT44DE_DynamicVecBuffer;

  TKDT44DE_Source = packed record
    Buff: TKDT44DE_Vec;
    index: Int64;
  end;

  PKDT44DE_Source       = ^TKDT44DE_Source;
  TKDT44DE_SourceBuffer = array [0 .. 0] of PKDT44DE_Source;
  PKDT44DE_SourceBuffer = ^TKDT44DE_SourceBuffer;

  TKDT44DEyanmicSourceBuffer = array of PKDT44DE_Source;
  PKDT44DEyanmicSourceBuffer = ^TKDT44DEyanmicSourceBuffer;

  TKDT44DEyanmicStoreBuffer = array of TKDT44DE_Source;
  PKDT44DEyanmicStoreBuffer = ^TKDT44DEyanmicStoreBuffer;

  PKDT44DE_Node = ^TKDT44DE_Node;

  TKDT44DE_Node = packed record
    Parent, Right, Left: PKDT44DE_Node;
    vec: PKDT44DE_Source;
  end;

  TKDT44DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT44DE_Source);
  TKDT44DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT44DE_Source) of object;
  {$IFNDEF FPC}
  TKDT44DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT44DE_Source);
  {$ENDIF}

  TKDT44DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT44DEyanmicStoreBuffer;
    KDBuff     : TKDT44DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT44DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT44DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT44DEyanmicStoreBuffer; const Buff: TKDT44DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT44DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT44DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT44DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT44DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DE_Node; overload;
    function Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DE_Node; overload;
    function Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double): PKDT44DE_Node; overload;
    function Search(const Buff: TKDT44DE_Vec): PKDT44DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT44DE_DynamicVecBuffer; var OutBuff: TKDT44DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT44DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT44DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT48DE_Vec = array [0 .. TKDT48DE_AxisCount - 1] of TKDT48DE_VecType;
  PKDT48DE_Vec = ^TKDT48DE_Vec;

  TKDT48DE_DynamicVecBuffer = array of TKDT48DE_Vec;
  PKDT48DE_DynamicVecBuffer = ^TKDT48DE_DynamicVecBuffer;

  TKDT48DE_Source = packed record
    Buff: TKDT48DE_Vec;
    index: Int64;
  end;

  PKDT48DE_Source       = ^TKDT48DE_Source;
  TKDT48DE_SourceBuffer = array [0 .. 0] of PKDT48DE_Source;
  PKDT48DE_SourceBuffer = ^TKDT48DE_SourceBuffer;

  TKDT48DEyanmicSourceBuffer = array of PKDT48DE_Source;
  PKDT48DEyanmicSourceBuffer = ^TKDT48DEyanmicSourceBuffer;

  TKDT48DEyanmicStoreBuffer = array of TKDT48DE_Source;
  PKDT48DEyanmicStoreBuffer = ^TKDT48DEyanmicStoreBuffer;

  PKDT48DE_Node = ^TKDT48DE_Node;

  TKDT48DE_Node = packed record
    Parent, Right, Left: PKDT48DE_Node;
    vec: PKDT48DE_Source;
  end;

  TKDT48DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT48DE_Source);
  TKDT48DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT48DE_Source) of object;
  {$IFNDEF FPC}
  TKDT48DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT48DE_Source);
  {$ENDIF}

  TKDT48DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT48DEyanmicStoreBuffer;
    KDBuff     : TKDT48DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT48DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT48DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT48DEyanmicStoreBuffer; const Buff: TKDT48DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT48DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT48DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT48DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DE_Node; overload;
    function Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DE_Node; overload;
    function Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double): PKDT48DE_Node; overload;
    function Search(const Buff: TKDT48DE_Vec): PKDT48DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT48DE_DynamicVecBuffer; var OutBuff: TKDT48DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT48DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT48DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT50DE_Vec = array [0 .. TKDT50DE_AxisCount - 1] of TKDT50DE_VecType;
  PKDT50DE_Vec = ^TKDT50DE_Vec;

  TKDT50DE_DynamicVecBuffer = array of TKDT50DE_Vec;
  PKDT50DE_DynamicVecBuffer = ^TKDT50DE_DynamicVecBuffer;

  TKDT50DE_Source = packed record
    Buff: TKDT50DE_Vec;
    index: Int64;
  end;

  PKDT50DE_Source       = ^TKDT50DE_Source;
  TKDT50DE_SourceBuffer = array [0 .. 0] of PKDT50DE_Source;
  PKDT50DE_SourceBuffer = ^TKDT50DE_SourceBuffer;

  TKDT50DEyanmicSourceBuffer = array of PKDT50DE_Source;
  PKDT50DEyanmicSourceBuffer = ^TKDT50DEyanmicSourceBuffer;

  TKDT50DEyanmicStoreBuffer = array of TKDT50DE_Source;
  PKDT50DEyanmicStoreBuffer = ^TKDT50DEyanmicStoreBuffer;

  PKDT50DE_Node = ^TKDT50DE_Node;

  TKDT50DE_Node = packed record
    Parent, Right, Left: PKDT50DE_Node;
    vec: PKDT50DE_Source;
  end;

  TKDT50DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT50DE_Source);
  TKDT50DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT50DE_Source) of object;
  {$IFNDEF FPC}
  TKDT50DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT50DE_Source);
  {$ENDIF}

  TKDT50DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT50DEyanmicStoreBuffer;
    KDBuff     : TKDT50DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT50DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT50DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT50DEyanmicStoreBuffer; const Buff: TKDT50DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT50DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT50DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT50DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT50DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DE_Node; overload;
    function Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DE_Node; overload;
    function Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double): PKDT50DE_Node; overload;
    function Search(const Buff: TKDT50DE_Vec): PKDT50DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT50DE_DynamicVecBuffer; var OutBuff: TKDT50DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT50DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT50DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT56DE_Vec = array [0 .. TKDT56DE_AxisCount - 1] of TKDT56DE_VecType;
  PKDT56DE_Vec = ^TKDT56DE_Vec;

  TKDT56DE_DynamicVecBuffer = array of TKDT56DE_Vec;
  PKDT56DE_DynamicVecBuffer = ^TKDT56DE_DynamicVecBuffer;

  TKDT56DE_Source = packed record
    Buff: TKDT56DE_Vec;
    index: Int64;
  end;

  PKDT56DE_Source       = ^TKDT56DE_Source;
  TKDT56DE_SourceBuffer = array [0 .. 0] of PKDT56DE_Source;
  PKDT56DE_SourceBuffer = ^TKDT56DE_SourceBuffer;

  TKDT56DEyanmicSourceBuffer = array of PKDT56DE_Source;
  PKDT56DEyanmicSourceBuffer = ^TKDT56DEyanmicSourceBuffer;

  TKDT56DEyanmicStoreBuffer = array of TKDT56DE_Source;
  PKDT56DEyanmicStoreBuffer = ^TKDT56DEyanmicStoreBuffer;

  PKDT56DE_Node = ^TKDT56DE_Node;

  TKDT56DE_Node = packed record
    Parent, Right, Left: PKDT56DE_Node;
    vec: PKDT56DE_Source;
  end;

  TKDT56DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT56DE_Source);
  TKDT56DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT56DE_Source) of object;
  {$IFNDEF FPC}
  TKDT56DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT56DE_Source);
  {$ENDIF}

  TKDT56DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT56DEyanmicStoreBuffer;
    KDBuff     : TKDT56DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT56DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT56DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT56DEyanmicStoreBuffer; const Buff: TKDT56DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT56DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT56DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT56DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT56DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DE_Node; overload;
    function Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DE_Node; overload;
    function Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double): PKDT56DE_Node; overload;
    function Search(const Buff: TKDT56DE_Vec): PKDT56DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT56DE_DynamicVecBuffer; var OutBuff: TKDT56DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT56DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT56DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT60DE_Vec = array [0 .. TKDT60DE_AxisCount - 1] of TKDT60DE_VecType;
  PKDT60DE_Vec = ^TKDT60DE_Vec;

  TKDT60DE_DynamicVecBuffer = array of TKDT60DE_Vec;
  PKDT60DE_DynamicVecBuffer = ^TKDT60DE_DynamicVecBuffer;

  TKDT60DE_Source = packed record
    Buff: TKDT60DE_Vec;
    index: Int64;
  end;

  PKDT60DE_Source       = ^TKDT60DE_Source;
  TKDT60DE_SourceBuffer = array [0 .. 0] of PKDT60DE_Source;
  PKDT60DE_SourceBuffer = ^TKDT60DE_SourceBuffer;

  TKDT60DEyanmicSourceBuffer = array of PKDT60DE_Source;
  PKDT60DEyanmicSourceBuffer = ^TKDT60DEyanmicSourceBuffer;

  TKDT60DEyanmicStoreBuffer = array of TKDT60DE_Source;
  PKDT60DEyanmicStoreBuffer = ^TKDT60DEyanmicStoreBuffer;

  PKDT60DE_Node = ^TKDT60DE_Node;

  TKDT60DE_Node = packed record
    Parent, Right, Left: PKDT60DE_Node;
    vec: PKDT60DE_Source;
  end;

  TKDT60DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT60DE_Source);
  TKDT60DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT60DE_Source) of object;
  {$IFNDEF FPC}
  TKDT60DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT60DE_Source);
  {$ENDIF}

  TKDT60DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT60DEyanmicStoreBuffer;
    KDBuff     : TKDT60DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT60DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT60DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT60DEyanmicStoreBuffer; const Buff: TKDT60DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT60DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT60DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT60DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT60DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DE_Node; overload;
    function Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DE_Node; overload;
    function Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double): PKDT60DE_Node; overload;
    function Search(const Buff: TKDT60DE_Vec): PKDT60DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT60DE_DynamicVecBuffer; var OutBuff: TKDT60DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT60DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT60DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT64DE_Vec = array [0 .. TKDT64DE_AxisCount - 1] of TKDT64DE_VecType;
  PKDT64DE_Vec = ^TKDT64DE_Vec;

  TKDT64DE_DynamicVecBuffer = array of TKDT64DE_Vec;
  PKDT64DE_DynamicVecBuffer = ^TKDT64DE_DynamicVecBuffer;

  TKDT64DE_Source = packed record
    Buff: TKDT64DE_Vec;
    index: Int64;
  end;

  PKDT64DE_Source       = ^TKDT64DE_Source;
  TKDT64DE_SourceBuffer = array [0 .. 0] of PKDT64DE_Source;
  PKDT64DE_SourceBuffer = ^TKDT64DE_SourceBuffer;

  TKDT64DEyanmicSourceBuffer = array of PKDT64DE_Source;
  PKDT64DEyanmicSourceBuffer = ^TKDT64DEyanmicSourceBuffer;

  TKDT64DEyanmicStoreBuffer = array of TKDT64DE_Source;
  PKDT64DEyanmicStoreBuffer = ^TKDT64DEyanmicStoreBuffer;

  PKDT64DE_Node = ^TKDT64DE_Node;

  TKDT64DE_Node = packed record
    Parent, Right, Left: PKDT64DE_Node;
    vec: PKDT64DE_Source;
  end;

  TKDT64DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT64DE_Source);
  TKDT64DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT64DE_Source) of object;
  {$IFNDEF FPC}
  TKDT64DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT64DE_Source);
  {$ENDIF}

  TKDT64DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT64DEyanmicStoreBuffer;
    KDBuff     : TKDT64DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT64DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT64DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT64DEyanmicStoreBuffer; const Buff: TKDT64DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT64DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT64DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT64DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DE_Node; overload;
    function Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DE_Node; overload;
    function Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double): PKDT64DE_Node; overload;
    function Search(const Buff: TKDT64DE_Vec): PKDT64DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT64DE_DynamicVecBuffer; var OutBuff: TKDT64DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT64DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT64DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT72DE_Vec = array [0 .. TKDT72DE_AxisCount - 1] of TKDT72DE_VecType;
  PKDT72DE_Vec = ^TKDT72DE_Vec;

  TKDT72DE_DynamicVecBuffer = array of TKDT72DE_Vec;
  PKDT72DE_DynamicVecBuffer = ^TKDT72DE_DynamicVecBuffer;

  TKDT72DE_Source = packed record
    Buff: TKDT72DE_Vec;
    index: Int64;
  end;

  PKDT72DE_Source       = ^TKDT72DE_Source;
  TKDT72DE_SourceBuffer = array [0 .. 0] of PKDT72DE_Source;
  PKDT72DE_SourceBuffer = ^TKDT72DE_SourceBuffer;

  TKDT72DEyanmicSourceBuffer = array of PKDT72DE_Source;
  PKDT72DEyanmicSourceBuffer = ^TKDT72DEyanmicSourceBuffer;

  TKDT72DEyanmicStoreBuffer = array of TKDT72DE_Source;
  PKDT72DEyanmicStoreBuffer = ^TKDT72DEyanmicStoreBuffer;

  PKDT72DE_Node = ^TKDT72DE_Node;

  TKDT72DE_Node = packed record
    Parent, Right, Left: PKDT72DE_Node;
    vec: PKDT72DE_Source;
  end;

  TKDT72DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT72DE_Source);
  TKDT72DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT72DE_Source) of object;
  {$IFNDEF FPC}
  TKDT72DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT72DE_Source);
  {$ENDIF}

  TKDT72DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT72DEyanmicStoreBuffer;
    KDBuff     : TKDT72DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT72DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT72DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT72DEyanmicStoreBuffer; const Buff: TKDT72DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT72DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT72DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT72DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT72DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DE_Node; overload;
    function Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DE_Node; overload;
    function Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double): PKDT72DE_Node; overload;
    function Search(const Buff: TKDT72DE_Vec): PKDT72DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT72DE_DynamicVecBuffer; var OutBuff: TKDT72DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT72DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT72DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT84DE_Vec = array [0 .. TKDT84DE_AxisCount - 1] of TKDT84DE_VecType;
  PKDT84DE_Vec = ^TKDT84DE_Vec;

  TKDT84DE_DynamicVecBuffer = array of TKDT84DE_Vec;
  PKDT84DE_DynamicVecBuffer = ^TKDT84DE_DynamicVecBuffer;

  TKDT84DE_Source = packed record
    Buff: TKDT84DE_Vec;
    index: Int64;
  end;

  PKDT84DE_Source       = ^TKDT84DE_Source;
  TKDT84DE_SourceBuffer = array [0 .. 0] of PKDT84DE_Source;
  PKDT84DE_SourceBuffer = ^TKDT84DE_SourceBuffer;

  TKDT84DEyanmicSourceBuffer = array of PKDT84DE_Source;
  PKDT84DEyanmicSourceBuffer = ^TKDT84DEyanmicSourceBuffer;

  TKDT84DEyanmicStoreBuffer = array of TKDT84DE_Source;
  PKDT84DEyanmicStoreBuffer = ^TKDT84DEyanmicStoreBuffer;

  PKDT84DE_Node = ^TKDT84DE_Node;

  TKDT84DE_Node = packed record
    Parent, Right, Left: PKDT84DE_Node;
    vec: PKDT84DE_Source;
  end;

  TKDT84DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT84DE_Source);
  TKDT84DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT84DE_Source) of object;
  {$IFNDEF FPC}
  TKDT84DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT84DE_Source);
  {$ENDIF}

  TKDT84DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT84DEyanmicStoreBuffer;
    KDBuff     : TKDT84DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT84DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT84DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT84DEyanmicStoreBuffer; const Buff: TKDT84DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT84DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT84DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT84DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT84DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DE_Node; overload;
    function Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DE_Node; overload;
    function Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double): PKDT84DE_Node; overload;
    function Search(const Buff: TKDT84DE_Vec): PKDT84DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT84DE_DynamicVecBuffer; var OutBuff: TKDT84DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT84DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT84DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT96DE_Vec = array [0 .. TKDT96DE_AxisCount - 1] of TKDT96DE_VecType;
  PKDT96DE_Vec = ^TKDT96DE_Vec;

  TKDT96DE_DynamicVecBuffer = array of TKDT96DE_Vec;
  PKDT96DE_DynamicVecBuffer = ^TKDT96DE_DynamicVecBuffer;

  TKDT96DE_Source = packed record
    Buff: TKDT96DE_Vec;
    index: Int64;
  end;

  PKDT96DE_Source       = ^TKDT96DE_Source;
  TKDT96DE_SourceBuffer = array [0 .. 0] of PKDT96DE_Source;
  PKDT96DE_SourceBuffer = ^TKDT96DE_SourceBuffer;

  TKDT96DEyanmicSourceBuffer = array of PKDT96DE_Source;
  PKDT96DEyanmicSourceBuffer = ^TKDT96DEyanmicSourceBuffer;

  TKDT96DEyanmicStoreBuffer = array of TKDT96DE_Source;
  PKDT96DEyanmicStoreBuffer = ^TKDT96DEyanmicStoreBuffer;

  PKDT96DE_Node = ^TKDT96DE_Node;

  TKDT96DE_Node = packed record
    Parent, Right, Left: PKDT96DE_Node;
    vec: PKDT96DE_Source;
  end;

  TKDT96DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT96DE_Source);
  TKDT96DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT96DE_Source) of object;
  {$IFNDEF FPC}
  TKDT96DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT96DE_Source);
  {$ENDIF}

  TKDT96DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT96DEyanmicStoreBuffer;
    KDBuff     : TKDT96DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT96DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT96DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT96DEyanmicStoreBuffer; const Buff: TKDT96DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT96DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT96DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT96DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DE_Node; overload;
    function Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DE_Node; overload;
    function Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double): PKDT96DE_Node; overload;
    function Search(const Buff: TKDT96DE_Vec): PKDT96DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT96DE_DynamicVecBuffer; var OutBuff: TKDT96DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT96DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT96DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT128DE_Vec = array [0 .. TKDT128DE_AxisCount - 1] of TKDT128DE_VecType;
  PKDT128DE_Vec = ^TKDT128DE_Vec;

  TKDT128DE_DynamicVecBuffer = array of TKDT128DE_Vec;
  PKDT128DE_DynamicVecBuffer = ^TKDT128DE_DynamicVecBuffer;

  TKDT128DE_Source = packed record
    Buff: TKDT128DE_Vec;
    index: Int64;
  end;

  PKDT128DE_Source       = ^TKDT128DE_Source;
  TKDT128DE_SourceBuffer = array [0 .. 0] of PKDT128DE_Source;
  PKDT128DE_SourceBuffer = ^TKDT128DE_SourceBuffer;

  TKDT128DEyanmicSourceBuffer = array of PKDT128DE_Source;
  PKDT128DEyanmicSourceBuffer = ^TKDT128DEyanmicSourceBuffer;

  TKDT128DEyanmicStoreBuffer = array of TKDT128DE_Source;
  PKDT128DEyanmicStoreBuffer = ^TKDT128DEyanmicStoreBuffer;

  PKDT128DE_Node = ^TKDT128DE_Node;

  TKDT128DE_Node = packed record
    Parent, Right, Left: PKDT128DE_Node;
    vec: PKDT128DE_Source;
  end;

  TKDT128DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT128DE_Source);
  TKDT128DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT128DE_Source) of object;
  {$IFNDEF FPC}
  TKDT128DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT128DE_Source);
  {$ENDIF}

  TKDT128DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT128DEyanmicStoreBuffer;
    KDBuff     : TKDT128DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT128DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT128DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT128DEyanmicStoreBuffer; const Buff: TKDT128DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT128DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT128DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT128DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DE_Node; overload;
    function Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DE_Node; overload;
    function Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double): PKDT128DE_Node; overload;
    function Search(const Buff: TKDT128DE_Vec): PKDT128DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT128DE_DynamicVecBuffer; var OutBuff: TKDT128DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT128DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT128DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT140DE_Vec = array [0 .. TKDT140DE_AxisCount - 1] of TKDT140DE_VecType;
  PKDT140DE_Vec = ^TKDT140DE_Vec;

  TKDT140DE_DynamicVecBuffer = array of TKDT140DE_Vec;
  PKDT140DE_DynamicVecBuffer = ^TKDT140DE_DynamicVecBuffer;

  TKDT140DE_Source = packed record
    Buff: TKDT140DE_Vec;
    index: Int64;
  end;

  PKDT140DE_Source       = ^TKDT140DE_Source;
  TKDT140DE_SourceBuffer = array [0 .. 0] of PKDT140DE_Source;
  PKDT140DE_SourceBuffer = ^TKDT140DE_SourceBuffer;

  TKDT140DEyanmicSourceBuffer = array of PKDT140DE_Source;
  PKDT140DEyanmicSourceBuffer = ^TKDT140DEyanmicSourceBuffer;

  TKDT140DEyanmicStoreBuffer = array of TKDT140DE_Source;
  PKDT140DEyanmicStoreBuffer = ^TKDT140DEyanmicStoreBuffer;

  PKDT140DE_Node = ^TKDT140DE_Node;

  TKDT140DE_Node = packed record
    Parent, Right, Left: PKDT140DE_Node;
    vec: PKDT140DE_Source;
  end;

  TKDT140DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT140DE_Source);
  TKDT140DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT140DE_Source) of object;
  {$IFNDEF FPC}
  TKDT140DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT140DE_Source);
  {$ENDIF}

  TKDT140DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT140DEyanmicStoreBuffer;
    KDBuff     : TKDT140DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT140DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT140DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT140DEyanmicStoreBuffer; const Buff: TKDT140DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT140DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT140DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT140DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT140DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DE_Node; overload;
    function Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DE_Node; overload;
    function Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double): PKDT140DE_Node; overload;
    function Search(const Buff: TKDT140DE_Vec): PKDT140DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT140DE_DynamicVecBuffer; var OutBuff: TKDT140DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT140DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT140DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT160DE_Vec = array [0 .. TKDT160DE_AxisCount - 1] of TKDT160DE_VecType;
  PKDT160DE_Vec = ^TKDT160DE_Vec;

  TKDT160DE_DynamicVecBuffer = array of TKDT160DE_Vec;
  PKDT160DE_DynamicVecBuffer = ^TKDT160DE_DynamicVecBuffer;

  TKDT160DE_Source = packed record
    Buff: TKDT160DE_Vec;
    index: Int64;
  end;

  PKDT160DE_Source       = ^TKDT160DE_Source;
  TKDT160DE_SourceBuffer = array [0 .. 0] of PKDT160DE_Source;
  PKDT160DE_SourceBuffer = ^TKDT160DE_SourceBuffer;

  TKDT160DEyanmicSourceBuffer = array of PKDT160DE_Source;
  PKDT160DEyanmicSourceBuffer = ^TKDT160DEyanmicSourceBuffer;

  TKDT160DEyanmicStoreBuffer = array of TKDT160DE_Source;
  PKDT160DEyanmicStoreBuffer = ^TKDT160DEyanmicStoreBuffer;

  PKDT160DE_Node = ^TKDT160DE_Node;

  TKDT160DE_Node = packed record
    Parent, Right, Left: PKDT160DE_Node;
    vec: PKDT160DE_Source;
  end;

  TKDT160DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT160DE_Source);
  TKDT160DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT160DE_Source) of object;
  {$IFNDEF FPC}
  TKDT160DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT160DE_Source);
  {$ENDIF}

  TKDT160DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT160DEyanmicStoreBuffer;
    KDBuff     : TKDT160DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT160DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT160DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT160DEyanmicStoreBuffer; const Buff: TKDT160DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT160DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT160DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT160DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT160DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DE_Node; overload;
    function Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DE_Node; overload;
    function Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double): PKDT160DE_Node; overload;
    function Search(const Buff: TKDT160DE_Vec): PKDT160DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT160DE_DynamicVecBuffer; var OutBuff: TKDT160DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT160DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT160DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT196DE_Vec = array [0 .. TKDT196DE_AxisCount - 1] of TKDT196DE_VecType;
  PKDT196DE_Vec = ^TKDT196DE_Vec;

  TKDT196DE_DynamicVecBuffer = array of TKDT196DE_Vec;
  PKDT196DE_DynamicVecBuffer = ^TKDT196DE_DynamicVecBuffer;

  TKDT196DE_Source = packed record
    Buff: TKDT196DE_Vec;
    index: Int64;
  end;

  PKDT196DE_Source       = ^TKDT196DE_Source;
  TKDT196DE_SourceBuffer = array [0 .. 0] of PKDT196DE_Source;
  PKDT196DE_SourceBuffer = ^TKDT196DE_SourceBuffer;

  TKDT196DEyanmicSourceBuffer = array of PKDT196DE_Source;
  PKDT196DEyanmicSourceBuffer = ^TKDT196DEyanmicSourceBuffer;

  TKDT196DEyanmicStoreBuffer = array of TKDT196DE_Source;
  PKDT196DEyanmicStoreBuffer = ^TKDT196DEyanmicStoreBuffer;

  PKDT196DE_Node = ^TKDT196DE_Node;

  TKDT196DE_Node = packed record
    Parent, Right, Left: PKDT196DE_Node;
    vec: PKDT196DE_Source;
  end;

  TKDT196DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT196DE_Source);
  TKDT196DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT196DE_Source) of object;
  {$IFNDEF FPC}
  TKDT196DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT196DE_Source);
  {$ENDIF}

  TKDT196DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT196DEyanmicStoreBuffer;
    KDBuff     : TKDT196DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT196DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT196DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT196DEyanmicStoreBuffer; const Buff: TKDT196DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT196DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT196DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT196DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT196DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DE_Node; overload;
    function Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DE_Node; overload;
    function Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double): PKDT196DE_Node; overload;
    function Search(const Buff: TKDT196DE_Vec): PKDT196DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT196DE_DynamicVecBuffer; var OutBuff: TKDT196DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT196DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT196DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT256DE_Vec = array [0 .. TKDT256DE_AxisCount - 1] of TKDT256DE_VecType;
  PKDT256DE_Vec = ^TKDT256DE_Vec;

  TKDT256DE_DynamicVecBuffer = array of TKDT256DE_Vec;
  PKDT256DE_DynamicVecBuffer = ^TKDT256DE_DynamicVecBuffer;

  TKDT256DE_Source = packed record
    Buff: TKDT256DE_Vec;
    index: Int64;
  end;

  PKDT256DE_Source       = ^TKDT256DE_Source;
  TKDT256DE_SourceBuffer = array [0 .. 0] of PKDT256DE_Source;
  PKDT256DE_SourceBuffer = ^TKDT256DE_SourceBuffer;

  TKDT256DEyanmicSourceBuffer = array of PKDT256DE_Source;
  PKDT256DEyanmicSourceBuffer = ^TKDT256DEyanmicSourceBuffer;

  TKDT256DEyanmicStoreBuffer = array of TKDT256DE_Source;
  PKDT256DEyanmicStoreBuffer = ^TKDT256DEyanmicStoreBuffer;

  PKDT256DE_Node = ^TKDT256DE_Node;

  TKDT256DE_Node = packed record
    Parent, Right, Left: PKDT256DE_Node;
    vec: PKDT256DE_Source;
  end;

  TKDT256DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT256DE_Source);
  TKDT256DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT256DE_Source) of object;
  {$IFNDEF FPC}
  TKDT256DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT256DE_Source);
  {$ENDIF}

  TKDT256DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT256DEyanmicStoreBuffer;
    KDBuff     : TKDT256DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT256DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT256DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT256DEyanmicStoreBuffer; const Buff: TKDT256DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT256DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT256DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT256DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DE_Node; overload;
    function Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DE_Node; overload;
    function Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double): PKDT256DE_Node; overload;
    function Search(const Buff: TKDT256DE_Vec): PKDT256DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT256DE_DynamicVecBuffer; var OutBuff: TKDT256DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT256DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT256DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT272DE_Vec = array [0 .. TKDT272DE_AxisCount - 1] of TKDT272DE_VecType;
  PKDT272DE_Vec = ^TKDT272DE_Vec;

  TKDT272DE_DynamicVecBuffer = array of TKDT272DE_Vec;
  PKDT272DE_DynamicVecBuffer = ^TKDT272DE_DynamicVecBuffer;

  TKDT272DE_Source = packed record
    Buff: TKDT272DE_Vec;
    index: Int64;
  end;

  PKDT272DE_Source       = ^TKDT272DE_Source;
  TKDT272DE_SourceBuffer = array [0 .. 0] of PKDT272DE_Source;
  PKDT272DE_SourceBuffer = ^TKDT272DE_SourceBuffer;

  TKDT272DEyanmicSourceBuffer = array of PKDT272DE_Source;
  PKDT272DEyanmicSourceBuffer = ^TKDT272DEyanmicSourceBuffer;

  TKDT272DEyanmicStoreBuffer = array of TKDT272DE_Source;
  PKDT272DEyanmicStoreBuffer = ^TKDT272DEyanmicStoreBuffer;

  PKDT272DE_Node = ^TKDT272DE_Node;

  TKDT272DE_Node = packed record
    Parent, Right, Left: PKDT272DE_Node;
    vec: PKDT272DE_Source;
  end;

  TKDT272DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT272DE_Source);
  TKDT272DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT272DE_Source) of object;
  {$IFNDEF FPC}
  TKDT272DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT272DE_Source);
  {$ENDIF}

  TKDT272DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT272DEyanmicStoreBuffer;
    KDBuff     : TKDT272DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT272DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT272DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT272DEyanmicStoreBuffer; const Buff: TKDT272DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT272DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT272DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT272DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT272DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DE_Node; overload;
    function Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DE_Node; overload;
    function Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double): PKDT272DE_Node; overload;
    function Search(const Buff: TKDT272DE_Vec): PKDT272DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT272DE_DynamicVecBuffer; var OutBuff: TKDT272DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT272DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT272DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT288DE_Vec = array [0 .. TKDT288DE_AxisCount - 1] of TKDT288DE_VecType;
  PKDT288DE_Vec = ^TKDT288DE_Vec;

  TKDT288DE_DynamicVecBuffer = array of TKDT288DE_Vec;
  PKDT288DE_DynamicVecBuffer = ^TKDT288DE_DynamicVecBuffer;

  TKDT288DE_Source = packed record
    Buff: TKDT288DE_Vec;
    index: Int64;
  end;

  PKDT288DE_Source       = ^TKDT288DE_Source;
  TKDT288DE_SourceBuffer = array [0 .. 0] of PKDT288DE_Source;
  PKDT288DE_SourceBuffer = ^TKDT288DE_SourceBuffer;

  TKDT288DEyanmicSourceBuffer = array of PKDT288DE_Source;
  PKDT288DEyanmicSourceBuffer = ^TKDT288DEyanmicSourceBuffer;

  TKDT288DEyanmicStoreBuffer = array of TKDT288DE_Source;
  PKDT288DEyanmicStoreBuffer = ^TKDT288DEyanmicStoreBuffer;

  PKDT288DE_Node = ^TKDT288DE_Node;

  TKDT288DE_Node = packed record
    Parent, Right, Left: PKDT288DE_Node;
    vec: PKDT288DE_Source;
  end;

  TKDT288DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT288DE_Source);
  TKDT288DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT288DE_Source) of object;
  {$IFNDEF FPC}
  TKDT288DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT288DE_Source);
  {$ENDIF}

  TKDT288DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT288DEyanmicStoreBuffer;
    KDBuff     : TKDT288DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT288DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT288DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT288DEyanmicStoreBuffer; const Buff: TKDT288DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT288DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT288DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT288DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT288DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DE_Node; overload;
    function Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DE_Node; overload;
    function Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double): PKDT288DE_Node; overload;
    function Search(const Buff: TKDT288DE_Vec): PKDT288DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT288DE_DynamicVecBuffer; var OutBuff: TKDT288DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT288DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT288DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT372DE_Vec = array [0 .. TKDT372DE_AxisCount - 1] of TKDT372DE_VecType;
  PKDT372DE_Vec = ^TKDT372DE_Vec;

  TKDT372DE_DynamicVecBuffer = array of TKDT372DE_Vec;
  PKDT372DE_DynamicVecBuffer = ^TKDT372DE_DynamicVecBuffer;

  TKDT372DE_Source = packed record
    Buff: TKDT372DE_Vec;
    index: Int64;
  end;

  PKDT372DE_Source       = ^TKDT372DE_Source;
  TKDT372DE_SourceBuffer = array [0 .. 0] of PKDT372DE_Source;
  PKDT372DE_SourceBuffer = ^TKDT372DE_SourceBuffer;

  TKDT372DEyanmicSourceBuffer = array of PKDT372DE_Source;
  PKDT372DEyanmicSourceBuffer = ^TKDT372DEyanmicSourceBuffer;

  TKDT372DEyanmicStoreBuffer = array of TKDT372DE_Source;
  PKDT372DEyanmicStoreBuffer = ^TKDT372DEyanmicStoreBuffer;

  PKDT372DE_Node = ^TKDT372DE_Node;

  TKDT372DE_Node = packed record
    Parent, Right, Left: PKDT372DE_Node;
    vec: PKDT372DE_Source;
  end;

  TKDT372DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT372DE_Source);
  TKDT372DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT372DE_Source) of object;
  {$IFNDEF FPC}
  TKDT372DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT372DE_Source);
  {$ENDIF}

  TKDT372DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT372DEyanmicStoreBuffer;
    KDBuff     : TKDT372DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT372DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT372DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT372DEyanmicStoreBuffer; const Buff: TKDT372DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT372DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT372DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT372DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT372DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DE_Node; overload;
    function Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DE_Node; overload;
    function Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double): PKDT372DE_Node; overload;
    function Search(const Buff: TKDT372DE_Vec): PKDT372DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT372DE_DynamicVecBuffer; var OutBuff: TKDT372DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT372DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT372DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT512DE_Vec = array [0 .. TKDT512DE_AxisCount - 1] of TKDT512DE_VecType;
  PKDT512DE_Vec = ^TKDT512DE_Vec;

  TKDT512DE_DynamicVecBuffer = array of TKDT512DE_Vec;
  PKDT512DE_DynamicVecBuffer = ^TKDT512DE_DynamicVecBuffer;

  TKDT512DE_Source = packed record
    Buff: TKDT512DE_Vec;
    index: Int64;
  end;

  PKDT512DE_Source       = ^TKDT512DE_Source;
  TKDT512DE_SourceBuffer = array [0 .. 0] of PKDT512DE_Source;
  PKDT512DE_SourceBuffer = ^TKDT512DE_SourceBuffer;

  TKDT512DEyanmicSourceBuffer = array of PKDT512DE_Source;
  PKDT512DEyanmicSourceBuffer = ^TKDT512DEyanmicSourceBuffer;

  TKDT512DEyanmicStoreBuffer = array of TKDT512DE_Source;
  PKDT512DEyanmicStoreBuffer = ^TKDT512DEyanmicStoreBuffer;

  PKDT512DE_Node = ^TKDT512DE_Node;

  TKDT512DE_Node = packed record
    Parent, Right, Left: PKDT512DE_Node;
    vec: PKDT512DE_Source;
  end;

  TKDT512DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT512DE_Source);
  TKDT512DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT512DE_Source) of object;
  {$IFNDEF FPC}
  TKDT512DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT512DE_Source);
  {$ENDIF}

  TKDT512DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT512DEyanmicStoreBuffer;
    KDBuff     : TKDT512DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT512DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT512DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT512DEyanmicStoreBuffer; const Buff: TKDT512DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT512DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT512DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT512DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DE_Node; overload;
    function Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DE_Node; overload;
    function Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double): PKDT512DE_Node; overload;
    function Search(const Buff: TKDT512DE_Vec): PKDT512DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT512DE_DynamicVecBuffer; var OutBuff: TKDT512DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT512DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT512DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT576DE_Vec = array [0 .. TKDT576DE_AxisCount - 1] of TKDT576DE_VecType;
  PKDT576DE_Vec = ^TKDT576DE_Vec;

  TKDT576DE_DynamicVecBuffer = array of TKDT576DE_Vec;
  PKDT576DE_DynamicVecBuffer = ^TKDT576DE_DynamicVecBuffer;

  TKDT576DE_Source = packed record
    Buff: TKDT576DE_Vec;
    index: Int64;
  end;

  PKDT576DE_Source       = ^TKDT576DE_Source;
  TKDT576DE_SourceBuffer = array [0 .. 0] of PKDT576DE_Source;
  PKDT576DE_SourceBuffer = ^TKDT576DE_SourceBuffer;

  TKDT576DEyanmicSourceBuffer = array of PKDT576DE_Source;
  PKDT576DEyanmicSourceBuffer = ^TKDT576DEyanmicSourceBuffer;

  TKDT576DEyanmicStoreBuffer = array of TKDT576DE_Source;
  PKDT576DEyanmicStoreBuffer = ^TKDT576DEyanmicStoreBuffer;

  PKDT576DE_Node = ^TKDT576DE_Node;

  TKDT576DE_Node = packed record
    Parent, Right, Left: PKDT576DE_Node;
    vec: PKDT576DE_Source;
  end;

  TKDT576DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT576DE_Source);
  TKDT576DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT576DE_Source) of object;
  {$IFNDEF FPC}
  TKDT576DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT576DE_Source);
  {$ENDIF}

  TKDT576DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT576DEyanmicStoreBuffer;
    KDBuff     : TKDT576DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT576DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT576DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT576DEyanmicStoreBuffer; const Buff: TKDT576DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT576DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT576DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT576DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT576DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DE_Node; overload;
    function Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DE_Node; overload;
    function Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double): PKDT576DE_Node; overload;
    function Search(const Buff: TKDT576DE_Vec): PKDT576DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT576DE_DynamicVecBuffer; var OutBuff: TKDT576DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT576DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT576DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT768DE_Vec = array [0 .. TKDT768DE_AxisCount - 1] of TKDT768DE_VecType;
  PKDT768DE_Vec = ^TKDT768DE_Vec;

  TKDT768DE_DynamicVecBuffer = array of TKDT768DE_Vec;
  PKDT768DE_DynamicVecBuffer = ^TKDT768DE_DynamicVecBuffer;

  TKDT768DE_Source = packed record
    Buff: TKDT768DE_Vec;
    index: Int64;
  end;

  PKDT768DE_Source       = ^TKDT768DE_Source;
  TKDT768DE_SourceBuffer = array [0 .. 0] of PKDT768DE_Source;
  PKDT768DE_SourceBuffer = ^TKDT768DE_SourceBuffer;

  TKDT768DEyanmicSourceBuffer = array of PKDT768DE_Source;
  PKDT768DEyanmicSourceBuffer = ^TKDT768DEyanmicSourceBuffer;

  TKDT768DEyanmicStoreBuffer = array of TKDT768DE_Source;
  PKDT768DEyanmicStoreBuffer = ^TKDT768DEyanmicStoreBuffer;

  PKDT768DE_Node = ^TKDT768DE_Node;

  TKDT768DE_Node = packed record
    Parent, Right, Left: PKDT768DE_Node;
    vec: PKDT768DE_Source;
  end;

  TKDT768DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT768DE_Source);
  TKDT768DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT768DE_Source) of object;
  {$IFNDEF FPC}
  TKDT768DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT768DE_Source);
  {$ENDIF}

  TKDT768DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT768DEyanmicStoreBuffer;
    KDBuff     : TKDT768DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT768DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT768DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT768DEyanmicStoreBuffer; const Buff: TKDT768DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT768DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT768DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT768DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT768DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DE_Node; overload;
    function Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DE_Node; overload;
    function Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double): PKDT768DE_Node; overload;
    function Search(const Buff: TKDT768DE_Vec): PKDT768DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT768DE_DynamicVecBuffer; var OutBuff: TKDT768DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT768DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT768DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1024DE_Vec = array [0 .. TKDT1024DE_AxisCount - 1] of TKDT1024DE_VecType;
  PKDT1024DE_Vec = ^TKDT1024DE_Vec;

  TKDT1024DE_DynamicVecBuffer = array of TKDT1024DE_Vec;
  PKDT1024DE_DynamicVecBuffer = ^TKDT1024DE_DynamicVecBuffer;

  TKDT1024DE_Source = packed record
    Buff: TKDT1024DE_Vec;
    index: Int64;
  end;

  PKDT1024DE_Source       = ^TKDT1024DE_Source;
  TKDT1024DE_SourceBuffer = array [0 .. 0] of PKDT1024DE_Source;
  PKDT1024DE_SourceBuffer = ^TKDT1024DE_SourceBuffer;

  TKDT1024DEyanmicSourceBuffer = array of PKDT1024DE_Source;
  PKDT1024DEyanmicSourceBuffer = ^TKDT1024DEyanmicSourceBuffer;

  TKDT1024DEyanmicStoreBuffer = array of TKDT1024DE_Source;
  PKDT1024DEyanmicStoreBuffer = ^TKDT1024DEyanmicStoreBuffer;

  PKDT1024DE_Node = ^TKDT1024DE_Node;

  TKDT1024DE_Node = packed record
    Parent, Right, Left: PKDT1024DE_Node;
    vec: PKDT1024DE_Source;
  end;

  TKDT1024DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1024DE_Source);
  TKDT1024DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1024DE_Source) of object;
  {$IFNDEF FPC}
  TKDT1024DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1024DE_Source);
  {$ENDIF}

  TKDT1024DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1024DEyanmicStoreBuffer;
    KDBuff     : TKDT1024DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1024DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1024DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1024DEyanmicStoreBuffer; const Buff: TKDT1024DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1024DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1024DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1024DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DE_Node; overload;
    function Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DE_Node; overload;
    function Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double): PKDT1024DE_Node; overload;
    function Search(const Buff: TKDT1024DE_Vec): PKDT1024DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1024DE_DynamicVecBuffer; var OutBuff: TKDT1024DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1024DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1024DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1040DE_Vec = array [0 .. TKDT1040DE_AxisCount - 1] of TKDT1040DE_VecType;
  PKDT1040DE_Vec = ^TKDT1040DE_Vec;

  TKDT1040DE_DynamicVecBuffer = array of TKDT1040DE_Vec;
  PKDT1040DE_DynamicVecBuffer = ^TKDT1040DE_DynamicVecBuffer;

  TKDT1040DE_Source = packed record
    Buff: TKDT1040DE_Vec;
    index: Int64;
  end;

  PKDT1040DE_Source       = ^TKDT1040DE_Source;
  TKDT1040DE_SourceBuffer = array [0 .. 0] of PKDT1040DE_Source;
  PKDT1040DE_SourceBuffer = ^TKDT1040DE_SourceBuffer;

  TKDT1040DEyanmicSourceBuffer = array of PKDT1040DE_Source;
  PKDT1040DEyanmicSourceBuffer = ^TKDT1040DEyanmicSourceBuffer;

  TKDT1040DEyanmicStoreBuffer = array of TKDT1040DE_Source;
  PKDT1040DEyanmicStoreBuffer = ^TKDT1040DEyanmicStoreBuffer;

  PKDT1040DE_Node = ^TKDT1040DE_Node;

  TKDT1040DE_Node = packed record
    Parent, Right, Left: PKDT1040DE_Node;
    vec: PKDT1040DE_Source;
  end;

  TKDT1040DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1040DE_Source);
  TKDT1040DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1040DE_Source) of object;
  {$IFNDEF FPC}
  TKDT1040DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1040DE_Source);
  {$ENDIF}

  TKDT1040DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1040DEyanmicStoreBuffer;
    KDBuff     : TKDT1040DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1040DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1040DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1040DEyanmicStoreBuffer; const Buff: TKDT1040DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1040DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1040DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1040DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1040DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DE_Node; overload;
    function Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DE_Node; overload;
    function Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double): PKDT1040DE_Node; overload;
    function Search(const Buff: TKDT1040DE_Vec): PKDT1040DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1040DE_DynamicVecBuffer; var OutBuff: TKDT1040DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1040DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1040DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1056DE_Vec = array [0 .. TKDT1056DE_AxisCount - 1] of TKDT1056DE_VecType;
  PKDT1056DE_Vec = ^TKDT1056DE_Vec;

  TKDT1056DE_DynamicVecBuffer = array of TKDT1056DE_Vec;
  PKDT1056DE_DynamicVecBuffer = ^TKDT1056DE_DynamicVecBuffer;

  TKDT1056DE_Source = packed record
    Buff: TKDT1056DE_Vec;
    index: Int64;
  end;

  PKDT1056DE_Source       = ^TKDT1056DE_Source;
  TKDT1056DE_SourceBuffer = array [0 .. 0] of PKDT1056DE_Source;
  PKDT1056DE_SourceBuffer = ^TKDT1056DE_SourceBuffer;

  TKDT1056DEyanmicSourceBuffer = array of PKDT1056DE_Source;
  PKDT1056DEyanmicSourceBuffer = ^TKDT1056DEyanmicSourceBuffer;

  TKDT1056DEyanmicStoreBuffer = array of TKDT1056DE_Source;
  PKDT1056DEyanmicStoreBuffer = ^TKDT1056DEyanmicStoreBuffer;

  PKDT1056DE_Node = ^TKDT1056DE_Node;

  TKDT1056DE_Node = packed record
    Parent, Right, Left: PKDT1056DE_Node;
    vec: PKDT1056DE_Source;
  end;

  TKDT1056DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1056DE_Source);
  TKDT1056DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1056DE_Source) of object;
  {$IFNDEF FPC}
  TKDT1056DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1056DE_Source);
  {$ENDIF}

  TKDT1056DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1056DEyanmicStoreBuffer;
    KDBuff     : TKDT1056DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1056DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1056DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1056DEyanmicStoreBuffer; const Buff: TKDT1056DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1056DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1056DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1056DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1056DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DE_Node; overload;
    function Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DE_Node; overload;
    function Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double): PKDT1056DE_Node; overload;
    function Search(const Buff: TKDT1056DE_Vec): PKDT1056DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1056DE_DynamicVecBuffer; var OutBuff: TKDT1056DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1056DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1056DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1536DE_Vec = array [0 .. TKDT1536DE_AxisCount - 1] of TKDT1536DE_VecType;
  PKDT1536DE_Vec = ^TKDT1536DE_Vec;

  TKDT1536DE_DynamicVecBuffer = array of TKDT1536DE_Vec;
  PKDT1536DE_DynamicVecBuffer = ^TKDT1536DE_DynamicVecBuffer;

  TKDT1536DE_Source = packed record
    Buff: TKDT1536DE_Vec;
    index: Int64;
  end;

  PKDT1536DE_Source       = ^TKDT1536DE_Source;
  TKDT1536DE_SourceBuffer = array [0 .. 0] of PKDT1536DE_Source;
  PKDT1536DE_SourceBuffer = ^TKDT1536DE_SourceBuffer;

  TKDT1536DEyanmicSourceBuffer = array of PKDT1536DE_Source;
  PKDT1536DEyanmicSourceBuffer = ^TKDT1536DEyanmicSourceBuffer;

  TKDT1536DEyanmicStoreBuffer = array of TKDT1536DE_Source;
  PKDT1536DEyanmicStoreBuffer = ^TKDT1536DEyanmicStoreBuffer;

  PKDT1536DE_Node = ^TKDT1536DE_Node;

  TKDT1536DE_Node = packed record
    Parent, Right, Left: PKDT1536DE_Node;
    vec: PKDT1536DE_Source;
  end;

  TKDT1536DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1536DE_Source);
  TKDT1536DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1536DE_Source) of object;
  {$IFNDEF FPC}
  TKDT1536DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1536DE_Source);
  {$ENDIF}

  TKDT1536DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1536DEyanmicStoreBuffer;
    KDBuff     : TKDT1536DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1536DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1536DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1536DEyanmicStoreBuffer; const Buff: TKDT1536DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1536DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1536DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1536DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1536DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DE_Node; overload;
    function Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DE_Node; overload;
    function Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double): PKDT1536DE_Node; overload;
    function Search(const Buff: TKDT1536DE_Vec): PKDT1536DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1536DE_DynamicVecBuffer; var OutBuff: TKDT1536DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1536DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1536DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1920DE_Vec = array [0 .. TKDT1920DE_AxisCount - 1] of TKDT1920DE_VecType;
  PKDT1920DE_Vec = ^TKDT1920DE_Vec;

  TKDT1920DE_DynamicVecBuffer = array of TKDT1920DE_Vec;
  PKDT1920DE_DynamicVecBuffer = ^TKDT1920DE_DynamicVecBuffer;

  TKDT1920DE_Source = packed record
    Buff: TKDT1920DE_Vec;
    index: Int64;
  end;

  PKDT1920DE_Source       = ^TKDT1920DE_Source;
  TKDT1920DE_SourceBuffer = array [0 .. 0] of PKDT1920DE_Source;
  PKDT1920DE_SourceBuffer = ^TKDT1920DE_SourceBuffer;

  TKDT1920DEyanmicSourceBuffer = array of PKDT1920DE_Source;
  PKDT1920DEyanmicSourceBuffer = ^TKDT1920DEyanmicSourceBuffer;

  TKDT1920DEyanmicStoreBuffer = array of TKDT1920DE_Source;
  PKDT1920DEyanmicStoreBuffer = ^TKDT1920DEyanmicStoreBuffer;

  PKDT1920DE_Node = ^TKDT1920DE_Node;

  TKDT1920DE_Node = packed record
    Parent, Right, Left: PKDT1920DE_Node;
    vec: PKDT1920DE_Source;
  end;

  TKDT1920DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1920DE_Source);
  TKDT1920DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1920DE_Source) of object;
  {$IFNDEF FPC}
  TKDT1920DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1920DE_Source);
  {$ENDIF}

  TKDT1920DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1920DEyanmicStoreBuffer;
    KDBuff     : TKDT1920DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1920DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1920DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1920DEyanmicStoreBuffer; const Buff: TKDT1920DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1920DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1920DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1920DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1920DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DE_Node; overload;
    function Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DE_Node; overload;
    function Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double): PKDT1920DE_Node; overload;
    function Search(const Buff: TKDT1920DE_Vec): PKDT1920DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1920DE_DynamicVecBuffer; var OutBuff: TKDT1920DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1920DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1920DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1980DE_Vec = array [0 .. TKDT1980DE_AxisCount - 1] of TKDT1980DE_VecType;
  PKDT1980DE_Vec = ^TKDT1980DE_Vec;

  TKDT1980DE_DynamicVecBuffer = array of TKDT1980DE_Vec;
  PKDT1980DE_DynamicVecBuffer = ^TKDT1980DE_DynamicVecBuffer;

  TKDT1980DE_Source = packed record
    Buff: TKDT1980DE_Vec;
    index: Int64;
  end;

  PKDT1980DE_Source       = ^TKDT1980DE_Source;
  TKDT1980DE_SourceBuffer = array [0 .. 0] of PKDT1980DE_Source;
  PKDT1980DE_SourceBuffer = ^TKDT1980DE_SourceBuffer;

  TKDT1980DEyanmicSourceBuffer = array of PKDT1980DE_Source;
  PKDT1980DEyanmicSourceBuffer = ^TKDT1980DEyanmicSourceBuffer;

  TKDT1980DEyanmicStoreBuffer = array of TKDT1980DE_Source;
  PKDT1980DEyanmicStoreBuffer = ^TKDT1980DEyanmicStoreBuffer;

  PKDT1980DE_Node = ^TKDT1980DE_Node;

  TKDT1980DE_Node = packed record
    Parent, Right, Left: PKDT1980DE_Node;
    vec: PKDT1980DE_Source;
  end;

  TKDT1980DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1980DE_Source);
  TKDT1980DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1980DE_Source) of object;
  {$IFNDEF FPC}
  TKDT1980DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1980DE_Source);
  {$ENDIF}

  TKDT1980DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1980DEyanmicStoreBuffer;
    KDBuff     : TKDT1980DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1980DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1980DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1980DEyanmicStoreBuffer; const Buff: TKDT1980DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1980DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1980DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1980DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1980DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DE_Node; overload;
    function Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DE_Node; overload;
    function Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double): PKDT1980DE_Node; overload;
    function Search(const Buff: TKDT1980DE_Vec): PKDT1980DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1980DE_DynamicVecBuffer; var OutBuff: TKDT1980DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1980DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1980DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT2048DE_Vec = array [0 .. TKDT2048DE_AxisCount - 1] of TKDT2048DE_VecType;
  PKDT2048DE_Vec = ^TKDT2048DE_Vec;

  TKDT2048DE_DynamicVecBuffer = array of TKDT2048DE_Vec;
  PKDT2048DE_DynamicVecBuffer = ^TKDT2048DE_DynamicVecBuffer;

  TKDT2048DE_Source = packed record
    Buff: TKDT2048DE_Vec;
    index: Int64;
  end;

  PKDT2048DE_Source       = ^TKDT2048DE_Source;
  TKDT2048DE_SourceBuffer = array [0 .. 0] of PKDT2048DE_Source;
  PKDT2048DE_SourceBuffer = ^TKDT2048DE_SourceBuffer;

  TKDT2048DEyanmicSourceBuffer = array of PKDT2048DE_Source;
  PKDT2048DEyanmicSourceBuffer = ^TKDT2048DEyanmicSourceBuffer;

  TKDT2048DEyanmicStoreBuffer = array of TKDT2048DE_Source;
  PKDT2048DEyanmicStoreBuffer = ^TKDT2048DEyanmicStoreBuffer;

  PKDT2048DE_Node = ^TKDT2048DE_Node;

  TKDT2048DE_Node = packed record
    Parent, Right, Left: PKDT2048DE_Node;
    vec: PKDT2048DE_Source;
  end;

  TKDT2048DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT2048DE_Source);
  TKDT2048DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT2048DE_Source) of object;
  {$IFNDEF FPC}
  TKDT2048DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT2048DE_Source);
  {$ENDIF}

  TKDT2048DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2048DEyanmicStoreBuffer;
    KDBuff     : TKDT2048DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2048DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT2048DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT2048DEyanmicStoreBuffer; const Buff: TKDT2048DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT2048DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2048DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2048DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2048DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DE_Node; overload;
    function Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DE_Node; overload;
    function Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double): PKDT2048DE_Node; overload;
    function Search(const Buff: TKDT2048DE_Vec): PKDT2048DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2048DE_DynamicVecBuffer; var OutBuff: TKDT2048DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT2048DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT2048DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3072DE_Vec = array [0 .. TKDT3072DE_AxisCount - 1] of TKDT3072DE_VecType;
  PKDT3072DE_Vec = ^TKDT3072DE_Vec;

  TKDT3072DE_DynamicVecBuffer = array of TKDT3072DE_Vec;
  PKDT3072DE_DynamicVecBuffer = ^TKDT3072DE_DynamicVecBuffer;

  TKDT3072DE_Source = packed record
    Buff: TKDT3072DE_Vec;
    index: Int64;
  end;

  PKDT3072DE_Source       = ^TKDT3072DE_Source;
  TKDT3072DE_SourceBuffer = array [0 .. 0] of PKDT3072DE_Source;
  PKDT3072DE_SourceBuffer = ^TKDT3072DE_SourceBuffer;

  TKDT3072DEyanmicSourceBuffer = array of PKDT3072DE_Source;
  PKDT3072DEyanmicSourceBuffer = ^TKDT3072DEyanmicSourceBuffer;

  TKDT3072DEyanmicStoreBuffer = array of TKDT3072DE_Source;
  PKDT3072DEyanmicStoreBuffer = ^TKDT3072DEyanmicStoreBuffer;

  PKDT3072DE_Node = ^TKDT3072DE_Node;

  TKDT3072DE_Node = packed record
    Parent, Right, Left: PKDT3072DE_Node;
    vec: PKDT3072DE_Source;
  end;

  TKDT3072DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3072DE_Source);
  TKDT3072DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3072DE_Source) of object;
  {$IFNDEF FPC}
  TKDT3072DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3072DE_Source);
  {$ENDIF}

  TKDT3072DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3072DEyanmicStoreBuffer;
    KDBuff     : TKDT3072DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3072DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3072DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3072DEyanmicStoreBuffer; const Buff: TKDT3072DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3072DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3072DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3072DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3072DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DE_Node; overload;
    function Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DE_Node; overload;
    function Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double): PKDT3072DE_Node; overload;
    function Search(const Buff: TKDT3072DE_Vec): PKDT3072DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3072DE_DynamicVecBuffer; var OutBuff: TKDT3072DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3072DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3072DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3088DE_Vec = array [0 .. TKDT3088DE_AxisCount - 1] of TKDT3088DE_VecType;
  PKDT3088DE_Vec = ^TKDT3088DE_Vec;

  TKDT3088DE_DynamicVecBuffer = array of TKDT3088DE_Vec;
  PKDT3088DE_DynamicVecBuffer = ^TKDT3088DE_DynamicVecBuffer;

  TKDT3088DE_Source = packed record
    Buff: TKDT3088DE_Vec;
    index: Int64;
  end;

  PKDT3088DE_Source       = ^TKDT3088DE_Source;
  TKDT3088DE_SourceBuffer = array [0 .. 0] of PKDT3088DE_Source;
  PKDT3088DE_SourceBuffer = ^TKDT3088DE_SourceBuffer;

  TKDT3088DEyanmicSourceBuffer = array of PKDT3088DE_Source;
  PKDT3088DEyanmicSourceBuffer = ^TKDT3088DEyanmicSourceBuffer;

  TKDT3088DEyanmicStoreBuffer = array of TKDT3088DE_Source;
  PKDT3088DEyanmicStoreBuffer = ^TKDT3088DEyanmicStoreBuffer;

  PKDT3088DE_Node = ^TKDT3088DE_Node;

  TKDT3088DE_Node = packed record
    Parent, Right, Left: PKDT3088DE_Node;
    vec: PKDT3088DE_Source;
  end;

  TKDT3088DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3088DE_Source);
  TKDT3088DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3088DE_Source) of object;
  {$IFNDEF FPC}
  TKDT3088DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3088DE_Source);
  {$ENDIF}

  TKDT3088DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3088DEyanmicStoreBuffer;
    KDBuff     : TKDT3088DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3088DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3088DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3088DEyanmicStoreBuffer; const Buff: TKDT3088DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3088DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3088DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3088DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3088DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DE_Node; overload;
    function Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DE_Node; overload;
    function Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double): PKDT3088DE_Node; overload;
    function Search(const Buff: TKDT3088DE_Vec): PKDT3088DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3088DE_DynamicVecBuffer; var OutBuff: TKDT3088DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3088DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3088DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3104DE_Vec = array [0 .. TKDT3104DE_AxisCount - 1] of TKDT3104DE_VecType;
  PKDT3104DE_Vec = ^TKDT3104DE_Vec;

  TKDT3104DE_DynamicVecBuffer = array of TKDT3104DE_Vec;
  PKDT3104DE_DynamicVecBuffer = ^TKDT3104DE_DynamicVecBuffer;

  TKDT3104DE_Source = packed record
    Buff: TKDT3104DE_Vec;
    index: Int64;
  end;

  PKDT3104DE_Source       = ^TKDT3104DE_Source;
  TKDT3104DE_SourceBuffer = array [0 .. 0] of PKDT3104DE_Source;
  PKDT3104DE_SourceBuffer = ^TKDT3104DE_SourceBuffer;

  TKDT3104DEyanmicSourceBuffer = array of PKDT3104DE_Source;
  PKDT3104DEyanmicSourceBuffer = ^TKDT3104DEyanmicSourceBuffer;

  TKDT3104DEyanmicStoreBuffer = array of TKDT3104DE_Source;
  PKDT3104DEyanmicStoreBuffer = ^TKDT3104DEyanmicStoreBuffer;

  PKDT3104DE_Node = ^TKDT3104DE_Node;

  TKDT3104DE_Node = packed record
    Parent, Right, Left: PKDT3104DE_Node;
    vec: PKDT3104DE_Source;
  end;

  TKDT3104DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3104DE_Source);
  TKDT3104DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3104DE_Source) of object;
  {$IFNDEF FPC}
  TKDT3104DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3104DE_Source);
  {$ENDIF}

  TKDT3104DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3104DEyanmicStoreBuffer;
    KDBuff     : TKDT3104DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3104DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3104DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3104DEyanmicStoreBuffer; const Buff: TKDT3104DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3104DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3104DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3104DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3104DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DE_Node; overload;
    function Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DE_Node; overload;
    function Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double): PKDT3104DE_Node; overload;
    function Search(const Buff: TKDT3104DE_Vec): PKDT3104DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3104DE_DynamicVecBuffer; var OutBuff: TKDT3104DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3104DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3104DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT4096DE_Vec = array [0 .. TKDT4096DE_AxisCount - 1] of TKDT4096DE_VecType;
  PKDT4096DE_Vec = ^TKDT4096DE_Vec;

  TKDT4096DE_DynamicVecBuffer = array of TKDT4096DE_Vec;
  PKDT4096DE_DynamicVecBuffer = ^TKDT4096DE_DynamicVecBuffer;

  TKDT4096DE_Source = packed record
    Buff: TKDT4096DE_Vec;
    index: Int64;
  end;

  PKDT4096DE_Source       = ^TKDT4096DE_Source;
  TKDT4096DE_SourceBuffer = array [0 .. 0] of PKDT4096DE_Source;
  PKDT4096DE_SourceBuffer = ^TKDT4096DE_SourceBuffer;

  TKDT4096DEyanmicSourceBuffer = array of PKDT4096DE_Source;
  PKDT4096DEyanmicSourceBuffer = ^TKDT4096DEyanmicSourceBuffer;

  TKDT4096DEyanmicStoreBuffer = array of TKDT4096DE_Source;
  PKDT4096DEyanmicStoreBuffer = ^TKDT4096DEyanmicStoreBuffer;

  PKDT4096DE_Node = ^TKDT4096DE_Node;

  TKDT4096DE_Node = packed record
    Parent, Right, Left: PKDT4096DE_Node;
    vec: PKDT4096DE_Source;
  end;

  TKDT4096DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT4096DE_Source);
  TKDT4096DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT4096DE_Source) of object;
  {$IFNDEF FPC}
  TKDT4096DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT4096DE_Source);
  {$ENDIF}

  TKDT4096DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT4096DEyanmicStoreBuffer;
    KDBuff     : TKDT4096DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4096DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT4096DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT4096DEyanmicStoreBuffer; const Buff: TKDT4096DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT4096DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4096DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4096DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT4096DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DE_Node; overload;
    function Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DE_Node; overload;
    function Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double): PKDT4096DE_Node; overload;
    function Search(const Buff: TKDT4096DE_Vec): PKDT4096DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4096DE_DynamicVecBuffer; var OutBuff: TKDT4096DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT4096DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT4096DE_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT8192DE_Vec = array [0 .. TKDT8192DE_AxisCount - 1] of TKDT8192DE_VecType;
  PKDT8192DE_Vec = ^TKDT8192DE_Vec;

  TKDT8192DE_DynamicVecBuffer = array of TKDT8192DE_Vec;
  PKDT8192DE_DynamicVecBuffer = ^TKDT8192DE_DynamicVecBuffer;

  TKDT8192DE_Source = packed record
    Buff: TKDT8192DE_Vec;
    index: Int64;
  end;

  PKDT8192DE_Source       = ^TKDT8192DE_Source;
  TKDT8192DE_SourceBuffer = array [0 .. 0] of PKDT8192DE_Source;
  PKDT8192DE_SourceBuffer = ^TKDT8192DE_SourceBuffer;

  TKDT8192DEyanmicSourceBuffer = array of PKDT8192DE_Source;
  PKDT8192DEyanmicSourceBuffer = ^TKDT8192DEyanmicSourceBuffer;

  TKDT8192DEyanmicStoreBuffer = array of TKDT8192DE_Source;
  PKDT8192DEyanmicStoreBuffer = ^TKDT8192DEyanmicStoreBuffer;

  PKDT8192DE_Node = ^TKDT8192DE_Node;

  TKDT8192DE_Node = packed record
    Parent, Right, Left: PKDT8192DE_Node;
    vec: PKDT8192DE_Source;
  end;

  TKDT8192DE_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT8192DE_Source);
  TKDT8192DE_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT8192DE_Source) of object;
  {$IFNDEF FPC}
  TKDT8192DE_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT8192DE_Source);
  {$ENDIF}

  TKDT8192DE = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT8192DEyanmicStoreBuffer;
    KDBuff     : TKDT8192DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8192DE_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT8192DE_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DE_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT8192DEyanmicStoreBuffer; const Buff: TKDT8192DE_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT8192DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8192DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8192DEyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT8192DE_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DE_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DE_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DE_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DE_Node; overload;
    function Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DE_Node; overload;
    function Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double): PKDT8192DE_Node; overload;
    function Search(const Buff: TKDT8192DE_Vec): PKDT8192DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8192DE_DynamicVecBuffer; var OutBuff: TKDT8192DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT8192DE_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT8192DE_Source);
    class procedure Test;
    {$ENDIF}
  end;






  // extended float: KDTree
function KDT1DEVec(const s: string): TKDT1DE_Vec; overload;
function KDT1DEVec(const v: TKDT1DE_Vec): string; overload;
function KDT1DEPow(const v: TKDT1DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1DEDistance(const v1, v2: TKDT1DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1DECmpare(const v1, v2: TKDT1DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT2DEVec(const s: string): TKDT2DE_Vec; overload;
function KDT2DEVec(const v: TKDT2DE_Vec): string; overload;
function KDT2DEPow(const v: TKDT2DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2DEDistance(const v1, v2: TKDT2DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2DECmpare(const v1, v2: TKDT2DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3DEVec(const s: string): TKDT3DE_Vec; overload;
function KDT3DEVec(const v: TKDT3DE_Vec): string; overload;
function KDT3DEPow(const v: TKDT3DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3DEDistance(const v1, v2: TKDT3DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3DECmpare(const v1, v2: TKDT3DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT4DEVec(const s: string): TKDT4DE_Vec; overload;
function KDT4DEVec(const v: TKDT4DE_Vec): string; overload;
function KDT4DEPow(const v: TKDT4DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4DEDistance(const v1, v2: TKDT4DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4DECmpare(const v1, v2: TKDT4DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT5DEVec(const s: string): TKDT5DE_Vec; overload;
function KDT5DEVec(const v: TKDT5DE_Vec): string; overload;
function KDT5DEPow(const v: TKDT5DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT5DEDistance(const v1, v2: TKDT5DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT5DECmpare(const v1, v2: TKDT5DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT6DEVec(const s: string): TKDT6DE_Vec; overload;
function KDT6DEVec(const v: TKDT6DE_Vec): string; overload;
function KDT6DEPow(const v: TKDT6DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT6DEDistance(const v1, v2: TKDT6DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT6DECmpare(const v1, v2: TKDT6DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT7DEVec(const s: string): TKDT7DE_Vec; overload;
function KDT7DEVec(const v: TKDT7DE_Vec): string; overload;
function KDT7DEPow(const v: TKDT7DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT7DEDistance(const v1, v2: TKDT7DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT7DECmpare(const v1, v2: TKDT7DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT8DEVec(const s: string): TKDT8DE_Vec; overload;
function KDT8DEVec(const v: TKDT8DE_Vec): string; overload;
function KDT8DEPow(const v: TKDT8DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8DEDistance(const v1, v2: TKDT8DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8DECmpare(const v1, v2: TKDT8DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT9DEVec(const s: string): TKDT9DE_Vec; overload;
function KDT9DEVec(const v: TKDT9DE_Vec): string; overload;
function KDT9DEPow(const v: TKDT9DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT9DEDistance(const v1, v2: TKDT9DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT9DECmpare(const v1, v2: TKDT9DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT10DEVec(const s: string): TKDT10DE_Vec; overload;
function KDT10DEVec(const v: TKDT10DE_Vec): string; overload;
function KDT10DEPow(const v: TKDT10DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT10DEDistance(const v1, v2: TKDT10DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT10DECmpare(const v1, v2: TKDT10DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT11DEVec(const s: string): TKDT11DE_Vec; overload;
function KDT11DEVec(const v: TKDT11DE_Vec): string; overload;
function KDT11DEPow(const v: TKDT11DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT11DEDistance(const v1, v2: TKDT11DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT11DECmpare(const v1, v2: TKDT11DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT12DEVec(const s: string): TKDT12DE_Vec; overload;
function KDT12DEVec(const v: TKDT12DE_Vec): string; overload;
function KDT12DEPow(const v: TKDT12DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT12DEDistance(const v1, v2: TKDT12DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT12DECmpare(const v1, v2: TKDT12DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT13DEVec(const s: string): TKDT13DE_Vec; overload;
function KDT13DEVec(const v: TKDT13DE_Vec): string; overload;
function KDT13DEPow(const v: TKDT13DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT13DEDistance(const v1, v2: TKDT13DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT13DECmpare(const v1, v2: TKDT13DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT14DEVec(const s: string): TKDT14DE_Vec; overload;
function KDT14DEVec(const v: TKDT14DE_Vec): string; overload;
function KDT14DEPow(const v: TKDT14DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT14DEDistance(const v1, v2: TKDT14DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT14DECmpare(const v1, v2: TKDT14DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT15DEVec(const s: string): TKDT15DE_Vec; overload;
function KDT15DEVec(const v: TKDT15DE_Vec): string; overload;
function KDT15DEPow(const v: TKDT15DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT15DEDistance(const v1, v2: TKDT15DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT15DECmpare(const v1, v2: TKDT15DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT16DEVec(const s: string): TKDT16DE_Vec; overload;
function KDT16DEVec(const v: TKDT16DE_Vec): string; overload;
function KDT16DEPow(const v: TKDT16DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT16DEDistance(const v1, v2: TKDT16DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT16DECmpare(const v1, v2: TKDT16DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT17DEVec(const s: string): TKDT17DE_Vec; overload;
function KDT17DEVec(const v: TKDT17DE_Vec): string; overload;
function KDT17DEPow(const v: TKDT17DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT17DEDistance(const v1, v2: TKDT17DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT17DECmpare(const v1, v2: TKDT17DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT18DEVec(const s: string): TKDT18DE_Vec; overload;
function KDT18DEVec(const v: TKDT18DE_Vec): string; overload;
function KDT18DEPow(const v: TKDT18DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT18DEDistance(const v1, v2: TKDT18DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT18DECmpare(const v1, v2: TKDT18DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT19DEVec(const s: string): TKDT19DE_Vec; overload;
function KDT19DEVec(const v: TKDT19DE_Vec): string; overload;
function KDT19DEPow(const v: TKDT19DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT19DEDistance(const v1, v2: TKDT19DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT19DECmpare(const v1, v2: TKDT19DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT20DEVec(const s: string): TKDT20DE_Vec; overload;
function KDT20DEVec(const v: TKDT20DE_Vec): string; overload;
function KDT20DEPow(const v: TKDT20DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT20DEDistance(const v1, v2: TKDT20DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT20DECmpare(const v1, v2: TKDT20DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT21DEVec(const s: string): TKDT21DE_Vec; overload;
function KDT21DEVec(const v: TKDT21DE_Vec): string; overload;
function KDT21DEPow(const v: TKDT21DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT21DEDistance(const v1, v2: TKDT21DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT21DECmpare(const v1, v2: TKDT21DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT22DEVec(const s: string): TKDT22DE_Vec; overload;
function KDT22DEVec(const v: TKDT22DE_Vec): string; overload;
function KDT22DEPow(const v: TKDT22DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT22DEDistance(const v1, v2: TKDT22DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT22DECmpare(const v1, v2: TKDT22DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT23DEVec(const s: string): TKDT23DE_Vec; overload;
function KDT23DEVec(const v: TKDT23DE_Vec): string; overload;
function KDT23DEPow(const v: TKDT23DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT23DEDistance(const v1, v2: TKDT23DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT23DECmpare(const v1, v2: TKDT23DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT24DEVec(const s: string): TKDT24DE_Vec; overload;
function KDT24DEVec(const v: TKDT24DE_Vec): string; overload;
function KDT24DEPow(const v: TKDT24DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT24DEDistance(const v1, v2: TKDT24DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT24DECmpare(const v1, v2: TKDT24DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT25DEVec(const s: string): TKDT25DE_Vec; overload;
function KDT25DEVec(const v: TKDT25DE_Vec): string; overload;
function KDT25DEPow(const v: TKDT25DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT25DEDistance(const v1, v2: TKDT25DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT25DECmpare(const v1, v2: TKDT25DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT26DEVec(const s: string): TKDT26DE_Vec; overload;
function KDT26DEVec(const v: TKDT26DE_Vec): string; overload;
function KDT26DEPow(const v: TKDT26DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT26DEDistance(const v1, v2: TKDT26DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT26DECmpare(const v1, v2: TKDT26DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT27DEVec(const s: string): TKDT27DE_Vec; overload;
function KDT27DEVec(const v: TKDT27DE_Vec): string; overload;
function KDT27DEPow(const v: TKDT27DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT27DEDistance(const v1, v2: TKDT27DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT27DECmpare(const v1, v2: TKDT27DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT28DEVec(const s: string): TKDT28DE_Vec; overload;
function KDT28DEVec(const v: TKDT28DE_Vec): string; overload;
function KDT28DEPow(const v: TKDT28DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT28DEDistance(const v1, v2: TKDT28DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT28DECmpare(const v1, v2: TKDT28DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT29DEVec(const s: string): TKDT29DE_Vec; overload;
function KDT29DEVec(const v: TKDT29DE_Vec): string; overload;
function KDT29DEPow(const v: TKDT29DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT29DEDistance(const v1, v2: TKDT29DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT29DECmpare(const v1, v2: TKDT29DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT30DEVec(const s: string): TKDT30DE_Vec; overload;
function KDT30DEVec(const v: TKDT30DE_Vec): string; overload;
function KDT30DEPow(const v: TKDT30DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT30DEDistance(const v1, v2: TKDT30DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT30DECmpare(const v1, v2: TKDT30DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT32DEVec(const s: string): TKDT32DE_Vec; overload;
function KDT32DEVec(const v: TKDT32DE_Vec): string; overload;
function KDT32DEPow(const v: TKDT32DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT32DEDistance(const v1, v2: TKDT32DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT32DECmpare(const v1, v2: TKDT32DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT34DEVec(const s: string): TKDT34DE_Vec; overload;
function KDT34DEVec(const v: TKDT34DE_Vec): string; overload;
function KDT34DEPow(const v: TKDT34DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT34DEDistance(const v1, v2: TKDT34DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT34DECmpare(const v1, v2: TKDT34DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT36DEVec(const s: string): TKDT36DE_Vec; overload;
function KDT36DEVec(const v: TKDT36DE_Vec): string; overload;
function KDT36DEPow(const v: TKDT36DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT36DEDistance(const v1, v2: TKDT36DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT36DECmpare(const v1, v2: TKDT36DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT38DEVec(const s: string): TKDT38DE_Vec; overload;
function KDT38DEVec(const v: TKDT38DE_Vec): string; overload;
function KDT38DEPow(const v: TKDT38DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT38DEDistance(const v1, v2: TKDT38DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT38DECmpare(const v1, v2: TKDT38DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT40DEVec(const s: string): TKDT40DE_Vec; overload;
function KDT40DEVec(const v: TKDT40DE_Vec): string; overload;
function KDT40DEPow(const v: TKDT40DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT40DEDistance(const v1, v2: TKDT40DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT40DECmpare(const v1, v2: TKDT40DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT44DEVec(const s: string): TKDT44DE_Vec; overload;
function KDT44DEVec(const v: TKDT44DE_Vec): string; overload;
function KDT44DEPow(const v: TKDT44DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT44DEDistance(const v1, v2: TKDT44DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT44DECmpare(const v1, v2: TKDT44DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT48DEVec(const s: string): TKDT48DE_Vec; overload;
function KDT48DEVec(const v: TKDT48DE_Vec): string; overload;
function KDT48DEPow(const v: TKDT48DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT48DEDistance(const v1, v2: TKDT48DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT48DECmpare(const v1, v2: TKDT48DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT50DEVec(const s: string): TKDT50DE_Vec; overload;
function KDT50DEVec(const v: TKDT50DE_Vec): string; overload;
function KDT50DEPow(const v: TKDT50DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT50DEDistance(const v1, v2: TKDT50DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT50DECmpare(const v1, v2: TKDT50DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT56DEVec(const s: string): TKDT56DE_Vec; overload;
function KDT56DEVec(const v: TKDT56DE_Vec): string; overload;
function KDT56DEPow(const v: TKDT56DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT56DEDistance(const v1, v2: TKDT56DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT56DECmpare(const v1, v2: TKDT56DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT60DEVec(const s: string): TKDT60DE_Vec; overload;
function KDT60DEVec(const v: TKDT60DE_Vec): string; overload;
function KDT60DEPow(const v: TKDT60DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT60DEDistance(const v1, v2: TKDT60DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT60DECmpare(const v1, v2: TKDT60DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT64DEVec(const s: string): TKDT64DE_Vec; overload;
function KDT64DEVec(const v: TKDT64DE_Vec): string; overload;
function KDT64DEPow(const v: TKDT64DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT64DEDistance(const v1, v2: TKDT64DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT64DECmpare(const v1, v2: TKDT64DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT72DEVec(const s: string): TKDT72DE_Vec; overload;
function KDT72DEVec(const v: TKDT72DE_Vec): string; overload;
function KDT72DEPow(const v: TKDT72DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT72DEDistance(const v1, v2: TKDT72DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT72DECmpare(const v1, v2: TKDT72DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT84DEVec(const s: string): TKDT84DE_Vec; overload;
function KDT84DEVec(const v: TKDT84DE_Vec): string; overload;
function KDT84DEPow(const v: TKDT84DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT84DEDistance(const v1, v2: TKDT84DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT84DECmpare(const v1, v2: TKDT84DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT96DEVec(const s: string): TKDT96DE_Vec; overload;
function KDT96DEVec(const v: TKDT96DE_Vec): string; overload;
function KDT96DEPow(const v: TKDT96DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT96DEDistance(const v1, v2: TKDT96DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT96DECmpare(const v1, v2: TKDT96DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT128DEVec(const s: string): TKDT128DE_Vec; overload;
function KDT128DEVec(const v: TKDT128DE_Vec): string; overload;
function KDT128DEPow(const v: TKDT128DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT128DEDistance(const v1, v2: TKDT128DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT128DECmpare(const v1, v2: TKDT128DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT140DEVec(const s: string): TKDT140DE_Vec; overload;
function KDT140DEVec(const v: TKDT140DE_Vec): string; overload;
function KDT140DEPow(const v: TKDT140DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT140DEDistance(const v1, v2: TKDT140DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT140DECmpare(const v1, v2: TKDT140DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT160DEVec(const s: string): TKDT160DE_Vec; overload;
function KDT160DEVec(const v: TKDT160DE_Vec): string; overload;
function KDT160DEPow(const v: TKDT160DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT160DEDistance(const v1, v2: TKDT160DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT160DECmpare(const v1, v2: TKDT160DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT196DEVec(const s: string): TKDT196DE_Vec; overload;
function KDT196DEVec(const v: TKDT196DE_Vec): string; overload;
function KDT196DEPow(const v: TKDT196DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT196DEDistance(const v1, v2: TKDT196DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT196DECmpare(const v1, v2: TKDT196DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT256DEVec(const s: string): TKDT256DE_Vec; overload;
function KDT256DEVec(const v: TKDT256DE_Vec): string; overload;
function KDT256DEPow(const v: TKDT256DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT256DEDistance(const v1, v2: TKDT256DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT256DECmpare(const v1, v2: TKDT256DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT272DEVec(const s: string): TKDT272DE_Vec; overload;
function KDT272DEVec(const v: TKDT272DE_Vec): string; overload;
function KDT272DEPow(const v: TKDT272DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT272DEDistance(const v1, v2: TKDT272DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT272DECmpare(const v1, v2: TKDT272DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT288DEVec(const s: string): TKDT288DE_Vec; overload;
function KDT288DEVec(const v: TKDT288DE_Vec): string; overload;
function KDT288DEPow(const v: TKDT288DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT288DEDistance(const v1, v2: TKDT288DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT288DECmpare(const v1, v2: TKDT288DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT372DEVec(const s: string): TKDT372DE_Vec; overload;
function KDT372DEVec(const v: TKDT372DE_Vec): string; overload;
function KDT372DEPow(const v: TKDT372DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT372DEDistance(const v1, v2: TKDT372DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT372DECmpare(const v1, v2: TKDT372DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT512DEVec(const s: string): TKDT512DE_Vec; overload;
function KDT512DEVec(const v: TKDT512DE_Vec): string; overload;
function KDT512DEPow(const v: TKDT512DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT512DEDistance(const v1, v2: TKDT512DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT512DECmpare(const v1, v2: TKDT512DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT576DEVec(const s: string): TKDT576DE_Vec; overload;
function KDT576DEVec(const v: TKDT576DE_Vec): string; overload;
function KDT576DEPow(const v: TKDT576DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT576DEDistance(const v1, v2: TKDT576DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT576DECmpare(const v1, v2: TKDT576DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT768DEVec(const s: string): TKDT768DE_Vec; overload;
function KDT768DEVec(const v: TKDT768DE_Vec): string; overload;
function KDT768DEPow(const v: TKDT768DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT768DEDistance(const v1, v2: TKDT768DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT768DECmpare(const v1, v2: TKDT768DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1024DEVec(const s: string): TKDT1024DE_Vec; overload;
function KDT1024DEVec(const v: TKDT1024DE_Vec): string; overload;
function KDT1024DEPow(const v: TKDT1024DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1024DEDistance(const v1, v2: TKDT1024DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1024DECmpare(const v1, v2: TKDT1024DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1040DEVec(const s: string): TKDT1040DE_Vec; overload;
function KDT1040DEVec(const v: TKDT1040DE_Vec): string; overload;
function KDT1040DEPow(const v: TKDT1040DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1040DEDistance(const v1, v2: TKDT1040DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1040DECmpare(const v1, v2: TKDT1040DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1056DEVec(const s: string): TKDT1056DE_Vec; overload;
function KDT1056DEVec(const v: TKDT1056DE_Vec): string; overload;
function KDT1056DEPow(const v: TKDT1056DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1056DEDistance(const v1, v2: TKDT1056DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1056DECmpare(const v1, v2: TKDT1056DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1536DEVec(const s: string): TKDT1536DE_Vec; overload;
function KDT1536DEVec(const v: TKDT1536DE_Vec): string; overload;
function KDT1536DEPow(const v: TKDT1536DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1536DEDistance(const v1, v2: TKDT1536DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1536DECmpare(const v1, v2: TKDT1536DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1920DEVec(const s: string): TKDT1920DE_Vec; overload;
function KDT1920DEVec(const v: TKDT1920DE_Vec): string; overload;
function KDT1920DEPow(const v: TKDT1920DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1920DEDistance(const v1, v2: TKDT1920DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1920DECmpare(const v1, v2: TKDT1920DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1980DEVec(const s: string): TKDT1980DE_Vec; overload;
function KDT1980DEVec(const v: TKDT1980DE_Vec): string; overload;
function KDT1980DEPow(const v: TKDT1980DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1980DEDistance(const v1, v2: TKDT1980DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1980DECmpare(const v1, v2: TKDT1980DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT2048DEVec(const s: string): TKDT2048DE_Vec; overload;
function KDT2048DEVec(const v: TKDT2048DE_Vec): string; overload;
function KDT2048DEPow(const v: TKDT2048DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2048DEDistance(const v1, v2: TKDT2048DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2048DECmpare(const v1, v2: TKDT2048DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3072DEVec(const s: string): TKDT3072DE_Vec; overload;
function KDT3072DEVec(const v: TKDT3072DE_Vec): string; overload;
function KDT3072DEPow(const v: TKDT3072DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3072DEDistance(const v1, v2: TKDT3072DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3072DECmpare(const v1, v2: TKDT3072DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3088DEVec(const s: string): TKDT3088DE_Vec; overload;
function KDT3088DEVec(const v: TKDT3088DE_Vec): string; overload;
function KDT3088DEPow(const v: TKDT3088DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3088DEDistance(const v1, v2: TKDT3088DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3088DECmpare(const v1, v2: TKDT3088DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3104DEVec(const s: string): TKDT3104DE_Vec; overload;
function KDT3104DEVec(const v: TKDT3104DE_Vec): string; overload;
function KDT3104DEPow(const v: TKDT3104DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3104DEDistance(const v1, v2: TKDT3104DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3104DECmpare(const v1, v2: TKDT3104DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT4096DEVec(const s: string): TKDT4096DE_Vec; overload;
function KDT4096DEVec(const v: TKDT4096DE_Vec): string; overload;
function KDT4096DEPow(const v: TKDT4096DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4096DEDistance(const v1, v2: TKDT4096DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4096DECmpare(const v1, v2: TKDT4096DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT8192DEVec(const s: string): TKDT8192DE_Vec; overload;
function KDT8192DEVec(const v: TKDT8192DE_Vec): string; overload;
function KDT8192DEPow(const v: TKDT8192DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8192DEDistance(const v1, v2: TKDT8192DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8192DECmpare(const v1, v2: TKDT8192DE_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

{$IFDEF DEBUG}
procedure Test_All;
{$ENDIF}


implementation

uses
  {$IFDEF FPC}
  mtprocs,
  {$ELSE FPC}
  Threading,
  {$ENDIF FPC}
  PascalStrings, TextParsing, UnicodeMixedLib, DoStatusIO;






function KDT1DEVec(const s: string): TKDT1DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1DEVec(const v: TKDT1DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1DEPow(const v: TKDT1DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT1DEDistance(const v1, v2: TKDT1DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1DE_AxisCount - 1 do
      Result := Result + KDT1DEPow(v2[i] - v1[i]);
end;

function KDT1DECmpare(const v1, v2: TKDT1DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1DE_Vec));
end;

function TKDT1DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DE_Node;
  function SortCompare(const p1, p2: PKDT1DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1DE_SourceBuffer;
  dynBuff  : PKDT1DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DE.SearchStoreBuff(const StoreBuffPtr: PKDT1DEyanmicStoreBuffer; const Buff: TKDT1DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1DE.GetData(const index: NativeInt): PKDT1DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DE.StoreBuffPtr: PKDT1DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1DE.BuildKDTreeWithCluster(const inBuff: TKDT1DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DE.BuildKDTreeWithCluster(const inBuff: TKDT1DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DE_BuildCall);
var
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DE_BuildMethod);
var
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DE_BuildProc);
var
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1DE.Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DE_Node;

var
  NearestNeighbour: PKDT1DE_Node;

  function FindParentNode(const BuffPtr: PKDT1DE_Vec; NodePtr: PKDT1DE_Node): PKDT1DE_Node;
  var
    Next       : PKDT1DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DE_Node; const BuffPtr: PKDT1DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1DE_Vec; const p1, p2: PKDT1DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1DE.Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DE.Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double): PKDT1DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DE.Search(const Buff: TKDT1DE_Vec): PKDT1DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1DE.Search(const inBuff: TKDT1DE_DynamicVecBuffer; var OutBuff: TKDT1DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DE_DynamicVecBuffer;
  outBuffPtr : PKDT1DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1DE_Source));
end;

procedure TKDT1DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1DE.PrintNodeTree(const NodePtr: PKDT1DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1DE.Test;
var
  TKDT1DE_Test    : TKDT1DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1DE_Test := TKDT1DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT1DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT1DE_AxisCount - 1 do
        TKDT1DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1DE_Test.TestBuff), length(TKDT1DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1DE_Test.BuildKDTreeM(False, length(TKDT1DE_Test.TestBuff), @TKDT1DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1DE_Test.BuildKDTreeM(False, length(TKDT1DE_Test.TestBuff), TKDT1DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1DE_Test.TestBuff));
  TKDT1DE_Test.Search(TKDT1DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1DEDistance(TKDT1DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1DE_Test.Clear;
  { kMean test }
  TKDT1DE_Test.BuildKDTreeWithCluster(TKDT1DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1DE_Test.Search(TKDT1DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1DE_Test);
end;

{$ENDIF DEBUG}


function KDT2DEVec(const s: string): TKDT2DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT2DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT2DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT2DEVec(const v: TKDT2DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT2DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT2DEPow(const v: TKDT2DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT2DEDistance(const v1, v2: TKDT2DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT2DE_AxisCount - 1 do
      Result := Result + KDT2DEPow(v2[i] - v1[i]);
end;

function KDT2DECmpare(const v1, v2: TKDT2DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT2DE_Vec));
end;

function TKDT2DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DE_Node;
  function SortCompare(const p1, p2: PKDT2DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2DE_SourceBuffer;
  dynBuff  : PKDT2DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT2DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DE.SearchStoreBuff(const StoreBuffPtr: PKDT2DEyanmicStoreBuffer; const Buff: TKDT2DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT2DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT2DE.GetData(const index: NativeInt): PKDT2DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DE.StoreBuffPtr: PKDT2DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2DE.BuildKDTreeWithCluster(const inBuff: TKDT2DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT2DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT2DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT2DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DE.BuildKDTreeWithCluster(const inBuff: TKDT2DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DE_BuildCall);
var
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DE_BuildMethod);
var
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DE_BuildProc);
var
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2DE.Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DE_Node;

var
  NearestNeighbour: PKDT2DE_Node;

  function FindParentNode(const BuffPtr: PKDT2DE_Vec; NodePtr: PKDT2DE_Node): PKDT2DE_Node;
  var
    Next       : PKDT2DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT2DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DE_Node; const BuffPtr: PKDT2DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT2DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2DE_Vec; const p1, p2: PKDT2DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DE_Node(NearestNodes[0]);
    end;
end;

function TKDT2DE.Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DE.Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double): PKDT2DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DE.Search(const Buff: TKDT2DE_Vec): PKDT2DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2DE.Search(const inBuff: TKDT2DE_DynamicVecBuffer; var OutBuff: TKDT2DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DE_DynamicVecBuffer;
  outBuffPtr : PKDT2DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2DE_Source));
end;

procedure TKDT2DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT2DE.PrintNodeTree(const NodePtr: PKDT2DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT2DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT2DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2DE.Test;
var
  TKDT2DE_Test    : TKDT2DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2DE_Test := TKDT2DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT2DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT2DE_AxisCount - 1 do
        TKDT2DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2DE_Test.TestBuff), length(TKDT2DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2DE_Test.BuildKDTreeM(False, length(TKDT2DE_Test.TestBuff), @TKDT2DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2DE_Test.BuildKDTreeM(False, length(TKDT2DE_Test.TestBuff), TKDT2DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2DE_Test.TestBuff));
  TKDT2DE_Test.Search(TKDT2DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2DEDistance(TKDT2DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2DE_Test.Clear;
  { kMean test }
  TKDT2DE_Test.BuildKDTreeWithCluster(TKDT2DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2DE_Test.Search(TKDT2DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2DE_Test);
end;

{$ENDIF DEBUG}


function KDT3DEVec(const s: string): TKDT3DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3DEVec(const v: TKDT3DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT3DEPow(const v: TKDT3DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT3DEDistance(const v1, v2: TKDT3DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3DE_AxisCount - 1 do
      Result := Result + KDT3DEPow(v2[i] - v1[i]);
end;

function KDT3DECmpare(const v1, v2: TKDT3DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3DE_Vec));
end;

function TKDT3DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DE_Node;
  function SortCompare(const p1, p2: PKDT3DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3DE_SourceBuffer;
  dynBuff  : PKDT3DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DE.SearchStoreBuff(const StoreBuffPtr: PKDT3DEyanmicStoreBuffer; const Buff: TKDT3DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3DE.GetData(const index: NativeInt): PKDT3DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DE.StoreBuffPtr: PKDT3DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3DE.BuildKDTreeWithCluster(const inBuff: TKDT3DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DE.BuildKDTreeWithCluster(const inBuff: TKDT3DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DE_BuildCall);
var
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DE_BuildMethod);
var
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DE_BuildProc);
var
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3DE.Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DE_Node;

var
  NearestNeighbour: PKDT3DE_Node;

  function FindParentNode(const BuffPtr: PKDT3DE_Vec; NodePtr: PKDT3DE_Node): PKDT3DE_Node;
  var
    Next       : PKDT3DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DE_Node; const BuffPtr: PKDT3DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3DE_Vec; const p1, p2: PKDT3DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DE_Node(NearestNodes[0]);
    end;
end;

function TKDT3DE.Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DE.Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double): PKDT3DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DE.Search(const Buff: TKDT3DE_Vec): PKDT3DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3DE.Search(const inBuff: TKDT3DE_DynamicVecBuffer; var OutBuff: TKDT3DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DE_DynamicVecBuffer;
  outBuffPtr : PKDT3DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3DE_Source));
end;

procedure TKDT3DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3DE.PrintNodeTree(const NodePtr: PKDT3DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3DE.Test;
var
  TKDT3DE_Test    : TKDT3DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3DE_Test := TKDT3DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT3DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT3DE_AxisCount - 1 do
        TKDT3DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3DE_Test.TestBuff), length(TKDT3DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3DE_Test.BuildKDTreeM(False, length(TKDT3DE_Test.TestBuff), @TKDT3DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3DE_Test.BuildKDTreeM(False, length(TKDT3DE_Test.TestBuff), TKDT3DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3DE_Test.TestBuff));
  TKDT3DE_Test.Search(TKDT3DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3DEDistance(TKDT3DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3DE_Test.Clear;
  { kMean test }
  TKDT3DE_Test.BuildKDTreeWithCluster(TKDT3DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3DE_Test.Search(TKDT3DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3DE_Test);
end;

{$ENDIF DEBUG}


function KDT4DEVec(const s: string): TKDT4DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT4DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT4DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT4DEVec(const v: TKDT4DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT4DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT4DEPow(const v: TKDT4DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT4DEDistance(const v1, v2: TKDT4DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT4DE_AxisCount - 1 do
      Result := Result + KDT4DEPow(v2[i] - v1[i]);
end;

function KDT4DECmpare(const v1, v2: TKDT4DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT4DE_Vec));
end;

function TKDT4DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DE_Node;
  function SortCompare(const p1, p2: PKDT4DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4DE_SourceBuffer;
  dynBuff  : PKDT4DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT4DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DE.SearchStoreBuff(const StoreBuffPtr: PKDT4DEyanmicStoreBuffer; const Buff: TKDT4DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT4DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT4DE.GetData(const index: NativeInt): PKDT4DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DE.StoreBuffPtr: PKDT4DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4DE.BuildKDTreeWithCluster(const inBuff: TKDT4DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT4DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT4DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT4DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DE.BuildKDTreeWithCluster(const inBuff: TKDT4DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DE_BuildCall);
var
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DE_BuildMethod);
var
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DE_BuildProc);
var
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT4DE.Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DE_Node;

var
  NearestNeighbour: PKDT4DE_Node;

  function FindParentNode(const BuffPtr: PKDT4DE_Vec; NodePtr: PKDT4DE_Node): PKDT4DE_Node;
  var
    Next       : PKDT4DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT4DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DE_Node; const BuffPtr: PKDT4DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT4DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4DE_Vec; const p1, p2: PKDT4DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DE_Node(NearestNodes[0]);
    end;
end;

function TKDT4DE.Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DE.Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double): PKDT4DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DE.Search(const Buff: TKDT4DE_Vec): PKDT4DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4DE.Search(const inBuff: TKDT4DE_DynamicVecBuffer; var OutBuff: TKDT4DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DE_DynamicVecBuffer;
  outBuffPtr : PKDT4DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4DE_Source));
end;

procedure TKDT4DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT4DE.PrintNodeTree(const NodePtr: PKDT4DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT4DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT4DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4DE.Test;
var
  TKDT4DE_Test    : TKDT4DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4DE_Test := TKDT4DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT4DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT4DE_AxisCount - 1 do
        TKDT4DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT4DE_Test.TestBuff), length(TKDT4DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4DE_Test.BuildKDTreeM(False, length(TKDT4DE_Test.TestBuff), @TKDT4DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4DE_Test.BuildKDTreeM(False, length(TKDT4DE_Test.TestBuff), TKDT4DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4DE_Test.TestBuff));
  TKDT4DE_Test.Search(TKDT4DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4DEDistance(TKDT4DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4DE_Test.Clear;
  { kMean test }
  TKDT4DE_Test.BuildKDTreeWithCluster(TKDT4DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4DE_Test.Search(TKDT4DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4DE_Test);
end;

{$ENDIF DEBUG}


function KDT5DEVec(const s: string): TKDT5DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT5DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT5DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT5DEVec(const v: TKDT5DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT5DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT5DEPow(const v: TKDT5DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT5DEDistance(const v1, v2: TKDT5DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT5DE_AxisCount - 1 do
      Result := Result + KDT5DEPow(v2[i] - v1[i]);
end;

function KDT5DECmpare(const v1, v2: TKDT5DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT5DE_Vec));
end;

function TKDT5DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DE_Node;
  function SortCompare(const p1, p2: PKDT5DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT5DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT5DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT5DE_SourceBuffer;
  dynBuff  : PKDT5DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT5DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT5DE.SearchStoreBuff(const StoreBuffPtr: PKDT5DEyanmicStoreBuffer; const Buff: TKDT5DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT5DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT5DE.GetData(const index: NativeInt): PKDT5DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT5DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT5DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT5DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT5DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT5DE.StoreBuffPtr: PKDT5DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT5DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT5DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT5DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT5DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT5DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT5DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT5DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT5DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT5DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT5DE.BuildKDTreeWithCluster(const inBuff: TKDT5DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT5DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT5DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT5DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT5DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT5DE.BuildKDTreeWithCluster(const inBuff: TKDT5DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DE_BuildCall);
var
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT5DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT5DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT5DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT5DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DE_BuildMethod);
var
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT5DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT5DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT5DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT5DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DE_BuildProc);
var
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT5DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT5DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT5DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT5DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT5DE.Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DE_Node;

var
  NearestNeighbour: PKDT5DE_Node;

  function FindParentNode(const BuffPtr: PKDT5DE_Vec; NodePtr: PKDT5DE_Node): PKDT5DE_Node;
  var
    Next       : PKDT5DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT5DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT5DE_Node; const BuffPtr: PKDT5DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT5DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT5DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT5DE_Vec; const p1, p2: PKDT5DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT5DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT5DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT5DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT5DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT5DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT5DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT5DE_Node(NearestNodes[0]);
    end;
end;

function TKDT5DE.Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT5DE.Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double): PKDT5DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT5DE.Search(const Buff: TKDT5DE_Vec): PKDT5DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT5DE.Search(const inBuff: TKDT5DE_DynamicVecBuffer; var OutBuff: TKDT5DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT5DE_DynamicVecBuffer;
  outBuffPtr : PKDT5DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT5DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT5DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT5DE_Source));
end;

procedure TKDT5DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT5DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT5DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT5DE.PrintNodeTree(const NodePtr: PKDT5DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT5DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT5DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT5DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT5DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT5DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT5DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT5DE.Test;
var
  TKDT5DE_Test    : TKDT5DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT5DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT5DE_Test := TKDT5DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT5DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT5DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT5DE_AxisCount - 1 do
        TKDT5DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT5DE_Test.TestBuff), length(TKDT5DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT5DE_Test.BuildKDTreeM(False, length(TKDT5DE_Test.TestBuff), @TKDT5DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT5DE_Test.BuildKDTreeM(False, length(TKDT5DE_Test.TestBuff), TKDT5DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT5DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT5DE_Test.TestBuff));
  TKDT5DE_Test.Search(TKDT5DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT5DEDistance(TKDT5DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT5DE_Test.Clear;
  { kMean test }
  TKDT5DE_Test.BuildKDTreeWithCluster(TKDT5DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT5DE_Test.Search(TKDT5DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT5DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT5DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT5DE_Test);
end;

{$ENDIF DEBUG}


function KDT6DEVec(const s: string): TKDT6DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT6DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT6DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT6DEVec(const v: TKDT6DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT6DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT6DEPow(const v: TKDT6DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT6DEDistance(const v1, v2: TKDT6DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT6DE_AxisCount - 1 do
      Result := Result + KDT6DEPow(v2[i] - v1[i]);
end;

function KDT6DECmpare(const v1, v2: TKDT6DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT6DE_Vec));
end;

function TKDT6DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DE_Node;
  function SortCompare(const p1, p2: PKDT6DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT6DE_SourceBuffer;
  dynBuff  : PKDT6DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT6DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DE.SearchStoreBuff(const StoreBuffPtr: PKDT6DEyanmicStoreBuffer; const Buff: TKDT6DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT6DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT6DE.GetData(const index: NativeInt): PKDT6DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT6DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DE.StoreBuffPtr: PKDT6DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT6DE.BuildKDTreeWithCluster(const inBuff: TKDT6DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT6DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT6DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT6DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DE.BuildKDTreeWithCluster(const inBuff: TKDT6DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DE_BuildCall);
var
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DE_BuildMethod);
var
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DE_BuildProc);
var
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT6DE.Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DE_Node;

var
  NearestNeighbour: PKDT6DE_Node;

  function FindParentNode(const BuffPtr: PKDT6DE_Vec; NodePtr: PKDT6DE_Node): PKDT6DE_Node;
  var
    Next       : PKDT6DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT6DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DE_Node; const BuffPtr: PKDT6DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT6DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT6DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT6DE_Vec; const p1, p2: PKDT6DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT6DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT6DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT6DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT6DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT6DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DE_Node(NearestNodes[0]);
    end;
end;

function TKDT6DE.Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DE.Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double): PKDT6DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DE.Search(const Buff: TKDT6DE_Vec): PKDT6DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT6DE.Search(const inBuff: TKDT6DE_DynamicVecBuffer; var OutBuff: TKDT6DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DE_DynamicVecBuffer;
  outBuffPtr : PKDT6DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT6DE_Source));
end;

procedure TKDT6DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT6DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT6DE.PrintNodeTree(const NodePtr: PKDT6DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT6DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT6DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT6DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT6DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT6DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT6DE.Test;
var
  TKDT6DE_Test    : TKDT6DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT6DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT6DE_Test := TKDT6DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT6DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT6DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT6DE_AxisCount - 1 do
        TKDT6DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT6DE_Test.TestBuff), length(TKDT6DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT6DE_Test.BuildKDTreeM(False, length(TKDT6DE_Test.TestBuff), @TKDT6DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT6DE_Test.BuildKDTreeM(False, length(TKDT6DE_Test.TestBuff), TKDT6DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT6DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT6DE_Test.TestBuff));
  TKDT6DE_Test.Search(TKDT6DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT6DEDistance(TKDT6DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT6DE_Test.Clear;
  { kMean test }
  TKDT6DE_Test.BuildKDTreeWithCluster(TKDT6DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT6DE_Test.Search(TKDT6DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT6DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT6DE_Test);
end;

{$ENDIF DEBUG}


function KDT7DEVec(const s: string): TKDT7DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT7DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT7DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT7DEVec(const v: TKDT7DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT7DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT7DEPow(const v: TKDT7DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT7DEDistance(const v1, v2: TKDT7DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT7DE_AxisCount - 1 do
      Result := Result + KDT7DEPow(v2[i] - v1[i]);
end;

function KDT7DECmpare(const v1, v2: TKDT7DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT7DE_Vec));
end;

function TKDT7DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DE_Node;
  function SortCompare(const p1, p2: PKDT7DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT7DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT7DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT7DE_SourceBuffer;
  dynBuff  : PKDT7DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT7DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT7DE.SearchStoreBuff(const StoreBuffPtr: PKDT7DEyanmicStoreBuffer; const Buff: TKDT7DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT7DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT7DE.GetData(const index: NativeInt): PKDT7DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT7DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT7DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT7DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT7DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT7DE.StoreBuffPtr: PKDT7DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT7DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT7DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT7DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT7DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT7DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT7DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT7DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT7DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT7DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT7DE.BuildKDTreeWithCluster(const inBuff: TKDT7DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT7DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT7DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT7DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT7DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT7DE.BuildKDTreeWithCluster(const inBuff: TKDT7DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DE_BuildCall);
var
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT7DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT7DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT7DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT7DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DE_BuildMethod);
var
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT7DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT7DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT7DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT7DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DE_BuildProc);
var
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT7DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT7DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT7DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT7DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT7DE.Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DE_Node;

var
  NearestNeighbour: PKDT7DE_Node;

  function FindParentNode(const BuffPtr: PKDT7DE_Vec; NodePtr: PKDT7DE_Node): PKDT7DE_Node;
  var
    Next       : PKDT7DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT7DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT7DE_Node; const BuffPtr: PKDT7DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT7DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT7DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT7DE_Vec; const p1, p2: PKDT7DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT7DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT7DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT7DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT7DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT7DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT7DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT7DE_Node(NearestNodes[0]);
    end;
end;

function TKDT7DE.Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT7DE.Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double): PKDT7DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT7DE.Search(const Buff: TKDT7DE_Vec): PKDT7DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT7DE.Search(const inBuff: TKDT7DE_DynamicVecBuffer; var OutBuff: TKDT7DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT7DE_DynamicVecBuffer;
  outBuffPtr : PKDT7DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT7DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT7DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT7DE_Source));
end;

procedure TKDT7DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT7DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT7DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT7DE.PrintNodeTree(const NodePtr: PKDT7DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT7DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT7DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT7DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT7DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT7DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT7DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT7DE.Test;
var
  TKDT7DE_Test    : TKDT7DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT7DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT7DE_Test := TKDT7DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT7DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT7DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT7DE_AxisCount - 1 do
        TKDT7DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT7DE_Test.TestBuff), length(TKDT7DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT7DE_Test.BuildKDTreeM(False, length(TKDT7DE_Test.TestBuff), @TKDT7DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT7DE_Test.BuildKDTreeM(False, length(TKDT7DE_Test.TestBuff), TKDT7DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT7DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT7DE_Test.TestBuff));
  TKDT7DE_Test.Search(TKDT7DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT7DEDistance(TKDT7DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT7DE_Test.Clear;
  { kMean test }
  TKDT7DE_Test.BuildKDTreeWithCluster(TKDT7DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT7DE_Test.Search(TKDT7DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT7DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT7DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT7DE_Test);
end;

{$ENDIF DEBUG}


function KDT8DEVec(const s: string): TKDT8DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT8DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT8DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT8DEVec(const v: TKDT8DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT8DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT8DEPow(const v: TKDT8DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT8DEDistance(const v1, v2: TKDT8DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT8DE_AxisCount - 1 do
      Result := Result + KDT8DEPow(v2[i] - v1[i]);
end;

function KDT8DECmpare(const v1, v2: TKDT8DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT8DE_Vec));
end;

function TKDT8DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DE_Node;
  function SortCompare(const p1, p2: PKDT8DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8DE_SourceBuffer;
  dynBuff  : PKDT8DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT8DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DE.SearchStoreBuff(const StoreBuffPtr: PKDT8DEyanmicStoreBuffer; const Buff: TKDT8DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT8DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT8DE.GetData(const index: NativeInt): PKDT8DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DE.StoreBuffPtr: PKDT8DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8DE.BuildKDTreeWithCluster(const inBuff: TKDT8DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT8DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT8DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT8DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DE.BuildKDTreeWithCluster(const inBuff: TKDT8DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DE_BuildCall);
var
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DE_BuildMethod);
var
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DE_BuildProc);
var
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT8DE.Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DE_Node;

var
  NearestNeighbour: PKDT8DE_Node;

  function FindParentNode(const BuffPtr: PKDT8DE_Vec; NodePtr: PKDT8DE_Node): PKDT8DE_Node;
  var
    Next       : PKDT8DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT8DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DE_Node; const BuffPtr: PKDT8DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT8DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8DE_Vec; const p1, p2: PKDT8DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DE_Node(NearestNodes[0]);
    end;
end;

function TKDT8DE.Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DE.Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double): PKDT8DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DE.Search(const Buff: TKDT8DE_Vec): PKDT8DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8DE.Search(const inBuff: TKDT8DE_DynamicVecBuffer; var OutBuff: TKDT8DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DE_DynamicVecBuffer;
  outBuffPtr : PKDT8DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8DE_Source));
end;

procedure TKDT8DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT8DE.PrintNodeTree(const NodePtr: PKDT8DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT8DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT8DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8DE.Test;
var
  TKDT8DE_Test    : TKDT8DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8DE_Test := TKDT8DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT8DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT8DE_AxisCount - 1 do
        TKDT8DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT8DE_Test.TestBuff), length(TKDT8DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8DE_Test.BuildKDTreeM(False, length(TKDT8DE_Test.TestBuff), @TKDT8DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8DE_Test.BuildKDTreeM(False, length(TKDT8DE_Test.TestBuff), TKDT8DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8DE_Test.TestBuff));
  TKDT8DE_Test.Search(TKDT8DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8DEDistance(TKDT8DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8DE_Test.Clear;
  { kMean test }
  TKDT8DE_Test.BuildKDTreeWithCluster(TKDT8DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8DE_Test.Search(TKDT8DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8DE_Test);
end;

{$ENDIF DEBUG}


function KDT9DEVec(const s: string): TKDT9DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT9DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT9DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT9DEVec(const v: TKDT9DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT9DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT9DEPow(const v: TKDT9DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT9DEDistance(const v1, v2: TKDT9DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT9DE_AxisCount - 1 do
      Result := Result + KDT9DEPow(v2[i] - v1[i]);
end;

function KDT9DECmpare(const v1, v2: TKDT9DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT9DE_Vec));
end;

function TKDT9DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DE_Node;
  function SortCompare(const p1, p2: PKDT9DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT9DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT9DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT9DE_SourceBuffer;
  dynBuff  : PKDT9DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT9DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT9DE.SearchStoreBuff(const StoreBuffPtr: PKDT9DEyanmicStoreBuffer; const Buff: TKDT9DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT9DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT9DE.GetData(const index: NativeInt): PKDT9DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT9DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT9DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT9DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT9DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT9DE.StoreBuffPtr: PKDT9DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT9DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT9DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT9DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT9DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT9DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT9DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT9DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT9DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT9DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT9DE.BuildKDTreeWithCluster(const inBuff: TKDT9DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT9DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT9DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT9DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT9DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT9DE.BuildKDTreeWithCluster(const inBuff: TKDT9DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DE_BuildCall);
var
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT9DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT9DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT9DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT9DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DE_BuildMethod);
var
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT9DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT9DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT9DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT9DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DE_BuildProc);
var
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT9DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT9DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT9DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT9DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT9DE.Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DE_Node;

var
  NearestNeighbour: PKDT9DE_Node;

  function FindParentNode(const BuffPtr: PKDT9DE_Vec; NodePtr: PKDT9DE_Node): PKDT9DE_Node;
  var
    Next       : PKDT9DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT9DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT9DE_Node; const BuffPtr: PKDT9DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT9DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT9DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT9DE_Vec; const p1, p2: PKDT9DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT9DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT9DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT9DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT9DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT9DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT9DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT9DE_Node(NearestNodes[0]);
    end;
end;

function TKDT9DE.Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT9DE.Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double): PKDT9DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT9DE.Search(const Buff: TKDT9DE_Vec): PKDT9DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT9DE.Search(const inBuff: TKDT9DE_DynamicVecBuffer; var OutBuff: TKDT9DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT9DE_DynamicVecBuffer;
  outBuffPtr : PKDT9DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT9DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT9DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT9DE_Source));
end;

procedure TKDT9DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT9DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT9DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT9DE.PrintNodeTree(const NodePtr: PKDT9DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT9DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT9DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT9DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT9DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT9DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT9DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT9DE.Test;
var
  TKDT9DE_Test    : TKDT9DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT9DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT9DE_Test := TKDT9DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT9DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT9DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT9DE_AxisCount - 1 do
        TKDT9DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT9DE_Test.TestBuff), length(TKDT9DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT9DE_Test.BuildKDTreeM(False, length(TKDT9DE_Test.TestBuff), @TKDT9DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT9DE_Test.BuildKDTreeM(False, length(TKDT9DE_Test.TestBuff), TKDT9DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT9DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT9DE_Test.TestBuff));
  TKDT9DE_Test.Search(TKDT9DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT9DEDistance(TKDT9DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT9DE_Test.Clear;
  { kMean test }
  TKDT9DE_Test.BuildKDTreeWithCluster(TKDT9DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT9DE_Test.Search(TKDT9DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT9DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT9DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT9DE_Test);
end;

{$ENDIF DEBUG}


function KDT10DEVec(const s: string): TKDT10DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT10DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT10DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT10DEVec(const v: TKDT10DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT10DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT10DEPow(const v: TKDT10DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT10DEDistance(const v1, v2: TKDT10DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT10DE_AxisCount - 1 do
      Result := Result + KDT10DEPow(v2[i] - v1[i]);
end;

function KDT10DECmpare(const v1, v2: TKDT10DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT10DE_Vec));
end;

function TKDT10DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DE_Node;
  function SortCompare(const p1, p2: PKDT10DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT10DE_SourceBuffer;
  dynBuff  : PKDT10DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT10DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DE.SearchStoreBuff(const StoreBuffPtr: PKDT10DEyanmicStoreBuffer; const Buff: TKDT10DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT10DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT10DE.GetData(const index: NativeInt): PKDT10DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT10DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DE.StoreBuffPtr: PKDT10DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT10DE.BuildKDTreeWithCluster(const inBuff: TKDT10DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT10DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT10DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT10DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DE.BuildKDTreeWithCluster(const inBuff: TKDT10DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DE_BuildCall);
var
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DE_BuildMethod);
var
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DE_BuildProc);
var
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT10DE.Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DE_Node;

var
  NearestNeighbour: PKDT10DE_Node;

  function FindParentNode(const BuffPtr: PKDT10DE_Vec; NodePtr: PKDT10DE_Node): PKDT10DE_Node;
  var
    Next       : PKDT10DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT10DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DE_Node; const BuffPtr: PKDT10DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT10DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT10DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT10DE_Vec; const p1, p2: PKDT10DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT10DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT10DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT10DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT10DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT10DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DE_Node(NearestNodes[0]);
    end;
end;

function TKDT10DE.Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DE.Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double): PKDT10DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DE.Search(const Buff: TKDT10DE_Vec): PKDT10DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT10DE.Search(const inBuff: TKDT10DE_DynamicVecBuffer; var OutBuff: TKDT10DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DE_DynamicVecBuffer;
  outBuffPtr : PKDT10DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT10DE_Source));
end;

procedure TKDT10DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT10DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT10DE.PrintNodeTree(const NodePtr: PKDT10DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT10DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT10DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT10DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT10DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT10DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT10DE.Test;
var
  TKDT10DE_Test    : TKDT10DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT10DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT10DE_Test := TKDT10DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT10DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT10DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT10DE_AxisCount - 1 do
        TKDT10DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT10DE_Test.TestBuff), length(TKDT10DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT10DE_Test.BuildKDTreeM(False, length(TKDT10DE_Test.TestBuff), @TKDT10DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT10DE_Test.BuildKDTreeM(False, length(TKDT10DE_Test.TestBuff), TKDT10DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT10DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT10DE_Test.TestBuff));
  TKDT10DE_Test.Search(TKDT10DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT10DEDistance(TKDT10DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT10DE_Test.Clear;
  { kMean test }
  TKDT10DE_Test.BuildKDTreeWithCluster(TKDT10DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT10DE_Test.Search(TKDT10DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT10DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT10DE_Test);
end;

{$ENDIF DEBUG}


function KDT11DEVec(const s: string): TKDT11DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT11DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT11DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT11DEVec(const v: TKDT11DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT11DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT11DEPow(const v: TKDT11DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT11DEDistance(const v1, v2: TKDT11DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT11DE_AxisCount - 1 do
      Result := Result + KDT11DEPow(v2[i] - v1[i]);
end;

function KDT11DECmpare(const v1, v2: TKDT11DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT11DE_Vec));
end;

function TKDT11DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DE_Node;
  function SortCompare(const p1, p2: PKDT11DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT11DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT11DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT11DE_SourceBuffer;
  dynBuff  : PKDT11DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT11DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT11DE.SearchStoreBuff(const StoreBuffPtr: PKDT11DEyanmicStoreBuffer; const Buff: TKDT11DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT11DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT11DE.GetData(const index: NativeInt): PKDT11DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT11DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT11DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT11DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT11DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT11DE.StoreBuffPtr: PKDT11DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT11DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT11DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT11DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT11DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT11DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT11DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT11DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT11DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT11DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT11DE.BuildKDTreeWithCluster(const inBuff: TKDT11DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT11DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT11DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT11DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT11DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT11DE.BuildKDTreeWithCluster(const inBuff: TKDT11DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DE_BuildCall);
var
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT11DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT11DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT11DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT11DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DE_BuildMethod);
var
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT11DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT11DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT11DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT11DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DE_BuildProc);
var
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT11DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT11DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT11DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT11DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT11DE.Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DE_Node;

var
  NearestNeighbour: PKDT11DE_Node;

  function FindParentNode(const BuffPtr: PKDT11DE_Vec; NodePtr: PKDT11DE_Node): PKDT11DE_Node;
  var
    Next       : PKDT11DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT11DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT11DE_Node; const BuffPtr: PKDT11DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT11DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT11DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT11DE_Vec; const p1, p2: PKDT11DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT11DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT11DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT11DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT11DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT11DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT11DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT11DE_Node(NearestNodes[0]);
    end;
end;

function TKDT11DE.Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT11DE.Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double): PKDT11DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT11DE.Search(const Buff: TKDT11DE_Vec): PKDT11DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT11DE.Search(const inBuff: TKDT11DE_DynamicVecBuffer; var OutBuff: TKDT11DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT11DE_DynamicVecBuffer;
  outBuffPtr : PKDT11DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT11DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT11DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT11DE_Source));
end;

procedure TKDT11DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT11DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT11DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT11DE.PrintNodeTree(const NodePtr: PKDT11DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT11DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT11DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT11DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT11DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT11DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT11DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT11DE.Test;
var
  TKDT11DE_Test    : TKDT11DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT11DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT11DE_Test := TKDT11DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT11DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT11DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT11DE_AxisCount - 1 do
        TKDT11DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT11DE_Test.TestBuff), length(TKDT11DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT11DE_Test.BuildKDTreeM(False, length(TKDT11DE_Test.TestBuff), @TKDT11DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT11DE_Test.BuildKDTreeM(False, length(TKDT11DE_Test.TestBuff), TKDT11DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT11DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT11DE_Test.TestBuff));
  TKDT11DE_Test.Search(TKDT11DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT11DEDistance(TKDT11DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT11DE_Test.Clear;
  { kMean test }
  TKDT11DE_Test.BuildKDTreeWithCluster(TKDT11DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT11DE_Test.Search(TKDT11DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT11DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT11DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT11DE_Test);
end;

{$ENDIF DEBUG}


function KDT12DEVec(const s: string): TKDT12DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT12DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT12DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT12DEVec(const v: TKDT12DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT12DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT12DEPow(const v: TKDT12DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT12DEDistance(const v1, v2: TKDT12DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT12DE_AxisCount - 1 do
      Result := Result + KDT12DEPow(v2[i] - v1[i]);
end;

function KDT12DECmpare(const v1, v2: TKDT12DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT12DE_Vec));
end;

function TKDT12DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DE_Node;
  function SortCompare(const p1, p2: PKDT12DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT12DE_SourceBuffer;
  dynBuff  : PKDT12DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT12DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DE.SearchStoreBuff(const StoreBuffPtr: PKDT12DEyanmicStoreBuffer; const Buff: TKDT12DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT12DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT12DE.GetData(const index: NativeInt): PKDT12DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT12DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DE.StoreBuffPtr: PKDT12DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT12DE.BuildKDTreeWithCluster(const inBuff: TKDT12DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT12DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT12DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT12DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DE.BuildKDTreeWithCluster(const inBuff: TKDT12DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DE_BuildCall);
var
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DE_BuildMethod);
var
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DE_BuildProc);
var
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT12DE.Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DE_Node;

var
  NearestNeighbour: PKDT12DE_Node;

  function FindParentNode(const BuffPtr: PKDT12DE_Vec; NodePtr: PKDT12DE_Node): PKDT12DE_Node;
  var
    Next       : PKDT12DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT12DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DE_Node; const BuffPtr: PKDT12DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT12DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT12DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT12DE_Vec; const p1, p2: PKDT12DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT12DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT12DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT12DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT12DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT12DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DE_Node(NearestNodes[0]);
    end;
end;

function TKDT12DE.Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DE.Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double): PKDT12DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DE.Search(const Buff: TKDT12DE_Vec): PKDT12DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT12DE.Search(const inBuff: TKDT12DE_DynamicVecBuffer; var OutBuff: TKDT12DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DE_DynamicVecBuffer;
  outBuffPtr : PKDT12DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT12DE_Source));
end;

procedure TKDT12DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT12DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT12DE.PrintNodeTree(const NodePtr: PKDT12DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT12DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT12DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT12DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT12DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT12DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT12DE.Test;
var
  TKDT12DE_Test    : TKDT12DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT12DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT12DE_Test := TKDT12DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT12DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT12DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT12DE_AxisCount - 1 do
        TKDT12DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT12DE_Test.TestBuff), length(TKDT12DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT12DE_Test.BuildKDTreeM(False, length(TKDT12DE_Test.TestBuff), @TKDT12DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT12DE_Test.BuildKDTreeM(False, length(TKDT12DE_Test.TestBuff), TKDT12DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT12DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT12DE_Test.TestBuff));
  TKDT12DE_Test.Search(TKDT12DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT12DEDistance(TKDT12DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT12DE_Test.Clear;
  { kMean test }
  TKDT12DE_Test.BuildKDTreeWithCluster(TKDT12DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT12DE_Test.Search(TKDT12DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT12DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT12DE_Test);
end;

{$ENDIF DEBUG}


function KDT13DEVec(const s: string): TKDT13DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT13DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT13DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT13DEVec(const v: TKDT13DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT13DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT13DEPow(const v: TKDT13DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT13DEDistance(const v1, v2: TKDT13DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT13DE_AxisCount - 1 do
      Result := Result + KDT13DEPow(v2[i] - v1[i]);
end;

function KDT13DECmpare(const v1, v2: TKDT13DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT13DE_Vec));
end;

function TKDT13DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DE_Node;
  function SortCompare(const p1, p2: PKDT13DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT13DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT13DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT13DE_SourceBuffer;
  dynBuff  : PKDT13DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT13DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT13DE.SearchStoreBuff(const StoreBuffPtr: PKDT13DEyanmicStoreBuffer; const Buff: TKDT13DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT13DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT13DE.GetData(const index: NativeInt): PKDT13DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT13DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT13DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT13DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT13DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT13DE.StoreBuffPtr: PKDT13DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT13DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT13DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT13DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT13DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT13DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT13DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT13DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT13DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT13DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT13DE.BuildKDTreeWithCluster(const inBuff: TKDT13DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT13DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT13DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT13DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT13DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT13DE.BuildKDTreeWithCluster(const inBuff: TKDT13DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DE_BuildCall);
var
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT13DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT13DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT13DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT13DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DE_BuildMethod);
var
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT13DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT13DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT13DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT13DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DE_BuildProc);
var
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT13DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT13DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT13DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT13DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT13DE.Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DE_Node;

var
  NearestNeighbour: PKDT13DE_Node;

  function FindParentNode(const BuffPtr: PKDT13DE_Vec; NodePtr: PKDT13DE_Node): PKDT13DE_Node;
  var
    Next       : PKDT13DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT13DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT13DE_Node; const BuffPtr: PKDT13DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT13DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT13DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT13DE_Vec; const p1, p2: PKDT13DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT13DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT13DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT13DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT13DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT13DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT13DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT13DE_Node(NearestNodes[0]);
    end;
end;

function TKDT13DE.Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT13DE.Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double): PKDT13DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT13DE.Search(const Buff: TKDT13DE_Vec): PKDT13DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT13DE.Search(const inBuff: TKDT13DE_DynamicVecBuffer; var OutBuff: TKDT13DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT13DE_DynamicVecBuffer;
  outBuffPtr : PKDT13DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT13DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT13DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT13DE_Source));
end;

procedure TKDT13DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT13DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT13DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT13DE.PrintNodeTree(const NodePtr: PKDT13DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT13DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT13DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT13DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT13DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT13DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT13DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT13DE.Test;
var
  TKDT13DE_Test    : TKDT13DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT13DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT13DE_Test := TKDT13DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT13DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT13DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT13DE_AxisCount - 1 do
        TKDT13DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT13DE_Test.TestBuff), length(TKDT13DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT13DE_Test.BuildKDTreeM(False, length(TKDT13DE_Test.TestBuff), @TKDT13DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT13DE_Test.BuildKDTreeM(False, length(TKDT13DE_Test.TestBuff), TKDT13DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT13DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT13DE_Test.TestBuff));
  TKDT13DE_Test.Search(TKDT13DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT13DEDistance(TKDT13DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT13DE_Test.Clear;
  { kMean test }
  TKDT13DE_Test.BuildKDTreeWithCluster(TKDT13DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT13DE_Test.Search(TKDT13DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT13DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT13DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT13DE_Test);
end;

{$ENDIF DEBUG}


function KDT14DEVec(const s: string): TKDT14DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT14DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT14DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT14DEVec(const v: TKDT14DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT14DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT14DEPow(const v: TKDT14DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT14DEDistance(const v1, v2: TKDT14DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT14DE_AxisCount - 1 do
      Result := Result + KDT14DEPow(v2[i] - v1[i]);
end;

function KDT14DECmpare(const v1, v2: TKDT14DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT14DE_Vec));
end;

function TKDT14DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DE_Node;
  function SortCompare(const p1, p2: PKDT14DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT14DE_SourceBuffer;
  dynBuff  : PKDT14DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT14DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DE.SearchStoreBuff(const StoreBuffPtr: PKDT14DEyanmicStoreBuffer; const Buff: TKDT14DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT14DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT14DE.GetData(const index: NativeInt): PKDT14DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT14DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DE.StoreBuffPtr: PKDT14DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT14DE.BuildKDTreeWithCluster(const inBuff: TKDT14DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT14DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT14DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT14DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DE.BuildKDTreeWithCluster(const inBuff: TKDT14DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DE_BuildCall);
var
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DE_BuildMethod);
var
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DE_BuildProc);
var
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT14DE.Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DE_Node;

var
  NearestNeighbour: PKDT14DE_Node;

  function FindParentNode(const BuffPtr: PKDT14DE_Vec; NodePtr: PKDT14DE_Node): PKDT14DE_Node;
  var
    Next       : PKDT14DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT14DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DE_Node; const BuffPtr: PKDT14DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT14DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT14DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT14DE_Vec; const p1, p2: PKDT14DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT14DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT14DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT14DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT14DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT14DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DE_Node(NearestNodes[0]);
    end;
end;

function TKDT14DE.Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DE.Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double): PKDT14DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DE.Search(const Buff: TKDT14DE_Vec): PKDT14DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT14DE.Search(const inBuff: TKDT14DE_DynamicVecBuffer; var OutBuff: TKDT14DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DE_DynamicVecBuffer;
  outBuffPtr : PKDT14DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT14DE_Source));
end;

procedure TKDT14DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT14DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT14DE.PrintNodeTree(const NodePtr: PKDT14DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT14DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT14DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT14DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT14DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT14DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT14DE.Test;
var
  TKDT14DE_Test    : TKDT14DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT14DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT14DE_Test := TKDT14DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT14DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT14DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT14DE_AxisCount - 1 do
        TKDT14DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT14DE_Test.TestBuff), length(TKDT14DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT14DE_Test.BuildKDTreeM(False, length(TKDT14DE_Test.TestBuff), @TKDT14DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT14DE_Test.BuildKDTreeM(False, length(TKDT14DE_Test.TestBuff), TKDT14DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT14DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT14DE_Test.TestBuff));
  TKDT14DE_Test.Search(TKDT14DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT14DEDistance(TKDT14DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT14DE_Test.Clear;
  { kMean test }
  TKDT14DE_Test.BuildKDTreeWithCluster(TKDT14DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT14DE_Test.Search(TKDT14DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT14DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT14DE_Test);
end;

{$ENDIF DEBUG}


function KDT15DEVec(const s: string): TKDT15DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT15DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT15DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT15DEVec(const v: TKDT15DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT15DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT15DEPow(const v: TKDT15DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT15DEDistance(const v1, v2: TKDT15DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT15DE_AxisCount - 1 do
      Result := Result + KDT15DEPow(v2[i] - v1[i]);
end;

function KDT15DECmpare(const v1, v2: TKDT15DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT15DE_Vec));
end;

function TKDT15DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DE_Node;
  function SortCompare(const p1, p2: PKDT15DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT15DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT15DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT15DE_SourceBuffer;
  dynBuff  : PKDT15DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT15DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT15DE.SearchStoreBuff(const StoreBuffPtr: PKDT15DEyanmicStoreBuffer; const Buff: TKDT15DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT15DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT15DE.GetData(const index: NativeInt): PKDT15DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT15DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT15DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT15DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT15DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT15DE.StoreBuffPtr: PKDT15DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT15DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT15DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT15DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT15DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT15DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT15DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT15DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT15DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT15DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT15DE.BuildKDTreeWithCluster(const inBuff: TKDT15DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT15DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT15DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT15DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT15DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT15DE.BuildKDTreeWithCluster(const inBuff: TKDT15DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DE_BuildCall);
var
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT15DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT15DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT15DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT15DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DE_BuildMethod);
var
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT15DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT15DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT15DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT15DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DE_BuildProc);
var
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT15DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT15DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT15DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT15DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT15DE.Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DE_Node;

var
  NearestNeighbour: PKDT15DE_Node;

  function FindParentNode(const BuffPtr: PKDT15DE_Vec; NodePtr: PKDT15DE_Node): PKDT15DE_Node;
  var
    Next       : PKDT15DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT15DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT15DE_Node; const BuffPtr: PKDT15DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT15DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT15DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT15DE_Vec; const p1, p2: PKDT15DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT15DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT15DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT15DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT15DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT15DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT15DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT15DE_Node(NearestNodes[0]);
    end;
end;

function TKDT15DE.Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT15DE.Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double): PKDT15DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT15DE.Search(const Buff: TKDT15DE_Vec): PKDT15DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT15DE.Search(const inBuff: TKDT15DE_DynamicVecBuffer; var OutBuff: TKDT15DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT15DE_DynamicVecBuffer;
  outBuffPtr : PKDT15DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT15DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT15DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT15DE_Source));
end;

procedure TKDT15DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT15DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT15DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT15DE.PrintNodeTree(const NodePtr: PKDT15DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT15DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT15DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT15DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT15DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT15DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT15DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT15DE.Test;
var
  TKDT15DE_Test    : TKDT15DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT15DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT15DE_Test := TKDT15DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT15DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT15DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT15DE_AxisCount - 1 do
        TKDT15DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT15DE_Test.TestBuff), length(TKDT15DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT15DE_Test.BuildKDTreeM(False, length(TKDT15DE_Test.TestBuff), @TKDT15DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT15DE_Test.BuildKDTreeM(False, length(TKDT15DE_Test.TestBuff), TKDT15DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT15DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT15DE_Test.TestBuff));
  TKDT15DE_Test.Search(TKDT15DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT15DEDistance(TKDT15DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT15DE_Test.Clear;
  { kMean test }
  TKDT15DE_Test.BuildKDTreeWithCluster(TKDT15DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT15DE_Test.Search(TKDT15DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT15DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT15DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT15DE_Test);
end;

{$ENDIF DEBUG}


function KDT16DEVec(const s: string): TKDT16DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT16DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT16DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT16DEVec(const v: TKDT16DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT16DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT16DEPow(const v: TKDT16DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT16DEDistance(const v1, v2: TKDT16DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT16DE_AxisCount - 1 do
      Result := Result + KDT16DEPow(v2[i] - v1[i]);
end;

function KDT16DECmpare(const v1, v2: TKDT16DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT16DE_Vec));
end;

function TKDT16DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DE_Node;
  function SortCompare(const p1, p2: PKDT16DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT16DE_SourceBuffer;
  dynBuff  : PKDT16DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT16DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DE.SearchStoreBuff(const StoreBuffPtr: PKDT16DEyanmicStoreBuffer; const Buff: TKDT16DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT16DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT16DE.GetData(const index: NativeInt): PKDT16DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT16DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DE.StoreBuffPtr: PKDT16DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT16DE.BuildKDTreeWithCluster(const inBuff: TKDT16DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT16DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT16DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT16DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DE.BuildKDTreeWithCluster(const inBuff: TKDT16DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DE_BuildCall);
var
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DE_BuildMethod);
var
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DE_BuildProc);
var
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT16DE.Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DE_Node;

var
  NearestNeighbour: PKDT16DE_Node;

  function FindParentNode(const BuffPtr: PKDT16DE_Vec; NodePtr: PKDT16DE_Node): PKDT16DE_Node;
  var
    Next       : PKDT16DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT16DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DE_Node; const BuffPtr: PKDT16DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT16DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT16DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT16DE_Vec; const p1, p2: PKDT16DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT16DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT16DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT16DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT16DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT16DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DE_Node(NearestNodes[0]);
    end;
end;

function TKDT16DE.Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DE.Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double): PKDT16DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DE.Search(const Buff: TKDT16DE_Vec): PKDT16DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT16DE.Search(const inBuff: TKDT16DE_DynamicVecBuffer; var OutBuff: TKDT16DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DE_DynamicVecBuffer;
  outBuffPtr : PKDT16DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT16DE_Source));
end;

procedure TKDT16DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT16DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT16DE.PrintNodeTree(const NodePtr: PKDT16DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT16DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT16DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT16DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT16DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT16DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT16DE.Test;
var
  TKDT16DE_Test    : TKDT16DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT16DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT16DE_Test := TKDT16DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT16DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT16DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT16DE_AxisCount - 1 do
        TKDT16DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT16DE_Test.TestBuff), length(TKDT16DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT16DE_Test.BuildKDTreeM(False, length(TKDT16DE_Test.TestBuff), @TKDT16DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT16DE_Test.BuildKDTreeM(False, length(TKDT16DE_Test.TestBuff), TKDT16DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT16DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT16DE_Test.TestBuff));
  TKDT16DE_Test.Search(TKDT16DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT16DEDistance(TKDT16DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT16DE_Test.Clear;
  { kMean test }
  TKDT16DE_Test.BuildKDTreeWithCluster(TKDT16DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT16DE_Test.Search(TKDT16DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT16DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT16DE_Test);
end;

{$ENDIF DEBUG}


function KDT17DEVec(const s: string): TKDT17DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT17DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT17DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT17DEVec(const v: TKDT17DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT17DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT17DEPow(const v: TKDT17DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT17DEDistance(const v1, v2: TKDT17DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT17DE_AxisCount - 1 do
      Result := Result + KDT17DEPow(v2[i] - v1[i]);
end;

function KDT17DECmpare(const v1, v2: TKDT17DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT17DE_Vec));
end;

function TKDT17DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DE_Node;
  function SortCompare(const p1, p2: PKDT17DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT17DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT17DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT17DE_SourceBuffer;
  dynBuff  : PKDT17DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT17DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT17DE.SearchStoreBuff(const StoreBuffPtr: PKDT17DEyanmicStoreBuffer; const Buff: TKDT17DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT17DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT17DE.GetData(const index: NativeInt): PKDT17DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT17DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT17DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT17DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT17DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT17DE.StoreBuffPtr: PKDT17DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT17DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT17DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT17DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT17DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT17DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT17DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT17DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT17DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT17DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT17DE.BuildKDTreeWithCluster(const inBuff: TKDT17DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT17DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT17DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT17DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT17DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT17DE.BuildKDTreeWithCluster(const inBuff: TKDT17DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DE_BuildCall);
var
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT17DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT17DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT17DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT17DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DE_BuildMethod);
var
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT17DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT17DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT17DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT17DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DE_BuildProc);
var
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT17DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT17DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT17DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT17DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT17DE.Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DE_Node;

var
  NearestNeighbour: PKDT17DE_Node;

  function FindParentNode(const BuffPtr: PKDT17DE_Vec; NodePtr: PKDT17DE_Node): PKDT17DE_Node;
  var
    Next       : PKDT17DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT17DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT17DE_Node; const BuffPtr: PKDT17DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT17DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT17DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT17DE_Vec; const p1, p2: PKDT17DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT17DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT17DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT17DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT17DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT17DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT17DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT17DE_Node(NearestNodes[0]);
    end;
end;

function TKDT17DE.Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT17DE.Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double): PKDT17DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT17DE.Search(const Buff: TKDT17DE_Vec): PKDT17DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT17DE.Search(const inBuff: TKDT17DE_DynamicVecBuffer; var OutBuff: TKDT17DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT17DE_DynamicVecBuffer;
  outBuffPtr : PKDT17DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT17DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT17DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT17DE_Source));
end;

procedure TKDT17DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT17DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT17DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT17DE.PrintNodeTree(const NodePtr: PKDT17DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT17DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT17DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT17DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT17DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT17DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT17DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT17DE.Test;
var
  TKDT17DE_Test    : TKDT17DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT17DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT17DE_Test := TKDT17DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT17DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT17DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT17DE_AxisCount - 1 do
        TKDT17DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT17DE_Test.TestBuff), length(TKDT17DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT17DE_Test.BuildKDTreeM(False, length(TKDT17DE_Test.TestBuff), @TKDT17DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT17DE_Test.BuildKDTreeM(False, length(TKDT17DE_Test.TestBuff), TKDT17DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT17DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT17DE_Test.TestBuff));
  TKDT17DE_Test.Search(TKDT17DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT17DEDistance(TKDT17DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT17DE_Test.Clear;
  { kMean test }
  TKDT17DE_Test.BuildKDTreeWithCluster(TKDT17DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT17DE_Test.Search(TKDT17DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT17DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT17DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT17DE_Test);
end;

{$ENDIF DEBUG}


function KDT18DEVec(const s: string): TKDT18DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT18DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT18DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT18DEVec(const v: TKDT18DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT18DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT18DEPow(const v: TKDT18DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT18DEDistance(const v1, v2: TKDT18DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT18DE_AxisCount - 1 do
      Result := Result + KDT18DEPow(v2[i] - v1[i]);
end;

function KDT18DECmpare(const v1, v2: TKDT18DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT18DE_Vec));
end;

function TKDT18DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DE_Node;
  function SortCompare(const p1, p2: PKDT18DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT18DE_SourceBuffer;
  dynBuff  : PKDT18DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT18DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DE.SearchStoreBuff(const StoreBuffPtr: PKDT18DEyanmicStoreBuffer; const Buff: TKDT18DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT18DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT18DE.GetData(const index: NativeInt): PKDT18DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT18DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DE.StoreBuffPtr: PKDT18DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT18DE.BuildKDTreeWithCluster(const inBuff: TKDT18DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT18DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT18DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT18DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DE.BuildKDTreeWithCluster(const inBuff: TKDT18DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DE_BuildCall);
var
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DE_BuildMethod);
var
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DE_BuildProc);
var
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT18DE.Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DE_Node;

var
  NearestNeighbour: PKDT18DE_Node;

  function FindParentNode(const BuffPtr: PKDT18DE_Vec; NodePtr: PKDT18DE_Node): PKDT18DE_Node;
  var
    Next       : PKDT18DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT18DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DE_Node; const BuffPtr: PKDT18DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT18DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT18DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT18DE_Vec; const p1, p2: PKDT18DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT18DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT18DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT18DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT18DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT18DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DE_Node(NearestNodes[0]);
    end;
end;

function TKDT18DE.Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DE.Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double): PKDT18DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DE.Search(const Buff: TKDT18DE_Vec): PKDT18DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT18DE.Search(const inBuff: TKDT18DE_DynamicVecBuffer; var OutBuff: TKDT18DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DE_DynamicVecBuffer;
  outBuffPtr : PKDT18DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT18DE_Source));
end;

procedure TKDT18DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT18DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT18DE.PrintNodeTree(const NodePtr: PKDT18DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT18DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT18DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT18DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT18DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT18DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT18DE.Test;
var
  TKDT18DE_Test    : TKDT18DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT18DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT18DE_Test := TKDT18DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT18DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT18DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT18DE_AxisCount - 1 do
        TKDT18DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT18DE_Test.TestBuff), length(TKDT18DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT18DE_Test.BuildKDTreeM(False, length(TKDT18DE_Test.TestBuff), @TKDT18DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT18DE_Test.BuildKDTreeM(False, length(TKDT18DE_Test.TestBuff), TKDT18DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT18DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT18DE_Test.TestBuff));
  TKDT18DE_Test.Search(TKDT18DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT18DEDistance(TKDT18DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT18DE_Test.Clear;
  { kMean test }
  TKDT18DE_Test.BuildKDTreeWithCluster(TKDT18DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT18DE_Test.Search(TKDT18DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT18DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT18DE_Test);
end;

{$ENDIF DEBUG}


function KDT19DEVec(const s: string): TKDT19DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT19DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT19DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT19DEVec(const v: TKDT19DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT19DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT19DEPow(const v: TKDT19DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT19DEDistance(const v1, v2: TKDT19DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT19DE_AxisCount - 1 do
      Result := Result + KDT19DEPow(v2[i] - v1[i]);
end;

function KDT19DECmpare(const v1, v2: TKDT19DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT19DE_Vec));
end;

function TKDT19DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DE_Node;
  function SortCompare(const p1, p2: PKDT19DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT19DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT19DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT19DE_SourceBuffer;
  dynBuff  : PKDT19DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT19DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT19DE.SearchStoreBuff(const StoreBuffPtr: PKDT19DEyanmicStoreBuffer; const Buff: TKDT19DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT19DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT19DE.GetData(const index: NativeInt): PKDT19DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT19DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT19DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT19DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT19DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT19DE.StoreBuffPtr: PKDT19DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT19DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT19DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT19DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT19DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT19DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT19DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT19DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT19DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT19DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT19DE.BuildKDTreeWithCluster(const inBuff: TKDT19DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT19DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT19DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT19DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT19DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT19DE.BuildKDTreeWithCluster(const inBuff: TKDT19DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DE_BuildCall);
var
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT19DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT19DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT19DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT19DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DE_BuildMethod);
var
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT19DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT19DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT19DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT19DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DE_BuildProc);
var
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT19DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT19DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT19DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT19DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT19DE.Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DE_Node;

var
  NearestNeighbour: PKDT19DE_Node;

  function FindParentNode(const BuffPtr: PKDT19DE_Vec; NodePtr: PKDT19DE_Node): PKDT19DE_Node;
  var
    Next       : PKDT19DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT19DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT19DE_Node; const BuffPtr: PKDT19DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT19DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT19DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT19DE_Vec; const p1, p2: PKDT19DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT19DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT19DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT19DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT19DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT19DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT19DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT19DE_Node(NearestNodes[0]);
    end;
end;

function TKDT19DE.Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT19DE.Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double): PKDT19DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT19DE.Search(const Buff: TKDT19DE_Vec): PKDT19DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT19DE.Search(const inBuff: TKDT19DE_DynamicVecBuffer; var OutBuff: TKDT19DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT19DE_DynamicVecBuffer;
  outBuffPtr : PKDT19DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT19DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT19DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT19DE_Source));
end;

procedure TKDT19DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT19DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT19DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT19DE.PrintNodeTree(const NodePtr: PKDT19DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT19DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT19DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT19DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT19DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT19DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT19DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT19DE.Test;
var
  TKDT19DE_Test    : TKDT19DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT19DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT19DE_Test := TKDT19DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT19DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT19DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT19DE_AxisCount - 1 do
        TKDT19DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT19DE_Test.TestBuff), length(TKDT19DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT19DE_Test.BuildKDTreeM(False, length(TKDT19DE_Test.TestBuff), @TKDT19DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT19DE_Test.BuildKDTreeM(False, length(TKDT19DE_Test.TestBuff), TKDT19DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT19DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT19DE_Test.TestBuff));
  TKDT19DE_Test.Search(TKDT19DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT19DEDistance(TKDT19DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT19DE_Test.Clear;
  { kMean test }
  TKDT19DE_Test.BuildKDTreeWithCluster(TKDT19DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT19DE_Test.Search(TKDT19DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT19DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT19DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT19DE_Test);
end;

{$ENDIF DEBUG}


function KDT20DEVec(const s: string): TKDT20DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT20DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT20DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT20DEVec(const v: TKDT20DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT20DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT20DEPow(const v: TKDT20DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT20DEDistance(const v1, v2: TKDT20DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT20DE_AxisCount - 1 do
      Result := Result + KDT20DEPow(v2[i] - v1[i]);
end;

function KDT20DECmpare(const v1, v2: TKDT20DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT20DE_Vec));
end;

function TKDT20DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DE_Node;
  function SortCompare(const p1, p2: PKDT20DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT20DE_SourceBuffer;
  dynBuff  : PKDT20DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT20DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DE.SearchStoreBuff(const StoreBuffPtr: PKDT20DEyanmicStoreBuffer; const Buff: TKDT20DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT20DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT20DE.GetData(const index: NativeInt): PKDT20DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT20DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DE.StoreBuffPtr: PKDT20DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT20DE.BuildKDTreeWithCluster(const inBuff: TKDT20DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT20DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT20DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT20DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DE.BuildKDTreeWithCluster(const inBuff: TKDT20DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DE_BuildCall);
var
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DE_BuildMethod);
var
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DE_BuildProc);
var
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT20DE.Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DE_Node;

var
  NearestNeighbour: PKDT20DE_Node;

  function FindParentNode(const BuffPtr: PKDT20DE_Vec; NodePtr: PKDT20DE_Node): PKDT20DE_Node;
  var
    Next       : PKDT20DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT20DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DE_Node; const BuffPtr: PKDT20DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT20DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT20DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT20DE_Vec; const p1, p2: PKDT20DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT20DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT20DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT20DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT20DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT20DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DE_Node(NearestNodes[0]);
    end;
end;

function TKDT20DE.Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DE.Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double): PKDT20DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DE.Search(const Buff: TKDT20DE_Vec): PKDT20DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT20DE.Search(const inBuff: TKDT20DE_DynamicVecBuffer; var OutBuff: TKDT20DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DE_DynamicVecBuffer;
  outBuffPtr : PKDT20DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT20DE_Source));
end;

procedure TKDT20DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT20DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT20DE.PrintNodeTree(const NodePtr: PKDT20DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT20DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT20DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT20DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT20DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT20DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT20DE.Test;
var
  TKDT20DE_Test    : TKDT20DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT20DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT20DE_Test := TKDT20DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT20DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT20DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT20DE_AxisCount - 1 do
        TKDT20DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT20DE_Test.TestBuff), length(TKDT20DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT20DE_Test.BuildKDTreeM(False, length(TKDT20DE_Test.TestBuff), @TKDT20DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT20DE_Test.BuildKDTreeM(False, length(TKDT20DE_Test.TestBuff), TKDT20DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT20DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT20DE_Test.TestBuff));
  TKDT20DE_Test.Search(TKDT20DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT20DEDistance(TKDT20DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT20DE_Test.Clear;
  { kMean test }
  TKDT20DE_Test.BuildKDTreeWithCluster(TKDT20DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT20DE_Test.Search(TKDT20DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT20DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT20DE_Test);
end;

{$ENDIF DEBUG}


function KDT21DEVec(const s: string): TKDT21DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT21DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT21DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT21DEVec(const v: TKDT21DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT21DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT21DEPow(const v: TKDT21DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT21DEDistance(const v1, v2: TKDT21DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT21DE_AxisCount - 1 do
      Result := Result + KDT21DEPow(v2[i] - v1[i]);
end;

function KDT21DECmpare(const v1, v2: TKDT21DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT21DE_Vec));
end;

function TKDT21DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DE_Node;
  function SortCompare(const p1, p2: PKDT21DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT21DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT21DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT21DE_SourceBuffer;
  dynBuff  : PKDT21DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT21DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT21DE.SearchStoreBuff(const StoreBuffPtr: PKDT21DEyanmicStoreBuffer; const Buff: TKDT21DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT21DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT21DE.GetData(const index: NativeInt): PKDT21DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT21DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT21DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT21DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT21DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT21DE.StoreBuffPtr: PKDT21DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT21DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT21DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT21DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT21DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT21DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT21DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT21DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT21DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT21DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT21DE.BuildKDTreeWithCluster(const inBuff: TKDT21DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT21DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT21DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT21DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT21DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT21DE.BuildKDTreeWithCluster(const inBuff: TKDT21DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DE_BuildCall);
var
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT21DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT21DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT21DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT21DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DE_BuildMethod);
var
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT21DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT21DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT21DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT21DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DE_BuildProc);
var
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT21DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT21DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT21DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT21DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT21DE.Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DE_Node;

var
  NearestNeighbour: PKDT21DE_Node;

  function FindParentNode(const BuffPtr: PKDT21DE_Vec; NodePtr: PKDT21DE_Node): PKDT21DE_Node;
  var
    Next       : PKDT21DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT21DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT21DE_Node; const BuffPtr: PKDT21DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT21DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT21DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT21DE_Vec; const p1, p2: PKDT21DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT21DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT21DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT21DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT21DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT21DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT21DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT21DE_Node(NearestNodes[0]);
    end;
end;

function TKDT21DE.Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT21DE.Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double): PKDT21DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT21DE.Search(const Buff: TKDT21DE_Vec): PKDT21DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT21DE.Search(const inBuff: TKDT21DE_DynamicVecBuffer; var OutBuff: TKDT21DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT21DE_DynamicVecBuffer;
  outBuffPtr : PKDT21DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT21DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT21DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT21DE_Source));
end;

procedure TKDT21DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT21DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT21DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT21DE.PrintNodeTree(const NodePtr: PKDT21DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT21DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT21DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT21DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT21DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT21DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT21DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT21DE.Test;
var
  TKDT21DE_Test    : TKDT21DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT21DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT21DE_Test := TKDT21DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT21DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT21DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT21DE_AxisCount - 1 do
        TKDT21DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT21DE_Test.TestBuff), length(TKDT21DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT21DE_Test.BuildKDTreeM(False, length(TKDT21DE_Test.TestBuff), @TKDT21DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT21DE_Test.BuildKDTreeM(False, length(TKDT21DE_Test.TestBuff), TKDT21DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT21DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT21DE_Test.TestBuff));
  TKDT21DE_Test.Search(TKDT21DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT21DEDistance(TKDT21DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT21DE_Test.Clear;
  { kMean test }
  TKDT21DE_Test.BuildKDTreeWithCluster(TKDT21DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT21DE_Test.Search(TKDT21DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT21DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT21DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT21DE_Test);
end;

{$ENDIF DEBUG}


function KDT22DEVec(const s: string): TKDT22DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT22DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT22DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT22DEVec(const v: TKDT22DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT22DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT22DEPow(const v: TKDT22DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT22DEDistance(const v1, v2: TKDT22DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT22DE_AxisCount - 1 do
      Result := Result + KDT22DEPow(v2[i] - v1[i]);
end;

function KDT22DECmpare(const v1, v2: TKDT22DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT22DE_Vec));
end;

function TKDT22DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DE_Node;
  function SortCompare(const p1, p2: PKDT22DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT22DE_SourceBuffer;
  dynBuff  : PKDT22DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT22DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DE.SearchStoreBuff(const StoreBuffPtr: PKDT22DEyanmicStoreBuffer; const Buff: TKDT22DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT22DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT22DE.GetData(const index: NativeInt): PKDT22DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT22DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DE.StoreBuffPtr: PKDT22DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT22DE.BuildKDTreeWithCluster(const inBuff: TKDT22DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT22DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT22DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT22DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DE.BuildKDTreeWithCluster(const inBuff: TKDT22DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DE_BuildCall);
var
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DE_BuildMethod);
var
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DE_BuildProc);
var
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT22DE.Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DE_Node;

var
  NearestNeighbour: PKDT22DE_Node;

  function FindParentNode(const BuffPtr: PKDT22DE_Vec; NodePtr: PKDT22DE_Node): PKDT22DE_Node;
  var
    Next       : PKDT22DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT22DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DE_Node; const BuffPtr: PKDT22DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT22DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT22DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT22DE_Vec; const p1, p2: PKDT22DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT22DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT22DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT22DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT22DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT22DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DE_Node(NearestNodes[0]);
    end;
end;

function TKDT22DE.Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DE.Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double): PKDT22DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DE.Search(const Buff: TKDT22DE_Vec): PKDT22DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT22DE.Search(const inBuff: TKDT22DE_DynamicVecBuffer; var OutBuff: TKDT22DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DE_DynamicVecBuffer;
  outBuffPtr : PKDT22DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT22DE_Source));
end;

procedure TKDT22DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT22DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT22DE.PrintNodeTree(const NodePtr: PKDT22DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT22DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT22DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT22DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT22DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT22DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT22DE.Test;
var
  TKDT22DE_Test    : TKDT22DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT22DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT22DE_Test := TKDT22DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT22DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT22DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT22DE_AxisCount - 1 do
        TKDT22DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT22DE_Test.TestBuff), length(TKDT22DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT22DE_Test.BuildKDTreeM(False, length(TKDT22DE_Test.TestBuff), @TKDT22DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT22DE_Test.BuildKDTreeM(False, length(TKDT22DE_Test.TestBuff), TKDT22DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT22DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT22DE_Test.TestBuff));
  TKDT22DE_Test.Search(TKDT22DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT22DEDistance(TKDT22DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT22DE_Test.Clear;
  { kMean test }
  TKDT22DE_Test.BuildKDTreeWithCluster(TKDT22DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT22DE_Test.Search(TKDT22DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT22DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT22DE_Test);
end;

{$ENDIF DEBUG}


function KDT23DEVec(const s: string): TKDT23DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT23DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT23DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT23DEVec(const v: TKDT23DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT23DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT23DEPow(const v: TKDT23DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT23DEDistance(const v1, v2: TKDT23DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT23DE_AxisCount - 1 do
      Result := Result + KDT23DEPow(v2[i] - v1[i]);
end;

function KDT23DECmpare(const v1, v2: TKDT23DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT23DE_Vec));
end;

function TKDT23DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DE_Node;
  function SortCompare(const p1, p2: PKDT23DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT23DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT23DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT23DE_SourceBuffer;
  dynBuff  : PKDT23DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT23DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT23DE.SearchStoreBuff(const StoreBuffPtr: PKDT23DEyanmicStoreBuffer; const Buff: TKDT23DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT23DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT23DE.GetData(const index: NativeInt): PKDT23DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT23DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT23DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT23DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT23DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT23DE.StoreBuffPtr: PKDT23DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT23DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT23DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT23DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT23DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT23DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT23DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT23DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT23DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT23DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT23DE.BuildKDTreeWithCluster(const inBuff: TKDT23DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT23DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT23DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT23DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT23DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT23DE.BuildKDTreeWithCluster(const inBuff: TKDT23DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DE_BuildCall);
var
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT23DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT23DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT23DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT23DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DE_BuildMethod);
var
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT23DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT23DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT23DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT23DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DE_BuildProc);
var
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT23DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT23DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT23DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT23DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT23DE.Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DE_Node;

var
  NearestNeighbour: PKDT23DE_Node;

  function FindParentNode(const BuffPtr: PKDT23DE_Vec; NodePtr: PKDT23DE_Node): PKDT23DE_Node;
  var
    Next       : PKDT23DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT23DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT23DE_Node; const BuffPtr: PKDT23DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT23DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT23DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT23DE_Vec; const p1, p2: PKDT23DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT23DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT23DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT23DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT23DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT23DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT23DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT23DE_Node(NearestNodes[0]);
    end;
end;

function TKDT23DE.Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT23DE.Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double): PKDT23DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT23DE.Search(const Buff: TKDT23DE_Vec): PKDT23DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT23DE.Search(const inBuff: TKDT23DE_DynamicVecBuffer; var OutBuff: TKDT23DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT23DE_DynamicVecBuffer;
  outBuffPtr : PKDT23DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT23DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT23DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT23DE_Source));
end;

procedure TKDT23DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT23DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT23DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT23DE.PrintNodeTree(const NodePtr: PKDT23DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT23DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT23DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT23DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT23DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT23DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT23DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT23DE.Test;
var
  TKDT23DE_Test    : TKDT23DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT23DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT23DE_Test := TKDT23DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT23DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT23DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT23DE_AxisCount - 1 do
        TKDT23DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT23DE_Test.TestBuff), length(TKDT23DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT23DE_Test.BuildKDTreeM(False, length(TKDT23DE_Test.TestBuff), @TKDT23DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT23DE_Test.BuildKDTreeM(False, length(TKDT23DE_Test.TestBuff), TKDT23DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT23DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT23DE_Test.TestBuff));
  TKDT23DE_Test.Search(TKDT23DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT23DEDistance(TKDT23DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT23DE_Test.Clear;
  { kMean test }
  TKDT23DE_Test.BuildKDTreeWithCluster(TKDT23DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT23DE_Test.Search(TKDT23DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT23DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT23DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT23DE_Test);
end;

{$ENDIF DEBUG}


function KDT24DEVec(const s: string): TKDT24DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT24DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT24DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT24DEVec(const v: TKDT24DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT24DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT24DEPow(const v: TKDT24DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT24DEDistance(const v1, v2: TKDT24DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT24DE_AxisCount - 1 do
      Result := Result + KDT24DEPow(v2[i] - v1[i]);
end;

function KDT24DECmpare(const v1, v2: TKDT24DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT24DE_Vec));
end;

function TKDT24DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DE_Node;
  function SortCompare(const p1, p2: PKDT24DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT24DE_SourceBuffer;
  dynBuff  : PKDT24DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT24DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DE.SearchStoreBuff(const StoreBuffPtr: PKDT24DEyanmicStoreBuffer; const Buff: TKDT24DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT24DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT24DE.GetData(const index: NativeInt): PKDT24DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT24DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DE.StoreBuffPtr: PKDT24DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT24DE.BuildKDTreeWithCluster(const inBuff: TKDT24DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT24DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT24DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT24DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DE.BuildKDTreeWithCluster(const inBuff: TKDT24DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DE_BuildCall);
var
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DE_BuildMethod);
var
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DE_BuildProc);
var
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT24DE.Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DE_Node;

var
  NearestNeighbour: PKDT24DE_Node;

  function FindParentNode(const BuffPtr: PKDT24DE_Vec; NodePtr: PKDT24DE_Node): PKDT24DE_Node;
  var
    Next       : PKDT24DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT24DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DE_Node; const BuffPtr: PKDT24DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT24DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT24DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT24DE_Vec; const p1, p2: PKDT24DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT24DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT24DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT24DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT24DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT24DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DE_Node(NearestNodes[0]);
    end;
end;

function TKDT24DE.Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DE.Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double): PKDT24DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DE.Search(const Buff: TKDT24DE_Vec): PKDT24DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT24DE.Search(const inBuff: TKDT24DE_DynamicVecBuffer; var OutBuff: TKDT24DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DE_DynamicVecBuffer;
  outBuffPtr : PKDT24DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT24DE_Source));
end;

procedure TKDT24DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT24DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT24DE.PrintNodeTree(const NodePtr: PKDT24DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT24DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT24DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT24DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT24DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT24DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT24DE.Test;
var
  TKDT24DE_Test    : TKDT24DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT24DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT24DE_Test := TKDT24DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT24DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT24DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT24DE_AxisCount - 1 do
        TKDT24DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT24DE_Test.TestBuff), length(TKDT24DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT24DE_Test.BuildKDTreeM(False, length(TKDT24DE_Test.TestBuff), @TKDT24DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT24DE_Test.BuildKDTreeM(False, length(TKDT24DE_Test.TestBuff), TKDT24DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT24DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT24DE_Test.TestBuff));
  TKDT24DE_Test.Search(TKDT24DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT24DEDistance(TKDT24DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT24DE_Test.Clear;
  { kMean test }
  TKDT24DE_Test.BuildKDTreeWithCluster(TKDT24DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT24DE_Test.Search(TKDT24DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT24DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT24DE_Test);
end;

{$ENDIF DEBUG}


function KDT25DEVec(const s: string): TKDT25DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT25DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT25DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT25DEVec(const v: TKDT25DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT25DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT25DEPow(const v: TKDT25DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT25DEDistance(const v1, v2: TKDT25DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT25DE_AxisCount - 1 do
      Result := Result + KDT25DEPow(v2[i] - v1[i]);
end;

function KDT25DECmpare(const v1, v2: TKDT25DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT25DE_Vec));
end;

function TKDT25DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DE_Node;
  function SortCompare(const p1, p2: PKDT25DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT25DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT25DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT25DE_SourceBuffer;
  dynBuff  : PKDT25DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT25DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT25DE.SearchStoreBuff(const StoreBuffPtr: PKDT25DEyanmicStoreBuffer; const Buff: TKDT25DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT25DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT25DE.GetData(const index: NativeInt): PKDT25DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT25DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT25DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT25DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT25DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT25DE.StoreBuffPtr: PKDT25DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT25DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT25DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT25DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT25DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT25DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT25DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT25DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT25DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT25DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT25DE.BuildKDTreeWithCluster(const inBuff: TKDT25DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT25DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT25DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT25DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT25DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT25DE.BuildKDTreeWithCluster(const inBuff: TKDT25DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT25DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DE_BuildCall);
var
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT25DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT25DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT25DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT25DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT25DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DE_BuildMethod);
var
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT25DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT25DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT25DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT25DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DE_BuildProc);
var
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT25DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT25DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT25DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT25DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT25DE.Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DE_Node;

var
  NearestNeighbour: PKDT25DE_Node;

  function FindParentNode(const BuffPtr: PKDT25DE_Vec; NodePtr: PKDT25DE_Node): PKDT25DE_Node;
  var
    Next       : PKDT25DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT25DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT25DE_Node; const BuffPtr: PKDT25DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT25DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT25DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT25DE_Vec; const p1, p2: PKDT25DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT25DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT25DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT25DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT25DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT25DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT25DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT25DE_Node(NearestNodes[0]);
    end;
end;

function TKDT25DE.Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT25DE.Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double): PKDT25DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT25DE.Search(const Buff: TKDT25DE_Vec): PKDT25DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT25DE.Search(const inBuff: TKDT25DE_DynamicVecBuffer; var OutBuff: TKDT25DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT25DE_DynamicVecBuffer;
  outBuffPtr : PKDT25DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT25DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT25DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT25DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT25DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT25DE_Source));
end;

procedure TKDT25DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT25DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT25DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT25DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT25DE.PrintNodeTree(const NodePtr: PKDT25DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT25DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT25DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT25DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT25DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT25DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT25DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT25DE.Test;
var
  TKDT25DE_Test    : TKDT25DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT25DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT25DE_Test := TKDT25DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT25DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT25DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT25DE_AxisCount - 1 do
        TKDT25DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT25DE_Test.TestBuff), length(TKDT25DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT25DE_Test.BuildKDTreeM(False, length(TKDT25DE_Test.TestBuff), @TKDT25DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT25DE_Test.BuildKDTreeM(False, length(TKDT25DE_Test.TestBuff), TKDT25DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT25DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT25DE_Test.TestBuff));
  TKDT25DE_Test.Search(TKDT25DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT25DEDistance(TKDT25DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT25DE_Test.Clear;
  { kMean test }
  TKDT25DE_Test.BuildKDTreeWithCluster(TKDT25DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT25DE_Test.Search(TKDT25DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT25DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT25DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT25DE_Test);
end;

{$ENDIF DEBUG}


function KDT26DEVec(const s: string): TKDT26DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT26DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT26DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT26DEVec(const v: TKDT26DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT26DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT26DEPow(const v: TKDT26DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT26DEDistance(const v1, v2: TKDT26DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT26DE_AxisCount - 1 do
      Result := Result + KDT26DEPow(v2[i] - v1[i]);
end;

function KDT26DECmpare(const v1, v2: TKDT26DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT26DE_Vec));
end;

function TKDT26DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DE_Node;
  function SortCompare(const p1, p2: PKDT26DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT26DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT26DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT26DE_SourceBuffer;
  dynBuff  : PKDT26DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT26DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT26DE.SearchStoreBuff(const StoreBuffPtr: PKDT26DEyanmicStoreBuffer; const Buff: TKDT26DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT26DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT26DE.GetData(const index: NativeInt): PKDT26DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT26DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT26DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT26DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT26DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT26DE.StoreBuffPtr: PKDT26DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT26DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT26DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT26DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT26DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT26DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT26DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT26DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT26DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT26DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT26DE.BuildKDTreeWithCluster(const inBuff: TKDT26DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT26DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT26DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT26DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT26DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT26DE.BuildKDTreeWithCluster(const inBuff: TKDT26DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT26DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DE_BuildCall);
var
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT26DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT26DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT26DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT26DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT26DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DE_BuildMethod);
var
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT26DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT26DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT26DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT26DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DE_BuildProc);
var
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT26DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT26DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT26DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT26DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT26DE.Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DE_Node;

var
  NearestNeighbour: PKDT26DE_Node;

  function FindParentNode(const BuffPtr: PKDT26DE_Vec; NodePtr: PKDT26DE_Node): PKDT26DE_Node;
  var
    Next       : PKDT26DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT26DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT26DE_Node; const BuffPtr: PKDT26DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT26DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT26DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT26DE_Vec; const p1, p2: PKDT26DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT26DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT26DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT26DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT26DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT26DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT26DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT26DE_Node(NearestNodes[0]);
    end;
end;

function TKDT26DE.Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT26DE.Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double): PKDT26DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT26DE.Search(const Buff: TKDT26DE_Vec): PKDT26DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT26DE.Search(const inBuff: TKDT26DE_DynamicVecBuffer; var OutBuff: TKDT26DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT26DE_DynamicVecBuffer;
  outBuffPtr : PKDT26DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT26DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT26DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT26DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT26DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT26DE_Source));
end;

procedure TKDT26DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT26DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT26DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT26DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT26DE.PrintNodeTree(const NodePtr: PKDT26DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT26DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT26DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT26DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT26DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT26DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT26DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT26DE.Test;
var
  TKDT26DE_Test    : TKDT26DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT26DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT26DE_Test := TKDT26DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT26DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT26DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT26DE_AxisCount - 1 do
        TKDT26DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT26DE_Test.TestBuff), length(TKDT26DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT26DE_Test.BuildKDTreeM(False, length(TKDT26DE_Test.TestBuff), @TKDT26DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT26DE_Test.BuildKDTreeM(False, length(TKDT26DE_Test.TestBuff), TKDT26DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT26DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT26DE_Test.TestBuff));
  TKDT26DE_Test.Search(TKDT26DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT26DEDistance(TKDT26DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT26DE_Test.Clear;
  { kMean test }
  TKDT26DE_Test.BuildKDTreeWithCluster(TKDT26DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT26DE_Test.Search(TKDT26DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT26DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT26DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT26DE_Test);
end;

{$ENDIF DEBUG}


function KDT27DEVec(const s: string): TKDT27DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT27DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT27DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT27DEVec(const v: TKDT27DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT27DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT27DEPow(const v: TKDT27DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT27DEDistance(const v1, v2: TKDT27DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT27DE_AxisCount - 1 do
      Result := Result + KDT27DEPow(v2[i] - v1[i]);
end;

function KDT27DECmpare(const v1, v2: TKDT27DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT27DE_Vec));
end;

function TKDT27DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DE_Node;
  function SortCompare(const p1, p2: PKDT27DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT27DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT27DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT27DE_SourceBuffer;
  dynBuff  : PKDT27DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT27DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT27DE.SearchStoreBuff(const StoreBuffPtr: PKDT27DEyanmicStoreBuffer; const Buff: TKDT27DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT27DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT27DE.GetData(const index: NativeInt): PKDT27DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT27DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT27DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT27DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT27DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT27DE.StoreBuffPtr: PKDT27DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT27DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT27DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT27DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT27DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT27DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT27DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT27DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT27DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT27DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT27DE.BuildKDTreeWithCluster(const inBuff: TKDT27DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT27DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT27DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT27DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT27DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT27DE.BuildKDTreeWithCluster(const inBuff: TKDT27DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT27DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DE_BuildCall);
var
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT27DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT27DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT27DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT27DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT27DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DE_BuildMethod);
var
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT27DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT27DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT27DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT27DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DE_BuildProc);
var
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT27DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT27DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT27DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT27DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT27DE.Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DE_Node;

var
  NearestNeighbour: PKDT27DE_Node;

  function FindParentNode(const BuffPtr: PKDT27DE_Vec; NodePtr: PKDT27DE_Node): PKDT27DE_Node;
  var
    Next       : PKDT27DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT27DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT27DE_Node; const BuffPtr: PKDT27DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT27DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT27DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT27DE_Vec; const p1, p2: PKDT27DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT27DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT27DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT27DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT27DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT27DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT27DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT27DE_Node(NearestNodes[0]);
    end;
end;

function TKDT27DE.Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT27DE.Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double): PKDT27DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT27DE.Search(const Buff: TKDT27DE_Vec): PKDT27DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT27DE.Search(const inBuff: TKDT27DE_DynamicVecBuffer; var OutBuff: TKDT27DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT27DE_DynamicVecBuffer;
  outBuffPtr : PKDT27DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT27DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT27DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT27DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT27DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT27DE_Source));
end;

procedure TKDT27DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT27DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT27DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT27DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT27DE.PrintNodeTree(const NodePtr: PKDT27DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT27DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT27DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT27DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT27DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT27DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT27DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT27DE.Test;
var
  TKDT27DE_Test    : TKDT27DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT27DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT27DE_Test := TKDT27DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT27DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT27DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT27DE_AxisCount - 1 do
        TKDT27DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT27DE_Test.TestBuff), length(TKDT27DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT27DE_Test.BuildKDTreeM(False, length(TKDT27DE_Test.TestBuff), @TKDT27DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT27DE_Test.BuildKDTreeM(False, length(TKDT27DE_Test.TestBuff), TKDT27DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT27DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT27DE_Test.TestBuff));
  TKDT27DE_Test.Search(TKDT27DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT27DEDistance(TKDT27DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT27DE_Test.Clear;
  { kMean test }
  TKDT27DE_Test.BuildKDTreeWithCluster(TKDT27DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT27DE_Test.Search(TKDT27DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT27DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT27DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT27DE_Test);
end;

{$ENDIF DEBUG}


function KDT28DEVec(const s: string): TKDT28DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT28DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT28DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT28DEVec(const v: TKDT28DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT28DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT28DEPow(const v: TKDT28DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT28DEDistance(const v1, v2: TKDT28DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT28DE_AxisCount - 1 do
      Result := Result + KDT28DEPow(v2[i] - v1[i]);
end;

function KDT28DECmpare(const v1, v2: TKDT28DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT28DE_Vec));
end;

function TKDT28DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DE_Node;
  function SortCompare(const p1, p2: PKDT28DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT28DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT28DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT28DE_SourceBuffer;
  dynBuff  : PKDT28DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT28DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT28DE.SearchStoreBuff(const StoreBuffPtr: PKDT28DEyanmicStoreBuffer; const Buff: TKDT28DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT28DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT28DE.GetData(const index: NativeInt): PKDT28DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT28DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT28DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT28DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT28DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT28DE.StoreBuffPtr: PKDT28DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT28DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT28DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT28DE.BuildKDTreeWithCluster(const inBuff: TKDT28DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT28DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT28DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT28DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT28DE.BuildKDTreeWithCluster(const inBuff: TKDT28DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DE_BuildCall);
var
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DE_BuildMethod);
var
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DE_BuildProc);
var
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT28DE.Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DE_Node;

var
  NearestNeighbour: PKDT28DE_Node;

  function FindParentNode(const BuffPtr: PKDT28DE_Vec; NodePtr: PKDT28DE_Node): PKDT28DE_Node;
  var
    Next       : PKDT28DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT28DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT28DE_Node; const BuffPtr: PKDT28DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT28DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT28DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT28DE_Vec; const p1, p2: PKDT28DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT28DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT28DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT28DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT28DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT28DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT28DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT28DE_Node(NearestNodes[0]);
    end;
end;

function TKDT28DE.Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT28DE.Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double): PKDT28DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT28DE.Search(const Buff: TKDT28DE_Vec): PKDT28DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT28DE.Search(const inBuff: TKDT28DE_DynamicVecBuffer; var OutBuff: TKDT28DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DE_DynamicVecBuffer;
  outBuffPtr : PKDT28DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT28DE_Source));
end;

procedure TKDT28DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT28DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT28DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT28DE.PrintNodeTree(const NodePtr: PKDT28DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT28DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT28DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT28DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT28DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT28DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT28DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT28DE.Test;
var
  TKDT28DE_Test    : TKDT28DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT28DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT28DE_Test := TKDT28DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT28DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT28DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT28DE_AxisCount - 1 do
        TKDT28DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT28DE_Test.TestBuff), length(TKDT28DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT28DE_Test.BuildKDTreeM(False, length(TKDT28DE_Test.TestBuff), @TKDT28DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT28DE_Test.BuildKDTreeM(False, length(TKDT28DE_Test.TestBuff), TKDT28DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT28DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT28DE_Test.TestBuff));
  TKDT28DE_Test.Search(TKDT28DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT28DEDistance(TKDT28DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT28DE_Test.Clear;
  { kMean test }
  TKDT28DE_Test.BuildKDTreeWithCluster(TKDT28DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT28DE_Test.Search(TKDT28DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT28DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT28DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT28DE_Test);
end;

{$ENDIF DEBUG}


function KDT29DEVec(const s: string): TKDT29DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT29DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT29DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT29DEVec(const v: TKDT29DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT29DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT29DEPow(const v: TKDT29DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT29DEDistance(const v1, v2: TKDT29DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT29DE_AxisCount - 1 do
      Result := Result + KDT29DEPow(v2[i] - v1[i]);
end;

function KDT29DECmpare(const v1, v2: TKDT29DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT29DE_Vec));
end;

function TKDT29DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DE_Node;
  function SortCompare(const p1, p2: PKDT29DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT29DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT29DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT29DE_SourceBuffer;
  dynBuff  : PKDT29DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT29DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT29DE.SearchStoreBuff(const StoreBuffPtr: PKDT29DEyanmicStoreBuffer; const Buff: TKDT29DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT29DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT29DE.GetData(const index: NativeInt): PKDT29DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT29DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT29DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT29DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT29DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT29DE.StoreBuffPtr: PKDT29DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT29DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT29DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT29DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT29DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT29DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT29DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT29DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT29DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT29DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT29DE.BuildKDTreeWithCluster(const inBuff: TKDT29DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT29DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT29DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT29DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT29DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT29DE.BuildKDTreeWithCluster(const inBuff: TKDT29DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT29DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DE_BuildCall);
var
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT29DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT29DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT29DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT29DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT29DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DE_BuildMethod);
var
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT29DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT29DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT29DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT29DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DE_BuildProc);
var
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT29DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT29DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT29DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT29DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT29DE.Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DE_Node;

var
  NearestNeighbour: PKDT29DE_Node;

  function FindParentNode(const BuffPtr: PKDT29DE_Vec; NodePtr: PKDT29DE_Node): PKDT29DE_Node;
  var
    Next       : PKDT29DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT29DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT29DE_Node; const BuffPtr: PKDT29DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT29DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT29DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT29DE_Vec; const p1, p2: PKDT29DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT29DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT29DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT29DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT29DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT29DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT29DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT29DE_Node(NearestNodes[0]);
    end;
end;

function TKDT29DE.Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT29DE.Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double): PKDT29DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT29DE.Search(const Buff: TKDT29DE_Vec): PKDT29DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT29DE.Search(const inBuff: TKDT29DE_DynamicVecBuffer; var OutBuff: TKDT29DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT29DE_DynamicVecBuffer;
  outBuffPtr : PKDT29DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT29DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT29DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT29DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT29DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT29DE_Source));
end;

procedure TKDT29DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT29DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT29DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT29DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT29DE.PrintNodeTree(const NodePtr: PKDT29DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT29DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT29DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT29DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT29DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT29DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT29DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT29DE.Test;
var
  TKDT29DE_Test    : TKDT29DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT29DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT29DE_Test := TKDT29DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT29DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT29DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT29DE_AxisCount - 1 do
        TKDT29DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT29DE_Test.TestBuff), length(TKDT29DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT29DE_Test.BuildKDTreeM(False, length(TKDT29DE_Test.TestBuff), @TKDT29DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT29DE_Test.BuildKDTreeM(False, length(TKDT29DE_Test.TestBuff), TKDT29DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT29DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT29DE_Test.TestBuff));
  TKDT29DE_Test.Search(TKDT29DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT29DEDistance(TKDT29DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT29DE_Test.Clear;
  { kMean test }
  TKDT29DE_Test.BuildKDTreeWithCluster(TKDT29DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT29DE_Test.Search(TKDT29DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT29DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT29DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT29DE_Test);
end;

{$ENDIF DEBUG}


function KDT30DEVec(const s: string): TKDT30DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT30DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT30DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT30DEVec(const v: TKDT30DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT30DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT30DEPow(const v: TKDT30DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT30DEDistance(const v1, v2: TKDT30DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT30DE_AxisCount - 1 do
      Result := Result + KDT30DEPow(v2[i] - v1[i]);
end;

function KDT30DECmpare(const v1, v2: TKDT30DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT30DE_Vec));
end;

function TKDT30DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DE_Node;
  function SortCompare(const p1, p2: PKDT30DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT30DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT30DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT30DE_SourceBuffer;
  dynBuff  : PKDT30DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT30DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT30DE.SearchStoreBuff(const StoreBuffPtr: PKDT30DEyanmicStoreBuffer; const Buff: TKDT30DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT30DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT30DE.GetData(const index: NativeInt): PKDT30DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT30DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT30DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT30DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT30DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT30DE.StoreBuffPtr: PKDT30DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT30DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT30DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT30DE.BuildKDTreeWithCluster(const inBuff: TKDT30DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT30DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT30DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT30DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT30DE.BuildKDTreeWithCluster(const inBuff: TKDT30DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DE_BuildCall);
var
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DE_BuildMethod);
var
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DE_BuildProc);
var
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT30DE.Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DE_Node;

var
  NearestNeighbour: PKDT30DE_Node;

  function FindParentNode(const BuffPtr: PKDT30DE_Vec; NodePtr: PKDT30DE_Node): PKDT30DE_Node;
  var
    Next       : PKDT30DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT30DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT30DE_Node; const BuffPtr: PKDT30DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT30DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT30DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT30DE_Vec; const p1, p2: PKDT30DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT30DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT30DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT30DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT30DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT30DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT30DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT30DE_Node(NearestNodes[0]);
    end;
end;

function TKDT30DE.Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT30DE.Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double): PKDT30DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT30DE.Search(const Buff: TKDT30DE_Vec): PKDT30DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT30DE.Search(const inBuff: TKDT30DE_DynamicVecBuffer; var OutBuff: TKDT30DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DE_DynamicVecBuffer;
  outBuffPtr : PKDT30DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT30DE_Source));
end;

procedure TKDT30DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT30DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT30DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT30DE.PrintNodeTree(const NodePtr: PKDT30DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT30DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT30DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT30DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT30DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT30DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT30DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT30DE.Test;
var
  TKDT30DE_Test    : TKDT30DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT30DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT30DE_Test := TKDT30DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT30DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT30DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT30DE_AxisCount - 1 do
        TKDT30DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT30DE_Test.TestBuff), length(TKDT30DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT30DE_Test.BuildKDTreeM(False, length(TKDT30DE_Test.TestBuff), @TKDT30DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT30DE_Test.BuildKDTreeM(False, length(TKDT30DE_Test.TestBuff), TKDT30DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT30DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT30DE_Test.TestBuff));
  TKDT30DE_Test.Search(TKDT30DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT30DEDistance(TKDT30DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT30DE_Test.Clear;
  { kMean test }
  TKDT30DE_Test.BuildKDTreeWithCluster(TKDT30DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT30DE_Test.Search(TKDT30DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT30DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT30DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT30DE_Test);
end;

{$ENDIF DEBUG}


function KDT32DEVec(const s: string): TKDT32DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT32DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT32DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT32DEVec(const v: TKDT32DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT32DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT32DEPow(const v: TKDT32DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT32DEDistance(const v1, v2: TKDT32DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT32DE_AxisCount - 1 do
      Result := Result + KDT32DEPow(v2[i] - v1[i]);
end;

function KDT32DECmpare(const v1, v2: TKDT32DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT32DE_Vec));
end;

function TKDT32DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DE_Node;
  function SortCompare(const p1, p2: PKDT32DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT32DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT32DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT32DE_SourceBuffer;
  dynBuff  : PKDT32DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT32DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT32DE.SearchStoreBuff(const StoreBuffPtr: PKDT32DEyanmicStoreBuffer; const Buff: TKDT32DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT32DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT32DE.GetData(const index: NativeInt): PKDT32DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT32DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT32DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT32DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT32DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT32DE.StoreBuffPtr: PKDT32DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT32DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT32DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT32DE.BuildKDTreeWithCluster(const inBuff: TKDT32DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT32DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT32DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT32DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT32DE.BuildKDTreeWithCluster(const inBuff: TKDT32DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DE_BuildCall);
var
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DE_BuildMethod);
var
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DE_BuildProc);
var
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT32DE.Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DE_Node;

var
  NearestNeighbour: PKDT32DE_Node;

  function FindParentNode(const BuffPtr: PKDT32DE_Vec; NodePtr: PKDT32DE_Node): PKDT32DE_Node;
  var
    Next       : PKDT32DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT32DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT32DE_Node; const BuffPtr: PKDT32DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT32DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT32DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT32DE_Vec; const p1, p2: PKDT32DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT32DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT32DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT32DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT32DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT32DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT32DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT32DE_Node(NearestNodes[0]);
    end;
end;

function TKDT32DE.Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT32DE.Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double): PKDT32DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT32DE.Search(const Buff: TKDT32DE_Vec): PKDT32DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT32DE.Search(const inBuff: TKDT32DE_DynamicVecBuffer; var OutBuff: TKDT32DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DE_DynamicVecBuffer;
  outBuffPtr : PKDT32DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT32DE_Source));
end;

procedure TKDT32DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT32DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT32DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT32DE.PrintNodeTree(const NodePtr: PKDT32DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT32DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT32DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT32DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT32DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT32DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT32DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT32DE.Test;
var
  TKDT32DE_Test    : TKDT32DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT32DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT32DE_Test := TKDT32DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT32DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT32DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT32DE_AxisCount - 1 do
        TKDT32DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT32DE_Test.TestBuff), length(TKDT32DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT32DE_Test.BuildKDTreeM(False, length(TKDT32DE_Test.TestBuff), @TKDT32DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT32DE_Test.BuildKDTreeM(False, length(TKDT32DE_Test.TestBuff), TKDT32DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT32DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT32DE_Test.TestBuff));
  TKDT32DE_Test.Search(TKDT32DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT32DEDistance(TKDT32DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT32DE_Test.Clear;
  { kMean test }
  TKDT32DE_Test.BuildKDTreeWithCluster(TKDT32DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT32DE_Test.Search(TKDT32DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT32DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT32DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT32DE_Test);
end;

{$ENDIF DEBUG}


function KDT34DEVec(const s: string): TKDT34DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT34DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT34DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT34DEVec(const v: TKDT34DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT34DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT34DEPow(const v: TKDT34DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT34DEDistance(const v1, v2: TKDT34DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT34DE_AxisCount - 1 do
      Result := Result + KDT34DEPow(v2[i] - v1[i]);
end;

function KDT34DECmpare(const v1, v2: TKDT34DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT34DE_Vec));
end;

function TKDT34DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DE_Node;
  function SortCompare(const p1, p2: PKDT34DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT34DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT34DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT34DE_SourceBuffer;
  dynBuff  : PKDT34DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT34DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT34DE.SearchStoreBuff(const StoreBuffPtr: PKDT34DEyanmicStoreBuffer; const Buff: TKDT34DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT34DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT34DE.GetData(const index: NativeInt): PKDT34DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT34DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT34DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT34DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT34DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT34DE.StoreBuffPtr: PKDT34DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT34DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT34DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT34DE.BuildKDTreeWithCluster(const inBuff: TKDT34DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT34DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT34DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT34DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT34DE.BuildKDTreeWithCluster(const inBuff: TKDT34DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DE_BuildCall);
var
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DE_BuildMethod);
var
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DE_BuildProc);
var
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT34DE.Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DE_Node;

var
  NearestNeighbour: PKDT34DE_Node;

  function FindParentNode(const BuffPtr: PKDT34DE_Vec; NodePtr: PKDT34DE_Node): PKDT34DE_Node;
  var
    Next       : PKDT34DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT34DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT34DE_Node; const BuffPtr: PKDT34DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT34DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT34DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT34DE_Vec; const p1, p2: PKDT34DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT34DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT34DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT34DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT34DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT34DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT34DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT34DE_Node(NearestNodes[0]);
    end;
end;

function TKDT34DE.Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT34DE.Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double): PKDT34DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT34DE.Search(const Buff: TKDT34DE_Vec): PKDT34DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT34DE.Search(const inBuff: TKDT34DE_DynamicVecBuffer; var OutBuff: TKDT34DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DE_DynamicVecBuffer;
  outBuffPtr : PKDT34DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT34DE_Source));
end;

procedure TKDT34DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT34DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT34DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT34DE.PrintNodeTree(const NodePtr: PKDT34DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT34DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT34DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT34DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT34DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT34DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT34DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT34DE.Test;
var
  TKDT34DE_Test    : TKDT34DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT34DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT34DE_Test := TKDT34DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT34DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT34DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT34DE_AxisCount - 1 do
        TKDT34DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT34DE_Test.TestBuff), length(TKDT34DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT34DE_Test.BuildKDTreeM(False, length(TKDT34DE_Test.TestBuff), @TKDT34DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT34DE_Test.BuildKDTreeM(False, length(TKDT34DE_Test.TestBuff), TKDT34DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT34DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT34DE_Test.TestBuff));
  TKDT34DE_Test.Search(TKDT34DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT34DEDistance(TKDT34DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT34DE_Test.Clear;
  { kMean test }
  TKDT34DE_Test.BuildKDTreeWithCluster(TKDT34DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT34DE_Test.Search(TKDT34DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT34DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT34DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT34DE_Test);
end;

{$ENDIF DEBUG}


function KDT36DEVec(const s: string): TKDT36DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT36DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT36DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT36DEVec(const v: TKDT36DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT36DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT36DEPow(const v: TKDT36DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT36DEDistance(const v1, v2: TKDT36DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT36DE_AxisCount - 1 do
      Result := Result + KDT36DEPow(v2[i] - v1[i]);
end;

function KDT36DECmpare(const v1, v2: TKDT36DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT36DE_Vec));
end;

function TKDT36DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DE_Node;
  function SortCompare(const p1, p2: PKDT36DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT36DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT36DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT36DE_SourceBuffer;
  dynBuff  : PKDT36DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT36DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT36DE.SearchStoreBuff(const StoreBuffPtr: PKDT36DEyanmicStoreBuffer; const Buff: TKDT36DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT36DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT36DE.GetData(const index: NativeInt): PKDT36DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT36DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT36DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT36DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT36DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT36DE.StoreBuffPtr: PKDT36DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT36DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT36DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT36DE.BuildKDTreeWithCluster(const inBuff: TKDT36DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT36DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT36DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT36DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT36DE.BuildKDTreeWithCluster(const inBuff: TKDT36DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DE_BuildCall);
var
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DE_BuildMethod);
var
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DE_BuildProc);
var
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT36DE.Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DE_Node;

var
  NearestNeighbour: PKDT36DE_Node;

  function FindParentNode(const BuffPtr: PKDT36DE_Vec; NodePtr: PKDT36DE_Node): PKDT36DE_Node;
  var
    Next       : PKDT36DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT36DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT36DE_Node; const BuffPtr: PKDT36DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT36DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT36DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT36DE_Vec; const p1, p2: PKDT36DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT36DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT36DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT36DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT36DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT36DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT36DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT36DE_Node(NearestNodes[0]);
    end;
end;

function TKDT36DE.Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT36DE.Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double): PKDT36DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT36DE.Search(const Buff: TKDT36DE_Vec): PKDT36DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT36DE.Search(const inBuff: TKDT36DE_DynamicVecBuffer; var OutBuff: TKDT36DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DE_DynamicVecBuffer;
  outBuffPtr : PKDT36DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT36DE_Source));
end;

procedure TKDT36DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT36DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT36DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT36DE.PrintNodeTree(const NodePtr: PKDT36DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT36DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT36DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT36DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT36DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT36DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT36DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT36DE.Test;
var
  TKDT36DE_Test    : TKDT36DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT36DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT36DE_Test := TKDT36DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT36DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT36DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT36DE_AxisCount - 1 do
        TKDT36DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT36DE_Test.TestBuff), length(TKDT36DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT36DE_Test.BuildKDTreeM(False, length(TKDT36DE_Test.TestBuff), @TKDT36DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT36DE_Test.BuildKDTreeM(False, length(TKDT36DE_Test.TestBuff), TKDT36DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT36DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT36DE_Test.TestBuff));
  TKDT36DE_Test.Search(TKDT36DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT36DEDistance(TKDT36DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT36DE_Test.Clear;
  { kMean test }
  TKDT36DE_Test.BuildKDTreeWithCluster(TKDT36DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT36DE_Test.Search(TKDT36DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT36DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT36DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT36DE_Test);
end;

{$ENDIF DEBUG}


function KDT38DEVec(const s: string): TKDT38DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT38DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT38DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT38DEVec(const v: TKDT38DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT38DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT38DEPow(const v: TKDT38DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT38DEDistance(const v1, v2: TKDT38DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT38DE_AxisCount - 1 do
      Result := Result + KDT38DEPow(v2[i] - v1[i]);
end;

function KDT38DECmpare(const v1, v2: TKDT38DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT38DE_Vec));
end;

function TKDT38DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DE_Node;
  function SortCompare(const p1, p2: PKDT38DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT38DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT38DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT38DE_SourceBuffer;
  dynBuff  : PKDT38DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT38DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT38DE.SearchStoreBuff(const StoreBuffPtr: PKDT38DEyanmicStoreBuffer; const Buff: TKDT38DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT38DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT38DE.GetData(const index: NativeInt): PKDT38DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT38DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT38DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT38DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT38DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT38DE.StoreBuffPtr: PKDT38DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT38DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT38DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT38DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT38DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT38DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT38DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT38DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT38DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT38DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT38DE.BuildKDTreeWithCluster(const inBuff: TKDT38DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT38DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT38DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT38DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT38DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT38DE.BuildKDTreeWithCluster(const inBuff: TKDT38DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT38DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DE_BuildCall);
var
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT38DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT38DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT38DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT38DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT38DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DE_BuildMethod);
var
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT38DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT38DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT38DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT38DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DE_BuildProc);
var
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT38DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT38DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT38DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT38DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT38DE.Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DE_Node;

var
  NearestNeighbour: PKDT38DE_Node;

  function FindParentNode(const BuffPtr: PKDT38DE_Vec; NodePtr: PKDT38DE_Node): PKDT38DE_Node;
  var
    Next       : PKDT38DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT38DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT38DE_Node; const BuffPtr: PKDT38DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT38DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT38DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT38DE_Vec; const p1, p2: PKDT38DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT38DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT38DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT38DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT38DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT38DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT38DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT38DE_Node(NearestNodes[0]);
    end;
end;

function TKDT38DE.Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT38DE.Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double): PKDT38DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT38DE.Search(const Buff: TKDT38DE_Vec): PKDT38DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT38DE.Search(const inBuff: TKDT38DE_DynamicVecBuffer; var OutBuff: TKDT38DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT38DE_DynamicVecBuffer;
  outBuffPtr : PKDT38DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT38DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT38DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT38DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT38DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT38DE_Source));
end;

procedure TKDT38DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT38DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT38DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT38DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT38DE.PrintNodeTree(const NodePtr: PKDT38DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT38DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT38DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT38DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT38DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT38DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT38DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT38DE.Test;
var
  TKDT38DE_Test    : TKDT38DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT38DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT38DE_Test := TKDT38DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT38DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT38DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT38DE_AxisCount - 1 do
        TKDT38DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT38DE_Test.TestBuff), length(TKDT38DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT38DE_Test.BuildKDTreeM(False, length(TKDT38DE_Test.TestBuff), @TKDT38DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT38DE_Test.BuildKDTreeM(False, length(TKDT38DE_Test.TestBuff), TKDT38DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT38DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT38DE_Test.TestBuff));
  TKDT38DE_Test.Search(TKDT38DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT38DEDistance(TKDT38DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT38DE_Test.Clear;
  { kMean test }
  TKDT38DE_Test.BuildKDTreeWithCluster(TKDT38DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT38DE_Test.Search(TKDT38DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT38DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT38DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT38DE_Test);
end;

{$ENDIF DEBUG}


function KDT40DEVec(const s: string): TKDT40DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT40DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT40DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT40DEVec(const v: TKDT40DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT40DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT40DEPow(const v: TKDT40DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT40DEDistance(const v1, v2: TKDT40DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT40DE_AxisCount - 1 do
      Result := Result + KDT40DEPow(v2[i] - v1[i]);
end;

function KDT40DECmpare(const v1, v2: TKDT40DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT40DE_Vec));
end;

function TKDT40DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DE_Node;
  function SortCompare(const p1, p2: PKDT40DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT40DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT40DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT40DE_SourceBuffer;
  dynBuff  : PKDT40DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT40DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT40DE.SearchStoreBuff(const StoreBuffPtr: PKDT40DEyanmicStoreBuffer; const Buff: TKDT40DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT40DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT40DE.GetData(const index: NativeInt): PKDT40DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT40DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT40DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT40DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT40DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT40DE.StoreBuffPtr: PKDT40DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT40DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT40DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT40DE.BuildKDTreeWithCluster(const inBuff: TKDT40DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT40DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT40DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT40DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT40DE.BuildKDTreeWithCluster(const inBuff: TKDT40DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DE_BuildCall);
var
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DE_BuildMethod);
var
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DE_BuildProc);
var
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT40DE.Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DE_Node;

var
  NearestNeighbour: PKDT40DE_Node;

  function FindParentNode(const BuffPtr: PKDT40DE_Vec; NodePtr: PKDT40DE_Node): PKDT40DE_Node;
  var
    Next       : PKDT40DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT40DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT40DE_Node; const BuffPtr: PKDT40DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT40DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT40DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT40DE_Vec; const p1, p2: PKDT40DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT40DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT40DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT40DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT40DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT40DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT40DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT40DE_Node(NearestNodes[0]);
    end;
end;

function TKDT40DE.Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT40DE.Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double): PKDT40DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT40DE.Search(const Buff: TKDT40DE_Vec): PKDT40DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT40DE.Search(const inBuff: TKDT40DE_DynamicVecBuffer; var OutBuff: TKDT40DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DE_DynamicVecBuffer;
  outBuffPtr : PKDT40DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT40DE_Source));
end;

procedure TKDT40DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT40DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT40DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT40DE.PrintNodeTree(const NodePtr: PKDT40DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT40DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT40DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT40DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT40DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT40DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT40DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT40DE.Test;
var
  TKDT40DE_Test    : TKDT40DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT40DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT40DE_Test := TKDT40DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT40DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT40DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT40DE_AxisCount - 1 do
        TKDT40DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT40DE_Test.TestBuff), length(TKDT40DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT40DE_Test.BuildKDTreeM(False, length(TKDT40DE_Test.TestBuff), @TKDT40DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT40DE_Test.BuildKDTreeM(False, length(TKDT40DE_Test.TestBuff), TKDT40DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT40DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT40DE_Test.TestBuff));
  TKDT40DE_Test.Search(TKDT40DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT40DEDistance(TKDT40DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT40DE_Test.Clear;
  { kMean test }
  TKDT40DE_Test.BuildKDTreeWithCluster(TKDT40DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT40DE_Test.Search(TKDT40DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT40DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT40DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT40DE_Test);
end;

{$ENDIF DEBUG}


function KDT44DEVec(const s: string): TKDT44DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT44DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT44DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT44DEVec(const v: TKDT44DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT44DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT44DEPow(const v: TKDT44DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT44DEDistance(const v1, v2: TKDT44DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT44DE_AxisCount - 1 do
      Result := Result + KDT44DEPow(v2[i] - v1[i]);
end;

function KDT44DECmpare(const v1, v2: TKDT44DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT44DE_Vec));
end;

function TKDT44DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DE_Node;
  function SortCompare(const p1, p2: PKDT44DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT44DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT44DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT44DE_SourceBuffer;
  dynBuff  : PKDT44DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT44DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT44DE.SearchStoreBuff(const StoreBuffPtr: PKDT44DEyanmicStoreBuffer; const Buff: TKDT44DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT44DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT44DE.GetData(const index: NativeInt): PKDT44DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT44DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT44DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT44DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT44DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT44DE.StoreBuffPtr: PKDT44DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT44DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT44DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT44DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT44DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT44DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT44DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT44DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT44DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT44DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT44DE.BuildKDTreeWithCluster(const inBuff: TKDT44DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT44DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT44DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT44DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT44DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT44DE.BuildKDTreeWithCluster(const inBuff: TKDT44DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT44DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DE_BuildCall);
var
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT44DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT44DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT44DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT44DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT44DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DE_BuildMethod);
var
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT44DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT44DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT44DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT44DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DE_BuildProc);
var
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT44DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT44DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT44DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT44DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT44DE.Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DE_Node;

var
  NearestNeighbour: PKDT44DE_Node;

  function FindParentNode(const BuffPtr: PKDT44DE_Vec; NodePtr: PKDT44DE_Node): PKDT44DE_Node;
  var
    Next       : PKDT44DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT44DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT44DE_Node; const BuffPtr: PKDT44DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT44DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT44DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT44DE_Vec; const p1, p2: PKDT44DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT44DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT44DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT44DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT44DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT44DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT44DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT44DE_Node(NearestNodes[0]);
    end;
end;

function TKDT44DE.Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT44DE.Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double): PKDT44DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT44DE.Search(const Buff: TKDT44DE_Vec): PKDT44DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT44DE.Search(const inBuff: TKDT44DE_DynamicVecBuffer; var OutBuff: TKDT44DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT44DE_DynamicVecBuffer;
  outBuffPtr : PKDT44DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT44DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT44DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT44DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT44DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT44DE_Source));
end;

procedure TKDT44DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT44DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT44DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT44DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT44DE.PrintNodeTree(const NodePtr: PKDT44DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT44DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT44DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT44DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT44DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT44DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT44DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT44DE.Test;
var
  TKDT44DE_Test    : TKDT44DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT44DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT44DE_Test := TKDT44DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT44DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT44DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT44DE_AxisCount - 1 do
        TKDT44DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT44DE_Test.TestBuff), length(TKDT44DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT44DE_Test.BuildKDTreeM(False, length(TKDT44DE_Test.TestBuff), @TKDT44DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT44DE_Test.BuildKDTreeM(False, length(TKDT44DE_Test.TestBuff), TKDT44DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT44DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT44DE_Test.TestBuff));
  TKDT44DE_Test.Search(TKDT44DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT44DEDistance(TKDT44DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT44DE_Test.Clear;
  { kMean test }
  TKDT44DE_Test.BuildKDTreeWithCluster(TKDT44DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT44DE_Test.Search(TKDT44DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT44DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT44DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT44DE_Test);
end;

{$ENDIF DEBUG}


function KDT48DEVec(const s: string): TKDT48DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT48DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT48DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT48DEVec(const v: TKDT48DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT48DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT48DEPow(const v: TKDT48DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT48DEDistance(const v1, v2: TKDT48DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT48DE_AxisCount - 1 do
      Result := Result + KDT48DEPow(v2[i] - v1[i]);
end;

function KDT48DECmpare(const v1, v2: TKDT48DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT48DE_Vec));
end;

function TKDT48DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DE_Node;
  function SortCompare(const p1, p2: PKDT48DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT48DE_SourceBuffer;
  dynBuff  : PKDT48DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT48DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DE.SearchStoreBuff(const StoreBuffPtr: PKDT48DEyanmicStoreBuffer; const Buff: TKDT48DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT48DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT48DE.GetData(const index: NativeInt): PKDT48DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT48DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DE.StoreBuffPtr: PKDT48DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT48DE.BuildKDTreeWithCluster(const inBuff: TKDT48DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT48DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT48DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT48DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DE.BuildKDTreeWithCluster(const inBuff: TKDT48DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DE_BuildCall);
var
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DE_BuildMethod);
var
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DE_BuildProc);
var
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT48DE.Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DE_Node;

var
  NearestNeighbour: PKDT48DE_Node;

  function FindParentNode(const BuffPtr: PKDT48DE_Vec; NodePtr: PKDT48DE_Node): PKDT48DE_Node;
  var
    Next       : PKDT48DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT48DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DE_Node; const BuffPtr: PKDT48DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT48DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT48DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT48DE_Vec; const p1, p2: PKDT48DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT48DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT48DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT48DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT48DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT48DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DE_Node(NearestNodes[0]);
    end;
end;

function TKDT48DE.Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DE.Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double): PKDT48DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DE.Search(const Buff: TKDT48DE_Vec): PKDT48DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT48DE.Search(const inBuff: TKDT48DE_DynamicVecBuffer; var OutBuff: TKDT48DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DE_DynamicVecBuffer;
  outBuffPtr : PKDT48DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT48DE_Source));
end;

procedure TKDT48DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT48DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT48DE.PrintNodeTree(const NodePtr: PKDT48DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT48DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT48DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT48DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT48DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT48DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT48DE.Test;
var
  TKDT48DE_Test    : TKDT48DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT48DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT48DE_Test := TKDT48DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT48DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT48DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT48DE_AxisCount - 1 do
        TKDT48DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT48DE_Test.TestBuff), length(TKDT48DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT48DE_Test.BuildKDTreeM(False, length(TKDT48DE_Test.TestBuff), @TKDT48DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT48DE_Test.BuildKDTreeM(False, length(TKDT48DE_Test.TestBuff), TKDT48DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT48DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT48DE_Test.TestBuff));
  TKDT48DE_Test.Search(TKDT48DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT48DEDistance(TKDT48DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT48DE_Test.Clear;
  { kMean test }
  TKDT48DE_Test.BuildKDTreeWithCluster(TKDT48DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT48DE_Test.Search(TKDT48DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT48DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT48DE_Test);
end;

{$ENDIF DEBUG}


function KDT50DEVec(const s: string): TKDT50DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT50DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT50DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT50DEVec(const v: TKDT50DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT50DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT50DEPow(const v: TKDT50DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT50DEDistance(const v1, v2: TKDT50DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT50DE_AxisCount - 1 do
      Result := Result + KDT50DEPow(v2[i] - v1[i]);
end;

function KDT50DECmpare(const v1, v2: TKDT50DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT50DE_Vec));
end;

function TKDT50DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DE_Node;
  function SortCompare(const p1, p2: PKDT50DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT50DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT50DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT50DE_SourceBuffer;
  dynBuff  : PKDT50DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT50DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT50DE.SearchStoreBuff(const StoreBuffPtr: PKDT50DEyanmicStoreBuffer; const Buff: TKDT50DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT50DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT50DE.GetData(const index: NativeInt): PKDT50DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT50DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT50DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT50DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT50DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT50DE.StoreBuffPtr: PKDT50DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT50DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT50DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT50DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT50DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT50DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT50DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT50DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT50DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT50DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT50DE.BuildKDTreeWithCluster(const inBuff: TKDT50DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT50DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT50DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT50DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT50DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT50DE.BuildKDTreeWithCluster(const inBuff: TKDT50DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT50DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DE_BuildCall);
var
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT50DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT50DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT50DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT50DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT50DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DE_BuildMethod);
var
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT50DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT50DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT50DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT50DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DE_BuildProc);
var
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT50DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT50DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT50DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT50DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT50DE.Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DE_Node;

var
  NearestNeighbour: PKDT50DE_Node;

  function FindParentNode(const BuffPtr: PKDT50DE_Vec; NodePtr: PKDT50DE_Node): PKDT50DE_Node;
  var
    Next       : PKDT50DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT50DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT50DE_Node; const BuffPtr: PKDT50DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT50DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT50DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT50DE_Vec; const p1, p2: PKDT50DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT50DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT50DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT50DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT50DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT50DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT50DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT50DE_Node(NearestNodes[0]);
    end;
end;

function TKDT50DE.Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT50DE.Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double): PKDT50DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT50DE.Search(const Buff: TKDT50DE_Vec): PKDT50DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT50DE.Search(const inBuff: TKDT50DE_DynamicVecBuffer; var OutBuff: TKDT50DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT50DE_DynamicVecBuffer;
  outBuffPtr : PKDT50DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT50DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT50DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT50DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT50DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT50DE_Source));
end;

procedure TKDT50DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT50DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT50DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT50DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT50DE.PrintNodeTree(const NodePtr: PKDT50DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT50DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT50DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT50DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT50DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT50DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT50DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT50DE.Test;
var
  TKDT50DE_Test    : TKDT50DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT50DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT50DE_Test := TKDT50DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT50DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT50DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT50DE_AxisCount - 1 do
        TKDT50DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT50DE_Test.TestBuff), length(TKDT50DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT50DE_Test.BuildKDTreeM(False, length(TKDT50DE_Test.TestBuff), @TKDT50DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT50DE_Test.BuildKDTreeM(False, length(TKDT50DE_Test.TestBuff), TKDT50DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT50DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT50DE_Test.TestBuff));
  TKDT50DE_Test.Search(TKDT50DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT50DEDistance(TKDT50DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT50DE_Test.Clear;
  { kMean test }
  TKDT50DE_Test.BuildKDTreeWithCluster(TKDT50DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT50DE_Test.Search(TKDT50DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT50DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT50DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT50DE_Test);
end;

{$ENDIF DEBUG}


function KDT56DEVec(const s: string): TKDT56DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT56DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT56DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT56DEVec(const v: TKDT56DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT56DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT56DEPow(const v: TKDT56DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT56DEDistance(const v1, v2: TKDT56DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT56DE_AxisCount - 1 do
      Result := Result + KDT56DEPow(v2[i] - v1[i]);
end;

function KDT56DECmpare(const v1, v2: TKDT56DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT56DE_Vec));
end;

function TKDT56DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DE_Node;
  function SortCompare(const p1, p2: PKDT56DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT56DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT56DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT56DE_SourceBuffer;
  dynBuff  : PKDT56DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT56DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT56DE.SearchStoreBuff(const StoreBuffPtr: PKDT56DEyanmicStoreBuffer; const Buff: TKDT56DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT56DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT56DE.GetData(const index: NativeInt): PKDT56DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT56DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT56DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT56DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT56DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT56DE.StoreBuffPtr: PKDT56DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT56DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT56DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT56DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT56DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT56DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT56DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT56DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT56DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT56DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT56DE.BuildKDTreeWithCluster(const inBuff: TKDT56DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT56DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT56DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT56DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT56DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT56DE.BuildKDTreeWithCluster(const inBuff: TKDT56DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT56DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DE_BuildCall);
var
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT56DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT56DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT56DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT56DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT56DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DE_BuildMethod);
var
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT56DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT56DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT56DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT56DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DE_BuildProc);
var
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT56DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT56DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT56DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT56DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT56DE.Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DE_Node;

var
  NearestNeighbour: PKDT56DE_Node;

  function FindParentNode(const BuffPtr: PKDT56DE_Vec; NodePtr: PKDT56DE_Node): PKDT56DE_Node;
  var
    Next       : PKDT56DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT56DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT56DE_Node; const BuffPtr: PKDT56DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT56DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT56DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT56DE_Vec; const p1, p2: PKDT56DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT56DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT56DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT56DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT56DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT56DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT56DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT56DE_Node(NearestNodes[0]);
    end;
end;

function TKDT56DE.Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT56DE.Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double): PKDT56DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT56DE.Search(const Buff: TKDT56DE_Vec): PKDT56DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT56DE.Search(const inBuff: TKDT56DE_DynamicVecBuffer; var OutBuff: TKDT56DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT56DE_DynamicVecBuffer;
  outBuffPtr : PKDT56DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT56DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT56DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT56DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT56DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT56DE_Source));
end;

procedure TKDT56DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT56DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT56DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT56DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT56DE.PrintNodeTree(const NodePtr: PKDT56DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT56DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT56DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT56DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT56DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT56DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT56DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT56DE.Test;
var
  TKDT56DE_Test    : TKDT56DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT56DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT56DE_Test := TKDT56DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT56DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT56DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT56DE_AxisCount - 1 do
        TKDT56DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT56DE_Test.TestBuff), length(TKDT56DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT56DE_Test.BuildKDTreeM(False, length(TKDT56DE_Test.TestBuff), @TKDT56DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT56DE_Test.BuildKDTreeM(False, length(TKDT56DE_Test.TestBuff), TKDT56DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT56DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT56DE_Test.TestBuff));
  TKDT56DE_Test.Search(TKDT56DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT56DEDistance(TKDT56DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT56DE_Test.Clear;
  { kMean test }
  TKDT56DE_Test.BuildKDTreeWithCluster(TKDT56DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT56DE_Test.Search(TKDT56DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT56DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT56DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT56DE_Test);
end;

{$ENDIF DEBUG}


function KDT60DEVec(const s: string): TKDT60DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT60DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT60DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT60DEVec(const v: TKDT60DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT60DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT60DEPow(const v: TKDT60DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT60DEDistance(const v1, v2: TKDT60DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT60DE_AxisCount - 1 do
      Result := Result + KDT60DEPow(v2[i] - v1[i]);
end;

function KDT60DECmpare(const v1, v2: TKDT60DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT60DE_Vec));
end;

function TKDT60DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DE_Node;
  function SortCompare(const p1, p2: PKDT60DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT60DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT60DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT60DE_SourceBuffer;
  dynBuff  : PKDT60DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT60DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT60DE.SearchStoreBuff(const StoreBuffPtr: PKDT60DEyanmicStoreBuffer; const Buff: TKDT60DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT60DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT60DE.GetData(const index: NativeInt): PKDT60DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT60DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT60DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT60DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT60DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT60DE.StoreBuffPtr: PKDT60DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT60DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT60DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT60DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT60DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT60DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT60DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT60DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT60DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT60DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT60DE.BuildKDTreeWithCluster(const inBuff: TKDT60DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT60DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT60DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT60DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT60DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT60DE.BuildKDTreeWithCluster(const inBuff: TKDT60DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT60DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DE_BuildCall);
var
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT60DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT60DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT60DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT60DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT60DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DE_BuildMethod);
var
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT60DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT60DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT60DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT60DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DE_BuildProc);
var
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT60DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT60DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT60DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT60DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT60DE.Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DE_Node;

var
  NearestNeighbour: PKDT60DE_Node;

  function FindParentNode(const BuffPtr: PKDT60DE_Vec; NodePtr: PKDT60DE_Node): PKDT60DE_Node;
  var
    Next       : PKDT60DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT60DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT60DE_Node; const BuffPtr: PKDT60DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT60DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT60DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT60DE_Vec; const p1, p2: PKDT60DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT60DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT60DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT60DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT60DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT60DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT60DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT60DE_Node(NearestNodes[0]);
    end;
end;

function TKDT60DE.Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT60DE.Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double): PKDT60DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT60DE.Search(const Buff: TKDT60DE_Vec): PKDT60DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT60DE.Search(const inBuff: TKDT60DE_DynamicVecBuffer; var OutBuff: TKDT60DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT60DE_DynamicVecBuffer;
  outBuffPtr : PKDT60DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT60DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT60DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT60DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT60DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT60DE_Source));
end;

procedure TKDT60DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT60DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT60DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT60DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT60DE.PrintNodeTree(const NodePtr: PKDT60DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT60DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT60DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT60DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT60DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT60DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT60DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT60DE.Test;
var
  TKDT60DE_Test    : TKDT60DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT60DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT60DE_Test := TKDT60DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT60DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT60DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT60DE_AxisCount - 1 do
        TKDT60DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT60DE_Test.TestBuff), length(TKDT60DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT60DE_Test.BuildKDTreeM(False, length(TKDT60DE_Test.TestBuff), @TKDT60DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT60DE_Test.BuildKDTreeM(False, length(TKDT60DE_Test.TestBuff), TKDT60DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT60DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT60DE_Test.TestBuff));
  TKDT60DE_Test.Search(TKDT60DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT60DEDistance(TKDT60DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT60DE_Test.Clear;
  { kMean test }
  TKDT60DE_Test.BuildKDTreeWithCluster(TKDT60DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT60DE_Test.Search(TKDT60DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT60DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT60DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT60DE_Test);
end;

{$ENDIF DEBUG}


function KDT64DEVec(const s: string): TKDT64DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT64DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT64DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT64DEVec(const v: TKDT64DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT64DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT64DEPow(const v: TKDT64DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT64DEDistance(const v1, v2: TKDT64DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT64DE_AxisCount - 1 do
      Result := Result + KDT64DEPow(v2[i] - v1[i]);
end;

function KDT64DECmpare(const v1, v2: TKDT64DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT64DE_Vec));
end;

function TKDT64DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DE_Node;
  function SortCompare(const p1, p2: PKDT64DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT64DE_SourceBuffer;
  dynBuff  : PKDT64DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT64DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DE.SearchStoreBuff(const StoreBuffPtr: PKDT64DEyanmicStoreBuffer; const Buff: TKDT64DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT64DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT64DE.GetData(const index: NativeInt): PKDT64DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT64DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DE.StoreBuffPtr: PKDT64DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT64DE.BuildKDTreeWithCluster(const inBuff: TKDT64DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT64DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT64DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT64DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DE.BuildKDTreeWithCluster(const inBuff: TKDT64DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DE_BuildCall);
var
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DE_BuildMethod);
var
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DE_BuildProc);
var
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT64DE.Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DE_Node;

var
  NearestNeighbour: PKDT64DE_Node;

  function FindParentNode(const BuffPtr: PKDT64DE_Vec; NodePtr: PKDT64DE_Node): PKDT64DE_Node;
  var
    Next       : PKDT64DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT64DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DE_Node; const BuffPtr: PKDT64DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT64DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT64DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT64DE_Vec; const p1, p2: PKDT64DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT64DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT64DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT64DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT64DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT64DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DE_Node(NearestNodes[0]);
    end;
end;

function TKDT64DE.Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DE.Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double): PKDT64DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DE.Search(const Buff: TKDT64DE_Vec): PKDT64DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT64DE.Search(const inBuff: TKDT64DE_DynamicVecBuffer; var OutBuff: TKDT64DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DE_DynamicVecBuffer;
  outBuffPtr : PKDT64DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT64DE_Source));
end;

procedure TKDT64DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT64DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT64DE.PrintNodeTree(const NodePtr: PKDT64DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT64DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT64DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT64DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT64DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT64DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT64DE.Test;
var
  TKDT64DE_Test    : TKDT64DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT64DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT64DE_Test := TKDT64DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT64DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT64DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT64DE_AxisCount - 1 do
        TKDT64DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT64DE_Test.TestBuff), length(TKDT64DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT64DE_Test.BuildKDTreeM(False, length(TKDT64DE_Test.TestBuff), @TKDT64DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT64DE_Test.BuildKDTreeM(False, length(TKDT64DE_Test.TestBuff), TKDT64DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT64DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT64DE_Test.TestBuff));
  TKDT64DE_Test.Search(TKDT64DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT64DEDistance(TKDT64DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT64DE_Test.Clear;
  { kMean test }
  TKDT64DE_Test.BuildKDTreeWithCluster(TKDT64DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT64DE_Test.Search(TKDT64DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT64DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT64DE_Test);
end;

{$ENDIF DEBUG}


function KDT72DEVec(const s: string): TKDT72DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT72DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT72DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT72DEVec(const v: TKDT72DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT72DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT72DEPow(const v: TKDT72DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT72DEDistance(const v1, v2: TKDT72DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT72DE_AxisCount - 1 do
      Result := Result + KDT72DEPow(v2[i] - v1[i]);
end;

function KDT72DECmpare(const v1, v2: TKDT72DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT72DE_Vec));
end;

function TKDT72DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DE_Node;
  function SortCompare(const p1, p2: PKDT72DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT72DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT72DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT72DE_SourceBuffer;
  dynBuff  : PKDT72DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT72DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT72DE.SearchStoreBuff(const StoreBuffPtr: PKDT72DEyanmicStoreBuffer; const Buff: TKDT72DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT72DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT72DE.GetData(const index: NativeInt): PKDT72DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT72DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT72DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT72DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT72DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT72DE.StoreBuffPtr: PKDT72DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT72DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT72DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT72DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT72DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT72DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT72DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT72DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT72DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT72DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT72DE.BuildKDTreeWithCluster(const inBuff: TKDT72DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT72DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT72DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT72DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT72DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT72DE.BuildKDTreeWithCluster(const inBuff: TKDT72DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT72DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DE_BuildCall);
var
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT72DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT72DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT72DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT72DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT72DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DE_BuildMethod);
var
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT72DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT72DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT72DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT72DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DE_BuildProc);
var
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT72DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT72DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT72DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT72DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT72DE.Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DE_Node;

var
  NearestNeighbour: PKDT72DE_Node;

  function FindParentNode(const BuffPtr: PKDT72DE_Vec; NodePtr: PKDT72DE_Node): PKDT72DE_Node;
  var
    Next       : PKDT72DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT72DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT72DE_Node; const BuffPtr: PKDT72DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT72DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT72DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT72DE_Vec; const p1, p2: PKDT72DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT72DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT72DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT72DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT72DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT72DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT72DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT72DE_Node(NearestNodes[0]);
    end;
end;

function TKDT72DE.Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT72DE.Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double): PKDT72DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT72DE.Search(const Buff: TKDT72DE_Vec): PKDT72DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT72DE.Search(const inBuff: TKDT72DE_DynamicVecBuffer; var OutBuff: TKDT72DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT72DE_DynamicVecBuffer;
  outBuffPtr : PKDT72DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT72DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT72DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT72DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT72DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT72DE_Source));
end;

procedure TKDT72DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT72DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT72DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT72DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT72DE.PrintNodeTree(const NodePtr: PKDT72DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT72DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT72DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT72DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT72DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT72DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT72DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT72DE.Test;
var
  TKDT72DE_Test    : TKDT72DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT72DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT72DE_Test := TKDT72DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT72DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT72DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT72DE_AxisCount - 1 do
        TKDT72DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT72DE_Test.TestBuff), length(TKDT72DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT72DE_Test.BuildKDTreeM(False, length(TKDT72DE_Test.TestBuff), @TKDT72DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT72DE_Test.BuildKDTreeM(False, length(TKDT72DE_Test.TestBuff), TKDT72DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT72DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT72DE_Test.TestBuff));
  TKDT72DE_Test.Search(TKDT72DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT72DEDistance(TKDT72DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT72DE_Test.Clear;
  { kMean test }
  TKDT72DE_Test.BuildKDTreeWithCluster(TKDT72DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT72DE_Test.Search(TKDT72DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT72DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT72DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT72DE_Test);
end;

{$ENDIF DEBUG}


function KDT84DEVec(const s: string): TKDT84DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT84DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT84DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT84DEVec(const v: TKDT84DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT84DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT84DEPow(const v: TKDT84DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT84DEDistance(const v1, v2: TKDT84DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT84DE_AxisCount - 1 do
      Result := Result + KDT84DEPow(v2[i] - v1[i]);
end;

function KDT84DECmpare(const v1, v2: TKDT84DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT84DE_Vec));
end;

function TKDT84DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DE_Node;
  function SortCompare(const p1, p2: PKDT84DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT84DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT84DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT84DE_SourceBuffer;
  dynBuff  : PKDT84DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT84DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT84DE.SearchStoreBuff(const StoreBuffPtr: PKDT84DEyanmicStoreBuffer; const Buff: TKDT84DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT84DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT84DE.GetData(const index: NativeInt): PKDT84DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT84DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT84DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT84DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT84DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT84DE.StoreBuffPtr: PKDT84DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT84DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT84DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT84DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT84DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT84DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT84DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT84DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT84DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT84DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT84DE.BuildKDTreeWithCluster(const inBuff: TKDT84DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT84DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT84DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT84DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT84DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT84DE.BuildKDTreeWithCluster(const inBuff: TKDT84DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT84DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DE_BuildCall);
var
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT84DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT84DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT84DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT84DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT84DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DE_BuildMethod);
var
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT84DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT84DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT84DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT84DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DE_BuildProc);
var
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT84DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT84DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT84DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT84DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT84DE.Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DE_Node;

var
  NearestNeighbour: PKDT84DE_Node;

  function FindParentNode(const BuffPtr: PKDT84DE_Vec; NodePtr: PKDT84DE_Node): PKDT84DE_Node;
  var
    Next       : PKDT84DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT84DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT84DE_Node; const BuffPtr: PKDT84DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT84DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT84DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT84DE_Vec; const p1, p2: PKDT84DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT84DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT84DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT84DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT84DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT84DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT84DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT84DE_Node(NearestNodes[0]);
    end;
end;

function TKDT84DE.Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT84DE.Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double): PKDT84DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT84DE.Search(const Buff: TKDT84DE_Vec): PKDT84DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT84DE.Search(const inBuff: TKDT84DE_DynamicVecBuffer; var OutBuff: TKDT84DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT84DE_DynamicVecBuffer;
  outBuffPtr : PKDT84DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT84DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT84DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT84DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT84DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT84DE_Source));
end;

procedure TKDT84DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT84DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT84DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT84DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT84DE.PrintNodeTree(const NodePtr: PKDT84DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT84DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT84DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT84DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT84DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT84DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT84DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT84DE.Test;
var
  TKDT84DE_Test    : TKDT84DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT84DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT84DE_Test := TKDT84DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT84DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT84DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT84DE_AxisCount - 1 do
        TKDT84DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT84DE_Test.TestBuff), length(TKDT84DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT84DE_Test.BuildKDTreeM(False, length(TKDT84DE_Test.TestBuff), @TKDT84DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT84DE_Test.BuildKDTreeM(False, length(TKDT84DE_Test.TestBuff), TKDT84DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT84DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT84DE_Test.TestBuff));
  TKDT84DE_Test.Search(TKDT84DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT84DEDistance(TKDT84DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT84DE_Test.Clear;
  { kMean test }
  TKDT84DE_Test.BuildKDTreeWithCluster(TKDT84DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT84DE_Test.Search(TKDT84DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT84DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT84DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT84DE_Test);
end;

{$ENDIF DEBUG}


function KDT96DEVec(const s: string): TKDT96DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT96DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT96DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT96DEVec(const v: TKDT96DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT96DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT96DEPow(const v: TKDT96DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT96DEDistance(const v1, v2: TKDT96DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT96DE_AxisCount - 1 do
      Result := Result + KDT96DEPow(v2[i] - v1[i]);
end;

function KDT96DECmpare(const v1, v2: TKDT96DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT96DE_Vec));
end;

function TKDT96DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DE_Node;
  function SortCompare(const p1, p2: PKDT96DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT96DE_SourceBuffer;
  dynBuff  : PKDT96DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT96DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DE.SearchStoreBuff(const StoreBuffPtr: PKDT96DEyanmicStoreBuffer; const Buff: TKDT96DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT96DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT96DE.GetData(const index: NativeInt): PKDT96DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT96DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DE.StoreBuffPtr: PKDT96DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT96DE.BuildKDTreeWithCluster(const inBuff: TKDT96DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT96DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT96DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT96DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DE.BuildKDTreeWithCluster(const inBuff: TKDT96DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DE_BuildCall);
var
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DE_BuildMethod);
var
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DE_BuildProc);
var
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT96DE.Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DE_Node;

var
  NearestNeighbour: PKDT96DE_Node;

  function FindParentNode(const BuffPtr: PKDT96DE_Vec; NodePtr: PKDT96DE_Node): PKDT96DE_Node;
  var
    Next       : PKDT96DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT96DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DE_Node; const BuffPtr: PKDT96DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT96DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT96DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT96DE_Vec; const p1, p2: PKDT96DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT96DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT96DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT96DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT96DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT96DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DE_Node(NearestNodes[0]);
    end;
end;

function TKDT96DE.Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DE.Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double): PKDT96DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DE.Search(const Buff: TKDT96DE_Vec): PKDT96DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT96DE.Search(const inBuff: TKDT96DE_DynamicVecBuffer; var OutBuff: TKDT96DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DE_DynamicVecBuffer;
  outBuffPtr : PKDT96DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT96DE_Source));
end;

procedure TKDT96DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT96DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT96DE.PrintNodeTree(const NodePtr: PKDT96DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT96DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT96DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT96DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT96DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT96DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT96DE.Test;
var
  TKDT96DE_Test    : TKDT96DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT96DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT96DE_Test := TKDT96DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT96DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT96DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT96DE_AxisCount - 1 do
        TKDT96DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT96DE_Test.TestBuff), length(TKDT96DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT96DE_Test.BuildKDTreeM(False, length(TKDT96DE_Test.TestBuff), @TKDT96DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT96DE_Test.BuildKDTreeM(False, length(TKDT96DE_Test.TestBuff), TKDT96DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT96DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT96DE_Test.TestBuff));
  TKDT96DE_Test.Search(TKDT96DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT96DEDistance(TKDT96DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT96DE_Test.Clear;
  { kMean test }
  TKDT96DE_Test.BuildKDTreeWithCluster(TKDT96DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT96DE_Test.Search(TKDT96DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT96DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT96DE_Test);
end;

{$ENDIF DEBUG}


function KDT128DEVec(const s: string): TKDT128DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT128DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT128DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT128DEVec(const v: TKDT128DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT128DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT128DEPow(const v: TKDT128DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT128DEDistance(const v1, v2: TKDT128DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT128DE_AxisCount - 1 do
      Result := Result + KDT128DEPow(v2[i] - v1[i]);
end;

function KDT128DECmpare(const v1, v2: TKDT128DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT128DE_Vec));
end;

function TKDT128DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DE_Node;
  function SortCompare(const p1, p2: PKDT128DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT128DE_SourceBuffer;
  dynBuff  : PKDT128DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT128DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DE.SearchStoreBuff(const StoreBuffPtr: PKDT128DEyanmicStoreBuffer; const Buff: TKDT128DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT128DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT128DE.GetData(const index: NativeInt): PKDT128DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT128DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DE.StoreBuffPtr: PKDT128DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT128DE.BuildKDTreeWithCluster(const inBuff: TKDT128DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT128DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT128DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT128DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DE.BuildKDTreeWithCluster(const inBuff: TKDT128DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DE_BuildCall);
var
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DE_BuildMethod);
var
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DE_BuildProc);
var
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT128DE.Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DE_Node;

var
  NearestNeighbour: PKDT128DE_Node;

  function FindParentNode(const BuffPtr: PKDT128DE_Vec; NodePtr: PKDT128DE_Node): PKDT128DE_Node;
  var
    Next       : PKDT128DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT128DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DE_Node; const BuffPtr: PKDT128DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT128DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT128DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT128DE_Vec; const p1, p2: PKDT128DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT128DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT128DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT128DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT128DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT128DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DE_Node(NearestNodes[0]);
    end;
end;

function TKDT128DE.Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DE.Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double): PKDT128DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DE.Search(const Buff: TKDT128DE_Vec): PKDT128DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT128DE.Search(const inBuff: TKDT128DE_DynamicVecBuffer; var OutBuff: TKDT128DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DE_DynamicVecBuffer;
  outBuffPtr : PKDT128DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT128DE_Source));
end;

procedure TKDT128DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT128DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT128DE.PrintNodeTree(const NodePtr: PKDT128DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT128DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT128DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT128DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT128DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT128DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT128DE.Test;
var
  TKDT128DE_Test    : TKDT128DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT128DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT128DE_Test := TKDT128DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT128DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT128DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT128DE_AxisCount - 1 do
        TKDT128DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT128DE_Test.TestBuff), length(TKDT128DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT128DE_Test.BuildKDTreeM(False, length(TKDT128DE_Test.TestBuff), @TKDT128DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT128DE_Test.BuildKDTreeM(False, length(TKDT128DE_Test.TestBuff), TKDT128DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT128DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT128DE_Test.TestBuff));
  TKDT128DE_Test.Search(TKDT128DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT128DEDistance(TKDT128DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT128DE_Test.Clear;
  { kMean test }
  TKDT128DE_Test.BuildKDTreeWithCluster(TKDT128DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT128DE_Test.Search(TKDT128DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT128DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT128DE_Test);
end;

{$ENDIF DEBUG}


function KDT140DEVec(const s: string): TKDT140DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT140DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT140DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT140DEVec(const v: TKDT140DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT140DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT140DEPow(const v: TKDT140DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT140DEDistance(const v1, v2: TKDT140DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT140DE_AxisCount - 1 do
      Result := Result + KDT140DEPow(v2[i] - v1[i]);
end;

function KDT140DECmpare(const v1, v2: TKDT140DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT140DE_Vec));
end;

function TKDT140DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DE_Node;
  function SortCompare(const p1, p2: PKDT140DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT140DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT140DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT140DE_SourceBuffer;
  dynBuff  : PKDT140DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT140DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT140DE.SearchStoreBuff(const StoreBuffPtr: PKDT140DEyanmicStoreBuffer; const Buff: TKDT140DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT140DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT140DE.GetData(const index: NativeInt): PKDT140DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT140DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT140DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT140DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT140DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT140DE.StoreBuffPtr: PKDT140DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT140DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT140DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT140DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT140DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT140DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT140DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT140DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT140DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT140DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT140DE.BuildKDTreeWithCluster(const inBuff: TKDT140DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT140DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT140DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT140DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT140DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT140DE.BuildKDTreeWithCluster(const inBuff: TKDT140DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT140DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DE_BuildCall);
var
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT140DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT140DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT140DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT140DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT140DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DE_BuildMethod);
var
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT140DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT140DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT140DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT140DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DE_BuildProc);
var
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT140DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT140DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT140DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT140DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT140DE.Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DE_Node;

var
  NearestNeighbour: PKDT140DE_Node;

  function FindParentNode(const BuffPtr: PKDT140DE_Vec; NodePtr: PKDT140DE_Node): PKDT140DE_Node;
  var
    Next       : PKDT140DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT140DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT140DE_Node; const BuffPtr: PKDT140DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT140DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT140DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT140DE_Vec; const p1, p2: PKDT140DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT140DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT140DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT140DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT140DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT140DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT140DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT140DE_Node(NearestNodes[0]);
    end;
end;

function TKDT140DE.Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT140DE.Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double): PKDT140DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT140DE.Search(const Buff: TKDT140DE_Vec): PKDT140DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT140DE.Search(const inBuff: TKDT140DE_DynamicVecBuffer; var OutBuff: TKDT140DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT140DE_DynamicVecBuffer;
  outBuffPtr : PKDT140DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT140DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT140DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT140DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT140DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT140DE_Source));
end;

procedure TKDT140DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT140DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT140DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT140DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT140DE.PrintNodeTree(const NodePtr: PKDT140DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT140DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT140DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT140DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT140DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT140DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT140DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT140DE.Test;
var
  TKDT140DE_Test    : TKDT140DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT140DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT140DE_Test := TKDT140DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT140DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT140DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT140DE_AxisCount - 1 do
        TKDT140DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT140DE_Test.TestBuff), length(TKDT140DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT140DE_Test.BuildKDTreeM(False, length(TKDT140DE_Test.TestBuff), @TKDT140DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT140DE_Test.BuildKDTreeM(False, length(TKDT140DE_Test.TestBuff), TKDT140DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT140DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT140DE_Test.TestBuff));
  TKDT140DE_Test.Search(TKDT140DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT140DEDistance(TKDT140DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT140DE_Test.Clear;
  { kMean test }
  TKDT140DE_Test.BuildKDTreeWithCluster(TKDT140DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT140DE_Test.Search(TKDT140DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT140DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT140DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT140DE_Test);
end;

{$ENDIF DEBUG}


function KDT160DEVec(const s: string): TKDT160DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT160DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT160DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT160DEVec(const v: TKDT160DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT160DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT160DEPow(const v: TKDT160DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT160DEDistance(const v1, v2: TKDT160DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT160DE_AxisCount - 1 do
      Result := Result + KDT160DEPow(v2[i] - v1[i]);
end;

function KDT160DECmpare(const v1, v2: TKDT160DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT160DE_Vec));
end;

function TKDT160DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DE_Node;
  function SortCompare(const p1, p2: PKDT160DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT160DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT160DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT160DE_SourceBuffer;
  dynBuff  : PKDT160DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT160DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT160DE.SearchStoreBuff(const StoreBuffPtr: PKDT160DEyanmicStoreBuffer; const Buff: TKDT160DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT160DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT160DE.GetData(const index: NativeInt): PKDT160DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT160DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT160DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT160DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT160DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT160DE.StoreBuffPtr: PKDT160DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT160DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT160DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT160DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT160DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT160DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT160DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT160DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT160DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT160DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT160DE.BuildKDTreeWithCluster(const inBuff: TKDT160DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT160DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT160DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT160DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT160DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT160DE.BuildKDTreeWithCluster(const inBuff: TKDT160DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT160DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DE_BuildCall);
var
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT160DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT160DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT160DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT160DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT160DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DE_BuildMethod);
var
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT160DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT160DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT160DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT160DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DE_BuildProc);
var
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT160DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT160DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT160DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT160DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT160DE.Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DE_Node;

var
  NearestNeighbour: PKDT160DE_Node;

  function FindParentNode(const BuffPtr: PKDT160DE_Vec; NodePtr: PKDT160DE_Node): PKDT160DE_Node;
  var
    Next       : PKDT160DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT160DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT160DE_Node; const BuffPtr: PKDT160DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT160DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT160DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT160DE_Vec; const p1, p2: PKDT160DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT160DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT160DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT160DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT160DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT160DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT160DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT160DE_Node(NearestNodes[0]);
    end;
end;

function TKDT160DE.Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT160DE.Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double): PKDT160DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT160DE.Search(const Buff: TKDT160DE_Vec): PKDT160DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT160DE.Search(const inBuff: TKDT160DE_DynamicVecBuffer; var OutBuff: TKDT160DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT160DE_DynamicVecBuffer;
  outBuffPtr : PKDT160DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT160DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT160DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT160DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT160DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT160DE_Source));
end;

procedure TKDT160DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT160DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT160DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT160DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT160DE.PrintNodeTree(const NodePtr: PKDT160DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT160DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT160DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT160DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT160DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT160DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT160DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT160DE.Test;
var
  TKDT160DE_Test    : TKDT160DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT160DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT160DE_Test := TKDT160DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT160DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT160DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT160DE_AxisCount - 1 do
        TKDT160DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT160DE_Test.TestBuff), length(TKDT160DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT160DE_Test.BuildKDTreeM(False, length(TKDT160DE_Test.TestBuff), @TKDT160DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT160DE_Test.BuildKDTreeM(False, length(TKDT160DE_Test.TestBuff), TKDT160DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT160DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT160DE_Test.TestBuff));
  TKDT160DE_Test.Search(TKDT160DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT160DEDistance(TKDT160DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT160DE_Test.Clear;
  { kMean test }
  TKDT160DE_Test.BuildKDTreeWithCluster(TKDT160DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT160DE_Test.Search(TKDT160DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT160DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT160DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT160DE_Test);
end;

{$ENDIF DEBUG}


function KDT196DEVec(const s: string): TKDT196DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT196DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT196DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT196DEVec(const v: TKDT196DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT196DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT196DEPow(const v: TKDT196DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT196DEDistance(const v1, v2: TKDT196DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT196DE_AxisCount - 1 do
      Result := Result + KDT196DEPow(v2[i] - v1[i]);
end;

function KDT196DECmpare(const v1, v2: TKDT196DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT196DE_Vec));
end;

function TKDT196DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DE_Node;
  function SortCompare(const p1, p2: PKDT196DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT196DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT196DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT196DE_SourceBuffer;
  dynBuff  : PKDT196DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT196DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT196DE.SearchStoreBuff(const StoreBuffPtr: PKDT196DEyanmicStoreBuffer; const Buff: TKDT196DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT196DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT196DE.GetData(const index: NativeInt): PKDT196DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT196DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT196DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT196DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT196DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT196DE.StoreBuffPtr: PKDT196DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT196DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT196DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT196DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT196DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT196DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT196DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT196DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT196DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT196DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT196DE.BuildKDTreeWithCluster(const inBuff: TKDT196DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT196DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT196DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT196DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT196DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT196DE.BuildKDTreeWithCluster(const inBuff: TKDT196DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT196DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DE_BuildCall);
var
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT196DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT196DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT196DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT196DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT196DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DE_BuildMethod);
var
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT196DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT196DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT196DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT196DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DE_BuildProc);
var
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT196DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT196DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT196DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT196DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT196DE.Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DE_Node;

var
  NearestNeighbour: PKDT196DE_Node;

  function FindParentNode(const BuffPtr: PKDT196DE_Vec; NodePtr: PKDT196DE_Node): PKDT196DE_Node;
  var
    Next       : PKDT196DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT196DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT196DE_Node; const BuffPtr: PKDT196DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT196DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT196DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT196DE_Vec; const p1, p2: PKDT196DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT196DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT196DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT196DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT196DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT196DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT196DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT196DE_Node(NearestNodes[0]);
    end;
end;

function TKDT196DE.Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT196DE.Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double): PKDT196DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT196DE.Search(const Buff: TKDT196DE_Vec): PKDT196DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT196DE.Search(const inBuff: TKDT196DE_DynamicVecBuffer; var OutBuff: TKDT196DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT196DE_DynamicVecBuffer;
  outBuffPtr : PKDT196DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT196DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT196DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT196DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT196DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT196DE_Source));
end;

procedure TKDT196DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT196DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT196DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT196DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT196DE.PrintNodeTree(const NodePtr: PKDT196DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT196DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT196DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT196DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT196DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT196DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT196DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT196DE.Test;
var
  TKDT196DE_Test    : TKDT196DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT196DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT196DE_Test := TKDT196DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT196DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT196DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT196DE_AxisCount - 1 do
        TKDT196DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT196DE_Test.TestBuff), length(TKDT196DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT196DE_Test.BuildKDTreeM(False, length(TKDT196DE_Test.TestBuff), @TKDT196DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT196DE_Test.BuildKDTreeM(False, length(TKDT196DE_Test.TestBuff), TKDT196DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT196DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT196DE_Test.TestBuff));
  TKDT196DE_Test.Search(TKDT196DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT196DEDistance(TKDT196DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT196DE_Test.Clear;
  { kMean test }
  TKDT196DE_Test.BuildKDTreeWithCluster(TKDT196DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT196DE_Test.Search(TKDT196DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT196DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT196DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT196DE_Test);
end;

{$ENDIF DEBUG}


function KDT256DEVec(const s: string): TKDT256DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT256DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT256DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT256DEVec(const v: TKDT256DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT256DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT256DEPow(const v: TKDT256DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT256DEDistance(const v1, v2: TKDT256DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT256DE_AxisCount - 1 do
      Result := Result + KDT256DEPow(v2[i] - v1[i]);
end;

function KDT256DECmpare(const v1, v2: TKDT256DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT256DE_Vec));
end;

function TKDT256DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DE_Node;
  function SortCompare(const p1, p2: PKDT256DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT256DE_SourceBuffer;
  dynBuff  : PKDT256DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT256DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DE.SearchStoreBuff(const StoreBuffPtr: PKDT256DEyanmicStoreBuffer; const Buff: TKDT256DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT256DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT256DE.GetData(const index: NativeInt): PKDT256DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT256DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DE.StoreBuffPtr: PKDT256DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT256DE.BuildKDTreeWithCluster(const inBuff: TKDT256DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT256DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT256DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT256DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DE.BuildKDTreeWithCluster(const inBuff: TKDT256DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DE_BuildCall);
var
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DE_BuildMethod);
var
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DE_BuildProc);
var
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT256DE.Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DE_Node;

var
  NearestNeighbour: PKDT256DE_Node;

  function FindParentNode(const BuffPtr: PKDT256DE_Vec; NodePtr: PKDT256DE_Node): PKDT256DE_Node;
  var
    Next       : PKDT256DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT256DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DE_Node; const BuffPtr: PKDT256DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT256DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT256DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT256DE_Vec; const p1, p2: PKDT256DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT256DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT256DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT256DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT256DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT256DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DE_Node(NearestNodes[0]);
    end;
end;

function TKDT256DE.Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DE.Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double): PKDT256DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DE.Search(const Buff: TKDT256DE_Vec): PKDT256DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT256DE.Search(const inBuff: TKDT256DE_DynamicVecBuffer; var OutBuff: TKDT256DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DE_DynamicVecBuffer;
  outBuffPtr : PKDT256DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT256DE_Source));
end;

procedure TKDT256DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT256DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT256DE.PrintNodeTree(const NodePtr: PKDT256DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT256DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT256DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT256DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT256DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT256DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT256DE.Test;
var
  TKDT256DE_Test    : TKDT256DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT256DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT256DE_Test := TKDT256DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT256DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT256DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT256DE_AxisCount - 1 do
        TKDT256DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT256DE_Test.TestBuff), length(TKDT256DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT256DE_Test.BuildKDTreeM(False, length(TKDT256DE_Test.TestBuff), @TKDT256DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT256DE_Test.BuildKDTreeM(False, length(TKDT256DE_Test.TestBuff), TKDT256DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT256DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT256DE_Test.TestBuff));
  TKDT256DE_Test.Search(TKDT256DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT256DEDistance(TKDT256DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT256DE_Test.Clear;
  { kMean test }
  TKDT256DE_Test.BuildKDTreeWithCluster(TKDT256DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT256DE_Test.Search(TKDT256DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT256DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT256DE_Test);
end;

{$ENDIF DEBUG}


function KDT272DEVec(const s: string): TKDT272DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT272DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT272DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT272DEVec(const v: TKDT272DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT272DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT272DEPow(const v: TKDT272DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT272DEDistance(const v1, v2: TKDT272DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT272DE_AxisCount - 1 do
      Result := Result + KDT272DEPow(v2[i] - v1[i]);
end;

function KDT272DECmpare(const v1, v2: TKDT272DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT272DE_Vec));
end;

function TKDT272DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DE_Node;
  function SortCompare(const p1, p2: PKDT272DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT272DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT272DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT272DE_SourceBuffer;
  dynBuff  : PKDT272DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT272DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT272DE.SearchStoreBuff(const StoreBuffPtr: PKDT272DEyanmicStoreBuffer; const Buff: TKDT272DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT272DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT272DE.GetData(const index: NativeInt): PKDT272DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT272DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT272DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT272DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT272DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT272DE.StoreBuffPtr: PKDT272DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT272DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT272DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT272DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT272DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT272DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT272DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT272DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT272DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT272DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT272DE.BuildKDTreeWithCluster(const inBuff: TKDT272DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT272DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT272DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT272DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT272DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT272DE.BuildKDTreeWithCluster(const inBuff: TKDT272DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT272DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DE_BuildCall);
var
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT272DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT272DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT272DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT272DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT272DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DE_BuildMethod);
var
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT272DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT272DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT272DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT272DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DE_BuildProc);
var
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT272DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT272DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT272DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT272DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT272DE.Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DE_Node;

var
  NearestNeighbour: PKDT272DE_Node;

  function FindParentNode(const BuffPtr: PKDT272DE_Vec; NodePtr: PKDT272DE_Node): PKDT272DE_Node;
  var
    Next       : PKDT272DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT272DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT272DE_Node; const BuffPtr: PKDT272DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT272DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT272DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT272DE_Vec; const p1, p2: PKDT272DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT272DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT272DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT272DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT272DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT272DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT272DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT272DE_Node(NearestNodes[0]);
    end;
end;

function TKDT272DE.Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT272DE.Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double): PKDT272DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT272DE.Search(const Buff: TKDT272DE_Vec): PKDT272DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT272DE.Search(const inBuff: TKDT272DE_DynamicVecBuffer; var OutBuff: TKDT272DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT272DE_DynamicVecBuffer;
  outBuffPtr : PKDT272DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT272DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT272DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT272DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT272DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT272DE_Source));
end;

procedure TKDT272DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT272DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT272DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT272DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT272DE.PrintNodeTree(const NodePtr: PKDT272DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT272DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT272DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT272DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT272DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT272DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT272DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT272DE.Test;
var
  TKDT272DE_Test    : TKDT272DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT272DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT272DE_Test := TKDT272DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT272DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT272DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT272DE_AxisCount - 1 do
        TKDT272DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT272DE_Test.TestBuff), length(TKDT272DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT272DE_Test.BuildKDTreeM(False, length(TKDT272DE_Test.TestBuff), @TKDT272DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT272DE_Test.BuildKDTreeM(False, length(TKDT272DE_Test.TestBuff), TKDT272DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT272DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT272DE_Test.TestBuff));
  TKDT272DE_Test.Search(TKDT272DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT272DEDistance(TKDT272DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT272DE_Test.Clear;
  { kMean test }
  TKDT272DE_Test.BuildKDTreeWithCluster(TKDT272DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT272DE_Test.Search(TKDT272DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT272DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT272DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT272DE_Test);
end;

{$ENDIF DEBUG}


function KDT288DEVec(const s: string): TKDT288DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT288DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT288DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT288DEVec(const v: TKDT288DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT288DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT288DEPow(const v: TKDT288DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT288DEDistance(const v1, v2: TKDT288DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT288DE_AxisCount - 1 do
      Result := Result + KDT288DEPow(v2[i] - v1[i]);
end;

function KDT288DECmpare(const v1, v2: TKDT288DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT288DE_Vec));
end;

function TKDT288DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DE_Node;
  function SortCompare(const p1, p2: PKDT288DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT288DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT288DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT288DE_SourceBuffer;
  dynBuff  : PKDT288DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT288DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT288DE.SearchStoreBuff(const StoreBuffPtr: PKDT288DEyanmicStoreBuffer; const Buff: TKDT288DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT288DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT288DE.GetData(const index: NativeInt): PKDT288DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT288DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT288DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT288DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT288DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT288DE.StoreBuffPtr: PKDT288DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT288DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT288DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT288DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT288DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT288DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT288DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT288DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT288DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT288DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT288DE.BuildKDTreeWithCluster(const inBuff: TKDT288DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT288DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT288DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT288DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT288DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT288DE.BuildKDTreeWithCluster(const inBuff: TKDT288DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT288DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DE_BuildCall);
var
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT288DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT288DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT288DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT288DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT288DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DE_BuildMethod);
var
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT288DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT288DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT288DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT288DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DE_BuildProc);
var
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT288DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT288DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT288DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT288DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT288DE.Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DE_Node;

var
  NearestNeighbour: PKDT288DE_Node;

  function FindParentNode(const BuffPtr: PKDT288DE_Vec; NodePtr: PKDT288DE_Node): PKDT288DE_Node;
  var
    Next       : PKDT288DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT288DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT288DE_Node; const BuffPtr: PKDT288DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT288DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT288DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT288DE_Vec; const p1, p2: PKDT288DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT288DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT288DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT288DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT288DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT288DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT288DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT288DE_Node(NearestNodes[0]);
    end;
end;

function TKDT288DE.Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT288DE.Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double): PKDT288DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT288DE.Search(const Buff: TKDT288DE_Vec): PKDT288DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT288DE.Search(const inBuff: TKDT288DE_DynamicVecBuffer; var OutBuff: TKDT288DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT288DE_DynamicVecBuffer;
  outBuffPtr : PKDT288DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT288DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT288DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT288DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT288DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT288DE_Source));
end;

procedure TKDT288DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT288DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT288DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT288DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT288DE.PrintNodeTree(const NodePtr: PKDT288DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT288DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT288DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT288DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT288DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT288DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT288DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT288DE.Test;
var
  TKDT288DE_Test    : TKDT288DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT288DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT288DE_Test := TKDT288DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT288DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT288DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT288DE_AxisCount - 1 do
        TKDT288DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT288DE_Test.TestBuff), length(TKDT288DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT288DE_Test.BuildKDTreeM(False, length(TKDT288DE_Test.TestBuff), @TKDT288DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT288DE_Test.BuildKDTreeM(False, length(TKDT288DE_Test.TestBuff), TKDT288DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT288DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT288DE_Test.TestBuff));
  TKDT288DE_Test.Search(TKDT288DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT288DEDistance(TKDT288DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT288DE_Test.Clear;
  { kMean test }
  TKDT288DE_Test.BuildKDTreeWithCluster(TKDT288DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT288DE_Test.Search(TKDT288DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT288DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT288DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT288DE_Test);
end;

{$ENDIF DEBUG}


function KDT372DEVec(const s: string): TKDT372DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT372DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT372DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT372DEVec(const v: TKDT372DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT372DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT372DEPow(const v: TKDT372DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT372DEDistance(const v1, v2: TKDT372DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT372DE_AxisCount - 1 do
      Result := Result + KDT372DEPow(v2[i] - v1[i]);
end;

function KDT372DECmpare(const v1, v2: TKDT372DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT372DE_Vec));
end;

function TKDT372DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DE_Node;
  function SortCompare(const p1, p2: PKDT372DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT372DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT372DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT372DE_SourceBuffer;
  dynBuff  : PKDT372DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT372DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT372DE.SearchStoreBuff(const StoreBuffPtr: PKDT372DEyanmicStoreBuffer; const Buff: TKDT372DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT372DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT372DE.GetData(const index: NativeInt): PKDT372DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT372DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT372DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT372DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT372DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT372DE.StoreBuffPtr: PKDT372DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT372DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT372DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT372DE.BuildKDTreeWithCluster(const inBuff: TKDT372DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT372DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT372DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT372DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT372DE.BuildKDTreeWithCluster(const inBuff: TKDT372DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DE_BuildCall);
var
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DE_BuildMethod);
var
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DE_BuildProc);
var
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT372DE.Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DE_Node;

var
  NearestNeighbour: PKDT372DE_Node;

  function FindParentNode(const BuffPtr: PKDT372DE_Vec; NodePtr: PKDT372DE_Node): PKDT372DE_Node;
  var
    Next       : PKDT372DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT372DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT372DE_Node; const BuffPtr: PKDT372DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT372DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT372DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT372DE_Vec; const p1, p2: PKDT372DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT372DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT372DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT372DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT372DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT372DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT372DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT372DE_Node(NearestNodes[0]);
    end;
end;

function TKDT372DE.Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT372DE.Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double): PKDT372DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT372DE.Search(const Buff: TKDT372DE_Vec): PKDT372DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT372DE.Search(const inBuff: TKDT372DE_DynamicVecBuffer; var OutBuff: TKDT372DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DE_DynamicVecBuffer;
  outBuffPtr : PKDT372DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT372DE_Source));
end;

procedure TKDT372DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT372DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT372DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT372DE.PrintNodeTree(const NodePtr: PKDT372DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT372DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT372DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT372DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT372DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT372DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT372DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT372DE.Test;
var
  TKDT372DE_Test    : TKDT372DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT372DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT372DE_Test := TKDT372DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT372DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT372DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT372DE_AxisCount - 1 do
        TKDT372DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT372DE_Test.TestBuff), length(TKDT372DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT372DE_Test.BuildKDTreeM(False, length(TKDT372DE_Test.TestBuff), @TKDT372DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT372DE_Test.BuildKDTreeM(False, length(TKDT372DE_Test.TestBuff), TKDT372DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT372DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT372DE_Test.TestBuff));
  TKDT372DE_Test.Search(TKDT372DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT372DEDistance(TKDT372DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT372DE_Test.Clear;
  { kMean test }
  TKDT372DE_Test.BuildKDTreeWithCluster(TKDT372DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT372DE_Test.Search(TKDT372DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT372DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT372DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT372DE_Test);
end;

{$ENDIF DEBUG}


function KDT512DEVec(const s: string): TKDT512DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT512DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT512DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT512DEVec(const v: TKDT512DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT512DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT512DEPow(const v: TKDT512DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT512DEDistance(const v1, v2: TKDT512DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT512DE_AxisCount - 1 do
      Result := Result + KDT512DEPow(v2[i] - v1[i]);
end;

function KDT512DECmpare(const v1, v2: TKDT512DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT512DE_Vec));
end;

function TKDT512DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DE_Node;
  function SortCompare(const p1, p2: PKDT512DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT512DE_SourceBuffer;
  dynBuff  : PKDT512DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT512DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DE.SearchStoreBuff(const StoreBuffPtr: PKDT512DEyanmicStoreBuffer; const Buff: TKDT512DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT512DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT512DE.GetData(const index: NativeInt): PKDT512DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT512DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DE.StoreBuffPtr: PKDT512DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT512DE.BuildKDTreeWithCluster(const inBuff: TKDT512DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT512DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT512DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT512DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DE.BuildKDTreeWithCluster(const inBuff: TKDT512DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DE_BuildCall);
var
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DE_BuildMethod);
var
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DE_BuildProc);
var
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT512DE.Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DE_Node;

var
  NearestNeighbour: PKDT512DE_Node;

  function FindParentNode(const BuffPtr: PKDT512DE_Vec; NodePtr: PKDT512DE_Node): PKDT512DE_Node;
  var
    Next       : PKDT512DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT512DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DE_Node; const BuffPtr: PKDT512DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT512DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT512DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT512DE_Vec; const p1, p2: PKDT512DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT512DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT512DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT512DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT512DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT512DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DE_Node(NearestNodes[0]);
    end;
end;

function TKDT512DE.Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DE.Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double): PKDT512DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DE.Search(const Buff: TKDT512DE_Vec): PKDT512DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT512DE.Search(const inBuff: TKDT512DE_DynamicVecBuffer; var OutBuff: TKDT512DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DE_DynamicVecBuffer;
  outBuffPtr : PKDT512DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT512DE_Source));
end;

procedure TKDT512DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT512DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT512DE.PrintNodeTree(const NodePtr: PKDT512DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT512DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT512DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT512DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT512DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT512DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT512DE.Test;
var
  TKDT512DE_Test    : TKDT512DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT512DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT512DE_Test := TKDT512DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT512DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT512DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT512DE_AxisCount - 1 do
        TKDT512DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT512DE_Test.TestBuff), length(TKDT512DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT512DE_Test.BuildKDTreeM(False, length(TKDT512DE_Test.TestBuff), @TKDT512DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT512DE_Test.BuildKDTreeM(False, length(TKDT512DE_Test.TestBuff), TKDT512DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT512DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT512DE_Test.TestBuff));
  TKDT512DE_Test.Search(TKDT512DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT512DEDistance(TKDT512DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT512DE_Test.Clear;
  { kMean test }
  TKDT512DE_Test.BuildKDTreeWithCluster(TKDT512DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT512DE_Test.Search(TKDT512DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT512DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT512DE_Test);
end;

{$ENDIF DEBUG}


function KDT576DEVec(const s: string): TKDT576DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT576DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT576DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT576DEVec(const v: TKDT576DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT576DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT576DEPow(const v: TKDT576DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT576DEDistance(const v1, v2: TKDT576DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT576DE_AxisCount - 1 do
      Result := Result + KDT576DEPow(v2[i] - v1[i]);
end;

function KDT576DECmpare(const v1, v2: TKDT576DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT576DE_Vec));
end;

function TKDT576DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DE_Node;
  function SortCompare(const p1, p2: PKDT576DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT576DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT576DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT576DE_SourceBuffer;
  dynBuff  : PKDT576DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT576DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT576DE.SearchStoreBuff(const StoreBuffPtr: PKDT576DEyanmicStoreBuffer; const Buff: TKDT576DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT576DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT576DE.GetData(const index: NativeInt): PKDT576DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT576DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT576DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT576DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT576DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT576DE.StoreBuffPtr: PKDT576DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT576DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT576DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT576DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT576DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT576DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT576DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT576DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT576DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT576DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT576DE.BuildKDTreeWithCluster(const inBuff: TKDT576DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT576DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT576DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT576DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT576DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT576DE.BuildKDTreeWithCluster(const inBuff: TKDT576DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT576DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DE_BuildCall);
var
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT576DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT576DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT576DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT576DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT576DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DE_BuildMethod);
var
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT576DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT576DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT576DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT576DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DE_BuildProc);
var
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT576DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT576DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT576DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT576DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT576DE.Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DE_Node;

var
  NearestNeighbour: PKDT576DE_Node;

  function FindParentNode(const BuffPtr: PKDT576DE_Vec; NodePtr: PKDT576DE_Node): PKDT576DE_Node;
  var
    Next       : PKDT576DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT576DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT576DE_Node; const BuffPtr: PKDT576DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT576DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT576DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT576DE_Vec; const p1, p2: PKDT576DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT576DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT576DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT576DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT576DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT576DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT576DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT576DE_Node(NearestNodes[0]);
    end;
end;

function TKDT576DE.Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT576DE.Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double): PKDT576DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT576DE.Search(const Buff: TKDT576DE_Vec): PKDT576DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT576DE.Search(const inBuff: TKDT576DE_DynamicVecBuffer; var OutBuff: TKDT576DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT576DE_DynamicVecBuffer;
  outBuffPtr : PKDT576DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT576DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT576DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT576DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT576DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT576DE_Source));
end;

procedure TKDT576DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT576DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT576DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT576DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT576DE.PrintNodeTree(const NodePtr: PKDT576DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT576DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT576DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT576DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT576DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT576DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT576DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT576DE.Test;
var
  TKDT576DE_Test    : TKDT576DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT576DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT576DE_Test := TKDT576DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT576DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT576DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT576DE_AxisCount - 1 do
        TKDT576DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT576DE_Test.TestBuff), length(TKDT576DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT576DE_Test.BuildKDTreeM(False, length(TKDT576DE_Test.TestBuff), @TKDT576DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT576DE_Test.BuildKDTreeM(False, length(TKDT576DE_Test.TestBuff), TKDT576DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT576DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT576DE_Test.TestBuff));
  TKDT576DE_Test.Search(TKDT576DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT576DEDistance(TKDT576DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT576DE_Test.Clear;
  { kMean test }
  TKDT576DE_Test.BuildKDTreeWithCluster(TKDT576DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT576DE_Test.Search(TKDT576DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT576DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT576DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT576DE_Test);
end;

{$ENDIF DEBUG}


function KDT768DEVec(const s: string): TKDT768DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT768DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT768DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT768DEVec(const v: TKDT768DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT768DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT768DEPow(const v: TKDT768DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT768DEDistance(const v1, v2: TKDT768DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT768DE_AxisCount - 1 do
      Result := Result + KDT768DEPow(v2[i] - v1[i]);
end;

function KDT768DECmpare(const v1, v2: TKDT768DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT768DE_Vec));
end;

function TKDT768DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DE_Node;
  function SortCompare(const p1, p2: PKDT768DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT768DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT768DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT768DE_SourceBuffer;
  dynBuff  : PKDT768DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT768DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT768DE.SearchStoreBuff(const StoreBuffPtr: PKDT768DEyanmicStoreBuffer; const Buff: TKDT768DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT768DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT768DE.GetData(const index: NativeInt): PKDT768DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT768DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT768DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT768DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT768DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT768DE.StoreBuffPtr: PKDT768DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT768DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT768DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT768DE.BuildKDTreeWithCluster(const inBuff: TKDT768DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT768DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT768DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT768DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT768DE.BuildKDTreeWithCluster(const inBuff: TKDT768DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DE_BuildCall);
var
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DE_BuildMethod);
var
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DE_BuildProc);
var
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT768DE.Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DE_Node;

var
  NearestNeighbour: PKDT768DE_Node;

  function FindParentNode(const BuffPtr: PKDT768DE_Vec; NodePtr: PKDT768DE_Node): PKDT768DE_Node;
  var
    Next       : PKDT768DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT768DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT768DE_Node; const BuffPtr: PKDT768DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT768DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT768DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT768DE_Vec; const p1, p2: PKDT768DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT768DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT768DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT768DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT768DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT768DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT768DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT768DE_Node(NearestNodes[0]);
    end;
end;

function TKDT768DE.Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT768DE.Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double): PKDT768DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT768DE.Search(const Buff: TKDT768DE_Vec): PKDT768DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT768DE.Search(const inBuff: TKDT768DE_DynamicVecBuffer; var OutBuff: TKDT768DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DE_DynamicVecBuffer;
  outBuffPtr : PKDT768DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT768DE_Source));
end;

procedure TKDT768DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT768DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT768DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT768DE.PrintNodeTree(const NodePtr: PKDT768DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT768DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT768DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT768DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT768DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT768DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT768DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT768DE.Test;
var
  TKDT768DE_Test    : TKDT768DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT768DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT768DE_Test := TKDT768DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT768DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT768DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT768DE_AxisCount - 1 do
        TKDT768DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT768DE_Test.TestBuff), length(TKDT768DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT768DE_Test.BuildKDTreeM(False, length(TKDT768DE_Test.TestBuff), @TKDT768DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT768DE_Test.BuildKDTreeM(False, length(TKDT768DE_Test.TestBuff), TKDT768DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT768DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT768DE_Test.TestBuff));
  TKDT768DE_Test.Search(TKDT768DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT768DEDistance(TKDT768DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT768DE_Test.Clear;
  { kMean test }
  TKDT768DE_Test.BuildKDTreeWithCluster(TKDT768DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT768DE_Test.Search(TKDT768DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT768DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT768DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT768DE_Test);
end;

{$ENDIF DEBUG}


function KDT1024DEVec(const s: string): TKDT1024DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1024DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1024DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1024DEVec(const v: TKDT1024DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1024DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1024DEPow(const v: TKDT1024DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT1024DEDistance(const v1, v2: TKDT1024DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1024DE_AxisCount - 1 do
      Result := Result + KDT1024DEPow(v2[i] - v1[i]);
end;

function KDT1024DECmpare(const v1, v2: TKDT1024DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1024DE_Vec));
end;

function TKDT1024DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DE_Node;
  function SortCompare(const p1, p2: PKDT1024DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1024DE_SourceBuffer;
  dynBuff  : PKDT1024DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1024DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DE.SearchStoreBuff(const StoreBuffPtr: PKDT1024DEyanmicStoreBuffer; const Buff: TKDT1024DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1024DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1024DE.GetData(const index: NativeInt): PKDT1024DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1024DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DE.StoreBuffPtr: PKDT1024DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1024DE.BuildKDTreeWithCluster(const inBuff: TKDT1024DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1024DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1024DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1024DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DE.BuildKDTreeWithCluster(const inBuff: TKDT1024DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DE_BuildCall);
var
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DE_BuildMethod);
var
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DE_BuildProc);
var
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1024DE.Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DE_Node;

var
  NearestNeighbour: PKDT1024DE_Node;

  function FindParentNode(const BuffPtr: PKDT1024DE_Vec; NodePtr: PKDT1024DE_Node): PKDT1024DE_Node;
  var
    Next       : PKDT1024DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1024DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DE_Node; const BuffPtr: PKDT1024DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1024DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1024DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1024DE_Vec; const p1, p2: PKDT1024DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1024DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1024DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1024DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1024DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1024DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DE.Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DE.Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double): PKDT1024DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DE.Search(const Buff: TKDT1024DE_Vec): PKDT1024DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1024DE.Search(const inBuff: TKDT1024DE_DynamicVecBuffer; var OutBuff: TKDT1024DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DE_DynamicVecBuffer;
  outBuffPtr : PKDT1024DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1024DE_Source));
end;

procedure TKDT1024DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1024DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1024DE.PrintNodeTree(const NodePtr: PKDT1024DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1024DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1024DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1024DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1024DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1024DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1024DE.Test;
var
  TKDT1024DE_Test    : TKDT1024DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1024DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1024DE_Test := TKDT1024DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1024DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT1024DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT1024DE_AxisCount - 1 do
        TKDT1024DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1024DE_Test.TestBuff), length(TKDT1024DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1024DE_Test.BuildKDTreeM(False, length(TKDT1024DE_Test.TestBuff), @TKDT1024DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1024DE_Test.BuildKDTreeM(False, length(TKDT1024DE_Test.TestBuff), TKDT1024DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1024DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1024DE_Test.TestBuff));
  TKDT1024DE_Test.Search(TKDT1024DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1024DEDistance(TKDT1024DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1024DE_Test.Clear;
  { kMean test }
  TKDT1024DE_Test.BuildKDTreeWithCluster(TKDT1024DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1024DE_Test.Search(TKDT1024DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1024DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1024DE_Test);
end;

{$ENDIF DEBUG}


function KDT1040DEVec(const s: string): TKDT1040DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1040DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1040DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1040DEVec(const v: TKDT1040DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1040DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1040DEPow(const v: TKDT1040DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT1040DEDistance(const v1, v2: TKDT1040DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1040DE_AxisCount - 1 do
      Result := Result + KDT1040DEPow(v2[i] - v1[i]);
end;

function KDT1040DECmpare(const v1, v2: TKDT1040DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1040DE_Vec));
end;

function TKDT1040DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DE_Node;
  function SortCompare(const p1, p2: PKDT1040DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1040DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1040DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1040DE_SourceBuffer;
  dynBuff  : PKDT1040DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1040DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1040DE.SearchStoreBuff(const StoreBuffPtr: PKDT1040DEyanmicStoreBuffer; const Buff: TKDT1040DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1040DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1040DE.GetData(const index: NativeInt): PKDT1040DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1040DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1040DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1040DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1040DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1040DE.StoreBuffPtr: PKDT1040DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1040DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1040DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1040DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1040DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1040DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1040DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1040DE.BuildKDTreeWithCluster(const inBuff: TKDT1040DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1040DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1040DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1040DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1040DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1040DE.BuildKDTreeWithCluster(const inBuff: TKDT1040DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1040DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DE_BuildCall);
var
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1040DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1040DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1040DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1040DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1040DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DE_BuildMethod);
var
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1040DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1040DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1040DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1040DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DE_BuildProc);
var
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1040DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1040DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1040DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1040DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1040DE.Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DE_Node;

var
  NearestNeighbour: PKDT1040DE_Node;

  function FindParentNode(const BuffPtr: PKDT1040DE_Vec; NodePtr: PKDT1040DE_Node): PKDT1040DE_Node;
  var
    Next       : PKDT1040DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1040DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1040DE_Node; const BuffPtr: PKDT1040DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1040DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1040DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1040DE_Vec; const p1, p2: PKDT1040DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1040DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1040DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1040DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1040DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1040DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1040DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1040DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1040DE.Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1040DE.Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double): PKDT1040DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1040DE.Search(const Buff: TKDT1040DE_Vec): PKDT1040DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1040DE.Search(const inBuff: TKDT1040DE_DynamicVecBuffer; var OutBuff: TKDT1040DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1040DE_DynamicVecBuffer;
  outBuffPtr : PKDT1040DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1040DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1040DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1040DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1040DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1040DE_Source));
end;

procedure TKDT1040DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1040DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1040DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1040DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1040DE.PrintNodeTree(const NodePtr: PKDT1040DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1040DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1040DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1040DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1040DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1040DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1040DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1040DE.Test;
var
  TKDT1040DE_Test    : TKDT1040DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1040DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1040DE_Test := TKDT1040DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1040DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT1040DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT1040DE_AxisCount - 1 do
        TKDT1040DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1040DE_Test.TestBuff), length(TKDT1040DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1040DE_Test.BuildKDTreeM(False, length(TKDT1040DE_Test.TestBuff), @TKDT1040DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1040DE_Test.BuildKDTreeM(False, length(TKDT1040DE_Test.TestBuff), TKDT1040DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1040DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1040DE_Test.TestBuff));
  TKDT1040DE_Test.Search(TKDT1040DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1040DEDistance(TKDT1040DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1040DE_Test.Clear;
  { kMean test }
  TKDT1040DE_Test.BuildKDTreeWithCluster(TKDT1040DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1040DE_Test.Search(TKDT1040DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1040DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1040DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1040DE_Test);
end;

{$ENDIF DEBUG}


function KDT1056DEVec(const s: string): TKDT1056DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1056DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1056DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1056DEVec(const v: TKDT1056DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1056DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1056DEPow(const v: TKDT1056DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT1056DEDistance(const v1, v2: TKDT1056DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1056DE_AxisCount - 1 do
      Result := Result + KDT1056DEPow(v2[i] - v1[i]);
end;

function KDT1056DECmpare(const v1, v2: TKDT1056DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1056DE_Vec));
end;

function TKDT1056DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DE_Node;
  function SortCompare(const p1, p2: PKDT1056DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1056DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1056DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1056DE_SourceBuffer;
  dynBuff  : PKDT1056DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1056DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1056DE.SearchStoreBuff(const StoreBuffPtr: PKDT1056DEyanmicStoreBuffer; const Buff: TKDT1056DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1056DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1056DE.GetData(const index: NativeInt): PKDT1056DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1056DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1056DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1056DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1056DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1056DE.StoreBuffPtr: PKDT1056DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1056DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1056DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1056DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1056DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1056DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1056DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1056DE.BuildKDTreeWithCluster(const inBuff: TKDT1056DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1056DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1056DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1056DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1056DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1056DE.BuildKDTreeWithCluster(const inBuff: TKDT1056DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1056DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DE_BuildCall);
var
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1056DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1056DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1056DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1056DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1056DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DE_BuildMethod);
var
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1056DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1056DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1056DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1056DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DE_BuildProc);
var
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1056DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1056DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1056DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1056DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1056DE.Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DE_Node;

var
  NearestNeighbour: PKDT1056DE_Node;

  function FindParentNode(const BuffPtr: PKDT1056DE_Vec; NodePtr: PKDT1056DE_Node): PKDT1056DE_Node;
  var
    Next       : PKDT1056DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1056DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1056DE_Node; const BuffPtr: PKDT1056DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1056DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1056DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1056DE_Vec; const p1, p2: PKDT1056DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1056DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1056DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1056DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1056DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1056DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1056DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1056DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1056DE.Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1056DE.Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double): PKDT1056DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1056DE.Search(const Buff: TKDT1056DE_Vec): PKDT1056DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1056DE.Search(const inBuff: TKDT1056DE_DynamicVecBuffer; var OutBuff: TKDT1056DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1056DE_DynamicVecBuffer;
  outBuffPtr : PKDT1056DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1056DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1056DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1056DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1056DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1056DE_Source));
end;

procedure TKDT1056DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1056DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1056DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1056DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1056DE.PrintNodeTree(const NodePtr: PKDT1056DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1056DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1056DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1056DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1056DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1056DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1056DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1056DE.Test;
var
  TKDT1056DE_Test    : TKDT1056DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1056DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1056DE_Test := TKDT1056DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1056DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT1056DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT1056DE_AxisCount - 1 do
        TKDT1056DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1056DE_Test.TestBuff), length(TKDT1056DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1056DE_Test.BuildKDTreeM(False, length(TKDT1056DE_Test.TestBuff), @TKDT1056DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1056DE_Test.BuildKDTreeM(False, length(TKDT1056DE_Test.TestBuff), TKDT1056DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1056DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1056DE_Test.TestBuff));
  TKDT1056DE_Test.Search(TKDT1056DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1056DEDistance(TKDT1056DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1056DE_Test.Clear;
  { kMean test }
  TKDT1056DE_Test.BuildKDTreeWithCluster(TKDT1056DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1056DE_Test.Search(TKDT1056DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1056DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1056DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1056DE_Test);
end;

{$ENDIF DEBUG}


function KDT1536DEVec(const s: string): TKDT1536DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1536DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1536DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1536DEVec(const v: TKDT1536DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1536DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1536DEPow(const v: TKDT1536DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT1536DEDistance(const v1, v2: TKDT1536DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1536DE_AxisCount - 1 do
      Result := Result + KDT1536DEPow(v2[i] - v1[i]);
end;

function KDT1536DECmpare(const v1, v2: TKDT1536DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1536DE_Vec));
end;

function TKDT1536DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DE_Node;
  function SortCompare(const p1, p2: PKDT1536DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1536DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1536DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1536DE_SourceBuffer;
  dynBuff  : PKDT1536DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1536DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1536DE.SearchStoreBuff(const StoreBuffPtr: PKDT1536DEyanmicStoreBuffer; const Buff: TKDT1536DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1536DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1536DE.GetData(const index: NativeInt): PKDT1536DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1536DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1536DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1536DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1536DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1536DE.StoreBuffPtr: PKDT1536DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1536DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1536DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1536DE.BuildKDTreeWithCluster(const inBuff: TKDT1536DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1536DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1536DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1536DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1536DE.BuildKDTreeWithCluster(const inBuff: TKDT1536DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DE_BuildCall);
var
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DE_BuildMethod);
var
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DE_BuildProc);
var
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1536DE.Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DE_Node;

var
  NearestNeighbour: PKDT1536DE_Node;

  function FindParentNode(const BuffPtr: PKDT1536DE_Vec; NodePtr: PKDT1536DE_Node): PKDT1536DE_Node;
  var
    Next       : PKDT1536DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1536DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1536DE_Node; const BuffPtr: PKDT1536DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1536DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1536DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1536DE_Vec; const p1, p2: PKDT1536DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1536DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1536DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1536DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1536DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1536DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1536DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1536DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1536DE.Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1536DE.Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double): PKDT1536DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1536DE.Search(const Buff: TKDT1536DE_Vec): PKDT1536DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1536DE.Search(const inBuff: TKDT1536DE_DynamicVecBuffer; var OutBuff: TKDT1536DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DE_DynamicVecBuffer;
  outBuffPtr : PKDT1536DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1536DE_Source));
end;

procedure TKDT1536DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1536DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1536DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1536DE.PrintNodeTree(const NodePtr: PKDT1536DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1536DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1536DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1536DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1536DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1536DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1536DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1536DE.Test;
var
  TKDT1536DE_Test    : TKDT1536DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1536DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1536DE_Test := TKDT1536DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1536DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT1536DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT1536DE_AxisCount - 1 do
        TKDT1536DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1536DE_Test.TestBuff), length(TKDT1536DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1536DE_Test.BuildKDTreeM(False, length(TKDT1536DE_Test.TestBuff), @TKDT1536DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1536DE_Test.BuildKDTreeM(False, length(TKDT1536DE_Test.TestBuff), TKDT1536DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1536DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1536DE_Test.TestBuff));
  TKDT1536DE_Test.Search(TKDT1536DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1536DEDistance(TKDT1536DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1536DE_Test.Clear;
  { kMean test }
  TKDT1536DE_Test.BuildKDTreeWithCluster(TKDT1536DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1536DE_Test.Search(TKDT1536DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1536DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1536DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1536DE_Test);
end;

{$ENDIF DEBUG}


function KDT1920DEVec(const s: string): TKDT1920DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1920DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1920DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1920DEVec(const v: TKDT1920DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1920DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1920DEPow(const v: TKDT1920DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT1920DEDistance(const v1, v2: TKDT1920DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1920DE_AxisCount - 1 do
      Result := Result + KDT1920DEPow(v2[i] - v1[i]);
end;

function KDT1920DECmpare(const v1, v2: TKDT1920DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1920DE_Vec));
end;

function TKDT1920DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DE_Node;
  function SortCompare(const p1, p2: PKDT1920DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1920DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1920DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1920DE_SourceBuffer;
  dynBuff  : PKDT1920DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1920DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1920DE.SearchStoreBuff(const StoreBuffPtr: PKDT1920DEyanmicStoreBuffer; const Buff: TKDT1920DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1920DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1920DE.GetData(const index: NativeInt): PKDT1920DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1920DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1920DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1920DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1920DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1920DE.StoreBuffPtr: PKDT1920DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1920DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1920DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1920DE.BuildKDTreeWithCluster(const inBuff: TKDT1920DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1920DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1920DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1920DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1920DE.BuildKDTreeWithCluster(const inBuff: TKDT1920DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DE_BuildCall);
var
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DE_BuildMethod);
var
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DE_BuildProc);
var
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1920DE.Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DE_Node;

var
  NearestNeighbour: PKDT1920DE_Node;

  function FindParentNode(const BuffPtr: PKDT1920DE_Vec; NodePtr: PKDT1920DE_Node): PKDT1920DE_Node;
  var
    Next       : PKDT1920DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1920DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1920DE_Node; const BuffPtr: PKDT1920DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1920DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1920DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1920DE_Vec; const p1, p2: PKDT1920DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1920DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1920DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1920DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1920DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1920DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1920DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1920DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1920DE.Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1920DE.Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double): PKDT1920DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1920DE.Search(const Buff: TKDT1920DE_Vec): PKDT1920DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1920DE.Search(const inBuff: TKDT1920DE_DynamicVecBuffer; var OutBuff: TKDT1920DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DE_DynamicVecBuffer;
  outBuffPtr : PKDT1920DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1920DE_Source));
end;

procedure TKDT1920DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1920DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1920DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1920DE.PrintNodeTree(const NodePtr: PKDT1920DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1920DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1920DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1920DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1920DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1920DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1920DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1920DE.Test;
var
  TKDT1920DE_Test    : TKDT1920DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1920DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1920DE_Test := TKDT1920DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1920DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT1920DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT1920DE_AxisCount - 1 do
        TKDT1920DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1920DE_Test.TestBuff), length(TKDT1920DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1920DE_Test.BuildKDTreeM(False, length(TKDT1920DE_Test.TestBuff), @TKDT1920DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1920DE_Test.BuildKDTreeM(False, length(TKDT1920DE_Test.TestBuff), TKDT1920DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1920DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1920DE_Test.TestBuff));
  TKDT1920DE_Test.Search(TKDT1920DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1920DEDistance(TKDT1920DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1920DE_Test.Clear;
  { kMean test }
  TKDT1920DE_Test.BuildKDTreeWithCluster(TKDT1920DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1920DE_Test.Search(TKDT1920DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1920DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1920DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1920DE_Test);
end;

{$ENDIF DEBUG}


function KDT1980DEVec(const s: string): TKDT1980DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1980DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1980DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1980DEVec(const v: TKDT1980DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1980DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1980DEPow(const v: TKDT1980DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT1980DEDistance(const v1, v2: TKDT1980DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1980DE_AxisCount - 1 do
      Result := Result + KDT1980DEPow(v2[i] - v1[i]);
end;

function KDT1980DECmpare(const v1, v2: TKDT1980DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1980DE_Vec));
end;

function TKDT1980DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DE_Node;
  function SortCompare(const p1, p2: PKDT1980DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1980DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1980DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1980DE_SourceBuffer;
  dynBuff  : PKDT1980DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1980DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1980DE.SearchStoreBuff(const StoreBuffPtr: PKDT1980DEyanmicStoreBuffer; const Buff: TKDT1980DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1980DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1980DE.GetData(const index: NativeInt): PKDT1980DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1980DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1980DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1980DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1980DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1980DE.StoreBuffPtr: PKDT1980DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1980DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1980DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1980DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1980DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1980DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1980DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1980DE.BuildKDTreeWithCluster(const inBuff: TKDT1980DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1980DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1980DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1980DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1980DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1980DE.BuildKDTreeWithCluster(const inBuff: TKDT1980DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1980DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DE_BuildCall);
var
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1980DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1980DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1980DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1980DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1980DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DE_BuildMethod);
var
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1980DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1980DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1980DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1980DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DE_BuildProc);
var
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1980DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1980DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1980DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1980DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1980DE.Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DE_Node;

var
  NearestNeighbour: PKDT1980DE_Node;

  function FindParentNode(const BuffPtr: PKDT1980DE_Vec; NodePtr: PKDT1980DE_Node): PKDT1980DE_Node;
  var
    Next       : PKDT1980DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1980DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1980DE_Node; const BuffPtr: PKDT1980DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1980DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1980DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1980DE_Vec; const p1, p2: PKDT1980DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1980DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1980DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1980DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1980DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1980DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1980DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1980DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1980DE.Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1980DE.Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double): PKDT1980DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1980DE.Search(const Buff: TKDT1980DE_Vec): PKDT1980DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1980DE.Search(const inBuff: TKDT1980DE_DynamicVecBuffer; var OutBuff: TKDT1980DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1980DE_DynamicVecBuffer;
  outBuffPtr : PKDT1980DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1980DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1980DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1980DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1980DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1980DE_Source));
end;

procedure TKDT1980DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1980DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1980DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1980DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1980DE.PrintNodeTree(const NodePtr: PKDT1980DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1980DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1980DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1980DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1980DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1980DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1980DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1980DE.Test;
var
  TKDT1980DE_Test    : TKDT1980DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1980DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1980DE_Test := TKDT1980DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1980DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT1980DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT1980DE_AxisCount - 1 do
        TKDT1980DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1980DE_Test.TestBuff), length(TKDT1980DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1980DE_Test.BuildKDTreeM(False, length(TKDT1980DE_Test.TestBuff), @TKDT1980DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1980DE_Test.BuildKDTreeM(False, length(TKDT1980DE_Test.TestBuff), TKDT1980DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1980DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1980DE_Test.TestBuff));
  TKDT1980DE_Test.Search(TKDT1980DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1980DEDistance(TKDT1980DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1980DE_Test.Clear;
  { kMean test }
  TKDT1980DE_Test.BuildKDTreeWithCluster(TKDT1980DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1980DE_Test.Search(TKDT1980DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1980DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1980DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1980DE_Test);
end;

{$ENDIF DEBUG}


function KDT2048DEVec(const s: string): TKDT2048DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT2048DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT2048DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT2048DEVec(const v: TKDT2048DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT2048DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT2048DEPow(const v: TKDT2048DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT2048DEDistance(const v1, v2: TKDT2048DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT2048DE_AxisCount - 1 do
      Result := Result + KDT2048DEPow(v2[i] - v1[i]);
end;

function KDT2048DECmpare(const v1, v2: TKDT2048DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT2048DE_Vec));
end;

function TKDT2048DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DE_Node;
  function SortCompare(const p1, p2: PKDT2048DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2048DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2048DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2048DE_SourceBuffer;
  dynBuff  : PKDT2048DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT2048DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2048DE.SearchStoreBuff(const StoreBuffPtr: PKDT2048DEyanmicStoreBuffer; const Buff: TKDT2048DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT2048DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT2048DE.GetData(const index: NativeInt): PKDT2048DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2048DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2048DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2048DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2048DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2048DE.StoreBuffPtr: PKDT2048DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2048DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2048DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2048DE.BuildKDTreeWithCluster(const inBuff: TKDT2048DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT2048DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT2048DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT2048DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2048DE.BuildKDTreeWithCluster(const inBuff: TKDT2048DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DE_BuildCall);
var
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DE_BuildMethod);
var
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DE_BuildProc);
var
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2048DE.Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DE_Node;

var
  NearestNeighbour: PKDT2048DE_Node;

  function FindParentNode(const BuffPtr: PKDT2048DE_Vec; NodePtr: PKDT2048DE_Node): PKDT2048DE_Node;
  var
    Next       : PKDT2048DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT2048DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2048DE_Node; const BuffPtr: PKDT2048DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2048DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT2048DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2048DE_Vec; const p1, p2: PKDT2048DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2048DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2048DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2048DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2048DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2048DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2048DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2048DE_Node(NearestNodes[0]);
    end;
end;

function TKDT2048DE.Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2048DE.Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double): PKDT2048DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2048DE.Search(const Buff: TKDT2048DE_Vec): PKDT2048DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2048DE.Search(const inBuff: TKDT2048DE_DynamicVecBuffer; var OutBuff: TKDT2048DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DE_DynamicVecBuffer;
  outBuffPtr : PKDT2048DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2048DE_Source));
end;

procedure TKDT2048DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2048DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2048DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT2048DE.PrintNodeTree(const NodePtr: PKDT2048DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2048DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2048DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2048DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2048DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT2048DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT2048DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2048DE.Test;
var
  TKDT2048DE_Test    : TKDT2048DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2048DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2048DE_Test := TKDT2048DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2048DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT2048DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT2048DE_AxisCount - 1 do
        TKDT2048DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2048DE_Test.TestBuff), length(TKDT2048DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2048DE_Test.BuildKDTreeM(False, length(TKDT2048DE_Test.TestBuff), @TKDT2048DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2048DE_Test.BuildKDTreeM(False, length(TKDT2048DE_Test.TestBuff), TKDT2048DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2048DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2048DE_Test.TestBuff));
  TKDT2048DE_Test.Search(TKDT2048DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2048DEDistance(TKDT2048DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2048DE_Test.Clear;
  { kMean test }
  TKDT2048DE_Test.BuildKDTreeWithCluster(TKDT2048DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2048DE_Test.Search(TKDT2048DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2048DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2048DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2048DE_Test);
end;

{$ENDIF DEBUG}


function KDT3072DEVec(const s: string): TKDT3072DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3072DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3072DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3072DEVec(const v: TKDT3072DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3072DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT3072DEPow(const v: TKDT3072DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT3072DEDistance(const v1, v2: TKDT3072DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3072DE_AxisCount - 1 do
      Result := Result + KDT3072DEPow(v2[i] - v1[i]);
end;

function KDT3072DECmpare(const v1, v2: TKDT3072DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3072DE_Vec));
end;

function TKDT3072DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DE_Node;
  function SortCompare(const p1, p2: PKDT3072DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3072DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3072DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3072DE_SourceBuffer;
  dynBuff  : PKDT3072DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3072DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3072DE.SearchStoreBuff(const StoreBuffPtr: PKDT3072DEyanmicStoreBuffer; const Buff: TKDT3072DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3072DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3072DE.GetData(const index: NativeInt): PKDT3072DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3072DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3072DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3072DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3072DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3072DE.StoreBuffPtr: PKDT3072DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3072DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3072DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3072DE.BuildKDTreeWithCluster(const inBuff: TKDT3072DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3072DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3072DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3072DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3072DE.BuildKDTreeWithCluster(const inBuff: TKDT3072DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DE_BuildCall);
var
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DE_BuildMethod);
var
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DE_BuildProc);
var
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3072DE.Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DE_Node;

var
  NearestNeighbour: PKDT3072DE_Node;

  function FindParentNode(const BuffPtr: PKDT3072DE_Vec; NodePtr: PKDT3072DE_Node): PKDT3072DE_Node;
  var
    Next       : PKDT3072DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3072DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3072DE_Node; const BuffPtr: PKDT3072DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3072DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3072DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3072DE_Vec; const p1, p2: PKDT3072DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3072DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3072DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3072DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3072DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3072DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3072DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3072DE_Node(NearestNodes[0]);
    end;
end;

function TKDT3072DE.Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3072DE.Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double): PKDT3072DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3072DE.Search(const Buff: TKDT3072DE_Vec): PKDT3072DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3072DE.Search(const inBuff: TKDT3072DE_DynamicVecBuffer; var OutBuff: TKDT3072DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DE_DynamicVecBuffer;
  outBuffPtr : PKDT3072DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3072DE_Source));
end;

procedure TKDT3072DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3072DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3072DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3072DE.PrintNodeTree(const NodePtr: PKDT3072DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3072DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3072DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3072DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3072DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3072DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3072DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3072DE.Test;
var
  TKDT3072DE_Test    : TKDT3072DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3072DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3072DE_Test := TKDT3072DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3072DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT3072DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT3072DE_AxisCount - 1 do
        TKDT3072DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3072DE_Test.TestBuff), length(TKDT3072DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3072DE_Test.BuildKDTreeM(False, length(TKDT3072DE_Test.TestBuff), @TKDT3072DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3072DE_Test.BuildKDTreeM(False, length(TKDT3072DE_Test.TestBuff), TKDT3072DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3072DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3072DE_Test.TestBuff));
  TKDT3072DE_Test.Search(TKDT3072DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3072DEDistance(TKDT3072DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3072DE_Test.Clear;
  { kMean test }
  TKDT3072DE_Test.BuildKDTreeWithCluster(TKDT3072DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3072DE_Test.Search(TKDT3072DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3072DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3072DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3072DE_Test);
end;

{$ENDIF DEBUG}


function KDT3088DEVec(const s: string): TKDT3088DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3088DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3088DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3088DEVec(const v: TKDT3088DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3088DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT3088DEPow(const v: TKDT3088DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT3088DEDistance(const v1, v2: TKDT3088DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3088DE_AxisCount - 1 do
      Result := Result + KDT3088DEPow(v2[i] - v1[i]);
end;

function KDT3088DECmpare(const v1, v2: TKDT3088DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3088DE_Vec));
end;

function TKDT3088DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DE_Node;
  function SortCompare(const p1, p2: PKDT3088DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3088DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3088DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3088DE_SourceBuffer;
  dynBuff  : PKDT3088DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3088DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3088DE.SearchStoreBuff(const StoreBuffPtr: PKDT3088DEyanmicStoreBuffer; const Buff: TKDT3088DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3088DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3088DE.GetData(const index: NativeInt): PKDT3088DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3088DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3088DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3088DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3088DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3088DE.StoreBuffPtr: PKDT3088DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3088DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3088DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3088DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3088DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3088DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3088DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3088DE.BuildKDTreeWithCluster(const inBuff: TKDT3088DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3088DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3088DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3088DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3088DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3088DE.BuildKDTreeWithCluster(const inBuff: TKDT3088DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3088DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DE_BuildCall);
var
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3088DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3088DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3088DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3088DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3088DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DE_BuildMethod);
var
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3088DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3088DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3088DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3088DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DE_BuildProc);
var
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3088DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3088DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3088DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3088DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3088DE.Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DE_Node;

var
  NearestNeighbour: PKDT3088DE_Node;

  function FindParentNode(const BuffPtr: PKDT3088DE_Vec; NodePtr: PKDT3088DE_Node): PKDT3088DE_Node;
  var
    Next       : PKDT3088DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3088DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3088DE_Node; const BuffPtr: PKDT3088DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3088DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3088DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3088DE_Vec; const p1, p2: PKDT3088DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3088DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3088DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3088DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3088DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3088DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3088DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3088DE_Node(NearestNodes[0]);
    end;
end;

function TKDT3088DE.Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3088DE.Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double): PKDT3088DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3088DE.Search(const Buff: TKDT3088DE_Vec): PKDT3088DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3088DE.Search(const inBuff: TKDT3088DE_DynamicVecBuffer; var OutBuff: TKDT3088DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3088DE_DynamicVecBuffer;
  outBuffPtr : PKDT3088DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3088DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3088DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3088DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3088DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3088DE_Source));
end;

procedure TKDT3088DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3088DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3088DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3088DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3088DE.PrintNodeTree(const NodePtr: PKDT3088DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3088DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3088DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3088DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3088DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3088DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3088DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3088DE.Test;
var
  TKDT3088DE_Test    : TKDT3088DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3088DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3088DE_Test := TKDT3088DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3088DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT3088DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT3088DE_AxisCount - 1 do
        TKDT3088DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3088DE_Test.TestBuff), length(TKDT3088DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3088DE_Test.BuildKDTreeM(False, length(TKDT3088DE_Test.TestBuff), @TKDT3088DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3088DE_Test.BuildKDTreeM(False, length(TKDT3088DE_Test.TestBuff), TKDT3088DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3088DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3088DE_Test.TestBuff));
  TKDT3088DE_Test.Search(TKDT3088DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3088DEDistance(TKDT3088DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3088DE_Test.Clear;
  { kMean test }
  TKDT3088DE_Test.BuildKDTreeWithCluster(TKDT3088DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3088DE_Test.Search(TKDT3088DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3088DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3088DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3088DE_Test);
end;

{$ENDIF DEBUG}


function KDT3104DEVec(const s: string): TKDT3104DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3104DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3104DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3104DEVec(const v: TKDT3104DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3104DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT3104DEPow(const v: TKDT3104DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT3104DEDistance(const v1, v2: TKDT3104DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3104DE_AxisCount - 1 do
      Result := Result + KDT3104DEPow(v2[i] - v1[i]);
end;

function KDT3104DECmpare(const v1, v2: TKDT3104DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3104DE_Vec));
end;

function TKDT3104DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DE_Node;
  function SortCompare(const p1, p2: PKDT3104DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3104DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3104DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3104DE_SourceBuffer;
  dynBuff  : PKDT3104DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3104DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3104DE.SearchStoreBuff(const StoreBuffPtr: PKDT3104DEyanmicStoreBuffer; const Buff: TKDT3104DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3104DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3104DE.GetData(const index: NativeInt): PKDT3104DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3104DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3104DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3104DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3104DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3104DE.StoreBuffPtr: PKDT3104DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3104DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3104DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3104DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3104DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3104DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3104DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3104DE.BuildKDTreeWithCluster(const inBuff: TKDT3104DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3104DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3104DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3104DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3104DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3104DE.BuildKDTreeWithCluster(const inBuff: TKDT3104DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3104DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DE_BuildCall);
var
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3104DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3104DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3104DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3104DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3104DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DE_BuildMethod);
var
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3104DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3104DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3104DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3104DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DE_BuildProc);
var
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3104DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3104DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3104DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3104DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3104DE.Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DE_Node;

var
  NearestNeighbour: PKDT3104DE_Node;

  function FindParentNode(const BuffPtr: PKDT3104DE_Vec; NodePtr: PKDT3104DE_Node): PKDT3104DE_Node;
  var
    Next       : PKDT3104DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3104DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3104DE_Node; const BuffPtr: PKDT3104DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3104DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3104DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3104DE_Vec; const p1, p2: PKDT3104DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3104DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3104DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3104DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3104DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3104DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3104DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3104DE_Node(NearestNodes[0]);
    end;
end;

function TKDT3104DE.Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3104DE.Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double): PKDT3104DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3104DE.Search(const Buff: TKDT3104DE_Vec): PKDT3104DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3104DE.Search(const inBuff: TKDT3104DE_DynamicVecBuffer; var OutBuff: TKDT3104DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3104DE_DynamicVecBuffer;
  outBuffPtr : PKDT3104DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3104DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3104DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3104DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3104DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3104DE_Source));
end;

procedure TKDT3104DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3104DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3104DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3104DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3104DE.PrintNodeTree(const NodePtr: PKDT3104DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3104DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3104DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3104DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3104DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3104DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3104DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3104DE.Test;
var
  TKDT3104DE_Test    : TKDT3104DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3104DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3104DE_Test := TKDT3104DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3104DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT3104DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT3104DE_AxisCount - 1 do
        TKDT3104DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3104DE_Test.TestBuff), length(TKDT3104DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3104DE_Test.BuildKDTreeM(False, length(TKDT3104DE_Test.TestBuff), @TKDT3104DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3104DE_Test.BuildKDTreeM(False, length(TKDT3104DE_Test.TestBuff), TKDT3104DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3104DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3104DE_Test.TestBuff));
  TKDT3104DE_Test.Search(TKDT3104DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3104DEDistance(TKDT3104DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3104DE_Test.Clear;
  { kMean test }
  TKDT3104DE_Test.BuildKDTreeWithCluster(TKDT3104DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3104DE_Test.Search(TKDT3104DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3104DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3104DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3104DE_Test);
end;

{$ENDIF DEBUG}


function KDT4096DEVec(const s: string): TKDT4096DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT4096DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT4096DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT4096DEVec(const v: TKDT4096DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT4096DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT4096DEPow(const v: TKDT4096DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT4096DEDistance(const v1, v2: TKDT4096DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT4096DE_AxisCount - 1 do
      Result := Result + KDT4096DEPow(v2[i] - v1[i]);
end;

function KDT4096DECmpare(const v1, v2: TKDT4096DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT4096DE_Vec));
end;

function TKDT4096DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DE_Node;
  function SortCompare(const p1, p2: PKDT4096DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4096DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4096DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4096DE_SourceBuffer;
  dynBuff  : PKDT4096DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT4096DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4096DE.SearchStoreBuff(const StoreBuffPtr: PKDT4096DEyanmicStoreBuffer; const Buff: TKDT4096DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT4096DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT4096DE.GetData(const index: NativeInt): PKDT4096DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4096DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4096DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4096DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4096DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4096DE.StoreBuffPtr: PKDT4096DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4096DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4096DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4096DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4096DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4096DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4096DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4096DE.BuildKDTreeWithCluster(const inBuff: TKDT4096DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT4096DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT4096DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT4096DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4096DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4096DE.BuildKDTreeWithCluster(const inBuff: TKDT4096DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4096DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DE_BuildCall);
var
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4096DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4096DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4096DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4096DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT4096DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DE_BuildMethod);
var
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4096DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4096DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4096DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4096DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DE_BuildProc);
var
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4096DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4096DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4096DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4096DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT4096DE.Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DE_Node;

var
  NearestNeighbour: PKDT4096DE_Node;

  function FindParentNode(const BuffPtr: PKDT4096DE_Vec; NodePtr: PKDT4096DE_Node): PKDT4096DE_Node;
  var
    Next       : PKDT4096DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT4096DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4096DE_Node; const BuffPtr: PKDT4096DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4096DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT4096DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4096DE_Vec; const p1, p2: PKDT4096DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4096DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4096DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4096DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4096DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4096DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4096DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4096DE_Node(NearestNodes[0]);
    end;
end;

function TKDT4096DE.Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4096DE.Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double): PKDT4096DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4096DE.Search(const Buff: TKDT4096DE_Vec): PKDT4096DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4096DE.Search(const inBuff: TKDT4096DE_DynamicVecBuffer; var OutBuff: TKDT4096DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4096DE_DynamicVecBuffer;
  outBuffPtr : PKDT4096DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4096DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4096DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4096DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4096DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4096DE_Source));
end;

procedure TKDT4096DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4096DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4096DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4096DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT4096DE.PrintNodeTree(const NodePtr: PKDT4096DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4096DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4096DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4096DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4096DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT4096DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT4096DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4096DE.Test;
var
  TKDT4096DE_Test    : TKDT4096DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4096DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4096DE_Test := TKDT4096DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4096DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT4096DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT4096DE_AxisCount - 1 do
        TKDT4096DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT4096DE_Test.TestBuff), length(TKDT4096DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4096DE_Test.BuildKDTreeM(False, length(TKDT4096DE_Test.TestBuff), @TKDT4096DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4096DE_Test.BuildKDTreeM(False, length(TKDT4096DE_Test.TestBuff), TKDT4096DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4096DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4096DE_Test.TestBuff));
  TKDT4096DE_Test.Search(TKDT4096DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4096DEDistance(TKDT4096DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4096DE_Test.Clear;
  { kMean test }
  TKDT4096DE_Test.BuildKDTreeWithCluster(TKDT4096DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4096DE_Test.Search(TKDT4096DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4096DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4096DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4096DE_Test);
end;

{$ENDIF DEBUG}


function KDT8192DEVec(const s: string): TKDT8192DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT8192DE_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT8192DE_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT8192DEVec(const v: TKDT8192DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT8192DE_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT8192DEPow(const v: TKDT8192DE_VecType): Double;
begin
  Result := v * v;
end;

function KDT8192DEDistance(const v1, v2: TKDT8192DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT8192DE_AxisCount - 1 do
      Result := Result + KDT8192DEPow(v2[i] - v1[i]);
end;

function KDT8192DECmpare(const v1, v2: TKDT8192DE_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT8192DE_Vec));
end;

function TKDT8192DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DE_Node;
  function SortCompare(const p1, p2: PKDT8192DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8192DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8192DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8192DE_SourceBuffer;
  dynBuff  : PKDT8192DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT8192DE_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8192DE.SearchStoreBuff(const StoreBuffPtr: PKDT8192DEyanmicStoreBuffer; const Buff: TKDT8192DE_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT8192DECmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT8192DE.GetData(const index: NativeInt): PKDT8192DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8192DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8192DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8192DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8192DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8192DE.StoreBuffPtr: PKDT8192DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8192DE.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8192DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8192DE.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8192DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DE.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8192DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8192DE_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8192DE.BuildKDTreeWithCluster(const inBuff: TKDT8192DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT8192DE_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT8192DE_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT8192DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8192DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8192DE.BuildKDTreeWithCluster(const inBuff: TKDT8192DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8192DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DE_BuildCall);
var
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8192DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8192DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8192DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8192DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DE_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT8192DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DE_BuildMethod);
var
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8192DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8192DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8192DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8192DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DE_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DE_BuildProc);
var
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8192DE_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8192DE_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8192DE_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8192DE_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DE_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT8192DE.Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DE_Node;

var
  NearestNeighbour: PKDT8192DE_Node;

  function FindParentNode(const BuffPtr: PKDT8192DE_Vec; NodePtr: PKDT8192DE_Node): PKDT8192DE_Node;
  var
    Next       : PKDT8192DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT8192DE_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8192DE_Node; const BuffPtr: PKDT8192DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8192DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT8192DE_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8192DE_Vec; const p1, p2: PKDT8192DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8192DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8192DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8192DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8192DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8192DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8192DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8192DE_Node(NearestNodes[0]);
    end;
end;

function TKDT8192DE.Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8192DE.Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double): PKDT8192DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8192DE.Search(const Buff: TKDT8192DE_Vec): PKDT8192DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8192DE.Search(const inBuff: TKDT8192DE_DynamicVecBuffer; var OutBuff: TKDT8192DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8192DE_DynamicVecBuffer;
  outBuffPtr : PKDT8192DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8192DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8192DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8192DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8192DE.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8192DE_Source));
end;

procedure TKDT8192DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8192DE_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8192DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8192DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT8192DE.PrintNodeTree(const NodePtr: PKDT8192DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8192DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8192DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8192DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8192DEVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT8192DE.Test_BuildM(IndexFor: NativeInt; var Source: TKDT8192DE_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8192DE.Test;
var
  TKDT8192DE_Test    : TKDT8192DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8192DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8192DE_Test := TKDT8192DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8192DE_Test.TestBuff, 300);
  for i := 0 to length(TKDT8192DE_Test.TestBuff) - 1 do
    for j := 0 to TKDT8192DE_AxisCount - 1 do
        TKDT8192DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT8192DE_Test.TestBuff), length(TKDT8192DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8192DE_Test.BuildKDTreeM(False, length(TKDT8192DE_Test.TestBuff), @TKDT8192DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8192DE_Test.BuildKDTreeM(False, length(TKDT8192DE_Test.TestBuff), TKDT8192DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8192DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8192DE_Test.TestBuff));
  TKDT8192DE_Test.Search(TKDT8192DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8192DEDistance(TKDT8192DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8192DE_Test.Clear;
  { kMean test }
  TKDT8192DE_Test.BuildKDTreeWithCluster(TKDT8192DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8192DE_Test.Search(TKDT8192DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8192DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8192DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8192DE_Test);
end;

{$ENDIF DEBUG}

{$IFDEF DEBUG}
procedure Test_All;
begin
  TKDT1DE.Test();
  TKDT2DE.Test();
  TKDT3DE.Test();
  TKDT4DE.Test();
  TKDT5DE.Test();
  TKDT6DE.Test();
  TKDT7DE.Test();
  TKDT8DE.Test();
  TKDT9DE.Test();
  TKDT10DE.Test();
  TKDT11DE.Test();
  TKDT12DE.Test();
  TKDT13DE.Test();
  TKDT14DE.Test();
  TKDT15DE.Test();
  TKDT16DE.Test();
  TKDT17DE.Test();
  TKDT18DE.Test();
  TKDT19DE.Test();
  TKDT20DE.Test();
  TKDT21DE.Test();
  TKDT22DE.Test();
  TKDT23DE.Test();
  TKDT24DE.Test();
  TKDT25DE.Test();
  TKDT26DE.Test();
  TKDT27DE.Test();
  TKDT28DE.Test();
  TKDT29DE.Test();
  TKDT30DE.Test();
  TKDT32DE.Test();
  TKDT34DE.Test();
  TKDT36DE.Test();
  TKDT38DE.Test();
  TKDT40DE.Test();
  TKDT44DE.Test();
  TKDT48DE.Test();
  TKDT50DE.Test();
  TKDT56DE.Test();
  TKDT60DE.Test();
  TKDT64DE.Test();
  TKDT72DE.Test();
  TKDT84DE.Test();
  TKDT96DE.Test();
  TKDT128DE.Test();
  TKDT140DE.Test();
  TKDT160DE.Test();
  TKDT196DE.Test();
  TKDT256DE.Test();
  TKDT272DE.Test();
  TKDT288DE.Test();
  TKDT372DE.Test();
  TKDT512DE.Test();
  TKDT576DE.Test();
  TKDT768DE.Test();
  TKDT1024DE.Test();
  TKDT1040DE.Test();
  TKDT1056DE.Test();
  TKDT1536DE.Test();
  TKDT1920DE.Test();
  TKDT1980DE.Test();
  TKDT2048DE.Test();
  TKDT3072DE.Test();
  TKDT3088DE.Test();
  TKDT3104DE.Test();
  TKDT4096DE.Test();
  TKDT8192DE.Test();
  DoStatus('All Test Finished');
end;
{$ENDIF}




initialization

finalization

end.

